
// ===== ./src/App.jsx =====

// src/App.jsx
import React from "react";
import { Routes, Route, Navigate } from "react-router-dom";                // componentes de enrutado declarativo
import PaginaLogin from "./paginas/PaginaLogin/PaginaLogin.jsx";           // pantalla de login (ruta "/")
import PaginaRegistro from "./paginas/PaginaRegistro/PaginaRegistro.jsx";  // pantalla de registro (ruta "/registro")
import PaginaAlimentadoresSupabase from "./paginas/PaginaAlimentadores/PaginaAlimentadoresSupabase.jsx"; // panel principal conectado a Supabase
import RecuperarContrasena from "./paginas/PaginaRecuperar/recuperarContrase√±a.jsx"; // pantalla de recupero de contrase√±a (ruta "/recuperarContrase√±a")

function App() {                                         // componente ra√≠z que define el mapa de rutas
	return (
		<Routes>                                           {/* contenedor de todas las <Route> */}
			<Route                                           
				path="/"                                     
				element={<PaginaLogin />}                    // ruta principal: muestra login
			/>

			<Route                                           
				path="/registro"                            
				element={<PaginaRegistro />}                 // ruta para crear un nuevo usuario
			/>

			<Route
				path="/recuperarContrase√±a"
				element={<RecuperarContrasena/>}            // ruta para recuperar contrase√±a
			/>

			<Route
				path="/alimentadores"
				element={<PaginaAlimentadoresSupabase />}    // ruta del panel de alimentadores conectado a Supabase
			/>

			<Route                                           
				path="*"                                    
				element={<Navigate to="/" replace />}       // cualquier otra URL redirige al login
			/>
		</Routes>
	);
}

export default App;                                          // se importa en main.jsx como componente principal

// ---------------------------------------------------------------------------
// NOTA PERSONAL SOBRE ESTE ARCHIVO (App.jsx)
// - Este componente define el enrutado de alto nivel de la aplicaci√≥n.
// - Usa <Routes> y <Route> de react-router-dom para asociar paths a componentes.
// - "/" carga PaginaLogin, "/registro" carga PaginaRegistro "/recuperarContrase√±a"
//   carga RecuperarContrase√±a y "/alimentadores" muestra el panel principal 
//   donde se manejan puestos y alimentadores.
// - La √∫ltima ruta con path="*" act√∫a como catch-all: cualquier URL desconocida
//   navega autom√°ticamente a "/", evitando pantallas en blanco o errores.
// - En resumen: App.jsx es el ‚Äúswitch‚Äù de rutas que decide qu√© pantalla ver en
//   funci√≥n de la URL actual del navegador.

// ===== ./src/componentes/comunes/ApexChartWrapper.jsx =====

/**
 * Wrapper personalizado para ApexCharts que maneja correctamente
 * el ciclo de vida con React 18 StrictMode.
 *
 * Soluciona el problema conocido de react-apexcharts donde el doble montaje
 * de StrictMode causa errores "parentNode is null" y "Element not found".
 *
 * Usa ApexCharts directamente en lugar del wrapper react-apexcharts.
 */

import { useEffect, useRef, useImperativeHandle, forwardRef, memo } from "react";
import ApexCharts from "apexcharts";

const ApexChartWrapper = forwardRef(({ options, series, type, height, width }, ref) => {
  const containerRef = useRef(null);
  const chartInstanceRef = useRef(null);

  // Exponer el chart instance y m√©todos √∫tiles al componente padre via ref
  useImperativeHandle(ref, () => ({
    get chart() {
      return chartInstanceRef.current;
    },
    /**
     * Captura la imagen del gr√°fico con estilo optimizado para informes
     * (fondo blanco, texto negro, fuentes m√°s grandes)
     * Crea un gr√°fico temporal oculto para la captura, sin afectar el visible.
     * @param {Object} exportOptions - Opciones adicionales para dataURI
     * @returns {Promise<{imgURI: string}>} - Imagen en formato data URI
     */
    async captureForReport(exportOptions = {}) {
      const chart = chartInstanceRef.current;
      if (!chart) {
        return { imgURI: null };
      }

      // Crear un contenedor temporal oculto para el gr√°fico de exportaci√≥n
      const tempContainer = document.createElement("div");
      tempContainer.style.cssText = "position:absolute;left:-9999px;top:-9999px;width:1200px;height:600px;";
      document.body.appendChild(tempContainer);

      // Opciones optimizadas para exportaci√≥n a informe (fondo blanco, texto negro, fuentes grandes)
      const opcionesExport = {
        ...options,
        chart: {
          ...options.chart,
          id: `export-temp-${Date.now()}`,
          background: "#ffffff",
          foreColor: "#1a1a1a",
          animations: { enabled: false },
          toolbar: { show: false },
          width: 1200,
          height: 600,
        },
        states: {
          hover: { filter: { type: "none" } },
          active: { filter: { type: "none" } },
        },
        markers: {
          ...options.markers,
          hover: { size: 0 },
        },
        tooltip: { enabled: false },
        xaxis: {
          ...options.xaxis,
          crosshairs: { show: false },
          labels: {
            ...options.xaxis?.labels,
            style: {
              ...options.xaxis?.labels?.style,
              colors: "#1a1a1a",
              fontSize: "16px",
              fontWeight: 600,
            },
          },
          axisBorder: { color: "#333333", show: true },
          axisTicks: { color: "#333333", show: true },
        },
        yaxis: {
          ...options.yaxis,
          crosshairs: { show: false },
          labels: {
            ...options.yaxis?.labels,
            style: {
              ...options.yaxis?.labels?.style,
              colors: "#1a1a1a",
              fontSize: "16px",
              fontWeight: 600,
            },
          },
        },
        grid: {
          ...options.grid,
          borderColor: "#bbbbbb",
        },
      };

      let tempChart = null;
      try {
        // Crear gr√°fico temporal con las opciones de exportaci√≥n
        tempChart = new ApexCharts(tempContainer, {
          ...opcionesExport,
          series: chart.w.config.series, // Usar las series actuales
        });
        await tempChart.render();

        // Peque√±a pausa para asegurar que el gr√°fico se renderice
        await new Promise(resolve => setTimeout(resolve, 150));

        // Capturar imagen del gr√°fico temporal
        const result = await tempChart.dataURI({ scale: exportOptions.scale || 2 });

        return result;
      } catch (err) {
        console.warn("Error capturando gr√°fico para informe:", err);
        return { imgURI: null };
      } finally {
        // Limpiar: destruir gr√°fico temporal y remover contenedor
        if (tempChart) {
          try {
            tempChart.destroy();
          } catch {
            // Ignorar errores de destrucci√≥n
          }
        }
        if (tempContainer.parentNode) {
          tempContainer.parentNode.removeChild(tempContainer);
        }
      }
    }
  }), [options]);

  // Refs para valores iniciales (evita re-crear el chart cuando cambian)
  const initialOptionsRef = useRef(options);
  const initialSeriesRef = useRef(series);
  const initialTypeRef = useRef(type);
  const initialHeightRef = useRef(height);
  const initialWidthRef = useRef(width);

  // Efecto principal: crear/destruir el chart (solo al montar/desmontar)
  useEffect(() => {
    // Si no hay contenedor, salir
    if (!containerRef.current) return;

    // Limpiar cualquier chart anterior que pudiera existir
    if (chartInstanceRef.current) {
      try {
        chartInstanceRef.current.destroy();
      } catch {
        // Ignorar errores de destrucci√≥n
      }
      chartInstanceRef.current = null;
    }

    // Usar valores iniciales de los refs
    const opts = initialOptionsRef.current;
    const ser = initialSeriesRef.current;
    const t = initialTypeRef.current;
    const h = initialHeightRef.current;
    const w = initialWidthRef.current;

    // Crear configuraci√≥n completa del chart
    const chartConfig = {
      ...opts,
      chart: {
        ...opts.chart,
        type: t || opts.chart?.type || "line",
        height: h || opts.chart?.height || "100%",
        width: w || opts.chart?.width || "100%",
      },
      series: ser || [],
    };

    // Crear nueva instancia
    const chart = new ApexCharts(containerRef.current, chartConfig);
    chartInstanceRef.current = chart;

    // Renderizar el chart
    chart.render();

    // Cleanup: destruir chart cuando el componente se desmonte
    return () => {
      if (chartInstanceRef.current) {
        try {
          chartInstanceRef.current.destroy();
        } catch {
          // Ignorar errores durante cleanup
        }
        chartInstanceRef.current = null;
      }
    };
  }, []); // Solo al montar/desmontar - las actualizaciones se hacen en otros effects

  // Efecto para actualizar opciones cuando cambien
  useEffect(() => {
    if (!chartInstanceRef.current) return;

    try {
      chartInstanceRef.current.updateOptions(
        {
          ...options,
          chart: {
            ...options.chart,
            type: type || options.chart?.type || "line",
          },
        },
        false, // No redraw
        true   // Animate
      );
    } catch (e) {
      console.warn("Error actualizando opciones del chart:", e);
    }
  }, [options, type]);

  // Efecto para actualizar series cuando cambien
  useEffect(() => {
    if (!chartInstanceRef.current) return;

    try {
      chartInstanceRef.current.updateSeries(series || [], true);
    } catch (e) {
      console.warn("Error actualizando series del chart:", e);
    }
  }, [series]);

  return (
    <div
      ref={containerRef}
      style={{
        width: width || "100%",
        height: height || "100%",
        minHeight: "200px",
      }}
    />
  );
});

ApexChartWrapper.displayName = "ApexChartWrapper";

export default memo(ApexChartWrapper);

// ===== ./src/componentes/comunes/SelectorFecha.css =====

/**
 * Estilos para SelectorFecha - DatePicker modular
 * Soporta modo d√≠a √∫nico y modo rango
 */

.selector-fecha {
  position: relative;
  display: inline-block;
}

/* Bot√≥n principal */
.selector-fecha-btn {
  width: 32px;
  height: 28px;
  padding: 0;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #94a3b8;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.selector-fecha-btn:hover:not(:disabled) {
  background: #475569;
  border-color: #64748b;
  color: #e2e8f0;
}

.selector-fecha-btn--activo {
  background: #0ea5e9;
  border-color: #0ea5e9;
  color: #ffffff;
}

.selector-fecha-btn--con-valor {
  border-color: #0ea5e9;
}

.selector-fecha-btn--disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.selector-fecha-icono {
  font-size: 0.9rem;
  line-height: 1;
}

/* Dropdown del calendario */
.selector-fecha-dropdown {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  background: #1e293b;
  border: 1px solid #475569;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  padding: 0.75rem;
  z-index: 1000;
  min-width: 260px;
}

/* Indicador de modo rango */
.selector-fecha-modo {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  margin-bottom: 0.75rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #334155;
}

.selector-fecha-modo-contenido {
  flex: 1;
}

.selector-fecha-instruccion {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.7rem;
  color: #64748b;
  justify-content: center;
}

.selector-fecha-limpiar-mini {
  padding: 0.15rem 0.4rem;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #94a3b8;
  font-size: 0.65rem;
  cursor: pointer;
  transition: all 0.15s ease;
  flex-shrink: 0;
}

.selector-fecha-limpiar-mini:hover {
  background: #475569;
  border-color: #64748b;
  color: #e2e8f0;
}

.selector-fecha-instruccion--activo {
  color: #94a3b8;
}

.selector-fecha-instruccion--completo {
  color: #22c55e;
}

.selector-fecha-desde-badge {
  padding: 0.15rem 0.4rem;
  background: rgba(34, 197, 94, 0.2);
  color: #22c55e;
  border-radius: 3px;
  font-weight: 600;
}

.selector-fecha-hasta-badge {
  padding: 0.15rem 0.4rem;
  background: rgba(14, 165, 233, 0.2);
  color: #0ea5e9;
  border-radius: 3px;
  font-weight: 600;
}

/* Header del calendario */
.selector-fecha-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.75rem;
}

.selector-fecha-nav {
  width: 28px;
  height: 28px;
  padding: 0;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #94a3b8;
  font-size: 0.75rem;
  cursor: pointer;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.selector-fecha-nav:hover {
  background: #475569;
  color: #e2e8f0;
}

.selector-fecha-mes {
  font-size: 0.85rem;
  font-weight: 600;
  color: #e2e8f0;
}

/* T√≠tulo clickeable del header (mes/a√±o) */
.selector-fecha-titulo {
  font-size: 0.85rem;
  font-weight: 600;
  color: #e2e8f0;
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  transition: all 0.15s ease;
}

.selector-fecha-titulo:hover {
  background: #334155;
  color: #0ea5e9;
}

.selector-fecha-titulo--no-click {
  cursor: default;
  padding: 0.25rem 0.5rem;
}

.selector-fecha-titulo--no-click:hover {
  background: transparent;
  color: #e2e8f0;
}

/* D√≠as de la semana */
.selector-fecha-dias-semana {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 2px;
  margin-bottom: 0.5rem;
}

.selector-fecha-dia-semana {
  text-align: center;
  font-size: 0.7rem;
  font-weight: 600;
  color: #64748b;
  padding: 0.25rem 0;
}

/* Grilla de d√≠as */
.selector-fecha-grilla {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 2px;
}

.selector-fecha-dia {
  width: 100%;
  aspect-ratio: 1;
  padding: 0;
  background: transparent;
  border: none;
  border-radius: 4px;
  color: #e2e8f0;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.selector-fecha-dia:hover:not(:disabled) {
  background: #334155;
}

.selector-fecha-dia--otro-mes {
  color: #475569;
}

.selector-fecha-dia--otro-mes:hover:not(:disabled) {
  color: #64748b;
}

.selector-fecha-dia--hoy {
  border: 1px solid #0ea5e9;
}

/* D√≠a √∫nico seleccionado (modo simple) */
.selector-fecha-dia--seleccionado {
  background: #0ea5e9;
  color: #ffffff;
}

.selector-fecha-dia--seleccionado:hover {
  background: #0284c7;
}

/* Modo rango: fecha desde */
.selector-fecha-dia--desde {
  background: #22c55e;
  color: #ffffff;
  border-radius: 4px 0 0 4px;
}

.selector-fecha-dia--desde:hover {
  background: #16a34a;
}

/* Modo rango: fecha hasta */
.selector-fecha-dia--hasta {
  background: #0ea5e9;
  color: #ffffff;
  border-radius: 0 4px 4px 0;
}

.selector-fecha-dia--hasta:hover {
  background: #0284c7;
}

/* Modo rango: mismo d√≠a desde y hasta */
.selector-fecha-dia--desde.selector-fecha-dia--hasta {
  background: linear-gradient(90deg, #22c55e 50%, #0ea5e9 50%);
  border-radius: 4px;
}

/* Modo rango: d√≠as entre desde y hasta */
.selector-fecha-dia--en-rango {
  background: rgba(14, 165, 233, 0.2);
  color: #e2e8f0;
  border-radius: 0;
}

.selector-fecha-dia--en-rango:hover:not(:disabled) {
  background: rgba(14, 165, 233, 0.35);
}

.selector-fecha-dia--deshabilitado {
  opacity: 0.3;
  cursor: not-allowed;
}

/* Footer con bot√≥n limpiar */
.selector-fecha-footer {
  margin-top: 0.75rem;
  padding-top: 0.75rem;
  border-top: 1px solid #334155;
  display: flex;
  justify-content: center;
}

.selector-fecha-limpiar {
  padding: 0.35rem 0.75rem;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #94a3b8;
  font-size: 0.75rem;
  cursor: pointer;
  transition: all 0.15s ease;
}

.selector-fecha-limpiar:hover {
  background: #475569;
  color: #e2e8f0;
}

/* Vista de meses */
.selector-fecha-grilla-meses {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 6px;
}

.selector-fecha-mes-item {
  padding: 0.6rem 0.25rem;
  background: transparent;
  border: none;
  border-radius: 4px;
  color: #e2e8f0;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s ease;
}

.selector-fecha-mes-item:hover {
  background: #334155;
}

.selector-fecha-mes-item--actual {
  border: 1px solid #0ea5e9;
}

.selector-fecha-mes-item--seleccionado {
  background: #0ea5e9;
  color: #ffffff;
}

.selector-fecha-mes-item--seleccionado:hover {
  background: #0284c7;
}

/* Vista de a√±os */
.selector-fecha-grilla-anios {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 6px;
}

.selector-fecha-anio-item {
  padding: 0.5rem 0.25rem;
  background: transparent;
  border: none;
  border-radius: 4px;
  color: #e2e8f0;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s ease;
}

.selector-fecha-anio-item:hover {
  background: #334155;
}

.selector-fecha-anio-item--actual {
  border: 1px solid #0ea5e9;
}

.selector-fecha-anio-item--seleccionado {
  background: #0ea5e9;
  color: #ffffff;
}

.selector-fecha-anio-item--seleccionado:hover {
  background: #0284c7;
}

/* M√≥vil portrait: dropdown hacia la izquierda */
@media (max-width: 600px) and (orientation: portrait) {
  .selector-fecha-dropdown {
    left: auto;
    right: 0;
  }
}

// ===== ./src/componentes/comunes/SelectorFecha.jsx =====

/**
 * Componente SelectorFecha - DatePicker modular reutilizable
 * Soporta selecci√≥n de d√≠a √∫nico o rango de fechas
 * Navegaci√≥n drill-down: d√≠as ‚Üí meses ‚Üí a√±os
 *
 * Modo rango:
 * - Primer click: selecciona "desde"
 * - Segundo click: selecciona "hasta" (si es despu√©s del desde) o nuevo "desde" (si es antes)
 * - Los d√≠as entre ambos se marcan con color de fondo
 */

import { useState, useRef, useEffect } from "react";
import "./SelectorFecha.css";

const SelectorFecha = ({
  value,
  onChange,
  minDate,
  maxDate,
  placeholder = "Seleccionar fecha",
  disabled = false,
  className = "",
  // Nuevas props para modo rango
  modoRango = false,
  valueHasta = null,
  onChangeRango = null, // (desde, hasta) => void
}) => {
  const [abierto, setAbierto] = useState(false);
  const [mesActual, setMesActual] = useState(() => {
    const fecha = value ? new Date(value) : new Date();
    return new Date(fecha.getFullYear(), fecha.getMonth(), 1);
  });
  // Vista actual: "dias" | "meses" | "anios"
  const [vistaActual, setVistaActual] = useState("dias");
  // Para modo rango: guardamos temporalmente el "desde" mientras se selecciona el "hasta"
  const [seleccionandoRango, setSeleccionandoRango] = useState(false);
  const contenedorRef = useRef(null);

  // Cerrar al hacer clic fuera
  useEffect(() => {
    const handleClickFuera = (e) => {
      if (contenedorRef.current && !contenedorRef.current.contains(e.target)) {
        setAbierto(false);
        setVistaActual("dias");
        // Si estaba seleccionando rango y cierra, mantener solo el desde
        if (seleccionandoRango && value && !valueHasta) {
          setSeleccionandoRango(false);
        }
      }
    };

    if (abierto) {
      document.addEventListener("mousedown", handleClickFuera);
    }

    return () => {
      document.removeEventListener("mousedown", handleClickFuera);
    };
  }, [abierto, seleccionandoRango, value, valueHasta]);

  // Actualizar mes cuando cambia el valor
  useEffect(() => {
    if (value) {
      const fecha = new Date(value);
      setMesActual(new Date(fecha.getFullYear(), fecha.getMonth(), 1));
    }
  }, [value]);

  // Reset vista cuando se abre
  useEffect(() => {
    if (abierto) {
      setVistaActual("dias");
    }
  }, [abierto]);

  const nombresMeses = [
    "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
    "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
  ];

  const nombresMesesCortos = [
    "Ene", "Feb", "Mar", "Abr", "May", "Jun",
    "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"
  ];

  const nombresDias = ["Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sa"];

  const obtenerDiasMes = (fecha) => {
    const year = fecha.getFullYear();
    const month = fecha.getMonth();
    const primerDia = new Date(year, month, 1);
    const ultimoDia = new Date(year, month + 1, 0);
    const diasEnMes = ultimoDia.getDate();
    const diaSemanaInicio = primerDia.getDay();

    const dias = [];

    // D√≠as del mes anterior
    const mesAnterior = new Date(year, month, 0);
    const diasMesAnterior = mesAnterior.getDate();
    for (let i = diaSemanaInicio - 1; i >= 0; i--) {
      dias.push({
        dia: diasMesAnterior - i,
        mesActual: false,
        fecha: new Date(year, month - 1, diasMesAnterior - i),
      });
    }

    // D√≠as del mes actual
    for (let i = 1; i <= diasEnMes; i++) {
      dias.push({
        dia: i,
        mesActual: true,
        fecha: new Date(year, month, i),
      });
    }

    // D√≠as del mes siguiente para completar la √∫ltima fila (solo si es necesario)
    const diasEnUltimaFila = dias.length % 7;
    if (diasEnUltimaFila > 0) {
      const diasRestantes = 7 - diasEnUltimaFila;
      for (let i = 1; i <= diasRestantes; i++) {
        dias.push({
          dia: i,
          mesActual: false,
          fecha: new Date(year, month + 1, i),
        });
      }
    }

    return dias;
  };

  // Obtener d√©cada actual (ej: 2020-2029)
  const obtenerDecada = (year) => {
    const inicio = Math.floor(year / 10) * 10;
    return { inicio, fin: inicio + 9 };
  };

  const irMesAnterior = () => {
    setMesActual(new Date(mesActual.getFullYear(), mesActual.getMonth() - 1, 1));
  };

  const irMesSiguiente = () => {
    setMesActual(new Date(mesActual.getFullYear(), mesActual.getMonth() + 1, 1));
  };

  const irAnioAnterior = () => {
    setMesActual(new Date(mesActual.getFullYear() - 1, mesActual.getMonth(), 1));
  };

  const irAnioSiguiente = () => {
    setMesActual(new Date(mesActual.getFullYear() + 1, mesActual.getMonth(), 1));
  };

  const irDecadaAnterior = () => {
    setMesActual(new Date(mesActual.getFullYear() - 10, mesActual.getMonth(), 1));
  };

  const irDecadaSiguiente = () => {
    setMesActual(new Date(mesActual.getFullYear() + 10, mesActual.getMonth(), 1));
  };

  const seleccionarMes = (mesIndex) => {
    setMesActual(new Date(mesActual.getFullYear(), mesIndex, 1));
    setVistaActual("dias");
  };

  const seleccionarAnio = (year) => {
    setMesActual(new Date(year, mesActual.getMonth(), 1));
    setVistaActual("meses");
  };

  const normalizarFecha = (fecha) => {
    const d = new Date(fecha);
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  };

  const compararFechas = (fecha1, fecha2) => {
    const d1 = normalizarFecha(fecha1);
    const d2 = normalizarFecha(fecha2);
    return d1.getTime() - d2.getTime();
  };

  const seleccionarDia = (dia) => {
    if (disabled) return;

    const fechaSeleccionada = dia.fecha;

    // Validar min/max
    if (minDate && fechaSeleccionada < new Date(minDate)) return;
    if (maxDate && fechaSeleccionada > new Date(maxDate)) return;

    if (modoRango && onChangeRango) {
      // Modo rango
      if (!value || (value && valueHasta)) {
        // No hay desde, o ya hay rango completo: empezar nuevo rango
        onChangeRango(fechaSeleccionada, null);
        setSeleccionandoRango(true);
      } else if (value && !valueHasta) {
        // Ya hay desde, seleccionar hasta
        const desde = new Date(value);
        if (compararFechas(fechaSeleccionada, desde) < 0) {
          // Click en fecha anterior al desde: usar como nuevo desde
          onChangeRango(fechaSeleccionada, null);
          setSeleccionandoRango(true);
        } else if (compararFechas(fechaSeleccionada, desde) === 0) {
          // Mismo d√≠a: selecci√≥n de d√≠a √∫nico
          onChangeRango(fechaSeleccionada, fechaSeleccionada);
          setSeleccionandoRango(false);
          setAbierto(false);
        } else {
          // Fecha posterior: completar rango
          onChangeRango(desde, fechaSeleccionada);
          setSeleccionandoRango(false);
          setAbierto(false);
        }
      }
    } else {
      // Modo d√≠a √∫nico
      onChange(fechaSeleccionada);
      setAbierto(false);
    }
  };

  const esDiaSeleccionado = (dia) => {
    if (!value) return false;
    return compararFechas(dia.fecha, value) === 0;
  };

  const esDiaHasta = (dia) => {
    if (!valueHasta) return false;
    return compararFechas(dia.fecha, valueHasta) === 0;
  };

  const esDiaEnRango = (dia) => {
    if (!modoRango || !value || !valueHasta) return false;
    const fechaDia = normalizarFecha(dia.fecha);
    const desde = normalizarFecha(value);
    const hasta = normalizarFecha(valueHasta);
    return fechaDia > desde && fechaDia < hasta;
  };

  const esHoy = (dia) => {
    const hoy = new Date();
    return (
      dia.fecha.getDate() === hoy.getDate() &&
      dia.fecha.getMonth() === hoy.getMonth() &&
      dia.fecha.getFullYear() === hoy.getFullYear()
    );
  };

  const esDiaDeshabilitado = (dia) => {
    if (minDate && dia.fecha < new Date(minDate)) return true;
    if (maxDate && dia.fecha > new Date(maxDate)) return true;
    return false;
  };

  const esMesActual = (mesIndex) => {
    const hoy = new Date();
    return mesIndex === hoy.getMonth() && mesActual.getFullYear() === hoy.getFullYear();
  };

  const esAnioActual = (year) => {
    return year === new Date().getFullYear();
  };

  const formatearFechaDisplay = (fecha) => {
    if (!fecha) return "";
    const d = new Date(fecha);
    const dia = d.getDate().toString().padStart(2, "0");
    const mes = (d.getMonth() + 1).toString().padStart(2, "0");
    const anio = d.getFullYear().toString().slice(-2);
    return `${dia}/${mes}/${anio}`;
  };

  const obtenerTextoBoton = () => {
    if (modoRango) {
      if (value && valueHasta) {
        if (compararFechas(value, valueHasta) === 0) {
          return formatearFechaDisplay(value);
        }
        return `${formatearFechaDisplay(value)} - ${formatearFechaDisplay(valueHasta)}`;
      }
      if (value && !valueHasta) {
        return `${formatearFechaDisplay(value)} - ...`;
      }
    } else if (value) {
      return formatearFechaDisplay(value);
    }
    return placeholder;
  };

  const limpiarSeleccion = () => {
    if (modoRango && onChangeRango) {
      onChangeRango(null, null);
    } else {
      onChange(null);
    }
    setSeleccionandoRango(false);
    setAbierto(false);
  };

  const tieneSeleccion = modoRango ? (value || valueHasta) : value;

  const dias = obtenerDiasMes(mesActual);
  const decada = obtenerDecada(mesActual.getFullYear());

  // Renderizar header seg√∫n vista
  const renderHeader = () => {
    if (vistaActual === "dias") {
      return (
        <div className="selector-fecha-header">
          <button type="button" className="selector-fecha-nav" onClick={irMesAnterior}>
            ‚óÄ
          </button>
          <button
            type="button"
            className="selector-fecha-titulo"
            onClick={() => setVistaActual("meses")}
          >
            {nombresMeses[mesActual.getMonth()]} {mesActual.getFullYear()}
          </button>
          <button type="button" className="selector-fecha-nav" onClick={irMesSiguiente}>
            ‚ñ∂
          </button>
        </div>
      );
    }

    if (vistaActual === "meses") {
      return (
        <div className="selector-fecha-header">
          <button type="button" className="selector-fecha-nav" onClick={irAnioAnterior}>
            ‚óÄ
          </button>
          <button
            type="button"
            className="selector-fecha-titulo"
            onClick={() => setVistaActual("anios")}
          >
            {mesActual.getFullYear()}
          </button>
          <button type="button" className="selector-fecha-nav" onClick={irAnioSiguiente}>
            ‚ñ∂
          </button>
        </div>
      );
    }

    // Vista a√±os
    return (
      <div className="selector-fecha-header">
        <button type="button" className="selector-fecha-nav" onClick={irDecadaAnterior}>
          ‚óÄ
        </button>
        <span className="selector-fecha-titulo selector-fecha-titulo--no-click">
          {decada.inicio} - {decada.fin}
        </span>
        <button type="button" className="selector-fecha-nav" onClick={irDecadaSiguiente}>
          ‚ñ∂
        </button>
      </div>
    );
  };

  // Renderizar contenido seg√∫n vista
  const renderContenido = () => {
    if (vistaActual === "dias") {
      return (
        <>
          <div className="selector-fecha-dias-semana">
            {nombresDias.map((nombre) => (
              <span key={nombre} className="selector-fecha-dia-semana">
                {nombre}
              </span>
            ))}
          </div>
          <div className="selector-fecha-grilla">
            {dias.map((dia, index) => (
              <button
                key={index}
                type="button"
                className={`selector-fecha-dia ${
                  !dia.mesActual ? "selector-fecha-dia--otro-mes" : ""
                } ${esDiaSeleccionado(dia) ? "selector-fecha-dia--desde" : ""} ${
                  esDiaHasta(dia) ? "selector-fecha-dia--hasta" : ""
                } ${esDiaEnRango(dia) ? "selector-fecha-dia--en-rango" : ""} ${
                  esHoy(dia) ? "selector-fecha-dia--hoy" : ""
                } ${esDiaDeshabilitado(dia) ? "selector-fecha-dia--deshabilitado" : ""}`}
                onClick={() => seleccionarDia(dia)}
                disabled={esDiaDeshabilitado(dia)}
              >
                {dia.dia}
              </button>
            ))}
          </div>
        </>
      );
    }

    if (vistaActual === "meses") {
      return (
        <div className="selector-fecha-grilla-meses">
          {nombresMesesCortos.map((nombre, index) => (
            <button
              key={index}
              type="button"
              className={`selector-fecha-mes-item ${
                esMesActual(index) ? "selector-fecha-mes-item--actual" : ""
              } ${
                mesActual.getMonth() === index ? "selector-fecha-mes-item--seleccionado" : ""
              }`}
              onClick={() => seleccionarMes(index)}
            >
              {nombre}
            </button>
          ))}
        </div>
      );
    }

    // Vista a√±os
    const anios = [];
    for (let i = decada.inicio; i <= decada.fin; i++) {
      anios.push(i);
    }

    return (
      <div className="selector-fecha-grilla-anios">
        {anios.map((year) => (
          <button
            key={year}
            type="button"
            className={`selector-fecha-anio-item ${
              esAnioActual(year) ? "selector-fecha-anio-item--actual" : ""
            } ${
              mesActual.getFullYear() === year ? "selector-fecha-anio-item--seleccionado" : ""
            }`}
            onClick={() => seleccionarAnio(year)}
          >
            {year}
          </button>
        ))}
      </div>
    );
  };

  return (
    <div className={`selector-fecha ${className}`} ref={contenedorRef}>
      <button
        type="button"
        className={`selector-fecha-btn ${abierto ? "selector-fecha-btn--activo" : ""} ${disabled ? "selector-fecha-btn--disabled" : ""} ${tieneSeleccion ? "selector-fecha-btn--con-valor" : ""}`}
        onClick={() => !disabled && setAbierto(!abierto)}
        disabled={disabled}
        title={obtenerTextoBoton()}
      >
        <span className="selector-fecha-icono">üìÖ</span>
      </button>

      {abierto && (
        <div className="selector-fecha-dropdown">
          {/* Indicador de modo rango */}
          {modoRango && (
            <div className="selector-fecha-modo">
              <div className="selector-fecha-modo-contenido">
                {!value ? (
                  <span className="selector-fecha-instruccion">Selecciona fecha inicial</span>
                ) : !valueHasta ? (
                  <span className="selector-fecha-instruccion selector-fecha-instruccion--activo">
                    <span className="selector-fecha-desde-badge">{formatearFechaDisplay(value)}</span>
                    ‚Üí Selecciona fecha final
                  </span>
                ) : (
                  <span className="selector-fecha-instruccion selector-fecha-instruccion--completo">
                    <span className="selector-fecha-desde-badge">{formatearFechaDisplay(value)}</span>
                    ‚Üí
                    <span className="selector-fecha-hasta-badge">{formatearFechaDisplay(valueHasta)}</span>
                  </span>
                )}
              </div>
              {tieneSeleccion && (
                <button
                  type="button"
                  className="selector-fecha-limpiar-mini"
                  onClick={limpiarSeleccion}
                  title="Limpiar selecci√≥n"
                >
                  Limpiar
                </button>
              )}
            </div>
          )}

          {renderHeader()}
          {renderContenido()}

          {/* Footer solo para modo simple (no rango) */}
          {!modoRango && tieneSeleccion && vistaActual === "dias" && (
            <div className="selector-fecha-footer">
              <button
                type="button"
                className="selector-fecha-limpiar"
                onClick={limpiarSeleccion}
              >
                Limpiar
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default SelectorFecha;

// ===== ./src/contextos/AuthContext.jsx =====

// src/contextos/AuthContext.jsx
// Contexto de autenticaci√≥n para toda la aplicaci√≥n

import React, { createContext, useContext, useState, useEffect } from 'react';
import {
  iniciarSesion,
  cerrarSesion,
  obtenerSesion,
  obtenerUsuarioActual,
  registrarUsuario,
  recuperarContrasena,
  suscribirseACambiosAuth,
} from '../servicios/authService';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [usuario, setUsuario] = useState(null);
  const [cargando, setCargando] = useState(true);
  const [error, setError] = useState(null);

  // Cargar sesi√≥n al iniciar
  useEffect(() => {
    const cargarSesion = async () => {
      try {
        const { session } = await obtenerSesion();
        if (session) {
          const { usuario: datosUsuario } = await obtenerUsuarioActual();
          setUsuario(datosUsuario);
        }
      } catch (err) {
        console.error('Error al cargar sesi√≥n:', err);
      } finally {
        setCargando(false);
      }
    };

    cargarSesion();

    // Suscribirse a cambios de auth
    const desuscribir = suscribirseACambiosAuth(async (event, session) => {
      if (event === 'SIGNED_IN' && session) {
        const { usuario: datosUsuario } = await obtenerUsuarioActual();
        setUsuario(datosUsuario);
      } else if (event === 'SIGNED_OUT') {
        setUsuario(null);
      }
    });

    return () => desuscribir();
  }, []);

  // Funci√≥n de login
  const login = async (email, password) => {
    setError(null);
    const { user, error: loginError } = await iniciarSesion(email, password);

    if (loginError) {
      setError(loginError);
      return { exito: false, error: loginError };
    }

    if (user) {
      const { usuario: datosUsuario } = await obtenerUsuarioActual();
      setUsuario(datosUsuario);
    }

    return { exito: true, error: null };
  };

  // Funci√≥n de registro
  const registro = async (email, password, nombre) => {
    setError(null);
    const { user, error: registroError } = await registrarUsuario(email, password, nombre);

    if (registroError) {
      setError(registroError);
      return { exito: false, error: registroError };
    }

    return { exito: true, error: null, requiereConfirmacion: true };
  };

  // Funci√≥n de logout
  const logout = async () => {
    const { error: logoutError } = await cerrarSesion();
    if (!logoutError) {
      setUsuario(null);
    }
    return { error: logoutError };
  };

  // Funci√≥n para recuperar contrase√±a
  const recuperar = async (email) => {
    setError(null);
    const { error: recuperarError } = await recuperarContrasena(email);

    if (recuperarError) {
      setError(recuperarError);
      return { exito: false, error: recuperarError };
    }

    return { exito: true, error: null };
  };

  const valor = {
    usuario,
    cargando,
    error,
    estaAutenticado: !!usuario,
    login,
    logout,
    registro,
    recuperar,
  };

  return (
    <AuthContext.Provider value={valor}>
      {children}
    </AuthContext.Provider>
  );
}

// Hook personalizado para usar el contexto
export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth debe usarse dentro de un AuthProvider');
  }
  return context;
}

// ===== ./src/fuentes.css =====

/* src/fuentes.css
 * Definiciones @font-face para todas las fuentes locales
 * Las fuentes se cargan desde public/fonts/
 */

/* ============================================
   FUENTES DIGITALES (ya existentes)
   ============================================ */

@font-face {
  font-family: 'Digital-7';
  src: url('/fonts/digital-7.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Digital-7-Mono';
  src: url('/fonts/digital-7 (mono).ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'DS-Digital';
  src: url('/fonts/ds-digi.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'DS-Digital-Bold';
  src: url('/fonts/DS-DIGIB.TTF') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'BalooBhai2';
  src: url('/fonts/BalooBhai2-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'BalooBhai2';
  src: url('/fonts/BalooBhai2-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* ============================================
   GOOGLE FONTS (descargadas localmente)
   ============================================ */

/* Fira Code - Monoespaciada para c√≥digo */
@font-face {
  font-family: 'Fira Code';
  src: url('/fonts/FiraCode-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Fira Code';
  src: url('/fonts/FiraCode-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Inter - Moderna para UI */
@font-face {
  font-family: 'Inter';
  src: url('/fonts/Inter-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Inter';
  src: url('/fonts/Inter-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Lato - Elegante y profesional */
@font-face {
  font-family: 'Lato';
  src: url('/fonts/Lato-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Lato';
  src: url('/fonts/Lato-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Montserrat - Variable font (400-700) */
@font-face {
  font-family: 'Montserrat';
  src: url('/fonts/Montserrat-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Open Sans - Variable font (400-700) */
@font-face {
  font-family: 'Open Sans';
  src: url('/fonts/OpenSans-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Orbitron - Futurista/Sci-fi */
@font-face {
  font-family: 'Orbitron';
  src: url('/fonts/Orbitron-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Orbitron';
  src: url('/fonts/Orbitron-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Rajdhani - T√©cnica/Industrial */
@font-face {
  font-family: 'Rajdhani';
  src: url('/fonts/Rajdhani-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Rajdhani';
  src: url('/fonts/Rajdhani-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Roboto - Variable font (400-700) */
@font-face {
  font-family: 'Roboto';
  src: url('/fonts/Roboto-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Roboto Mono - Monoespaciada */
@font-face {
  font-family: 'Roboto Mono';
  src: url('/fonts/RobotoMono-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Roboto Mono';
  src: url('/fonts/RobotoMono-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Source Sans 3 - Adobe, excelente legibilidad */
@font-face {
  font-family: 'Source Sans 3';
  src: url('/fonts/SourceSans3-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* ============================================
   FUENTES ADICIONALES (10 nuevas)
   ============================================ */

/* Ubuntu - Muy legible, moderna */
@font-face {
  font-family: 'Ubuntu';
  src: url('/fonts/Ubuntu-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Ubuntu';
  src: url('/fonts/Ubuntu-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Poppins - Geom√©trica, popular */
@font-face {
  font-family: 'Poppins';
  src: url('/fonts/Poppins-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Poppins';
  src: url('/fonts/Poppins-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Quicksand - Redondeada, amigable (variable) */
@font-face {
  font-family: 'Quicksand';
  src: url('/fonts/Quicksand-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Oswald - Condensada, impactante (variable) */
@font-face {
  font-family: 'Oswald';
  src: url('/fonts/Oswald-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Playfair Display - Serif elegante (variable) */
@font-face {
  font-family: 'Playfair Display';
  src: url('/fonts/PlayfairDisplay-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Nunito - Redondeada, muy legible (variable) */
@font-face {
  font-family: 'Nunito';
  src: url('/fonts/Nunito-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Russo One - Estilo industrial/gaming */
@font-face {
  font-family: 'Russo One';
  src: url('/fonts/RussoOne-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

/* Teko - Condensada, t√©cnica (variable) */
@font-face {
  font-family: 'Teko';
  src: url('/fonts/Teko-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Share Tech Mono - Monoespaciada tecnol√≥gica */
@font-face {
  font-family: 'Share Tech Mono';
  src: url('/fonts/ShareTechMono-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

/* JetBrains Mono - Excelente para c√≥digo */
@font-face {
  font-family: 'JetBrains Mono';
  src: url('/fonts/JetBrainsMono-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'JetBrains Mono';
  src: url('/fonts/JetBrainsMono-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* ============================================
   FUENTES ADICIONALES (15 nuevas)
   ============================================ */

/* Barlow - Grotesk moderna, legible */
@font-face {
  font-family: 'Barlow';
  src: url('/fonts/Barlow-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Barlow';
  src: url('/fonts/Barlow-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Bebas Neue - Display, impactante */
@font-face {
  font-family: 'Bebas Neue';
  src: url('/fonts/BebasNeue-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

/* Cabin - Humanista, amigable */
@font-face {
  font-family: 'Cabin';
  src: url('/fonts/Cabin-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Cabin';
  src: url('/fonts/Cabin-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Comfortaa - Redondeada, moderna (variable) */
@font-face {
  font-family: 'Comfortaa';
  src: url('/fonts/Comfortaa-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Exo 2 - Tecnol√≥gica, futurista */
@font-face {
  font-family: 'Exo 2';
  src: url('/fonts/Exo2-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

/* IBM Plex Sans - Corporativa, t√©cnica */
@font-face {
  font-family: 'IBM Plex Sans';
  src: url('/fonts/IBMPlexSans-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'IBM Plex Sans';
  src: url('/fonts/IBMPlexSans-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Inconsolata - Monoespaciada, clara */
@font-face {
  font-family: 'Inconsolata';
  src: url('/fonts/Inconsolata-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

/* Kanit - Thai-latina, angular */
@font-face {
  font-family: 'Kanit';
  src: url('/fonts/Kanit-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Kanit';
  src: url('/fonts/Kanit-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Oxanium - Gaming/Sci-fi (variable) */
@font-face {
  font-family: 'Oxanium';
  src: url('/fonts/Oxanium-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Play - T√©cnica, industrial */
@font-face {
  font-family: 'Play';
  src: url('/fonts/Play-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Play';
  src: url('/fonts/Play-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Rubik - Geom√©trica, vers√°til (variable) */
@font-face {
  font-family: 'Rubik';
  src: url('/fonts/Rubik-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Space Mono - Monoespaciada, retro-futurista */
@font-face {
  font-family: 'Space Mono';
  src: url('/fonts/SpaceMono-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Space Mono';
  src: url('/fonts/SpaceMono-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Titillium Web - T√©cnica, NASA-style */
@font-face {
  font-family: 'Titillium Web';
  src: url('/fonts/TitilliumWeb-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Titillium Web';
  src: url('/fonts/TitilliumWeb-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Work Sans - Grotesk, optimizada para pantalla (variable) */
@font-face {
  font-family: 'Work Sans';
  src: url('/fonts/WorkSans-Regular.ttf') format('truetype');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* Zilla Slab - Slab serif, Mozilla */
@font-face {
  font-family: 'Zilla Slab';
  src: url('/fonts/ZillaSlab-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Zilla Slab';
  src: url('/fonts/ZillaSlab-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

// ===== ./src/hooks/useErrorHandler.js =====

/**
 * Hook para manejo consistente de errores en la aplicaci√≥n
 * Proporciona funciones para capturar, mostrar y reportar errores
 */

import { useState, useCallback, useRef } from "react";

/**
 * Niveles de severidad de errores
 */
export const ERROR_LEVELS = {
  INFO: "info",
  WARNING: "warning",
  ERROR: "error",
  CRITICAL: "critical",
};

/**
 * C√≥digos de error predefinidos
 */
export const ERROR_CODES = {
  NETWORK: "NETWORK_ERROR",
  DATABASE: "DATABASE_ERROR",
  VALIDATION: "VALIDATION_ERROR",
  AUTH: "AUTH_ERROR",
  MODBUS: "MODBUS_ERROR",
  UNKNOWN: "UNKNOWN_ERROR",
};

/**
 * Hook para manejar errores de forma consistente
 * @param {Object} options - Opciones de configuraci√≥n
 * @param {boolean} options.logToConsole - Si debe loggear a consola (default: true en dev)
 * @param {number} options.maxErrors - M√°ximo de errores a mantener en historial (default: 50)
 * @param {number} options.autoCleanupMs - Tiempo en ms para limpiar errores viejos (default: 300000 = 5 min)
 * @returns {Object} - Funciones y estado del manejador de errores
 */
const useErrorHandler = (options = {}) => {
  const {
    logToConsole = import.meta.env.DEV,
    maxErrors = 50,
    autoCleanupMs = 5 * 60 * 1000,
  } = options;

  // Estado de errores actuales
  const [errors, setErrors] = useState([]);
  const [lastError, setLastError] = useState(null);

  // Ref para el timer de auto-cleanup
  const cleanupTimerRef = useRef(null);

  /**
   * Genera un ID √∫nico para cada error
   */
  const generateErrorId = useCallback(() => {
    return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }, []);

  /**
   * Formatea un error para almacenamiento consistente
   */
  const formatError = useCallback((error, context = {}) => {
    const errorObj = {
      id: generateErrorId(),
      timestamp: new Date().toISOString(),
      message: "",
      code: ERROR_CODES.UNKNOWN,
      level: ERROR_LEVELS.ERROR,
      stack: null,
      context: {},
      originalError: null,
    };

    // Si es un Error nativo
    if (error instanceof Error) {
      errorObj.message = error.message;
      errorObj.stack = error.stack;
      errorObj.originalError = error;

      // Detectar tipo de error por mensaje
      if (error.message.includes("fetch") || error.message.includes("network")) {
        errorObj.code = ERROR_CODES.NETWORK;
      } else if (error.message.includes("IndexedDB") || error.message.includes("database")) {
        errorObj.code = ERROR_CODES.DATABASE;
      } else if (error.message.includes("Modbus") || error.message.includes("modbus")) {
        errorObj.code = ERROR_CODES.MODBUS;
      }
    }
    // Si es un string
    else if (typeof error === "string") {
      errorObj.message = error;
    }
    // Si es un objeto con propiedades de error
    else if (typeof error === "object" && error !== null) {
      errorObj.message = error.message || JSON.stringify(error);
      errorObj.code = error.code || ERROR_CODES.UNKNOWN;
      errorObj.level = error.level || ERROR_LEVELS.ERROR;
    }

    // Merge con contexto proporcionado
    errorObj.context = {
      ...context,
      userAgent: typeof navigator !== "undefined" ? navigator.userAgent : "unknown",
      url: typeof window !== "undefined" ? window.location.href : "unknown",
    };

    // Override con valores del contexto si existen
    if (context.code) errorObj.code = context.code;
    if (context.level) errorObj.level = context.level;

    return errorObj;
  }, [generateErrorId]);

  /**
   * Captura y registra un error
   * @param {Error|string|Object} error - El error a capturar
   * @param {Object} context - Contexto adicional (c√≥digo, nivel, metadata)
   * @returns {Object} - El error formateado
   */
  const captureError = useCallback((error, context = {}) => {
    const formattedError = formatError(error, context);

    // Log a consola si est√° habilitado
    if (logToConsole) {
      const logMethod = formattedError.level === ERROR_LEVELS.WARNING ? console.warn : console.error;
      logMethod(`[${formattedError.code}] ${formattedError.message}`, {
        context: formattedError.context,
        stack: formattedError.stack,
      });
    }

    // Agregar al estado
    setErrors((prev) => {
      const updated = [formattedError, ...prev];
      // Limitar tama√±o del historial
      return updated.slice(0, maxErrors);
    });

    setLastError(formattedError);

    // Programar auto-limpieza
    if (cleanupTimerRef.current) {
      clearTimeout(cleanupTimerRef.current);
    }
    cleanupTimerRef.current = setTimeout(() => {
      setErrors((prev) => {
        const cutoffTime = Date.now() - autoCleanupMs;
        return prev.filter((err) => new Date(err.timestamp).getTime() > cutoffTime);
      });
    }, autoCleanupMs);

    return formattedError;
  }, [formatError, logToConsole, maxErrors, autoCleanupMs]);

  /**
   * Captura un error de nivel warning
   */
  const captureWarning = useCallback((message, context = {}) => {
    return captureError(message, { ...context, level: ERROR_LEVELS.WARNING });
  }, [captureError]);

  /**
   * Captura un error de nivel info
   */
  const captureInfo = useCallback((message, context = {}) => {
    return captureError(message, { ...context, level: ERROR_LEVELS.INFO });
  }, [captureError]);

  /**
   * Limpia un error espec√≠fico por ID
   */
  const dismissError = useCallback((errorId) => {
    setErrors((prev) => prev.filter((err) => err.id !== errorId));
    setLastError((prev) => (prev?.id === errorId ? null : prev));
  }, []);

  /**
   * Limpia todos los errores
   */
  const clearAllErrors = useCallback(() => {
    setErrors([]);
    setLastError(null);
    if (cleanupTimerRef.current) {
      clearTimeout(cleanupTimerRef.current);
    }
  }, []);

  /**
   * Obtiene errores filtrados por nivel
   */
  const getErrorsByLevel = useCallback((level) => {
    return errors.filter((err) => err.level === level);
  }, [errors]);

  /**
   * Obtiene errores filtrados por c√≥digo
   */
  const getErrorsByCode = useCallback((code) => {
    return errors.filter((err) => err.code === code);
  }, [errors]);

  /**
   * Wrapper para funciones async que captura errores autom√°ticamente
   * @param {Function} asyncFn - Funci√≥n async a ejecutar
   * @param {Object} context - Contexto para el error si ocurre
   * @returns {Promise<[result, error]>} - Tupla [resultado, error]
   */
  const withErrorCapture = useCallback((asyncFn, context = {}) => {
    return async (...args) => {
      try {
        const result = await asyncFn(...args);
        return [result, null];
      } catch (error) {
        const captured = captureError(error, context);
        return [null, captured];
      }
    };
  }, [captureError]);

  /**
   * Ejecuta una funci√≥n y captura errores autom√°ticamente
   * @param {Function} fn - Funci√≥n a ejecutar
   * @param {Object} context - Contexto para el error si ocurre
   * @returns {Promise<[result, error]>} - Tupla [resultado, error]
   */
  const tryCatch = useCallback(async (fn, context = {}) => {
    try {
      const result = await fn();
      return [result, null];
    } catch (error) {
      const captured = captureError(error, context);
      return [null, captured];
    }
  }, [captureError]);

  return {
    // Estado
    errors,
    lastError,
    hasErrors: errors.length > 0,
    errorCount: errors.length,

    // Funciones de captura
    captureError,
    captureWarning,
    captureInfo,

    // Funciones de limpieza
    dismissError,
    clearAllErrors,

    // Funciones de filtrado
    getErrorsByLevel,
    getErrorsByCode,

    // Utilidades
    withErrorCapture,
    tryCatch,

    // Constantes exportadas
    ERROR_LEVELS,
    ERROR_CODES,
  };
};

export default useErrorHandler;

// ===== ./src/hooks/usePushNotifications.js =====

// src/hooks/usePushNotifications.js
// Hook para gestionar push notifications en la app

import { useEffect, useRef, useCallback } from 'react';
import {
  esPlataformaNativa,
  registrarPushNotifications,
  desregistrarPushNotifications,
} from '../servicios/pushNotifications';
import { registrarTokenDispositivo } from '../servicios/apiService';

/**
 * Hook para inicializar y gestionar push notifications.
 * Solo funciona en plataformas nativas (Android/iOS).
 *
 * @param {Object} opciones - Opciones del hook
 * @param {boolean} opciones.habilitado - Si las notificaciones est√°n habilitadas (default: true)
 * @param {Function} opciones.onNotificacion - Callback cuando llega una notificaci√≥n en primer plano
 * @param {Function} opciones.onNotificacionTocada - Callback cuando el usuario toca la notificaci√≥n
 * @returns {Object} { esNativo, tokenRegistrado }
 */
export function usePushNotifications({
  habilitado = true,
  onNotificacion = null,
  onNotificacionTocada = null,
} = {}) {
  const tokenRegistradoRef = useRef(false);
  const esNativo = esPlataformaNativa();

  // Callback para cuando se recibe el token FCM
  const handleTokenRecibido = useCallback(async (token) => {
    if (tokenRegistradoRef.current) {
      console.log('[Push Hook] Token ya registrado, ignorando');
      return;
    }

    try {
      console.log('[Push Hook] Registrando token en backend...');
      await registrarTokenDispositivo(token, 'android');
      tokenRegistradoRef.current = true;
      console.log('[Push Hook] Token registrado exitosamente');
    } catch (error) {
      console.error('[Push Hook] Error registrando token:', error);
    }
  }, []);

  // Callback para notificaciones en primer plano
  const handleNotificacion = useCallback((notificacion) => {
    console.log('[Push Hook] Notificaci√≥n recibida:', notificacion);
    if (onNotificacion) {
      onNotificacion(notificacion);
    }
  }, [onNotificacion]);

  // Callback para cuando el usuario toca la notificaci√≥n
  const handleNotificacionTocada = useCallback((datos) => {
    console.log('[Push Hook] Notificaci√≥n tocada:', datos);
    if (onNotificacionTocada) {
      onNotificacionTocada(datos);
    }
  }, [onNotificacionTocada]);

  useEffect(() => {
    if (!esNativo || !habilitado) {
      console.log('[Push Hook] Saltando inicializaci√≥n (nativo:', esNativo, ', habilitado:', habilitado, ')');
      return;
    }

    console.log('[Push Hook] Inicializando push notifications...');

    // Inicializar push notifications
    registrarPushNotifications(
      handleTokenRecibido,
      handleNotificacion,
      handleNotificacionTocada
    );

    // Cleanup al desmontar
    return () => {
      console.log('[Push Hook] Limpiando listeners...');
      desregistrarPushNotifications();
    };
  }, [esNativo, habilitado, handleTokenRecibido, handleNotificacion, handleNotificacionTocada]);

  return {
    esNativo,
    tokenRegistrado: tokenRegistradoRef.current,
  };
}

export default usePushNotifications;

// ===== ./src/index.css =====

@import "tailwindcss";
@import "tw-animate-css";

/* src/index.css */
/* 
   NOTA PERSONAL SOBRE ESTE ARCHIVO (index.css)
   - Este archivo define la ‚Äúbase‚Äù de estilos globales de la app.
   - Primero importa Tailwind (`tailwindcss` y `tw-animate-css`) para poder usar
      las utilidades y animaciones en todos los componentes.
   - Luego declara muchas CSS custom properties (variables) para colores, radios,
      fondos, etc., que funcionan como un peque√±o sistema de dise√±o com√∫n.
   - La secci√≥n `.dark { ... }` redefine esas mismas variables cuando el
      documento tiene la clase `dark`, habilitando el tema oscuro.
   - En `@layer base` se aplican estilos base de Tailwind al `body` y a todos
      los elementos (borde/outline seg√∫n el tema).
   - Al final se registra la fuente ‚ÄúDS-Digital‚Äù, que se usa en los displays
      num√©ricos de las tarjetas de alimentadores para simular un display digital.
*/

@custom-variant dark (&:is(.dark *));

@theme inline {
   --radius-sm: calc(var(--radius) - 4px);
   --radius-md: calc(var(--radius) - 2px);
   --radius-lg: var(--radius);
   --radius-xl: calc(var(--radius) + 4px);
   --color-background: var(--background);
   --color-foreground: var(--foreground);
   --color-card: var(--card);
   --color-card-foreground: var(--card-foreground);
   --color-popover: var(--popover);
   --color-popover-foreground: var(--popover-foreground);
   --color-primary: var(--primary);
   --color-primary-foreground: var(--primary-foreground);
   --color-secondary: var(--secondary);
   --color-secondary-foreground: var(--secondary-foreground);
   --color-muted: var(--muted);
   --color-muted-foreground: var(--muted-foreground);
   --color-accent: var(--accent);
   --color-accent-foreground: var(--accent-foreground);
   --color-destructive: var(--destructive);
   --color-border: var(--border);
   --color-input: var(--input);
   --color-ring: var(--ring);
   --color-chart-1: var(--chart-1);
   --color-chart-2: var(--chart-2);
   --color-chart-3: var(--chart-3);
   --color-chart-4: var(--chart-4);
   --color-chart-5: var(--chart-5);
   --color-sidebar: var(--sidebar);
   --color-sidebar-foreground: var(--sidebar-foreground);
   --color-sidebar-primary: var(--sidebar-primary);
   --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
   --color-sidebar-accent: var(--sidebar-accent);
   --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
   --color-sidebar-border: var(--sidebar-border);
   --color-sidebar-ring: var(--sidebar-ring);
}

:root {
   --radius: 0.625rem;
   --background: oklch(1 0 0);
   --foreground: oklch(0.145 0 0);
   --card: oklch(1 0 0);
   --card-foreground: oklch(0.145 0 0);
   --popover: oklch(1 0 0);
   --popover-foreground: oklch(0.145 0 0);
   --primary: oklch(0.205 0 0);
   --primary-foreground: oklch(0.985 0 0);
   --secondary: oklch(0.97 0 0);
   --secondary-foreground: oklch(0.205 0 0);
   --muted: oklch(0.97 0 0);
   --muted-foreground: oklch(0.556 0 0);
   --accent: oklch(0.97 0 0);
   --accent-foreground: oklch(0.205 0 0);
   --destructive: oklch(0.577 0.245 27.325);
   --border: oklch(0.922 0 0);
   --input: oklch(0.922 0 0);
   --ring: oklch(0.708 0 0);
   --chart-1: oklch(0.646 0.222 41.116);
   --chart-2: oklch(0.6 0.118 184.704);
   --chart-3: oklch(0.398 0.07 227.392);
   --chart-4: oklch(0.828 0.189 84.429);
   --chart-5: oklch(0.769 0.188 70.08);
   --sidebar: oklch(0.985 0 0);
   --sidebar-foreground: oklch(0.145 0 0);
   --sidebar-primary: oklch(0.205 0 0);
   --sidebar-primary-foreground: oklch(0.985 0 0);
   --sidebar-accent: oklch(0.97 0 0);
   --sidebar-accent-foreground: oklch(0.205 0 0);
   --sidebar-border: oklch(0.922 0 0);
   --sidebar-ring: oklch(0.708 0 0);
}

.dark {
   --background: oklch(0.145 0 0);
   --foreground: oklch(0.985 0 0);
   --card: oklch(0.205 0 0);
   --card-foreground: oklch(0.985 0 0);
   --popover: oklch(0.205 0 0);
   --popover-foreground: oklch(0.985 0 0);
   --primary: oklch(0.922 0 0);
   --primary-foreground: oklch(0.205 0 0);
   --secondary: oklch(0.269 0 0);
   --secondary-foreground: oklch(0.985 0 0);
   --muted: oklch(0.269 0 0);
   --muted-foreground: oklch(0.708 0 0);
   --accent: oklch(0.269 0 0);
   --accent-foreground: oklch(0.985 0 0);
   --destructive: oklch(0.704 0.191 22.216);
   --border: oklch(1 0 0 / 10%);
   --input: oklch(1 0 0 / 15%);
   --ring: oklch(0.556 0 0);
   --chart-1: oklch(0.488 0.243 264.376);
   --chart-2: oklch(0.696 0.17 162.48);
   --chart-3: oklch(0.769 0.188 70.08);
   --chart-4: oklch(0.627 0.265 303.9);
   --chart-5: oklch(0.645 0.246 16.439);
   --sidebar: oklch(0.205 0 0);
   --sidebar-foreground: oklch(0.985 0 0);
   --sidebar-primary: oklch(0.488 0.243 264.376);
   --sidebar-primary-foreground: oklch(0.985 0 0);
   --sidebar-accent: oklch(0.269 0 0);
   --sidebar-accent-foreground: oklch(0.985 0 0);
   --sidebar-border: oklch(1 0 0 / 10%);
   --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
   * {
      @apply border-border outline-ring/50;
   }
   body {
      @apply bg-background text-foreground;
      min-height: 100vh;
      min-height: 100dvh; /* Dynamic viewport height para m√≥viles */
   }

   /* Safe Area Insets - Compatibilidad con plugin @capacitor-community/safe-area
      El plugin establece variables var(--safe-area-inset-*) en Android.
      Usamos fallback a env() para navegadores que lo soportan nativamente. */
   :root {
      --safe-area-inset-top: env(safe-area-inset-top, 0px);
      --safe-area-inset-right: env(safe-area-inset-right, 0px);
      --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
      --safe-area-inset-left: env(safe-area-inset-left, 0px);
   }
}

/* Fuentes digitales para los displays de los alimentadores */
@font-face {
   font-family: "DS-Digital";
   src: url("/fonts/ds-digi.ttf") format("truetype");
   font-weight: normal;
   font-style: normal;
   font-display: swap;
}

@font-face {
   font-family: "DS-Digital-Bold";
   src: url("/fonts/DS-DIGIB.TTF") format("truetype");
   font-weight: bold;
   font-style: normal;
   font-display: swap;
}

@font-face {
   font-family: "Digital-7";
   src: url("/fonts/digital-7.ttf") format("truetype");
   font-weight: normal;
   font-style: normal;
   font-display: swap;
}

@font-face {
   font-family: "Digital-7-Mono";
   src: url("/fonts/digital-7 (mono).ttf") format("truetype");
   font-weight: normal;
   font-style: normal;
   font-display: swap;
}

/* Fuentes industriales/t√©cnicas adicionales */
@font-face {
   font-family: "Orbitron";
   src: url("/fonts/Orbitron-Regular.ttf") format("truetype");
   font-weight: normal;
   font-style: normal;
   font-display: swap;
}

@font-face {
   font-family: "Orbitron";
   src: url("/fonts/Orbitron-Bold.ttf") format("truetype");
   font-weight: bold;
   font-style: normal;
   font-display: swap;
}

@font-face {
   font-family: "Roboto Mono";
   src: url("/fonts/RobotoMono-Regular.ttf") format("truetype");
   font-weight: normal;
   font-style: normal;
   font-display: swap;
}

@font-face {
   font-family: "Roboto Mono";
   src: url("/fonts/RobotoMono-Bold.ttf") format("truetype");
   font-weight: bold;
   font-style: normal;
   font-display: swap;
}

@font-face {
   font-family: "Rajdhani";
   src: url("/fonts/Rajdhani-Regular.ttf") format("truetype");
   font-weight: normal;
   font-style: normal;
   font-display: swap;
}

@font-face {
   font-family: "Rajdhani";
   src: url("/fonts/Rajdhani-Bold.ttf") format("truetype");
   font-weight: bold;
   font-style: normal;
   font-display: swap;
}

/* Ocultar scrollbar pero mantener scroll funcional */
html,
body,
* {
   scrollbar-width: none; /* Firefox */
}
html::-webkit-scrollbar,
body::-webkit-scrollbar,
*::-webkit-scrollbar {
   display: none; /* Chrome, Safari, Edge */
}

/* =========================================================
   ESTILOS PARA CAPACITOR (App Nativa Android/iOS)
   Android 15+ fuerza edge-to-edge, usamos CSS para compensar.
   Capacitor inyecta --safe-area-inset-* autom√°ticamente.
   ========================================================= */
html.capacitor-native {
   background-color: #0f172a;
   margin: 0;
   padding: 0;
}

body.capacitor-native {
   background-color: #0f172a;
   margin: 0;
   padding: 0;
}

.capacitor-native #root {
   background-color: #0f172a;
   margin: 0;
   padding: 0;
}

/* El div#status-bar-cover se crea din√°micamente en main.jsx para cubrir la status bar */


// ===== ./src/lib/supabase.js =====

// src/lib/supabase.js
// Cliente de Supabase para el frontend

import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Faltan las variables de entorno de Supabase (VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY)');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);

// ===== ./src/main.jsx =====

// src/main.jsx
import React from "react";                         // librer√≠a principal de React para componentes
import ReactDOM from "react-dom/client";           // API moderna de renderizado en el navegador
import { BrowserRouter } from "react-router-dom";  // enrutador basado en historial del navegador
import { AuthProvider } from "./contextos/AuthContext"; // contexto de autenticaci√≥n con Supabase
import App from "./App.jsx";                       // componente ra√≠z de la aplicaci√≥n (define las rutas)
import "./index.css";                              // estilos globales (tailwind + tema general)
import "./fuentes.css";                            // fuentes locales desde public/fonts/
import { Capacitor } from "@capacitor/core";       // para detectar plataforma nativa

// Configurar plataforma nativa (Android/iOS)
if (Capacitor.isNativePlatform()) {
   // Agregar clase a html y body para estilos espec√≠ficos de app nativa
   document.documentElement.classList.add('capacitor-native');
   document.body.classList.add('capacitor-native');
   // Los insets se manejan desde MainActivity.java con ViewCompat.setOnApplyWindowInsetsListener
}

ReactDOM.createRoot(document.getElementById("root")).render(   // crea la ra√≠z de React sobre el div#root
   <React.StrictMode>                   {/* modo estricto: ayuda a detectar problemas en desarrollo */}
      <BrowserRouter>                   {/* provee contexto de rutas a toda la app */}
         <AuthProvider>                 {/* provee contexto de autenticaci√≥n a toda la app */}
            <App />                     {/* componente principal que contiene las p√°ginas/rutas */}
         </AuthProvider>
      </BrowserRouter>
   </React.StrictMode>
);

// ---------------------------------------------------------------------------
// NOTA PERSONAL SOBRE ESTE ARCHIVO (main.jsx)
// - Este es el punto de entrada de la app React que usa Vite.
// - ReactDOM.createRoot() toma el <div id="root"> del index.html y ah√≠ monta todo.
// - StrictMode solo afecta al modo desarrollo: vuelve a montar componentes para
//   avisar de problemas potenciales, pero en producci√≥n no impacta.
// - BrowserRouter envuelve a <App /> para que dentro pueda usar rutas
//   (Link, Route, useNavigate, etc.) basadas en la URL del navegador.
// - En resumen: ac√° se conecta el HTML base con mi √°rbol de componentes y el
//   sistema de rutas de React Router.

// ===== ./src/paginas/PaginaAlimentadores/componentes/historial/BarraControlesHistorial.jsx =====

/**
 * Barra de controles para la ventana de historial
 * Incluye: toggle panel, tabs de zona, selector de rango, tipo de grafico, selector alimentador, cache
 */

import PropTypes from "prop-types";
import { RANGOS_TIEMPO, TIPOS_GRAFICO } from "../../constantes/historialConfig";
import SelectorFecha from "../../../../componentes/comunes/SelectorFecha";

/**
 * @param {Object} props
 * @param {boolean} props.panelDatosAbierto - Si el panel de datos est√° visible
 * @param {Function} props.onTogglePanel - Callback para toggle del panel
 * @param {string} props.zonaSeleccionada - "superior" o "inferior"
 * @param {Function} props.onZonaChange - Callback al cambiar zona
 * @param {Function} props.zonaDisponible - Funci√≥n que verifica si una zona est√° disponible
 * @param {string} props.tituloSuperior - T√≠tulo de la zona superior
 * @param {string} props.tituloInferior - T√≠tulo de la zona inferior
 * @param {string} props.rangoSeleccionado - ID del rango seleccionado
 * @param {Function} props.onRangoChange - Callback al cambiar rango
 * @param {Date|null} props.fechaRangoDesde - Fecha desde (rango personalizado)
 * @param {Date|null} props.fechaRangoHasta - Fecha hasta (rango personalizado)
 * @param {Function} props.onFechaRangoChange - Callback al cambiar fechas
 * @param {string} props.tipoGrafico - Tipo de gr√°fico seleccionado
 * @param {Function} props.onTipoGraficoChange - Callback al cambiar tipo
 * @param {string} props.alimentadorId - ID del alimentador actual
 * @param {Array} props.alimentadores - Lista de alimentadores disponibles
 * @param {Function} props.onAlimentadorChange - Callback al cambiar alimentador
 * @param {number} props.precargaProgreso - Progreso de precarga (0-100)
 * @param {boolean} props.precargaCompleta - Si la precarga termin√≥
 * @param {boolean} props.precargando - Si est√° precargando
 * @param {string|null} props.fuenteDatos - Fuente de datos actual
 * @param {Function} props.onLimpiarCache - Callback para limpiar cache
 */
const BarraControlesHistorial = ({
  panelDatosAbierto,
  onTogglePanel,
  zonaSeleccionada,
  onZonaChange,
  zonaDisponible,
  tituloSuperior,
  tituloInferior,
  rangoSeleccionado,
  onRangoChange,
  fechaRangoDesde,
  fechaRangoHasta,
  onFechaRangoChange,
  tipoGrafico,
  onTipoGraficoChange,
  alimentadorId,
  alimentadores,
  onAlimentadorChange,
  precargaProgreso,
  precargaCompleta,
  precargando,
  fuenteDatos,
  onLimpiarCache,
  graficoVisible,
  onToggleGrafico,
}) => {
  return (
    <div className="ventana-controles">
      {/* Boton toggle para panel de datos */}
      <button
        type="button"
        className={`ventana-toggle-datos ${panelDatosAbierto ? "ventana-toggle-datos--activo" : ""}`}
        onClick={onTogglePanel}
        title={panelDatosAbierto ? "Ocultar datos" : "Ver datos"}
      >
        <span className="ventana-toggle-icono">‚ñ≤</span>
      </button>

      {/* Tabs de zona */}
      <div className="ventana-tabs">
        <button
          type="button"
          className={`ventana-tab ${zonaSeleccionada === "superior" ? "ventana-tab--activo" : ""}`}
          onClick={() => onZonaChange("superior")}
          disabled={!zonaDisponible("superior")}
        >
          {tituloSuperior}
        </button>
        <button
          type="button"
          className={`ventana-tab ${zonaSeleccionada === "inferior" ? "ventana-tab--activo" : ""}`}
          onClick={() => onZonaChange("inferior")}
          disabled={!zonaDisponible("inferior")}
        >
          {tituloInferior}
        </button>
      </div>

      {/* Selector de rango */}
      <div className="ventana-rango">
        {RANGOS_TIEMPO.filter((r) => r.id !== "custom").map((r) => (
          <button
            key={r.id}
            type="button"
            className={`ventana-rango-btn ${rangoSeleccionado === r.id && !fechaRangoDesde ? "ventana-rango-btn--activo" : ""}`}
            onClick={() => onRangoChange(r.id)}
          >
            {r.label}
          </button>
        ))}
      </div>

      {/* Grupo: Selector de fechas + Tipo de gr√°fico */}
      <div className="ventana-grupo-graficos">
        {/* Selector de rango de fechas */}
        <div className="ventana-selector-dia">
          <SelectorFecha
            value={fechaRangoDesde}
            valueHasta={fechaRangoHasta}
            modoRango={true}
            onChangeRango={onFechaRangoChange}
            maxDate={new Date()}
            placeholder="Seleccionar fechas"
          />
          {fechaRangoDesde && fechaRangoHasta && (
            <span className="ventana-dia-seleccionado">
              {new Date(fechaRangoDesde).toLocaleDateString("es-AR", {
                day: "2-digit",
                month: "2-digit",
                year: "2-digit",
              })}
              {fechaRangoDesde.getTime() !== fechaRangoHasta.getTime() && (
                <>
                  {" "}
                  -{" "}
                  {new Date(fechaRangoHasta).toLocaleDateString("es-AR", {
                    day: "2-digit",
                    month: "2-digit",
                    year: "2-digit",
                  })}
                </>
              )}
            </span>
          )}
        </div>

        {/* Selector de tipo de grafico */}
        <div className="ventana-tipo-grafico">
          {TIPOS_GRAFICO.map((tipo) => (
            <button
              key={tipo.id}
              type="button"
              className={`ventana-tipo-btn ${tipoGrafico === tipo.id ? "ventana-tipo-btn--activo" : ""}`}
              onClick={() => onTipoGraficoChange(tipo.id)}
              title={tipo.label}
            >
              {tipo.icon}
            </button>
          ))}
        </div>
      </div>

      {/* Selector de alimentador */}
      {alimentadores && alimentadores.length > 1 && (
        <div className="ventana-selector-alimentador-container">
          <select
            className="ventana-selector-alimentador"
            value={alimentadorId}
            onChange={(e) => onAlimentadorChange(e.target.value)}
            title="Cambiar alimentador"
          >
            {alimentadores.map((alim) => (
              <option key={alim.id} value={alim.id}>
                {alim.nombre}
              </option>
            ))}
          </select>
        </div>
      )}

      {/* Cache + Fuente */}
      <div className="ventana-cache">
        {/* Bot√≥n toggle gr√°fico - solo visible en m√≥vil portrait */}
        <button
          type="button"
          className={`ventana-toggle-grafico ${graficoVisible ? "" : "ventana-toggle-grafico--cerrado"}`}
          onClick={onToggleGrafico}
          title={graficoVisible ? "Ocultar gr√°fico" : "Mostrar gr√°fico"}
        >
          <span className="ventana-toggle-grafico-icono">‚ñº</span>
        </button>
        <div className="ventana-cache-barra">
          <div
            className={`ventana-cache-progreso ${precargaCompleta ? "ventana-cache-progreso--completo" : ""}`}
            style={{ width: `${precargaProgreso}%` }}
          />
        </div>
        <span className="ventana-cache-texto">
          {precargaCompleta ? "‚úì" : `${precargaProgreso}%`}
        </span>
        {fuenteDatos && (
          <span className={`ventana-fuente ventana-fuente--${fuenteDatos}`}>
            {fuenteDatos === "local" ? "Local" : fuenteDatos === "remoto" ? "BD" : "Mixto"}
          </span>
        )}
        <button
          type="button"
          className="ventana-btn-limpiar"
          onClick={onLimpiarCache}
          disabled={precargando}
          title="Limpiar cache"
        >
          üóë
        </button>
      </div>
    </div>
  );
};

BarraControlesHistorial.propTypes = {
  panelDatosAbierto: PropTypes.bool.isRequired,
  onTogglePanel: PropTypes.func.isRequired,
  zonaSeleccionada: PropTypes.oneOf(["superior", "inferior"]).isRequired,
  onZonaChange: PropTypes.func.isRequired,
  zonaDisponible: PropTypes.func.isRequired,
  tituloSuperior: PropTypes.string,
  tituloInferior: PropTypes.string,
  rangoSeleccionado: PropTypes.string.isRequired,
  onRangoChange: PropTypes.func.isRequired,
  fechaRangoDesde: PropTypes.instanceOf(Date),
  fechaRangoHasta: PropTypes.instanceOf(Date),
  onFechaRangoChange: PropTypes.func.isRequired,
  tipoGrafico: PropTypes.oneOf(["line", "area", "bar"]).isRequired,
  onTipoGraficoChange: PropTypes.func.isRequired,
  alimentadorId: PropTypes.string,
  alimentadores: PropTypes.array,
  onAlimentadorChange: PropTypes.func,
  precargaProgreso: PropTypes.number,
  precargaCompleta: PropTypes.bool,
  precargando: PropTypes.bool,
  fuenteDatos: PropTypes.oneOf(["local", "remoto", "mixto", null]),
  onLimpiarCache: PropTypes.func.isRequired,
  graficoVisible: PropTypes.bool,
  onToggleGrafico: PropTypes.func,
};

BarraControlesHistorial.defaultProps = {
  tituloSuperior: "Superior",
  tituloInferior: "Inferior",
  fechaRangoDesde: null,
  fechaRangoHasta: null,
  alimentadorId: "",
  alimentadores: [],
  onAlimentadorChange: () => {},
  precargaProgreso: 0,
  precargaCompleta: false,
  precargando: false,
  fuenteDatos: null,
  graficoVisible: true,
  onToggleGrafico: () => {},
};

export default BarraControlesHistorial;

// ===== ./src/paginas/PaginaAlimentadores/componentes/historial/BarraTituloVentana.jsx =====

/**
 * Barra de titulo arrastrable para ventanas flotantes de historial
 * Incluye titulo, botones de minimizar/maximizar/cerrar
 * En m√≥vil solo muestra el bot√≥n de cerrar
 */

import { forwardRef } from "react";
import PropTypes from "prop-types";

/**
 * @param {Object} props
 * @param {string} props.nombre - Nombre del alimentador
 * @param {boolean} props.maximizada - Si la ventana esta maximizada
 * @param {Function} props.onMinimizar - Callback para minimizar
 * @param {Function} props.onMaximizar - Callback para maximizar/restaurar
 * @param {Function} props.onCerrar - Callback para cerrar
 * @param {Function} props.onMouseDown - Callback para iniciar arrastre
 * @param {React.Ref} ref - Ref para el header
 */
const BarraTituloVentana = forwardRef(({
  nombre,
  maximizada,
  onMinimizar,
  onMaximizar,
  onCerrar,
  onMouseDown,
}, ref) => {
  return (
    <header
      ref={ref}
      className="ventana-historial-header"
      onMouseDown={onMouseDown}
    >
      <div className="ventana-historial-titulo">
        <span className="ventana-historial-icono">üìä</span>
        <span className="ventana-historial-nombre">{nombre}</span>
      </div>
      <div className="ventana-historial-controles">
        {/* Botones minimizar/maximizar ocultos en m√≥vil via CSS */}
        <button
          type="button"
          className="ventana-btn ventana-btn--minimizar ventana-btn--desktop-only"
          onClick={onMinimizar}
          title="Minimizar"
        >
          <span>‚îÄ</span>
        </button>
        <button
          type="button"
          className="ventana-btn ventana-btn--maximizar ventana-btn--desktop-only"
          onClick={onMaximizar}
          title={maximizada ? "Restaurar" : "Maximizar"}
        >
          <span>{maximizada ? "‚ùê" : "‚ñ°"}</span>
        </button>
        <button
          type="button"
          className="ventana-btn ventana-btn--cerrar"
          onClick={onCerrar}
          title="Cerrar"
        >
          <span>√ó</span>
        </button>
      </div>
    </header>
  );
});

BarraTituloVentana.displayName = "BarraTituloVentana";

BarraTituloVentana.propTypes = {
  nombre: PropTypes.string,
  maximizada: PropTypes.bool,
  onMinimizar: PropTypes.func.isRequired,
  onMaximizar: PropTypes.func.isRequired,
  onCerrar: PropTypes.func.isRequired,
  onMouseDown: PropTypes.func.isRequired,
};

BarraTituloVentana.defaultProps = {
  nombre: "Ventana",
  maximizada: false,
};

export default BarraTituloVentana;

// ===== ./src/paginas/PaginaAlimentadores/componentes/historial/PanelDatosHistorial.jsx =====

/**
 * Panel lateral que muestra la tabla de datos del historial
 * Recibe los datos ya filtrados desde VentanaHistorial
 */

import { useMemo } from "react";
import PropTypes from "prop-types";

/**
 * @param {Object} props
 * @param {boolean} props.abierto - Si el panel est√° visible
 * @param {string} props.tituloPeriodo - T√≠tulo mostrando el per√≠odo de fechas
 * @param {number} props.intervaloFiltro - Intervalo de filtrado actual (0, 15, 30, 60 minutos)
 * @param {Function} props.onIntervaloChange - Callback al cambiar intervalo
 * @param {Array} props.datosFiltrados - Datos ya filtrados [{x, y}]
 * @param {string} props.tipoGrafico - Tipo de gr√°fico actual (line, area, bar)
 */
const PanelDatosHistorial = ({
  abierto,
  tituloPeriodo,
  intervaloFiltro,
  onIntervaloChange,
  datosFiltrados,
  tipoGrafico,
}) => {
  // El gr√°fico de barras no soporta "Todos (1/min)" por rendimiento
  const todosDeshabilitado = tipoGrafico === "bar";

  // Formatear datos para la tabla
  const datosTabla = useMemo(() => {
    return datosFiltrados.map((punto) => {
      const fecha = new Date(punto.x);
      return {
        fecha: fecha.toLocaleDateString("es-AR", { day: "2-digit", month: "2-digit", year: "2-digit" }),
        hora: fecha.toLocaleTimeString("es-AR", { hour: "2-digit", minute: "2-digit", second: "2-digit" }),
        medicion: Math.ceil(punto.y * 100) / 100,
      };
    });
  }, [datosFiltrados]);

  if (!abierto) return null;

  return (
    <div className="ventana-panel-datos">
      <div className="ventana-panel-header">
        <span>{tituloPeriodo}</span>
        <select
          className="ventana-panel-intervalo"
          value={intervaloFiltro}
          onChange={(e) => onIntervaloChange(Number(e.target.value))}
        >
          <option value={0} disabled={todosDeshabilitado}>
            {todosDeshabilitado ? "Todos (no disp.)" : "Todos"}
          </option>
          <option value={15}>cada 15m</option>
          <option value={30}>cada 30m</option>
          <option value={60}>cada 60m</option>
        </select>
      </div>
      <div className="ventana-panel-tabla-container">
        <table className="ventana-panel-tabla">
          <thead>
            <tr>
              <th>Fecha</th>
              <th>Hora</th>
              <th>Medicion</th>
            </tr>
          </thead>
          <tbody>
            {datosTabla.map((fila, idx) => (
              <tr key={idx}>
                <td>{fila.fecha}</td>
                <td>{fila.hora}</td>
                <td>{fila.medicion.toFixed(2)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

PanelDatosHistorial.propTypes = {
  abierto: PropTypes.bool.isRequired,
  tituloPeriodo: PropTypes.string,
  intervaloFiltro: PropTypes.number,
  onIntervaloChange: PropTypes.func.isRequired,
  datosFiltrados: PropTypes.arrayOf(
    PropTypes.shape({
      x: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.number]),
      y: PropTypes.number,
    })
  ),
  tipoGrafico: PropTypes.oneOf(["line", "area", "bar"]),
};

PanelDatosHistorial.defaultProps = {
  tituloPeriodo: "Sin datos",
  intervaloFiltro: 60,
  datosFiltrados: [],
  tipoGrafico: "line",
};

export default PanelDatosHistorial;

// ===== ./src/paginas/PaginaAlimentadores/componentes/layout/VistaAlimentadores.css =====

/* src/paginas/PaginaAlimentadores/componentes/layout/VistaAlimentadores.css */
/*
   NOTA SOBRE ESTE ARCHIVO (VistaAlimentadores.css)
   - Define el layout general de la pantalla de alimentadores (`.alim-page`
     y `.alim-main`), incluyendo paddings, fondo y tipograf√≠a base.

   - Centraliza estilos de botones gen√©ricos (`.alim-btn`, `.alim-btn-add`,
     `.alim-btn-exit`) que se usan tanto en la barra superior como en el men√∫
     lateral y otros componentes.

   - Tambi√©n maneja los estados vac√≠os (`.alim-empty`, `.alim-empty-state`)
     que se muestran cuando todav√≠a no hay puestos o tarjetas configuradas.
*/

/* =========================================================
   LAYOUT GENERAL
   ========================================================= */
.alim-page {
	min-height: 100vh;
	min-height: 100dvh;
	/* Dynamic viewport height para m√≥viles */
	/* Fondo oscuro igual que navbar para evitar l√≠nea visible en el gap */
	background-color: #0f172a;
	display: flex;
	flex-direction: column;
	font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
		sans-serif;
	color: #1e293b;
	/* Navbar es relative, no necesita padding-top compensatorio */
}

/* Estados de carga y error */
.alim-page--cargando,
.alim-page--error {
	justify-content: center;
	align-items: center;
}

.alim-loading,
.alim-error {
	text-align: center;
	padding: 2rem;
}

.alim-loading__spinner {
	width: 40px;
	height: 40px;
	margin: 0 auto 1rem;
	border: 3px solid #e2e8f0;
	border-top-color: #3b82f6;
	border-radius: 50%;
	animation: spin 0.8s linear infinite;
}

@keyframes spin {
	to {
		transform: rotate(360deg);
	}
}

.alim-loading p,
.alim-error p {
	color: #64748b;
	margin-bottom: 1rem;
}

.alim-error button {
	padding: 8px 16px;
	background: #3b82f6;
	color: white;
	border: none;
	border-radius: 6px;
	cursor: pointer;
}

.alim-error button:hover {
	background: #2563eb;
}

/* Estado sin workspaces (dentro de main) */
.alim-sin-workspace {
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	height: 100%;
	min-height: 300px;
	text-align: center;
	padding: 2rem;
}

.alim-sin-workspace h2 {
	color: #475569;
	margin-bottom: 0.5rem;
	font-size: 1.25rem;
}

.alim-sin-workspace p {
	color: #64748b;
	margin-bottom: 0.5rem;
}

.alim-sin-workspace button {
	margin-top: 1rem;
	padding: 10px 20px;
	background: #3b82f6;
	color: white;
	border: none;
	border-radius: 6px;
	cursor: pointer;
	font-weight: 500;
}

.alim-sin-workspace button:hover {
	background: #2563eb;
}

.alim-main {
	flex: 1;
	padding: 0 1.5rem calc(1.5rem + var(--safe-area-inset-bottom, 0px)) 1.5rem;
	width: 100%;
	min-width: 0;
	/* Permite que flex shrink funcione correctamente */
	overflow-x: hidden;
	/* Evita scroll horizontal no deseado */
}

/* Ajuste de paddings en pantallas chicas/medianas */
@media (max-width: 982px) {
	.alim-main {
		padding: 0 0.75rem 1rem 0.75rem;
	}
}



/* =========================================================
   BOTONES GENERALES
   ========================================================= */

/* Botones de puesto / gen√©ricos */
.alim-btn {
	border: none;
	border-radius: 10px;
	padding: 0.45rem 1.2rem;
	font-size: 0.9rem;
	font-weight: 600;
	cursor: pointer;
	background-color: #22c55e;
	color: #022c22;
	transition: transform 0.1s ease, box-shadow 0.1s ease,
		background-color 0.15s ease;
	display: inline-flex;
	align-items: center;
	justify-content: center;
}

.alim-btn:hover {
	background-color: #16a34a;
	box-shadow: 0 4px 10px rgba(21, 128, 61, 0.4);
	transform: translateY(-1px);
}

.alim-btn:active {
	transform: translateY(0);
	box-shadow: none;
}

/* Bot√≥n de puesto activo */
.alim-btn-active {
	background-color: #0ea5e9;
	color: #0f172a;
}

/* Bot√≥n "+" para agregar puesto (nav y drawer) */
.alim-btn-add {
	background-color: transparent;
	color: #e5e7eb;
	border: 1px dashed #9ca3af;
	width: 2.5rem;
	height: 2.5rem;
	padding: 0;
	font-size: 2rem;
	line-height: 1;
}

.alim-btn-add-icon {
	display: block;
	transform: translateY(-3px);
}

.alim-btn-add:hover {
	background-color: rgba(148, 163, 184, 0.2);
	box-shadow: none;
	transform: none;
}

/* Bot√≥n salir - estilo rojo gradient */
.alim-btn-exit {
	border: 1px solid #f87171;
	border-radius: 8px;
	padding: 0.5rem 1rem;
	font-size: 0.875rem;
	font-weight: 600;
	cursor: pointer;
	background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
	color: #fef2f2;
	transition: all 0.2s ease;
	display: inline-flex;
	align-items: center;
	justify-content: center;
}

.alim-btn-exit:hover {
	background: linear-gradient(135deg, #b91c1c 0%, #991b1b 100%);
	border-color: #fca5a5;
	box-shadow: 0 4px 12px rgba(220, 38, 38, 0.35);
	transform: translateY(-1px);
}

.alim-btn-exit:active {
	transform: translateY(0);
	box-shadow: none;
}


/* =========================================================
   ESTADOS VAC√çOS
   ========================================================= */
.alim-empty {
	height: 100%;
	display: flex;
	align-items: flex-start;
	justify-content: center;
	padding-top: 2rem;
	color: #64748b;
	font-size: 0.95rem;
	text-align: center;
}

.alim-empty-state {
	margin-bottom: 1rem;
	color: #020202;
	font-size: 0.95rem;
}

/* =========================================================
   OVERLAY DE PROBLEMA DE CONEXI√ìN
   ========================================================= */
.alim-overlay-conexion {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	z-index: 100;
	display: flex;
	align-items: flex-start;
	justify-content: center;
	padding-top: 15vh;
}

/* Capa de blur constante */
.alim-overlay-conexion::before {
	content: '';
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	backdrop-filter: blur(2px);
}

/* Capa de oscuridad constante */
.alim-overlay-conexion::after {
	content: '';
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.6);
}

.alim-overlay-conexion__contenido {
	position: relative;
	z-index: 1;
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 0.5rem;
	padding: 1.5rem 2rem;
	background: rgba(30, 20, 0, 0.95);
	border: 2px solid #f59e0b;
	border-radius: 12px;
	box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
	animation: contenidoPulse 3.5s ease-in-out infinite;
}

.alim-overlay-conexion__icono {
	font-size: 2rem;
	color: #fbbf24;
	animation: iconoPulse 3.5s ease-in-out infinite;
}

.alim-overlay-conexion__titulo {
	font-size: 1.25rem;
	font-weight: 700;
	color: #fbbf24;
	letter-spacing: 0.05em;
}

.alim-overlay-conexion__texto {
	font-size: 0.9rem;
	color: #fcd34d;
	text-align: center;
}

/* Animaci√≥n continua del fondo (breathing) */
@keyframes fondoPulse {

	0%,
	100% {
		opacity: 0.4;
	}

	50% {
		opacity: 1;
	}
}

/* Animaci√≥n continua del contenido/cartel (breathing con pausa en m√°ximo) */
@keyframes contenidoPulse {

	0%,
	100% {
		transform: scale(0.88);
	}

	45%,
	55% {
		transform: scale(1.12);
	}
}

/* Animaci√≥n del icono (con pausa en m√°ximo) */
@keyframes iconoPulse {

	0%,
	100% {
		transform: scale(1);
		opacity: 1;
	}

	45%,
	55% {
		transform: scale(1.55);
		opacity: 0.85;
	}
}

/* El main necesita position relative para que el overlay absolute funcione */
.alim-main {
	position: relative;
}

/* =========================================================
// ===== ./src/paginas/PaginaAlimentadores/componentes/layout/VistaAlimentadores.jsx =====

// src/paginas/PaginaAlimentadores/componentes/layout/VistaAlimentadores.jsx

import React, { useEffect, useState, useRef, useCallback, useMemo } from "react";
import ReactDOM from "react-dom";                                    // para portal del overlay
import { useNavigate } from "react-router-dom";                     // navegaci√≥n entre rutas
import { useAuth } from "../../../../contextos/AuthContext";        // contexto de autenticaci√≥n
import "./VistaAlimentadores.css";                                  // estilos espec√≠ficos del layout de alimentadores
import "../navegacion/BotonGuardarCambios.css";                     // estilos del overlay de guardando

import BarraNavegacion from "../navegacion/BarraNavegacion.jsx";    // barra superior (t√≠tulo + botones de puestos)
import MenuLateral from "../navegacion/MenuLateral.jsx";            // men√∫ lateral en modo compacto (mobile)
import GrillaTarjetas from "../tarjetas/GrillaTarjetas.jsx";        // grilla de tarjetas de alimentadores
import SkeletonCard from "../tarjetas/SkeletonCard.jsx";            // skeleton de tarjeta (loading state)
import ModalNuevoPuesto from "../modales/ModalNuevoPuesto.jsx";     // modal para crear puestos
import ModalEditarPuestos from "../modales/ModalEditarPuestos.jsx"; // modal para editar/renombrar/eliminar puestos
import ModalConfiguracionAlimentador from "../modales/ModalConfiguracionAlimentador.jsx"; // modal de config de registrador
import ModalConfiguracionPuesto from "../modales/ModalConfiguracionPuesto.jsx";           // modal de configuraci√≥n global del puesto
import ModalConfigurarAgente from "../modales/ModalConfigurarAgente.jsx";                 // modal de configuraci√≥n del agente
import ModalGestionarAccesos from "../modales/ModalGestionarAccesos.jsx";                 // modal de gesti√≥n de accesos al workspace
import ModalPanelPermisos from "../modales/ModalPanelPermisos.jsx";                       // modal de panel de permisos (solo superadmin)
import ContenedorVentanasHistorial from "../modales/ContenedorVentanasHistorial.jsx";     // contenedor de ventanas flotantes de historial
import { useVentanasHistorial } from "../../hooks/useVentanasHistorial";               // hook para gestionar ventanas de historial
import { useVentanaConfigAgente } from "../../hooks/useVentanaConfigAgente";           // hook para gestionar ventana de configuraci√≥n de agentes

import { COLORES_SISTEMA } from "../../constantes/colores";         // paleta de colores para botones/puestos
import { useArrastrarSoltar } from "../../hooks/useArrastrarSoltar"; // hook de drag & drop de tarjetas
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase"; // contexto con datos y acciones (Supabase)
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion"; // contexto de workspaces
import { useGestorModales } from "../../hooks/useGestorModales";    // hook para abrir/cerrar modales por clave
import { obtenerUltimasLecturasPorRegistrador, listarAgentesWorkspace, listarRegistradoresAgente } from "../../../../servicios/apiService"; // API para polling de lecturas
import { useHistorialLocal } from "../../hooks/useHistorialLocal"; // Hook para guardar historial en IndexedDB
import { usePushNotifications } from "../../../../hooks/usePushNotifications"; // Hook para push notifications (Android)

const VistaAlimentadores = () => {
	const navigate = useNavigate();                                  // para salir al login
	const { logout } = useAuth();                                    // funci√≥n de logout del contexto de auth
	const {
		configuracionSeleccionada,
		perfil,
		rolGlobal,
		// Estilos globales de tarjetas
		estilosGlobales,
		guardarEstilosGlobales,
	} = usarContextoConfiguracion(); // workspace activo + perfil usuario + rol + estilos globales

	const {
   puestos,                               // lista completa de puestos configurados en el sistema
   puestoSeleccionado,                    // puesto actualmente activo/visible en la vista
   agregarPuesto,                         // agrega un nuevo puesto (se usa desde el modal de nuevo puesto)
   eliminarPuesto,                        // elimina un puesto de la BD
   seleccionarPuesto,                     // cambia el puesto activo cuando el usuario hace clic en otro
   actualizarPuestos,                     // guarda la lista de puestos editada (nombres/colores, orden, etc.)
   agregarAlimentador,                    // agrega un alimentador al puesto seleccionado
   actualizarAlimentador,                 // actualiza los datos de un alimentador existente
   eliminarAlimentador,                   // elimina un alimentador de un puesto
   reordenarAlimentadores,                // guarda el nuevo orden de alimentadores tras el drag & drop
   lecturasTarjetas,                      // lecturas ya procesadas listas para mostrar en las tarjetas
   estaMidiendo,                          // indica si un alimentador/equipo est√° midiendo (true/false)
   obtenerTimestampInicio,                // devuelve el timestamp de la √∫ltima lectura (para animaciones/tiempos)
   obtenerContadorLecturas,               // cu√°ntas lecturas se hicieron desde que arranc√≥ la medici√≥n
   detenerMedicion,                       // detiene expl√≠citamente la medici√≥n de un alimentador/equipo
   actualizarRegistros,                   // actualiza registros manualmente (para polling de lecturas)
   cargando,                              // estado de carga (Supabase)
   error,                                 // error si hubo problema cargando datos
   // Preferencias UI (gaps) - vienen del contexto para consistencia
   obtenerGap,                            // obtiene gap horizontal de un alimentador (localStorage > BD > default)
   establecerGap,                         // establece gap horizontal de un alimentador
   obtenerRowGap,                         // obtiene gap vertical de una fila (localStorage > BD > default)
   establecerRowGap,                      // establece gap vertical de una fila
   GAP_DEFAULT,                           // valor por defecto para gaps horizontales
   // Escala de tarjetas
   escalaGlobal,                          // escala global para todas las tarjetas
   establecerEscalaGlobal,                // establece escala global
   obtenerEscalaEfectiva,                 // obtiene escala efectiva (individual > puesto > global > default)
   establecerEscalaTarjeta,               // establece escala individual de un alimentador
   resetearEscalaTarjeta,                 // resetea escala individual de un alimentador
   obtenerEscalaPuesto,                   // obtiene escala de un puesto espec√≠fico
   establecerEscalaPuesto,                // establece escala de un puesto
   ESCALA_MIN,                            // escala m√≠nima permitida
   ESCALA_MAX,                            // escala m√°xima permitida
   // Limpieza al salir
   limpiarPreferenciasUI,                 // limpia localStorage de gaps al salir
   // Estado de sincronizaci√≥n
   sincronizando,                         // true mientras se guardan cambios en BD
   // Getters de colores (para soporte de preferencias de invitados)
   obtenerBgColorPuesto,                  // obtiene bgColor del puesto (con preferencias de invitado)
   obtenerColorPuesto,                    // obtiene color del puesto (con preferencias de invitado)
   // Info del rol del usuario en el workspace
   esCreador,                             // true si el usuario es creador del workspace
   // Preferencias visuales (para invitados)
   preferenciasVisuales,                  // objeto con funciones para obtener preferencias personales
} = usarContextoAlimentadores();          // hook que conecta esta vista con el contexto global de alimentadores


const {
   elementoArrastrandoId,                 // id del alimentador que se est√° arrastrando actualmente (o null)
   alIniciarArrastre,                     // handler para onDragStart: marca qu√© tarjeta empez√≥ a moverse
   alTerminarArrastre,                    // handler para onDragEnd: limpia el estado de arrastre
   alPasarPorEncima,                      // handler para onDragOver: habilita que se pueda soltar en ese destino
   reordenarLista,                        // calcula una nueva lista con un elemento movido a la posici√≥n de otro
   moverAlFinal,                          // calcula una nueva lista moviendo un elemento al final
} = useArrastrarSoltar();                // hook que encapsula el estado y la l√≥gica de drag & drop de tarjetas


	const { abrirModal, cerrarModal, obtenerEstado } = useGestorModales(); // gestor centralizado de modales
	const { guardarLecturaLocal } = useHistorialLocal(); // Hook para guardar lecturas en IndexedDB

	// Inicializar push notifications para app Android (solo se activa en plataforma nativa)
	usePushNotifications({
		habilitado: true,
		onNotificacion: (notif) => {
			console.log('[VistaAlimentadores] Notificaci√≥n en primer plano:', notif);
			// TODO: Mostrar toast o notificaci√≥n in-app
		},
		onNotificacionTocada: (datos) => {
			console.log('[VistaAlimentadores] Usuario toc√≥ notificaci√≥n:', datos);
			// TODO: Navegar a alimentador espec√≠fico si viene en datos
		},
	});

	// Sistema de ventanas flotantes de historial
	const {
		listaVentanas,
		ventanasMinimizadas,
		abrirVentana,
		cerrarVentana,
		toggleMinimizar,
		toggleMaximizar,
		enfocarVentana,
		moverVentana,
	} = useVentanasHistorial();

	const [menuAbierto, setMenuAbierto] = useState(false);           // estado del drawer lateral en mobile
	const [esCompacto, setEsCompacto] = useState(false);             // flag: layout compacto (pantalla angosta)
	const [guardandoAlimentador, setGuardandoAlimentador] = useState(false); // flag: guardando alimentador (muestra skeleton)
	const [guardandoPuestos, setGuardandoPuestos] = useState(false); // flag: guardando/eliminando puestos
	// Hook para ventana flotante de configuraci√≥n de agentes
	const {
		ventana: ventanaConfigAgente,
		abrirVentana: abrirVentanaConfigAgente,
		cerrarVentana: cerrarVentanaConfigAgente,
		toggleMinimizar: toggleMinimizarConfigAgente,
		toggleMaximizar: toggleMaximizarConfigAgente,
		enfocarVentana: enfocarVentanaConfigAgente,
		moverVentana: moverVentanaConfigAgente,
	} = useVentanaConfigAgente();
	const [modalAccesosAbierto, setModalAccesosAbierto] = useState(false); // estado del modal de gesti√≥n de accesos
	const [modalPanelPermisosAbierto, setModalPanelPermisosAbierto] = useState(false); // estado del modal de panel de permisos
	const [alimentadoresPolling, setAlimentadoresPolling] = useState({}); // { [alimId]: true/false } para tracking de polling
	const [lecturasPolling, setLecturasPolling] = useState({}); // { [alimId]: { valores, timestamp, ... } } - √∫ltimas lecturas obtenidas
	const [contadoresPolling, setContadoresPolling] = useState({}); // { [alimId]: number } - contador de lecturas para animaci√≥n
	const pollingIntervalsRef = useRef({}); // { [alimId]: intervalId } - para limpiar intervalos
	const contadorIntervalsRef = useRef({}); // { [alimId]: intervalId } - intervalos separados para incrementar contador (1 por ciclo)
	const [registradores, setRegistradores] = useState([]); // Lista de registradores del workspace
	// Errores de lectura: el agente no pudo leer del equipo Modbus (exito === false)
	const [contadoresErrorLectura, setContadoresErrorLectura] = useState({}); // { [alimId_zona]: number }
	// Errores de red: el frontend no pudo comunicarse con el backend (fetch fall√≥)
	const [contadoresErrorRed, setContadoresErrorRed] = useState({}); // { [alimId_zona]: number }
	// Estado global de conexi√≥n con el backend
	const [hayProblemaConexion, setHayProblemaConexion] = useState(false);

	// ===== PUESTOS CON PREFERENCIAS (PARA MODAL DE EDICI√ìN) =====
	// Para invitados: aplicamos las preferencias personales sobre los puestos base
	// Esto asegura que el modal de edici√≥n muestre los colores correctos
	const puestosConPreferencias = useMemo(() => {
		if (esCreador || !preferenciasVisuales) {
			return puestos;
		}

		// Aplicar preferencias personales sobre los puestos base
		return puestos.map(puesto => {
			const configPuesto = preferenciasVisuales.obtenerConfigPuesto?.(puesto.id);

			return {
				...puesto,
				color: configPuesto?.color || puesto.color,
				bgColor: configPuesto?.bg_color || puesto.bgColor || puesto.bg_color,
				// Los alimentadores tambi√©n pueden tener preferencias
				alimentadores: (puesto.alimentadores || []).map(alim => {
					const configAlim = preferenciasVisuales.obtenerConfigAlimentador?.(alim.id, puesto.id);
					return {
						...alim,
						color: configAlim?.color || alim.color,
					};
				}),
			};
		});
	}, [esCreador, puestos, preferenciasVisuales]);

	// ===== ALIMENTADORES DEL PUESTO SELECCIONADO CON PREFERENCIAS =====
	// Los alimentadores del puesto seleccionado con las preferencias aplicadas
	// (color, intervalo_consulta_ms, oculto de zonas para operadores)
	const alimentadoresConPreferencias = useMemo(() => {
		if (!puestoSeleccionado?.alimentadores) return [];
		if (esCreador || !preferenciasVisuales) {
			return puestoSeleccionado.alimentadores;
		}

		// Aplicar preferencias personales sobre los alimentadores base
		return puestoSeleccionado.alimentadores.map(alim => {
			const configAlim = preferenciasVisuales.obtenerConfigAlimentador?.(alim.id, puestoSeleccionado.id);

			// Construir el alimentador con preferencias aplicadas
			const alimConPrefs = {
				...alim,
				color: configAlim?.color || alim.color,
			};

			// Aplicar intervalo personalizado si existe
			if (configAlim?.intervalo_consulta_ms !== undefined) {
				alimConPrefs.intervalo_consulta_ms = configAlim.intervalo_consulta_ms;
			}

			// Aplicar estados "oculto" personalizados a las zonas del card_design
			if (configAlim?.oculto_superior !== undefined || configAlim?.oculto_inferior !== undefined) {
				alimConPrefs.card_design = {
					...alim.card_design,
					superior: {
						...alim.card_design?.superior,
						...(configAlim?.oculto_superior !== undefined && { oculto: configAlim.oculto_superior }),
					},
					inferior: {
						...alim.card_design?.inferior,
						...(configAlim?.oculto_inferior !== undefined && { oculto: configAlim.oculto_inferior }),
					},
				};
			}

			return alimConPrefs;
		});
	}, [esCreador, puestoSeleccionado, preferenciasVisuales]);

	// Responsive: detectar modo compacto seg√∫n el ancho de la ventana
	useEffect(() => {
		const actualizarModo = () => setEsCompacto(window.innerWidth < 900);
		actualizarModo();                                            // eval√∫a una vez al montar
		window.addEventListener("resize", actualizarModo);
		return () => window.removeEventListener("resize", actualizarModo);
	}, []);

	// En modo compacto (m√≥vil), forzar escala global a 1 para visualizaci√≥n
	// Esto es solo visual, NO se persiste en BD ni en preferencias de usuario
	const escalaGlobalEfectiva = esCompacto ? 1 : escalaGlobal;

	// Wrapper para obtenerEscalaEfectiva que considera el modo compacto
	// En m√≥vil, si no hay escala individual ni de puesto, usa 1 en vez de escalaGlobal
	const obtenerEscalaEfectivaConModoCompacto = useCallback((alimentadorId, puestoId) => {
		if (esCompacto) {
			// En modo compacto, forzar escala 1
			// No importa qu√© tenga configurado el usuario, en m√≥vil siempre es 1
			return 1;
		}
		return obtenerEscalaEfectiva(alimentadorId, puestoId);
	}, [esCompacto, obtenerEscalaEfectiva]);

	// Cargar registradores del workspace (a trav√©s de los agentes vinculados)
	useEffect(() => {
		if (!configuracionSeleccionada?.id) return;
		const cargarRegistradores = async () => {
			try {
				// Primero obtener los agentes vinculados al workspace
				const agentes = await listarAgentesWorkspace(configuracionSeleccionada.id);

				// Luego cargar los registradores de cada agente
				const todosRegistradores = [];
				for (const agente of agentes || []) {
					try {
						const regs = await listarRegistradoresAgente(agente.id);
						if (regs && regs.length > 0) {
							todosRegistradores.push(...regs);
						}
					} catch (err) {
						console.error(`Error cargando registradores del agente ${agente.id}:`, err);
					}
				}
				setRegistradores(todosRegistradores);
			} catch (err) {
				console.error("Error cargando registradores:", err);
			}
		};
		cargarRegistradores();
	}, [configuracionSeleccionada?.id]);

	const estadoModalNuevoPuesto = obtenerEstado("nuevoPuesto");     // { abierto, datos } para modal de nuevo puesto
	const estadoModalEditarPuestos = obtenerEstado("editarPuestos"); // idem para modal de edici√≥n de puestos
	const estadoModalAlimentador = obtenerEstado("alimentador");     // idem para modal de configuraci√≥n de alimentador
	const estadoModalConfigPuesto = obtenerEstado("configPuesto");   // idem para modal de configuraci√≥n global del puesto

	const buscarAlimentador = (alimId) =>
		alimentadoresConPreferencias.find((a) => a.id === alimId) || null; // helper para obtener el alimentador por id (con preferencias aplicadas)

	const buscarRegistrador = useCallback((regId) =>
		registradores.find((r) => r.id === regId) || null, [registradores]); // helper para obtener el registrador por id

	const alimentadorEnEdicion = estadoModalAlimentador.datos?.alimentadorId
		? buscarAlimentador(estadoModalAlimentador.datos.alimentadorId)
		: null;

	const modoAlimentador = estadoModalAlimentador.datos?.modo || "crear"; // "crear" o "editar" seg√∫n c√≥mo se abri√≥ el modal

	// Navegacion
	const handleSalir = async () => {
		// Limpiar localStorage de gaps antes de salir
		// As√≠ al volver a entrar se cargan los datos frescos de BD
		limpiarPreferenciasUI();
		// Cerrar sesi√≥n de Supabase y limpiar localStorage de configuraci√≥n
		// Esto evita que al loguearse otro usuario se intente acceder a workspaces del anterior
		await logout();
		navigate("/");                                                 // vuelve al login
	};

	// ===== MODALES PUESTOS =====
	const abrirModalNuevoPuesto = () => abrirModal("nuevoPuesto");    // abre modal para crear puesto
	const abrirModalEditarPuestos = () => abrirModal("editarPuestos");// abre modal para editar lista de puestos
	const abrirModalConfigPuesto = () => abrirModal("configPuesto");  // abre modal de configuraci√≥n global del puesto
	const abrirModalConfigurarAgente = () => abrirVentanaConfigAgente(configuracionSeleccionada?.id); // abre ventana de configuraci√≥n del agente
	const abrirModalGestionarAccesos = () => setModalAccesosAbierto(true); // abre modal de gesti√≥n de accesos
	const abrirModalPanelPermisos = () => setModalPanelPermisosAbierto(true); // abre modal de panel de permisos

	const handleCrearPuesto = (nombre, color) => {
		agregarPuesto(nombre, color);                                 // crea el puesto v√≠a contexto
		cerrarModal("nuevoPuesto");
	};

	const handleGuardarPuestos = async (puestosEditados) => {
		// Cerrar modal inmediatamente y mostrar overlay a nivel de p√°gina
		cerrarModal("editarPuestos");
		setGuardandoPuestos(true);

		try {
			// Detectar puestos eliminados (est√°n en puestos original pero no en puestosEditados)
			const idsEditados = new Set(puestosEditados.map(p => p.id));
			const puestosEliminados = puestos.filter(p => !idsEditados.has(p.id));

			// Primero eliminar los puestos que fueron removidos de la lista
			for (const puesto of puestosEliminados) {
				await eliminarPuesto(puesto.id);
			}

			// Luego actualizar los puestos restantes (nombres/colores)
			if (puestosEditados.length > 0) {
				await actualizarPuestos(puestosEditados);
			}
		} catch (error) {
			console.error('Error guardando puestos:', error);
		} finally {
			setGuardandoPuestos(false);
		}
	};

	// Handler para cambio de escala de puesto: establece la escala y limpia las escalas individuales
	const handleEscalaPuestoChange = useCallback((puestoId, escala) => {
		// Encontrar el puesto para obtener sus alimentadores
		const puesto = puestos.find(p => p.id === puestoId);
		if (puesto && puesto.alimentadores) {
			// Limpiar las escalas individuales de todos los alimentadores del puesto
			puesto.alimentadores.forEach(alim => {
				resetearEscalaTarjeta(alim.id);
			});
		}
		// Establecer la nueva escala del puesto
		establecerEscalaPuesto(puestoId, escala);
	}, [puestos, establecerEscalaPuesto, resetearEscalaTarjeta]);

	// ===== MODALES ALIMENTADORES =====
	const abrirModalNuevoAlim = () => abrirModal("alimentador", { modo: "crear" });

	const abrirModalEditarAlim = (_puestoId, alimentador) =>
		abrirModal("alimentador", { modo: "editar", alimentadorId: alimentador.id });

	const handleGuardarAlimentador = async (datos) => {
		if (!datos || !datos.nombre || !puestoSeleccionado) return;

		// Solo mostrar skeleton si estamos creando (no al editar)
		if (modoAlimentador === "crear") {
			setGuardandoAlimentador(true);                        // activar skeleton
			cerrarModal("alimentador");                           // cerrar modal INMEDIATAMENTE para ver el skeleton
		}

		try {
			if (modoAlimentador === "crear") {
				const nuevoAlimentador = await agregarAlimentador(datos); // alta de nuevo alimentador
				// Establecer gap horizontal inicial de 10px para el nuevo alimentador
				if (nuevoAlimentador?.id) {
					establecerGap(nuevoAlimentador.id, 10);
				}
			} else if (alimentadorEnEdicion) {
				if (esCreador) {
					// CREADOR: Guardar todo en BASE (BD)
					const gapActual = obtenerGap(alimentadorEnEdicion.id);
					await actualizarAlimentador(
						puestoSeleccionado.id,
						alimentadorEnEdicion.id,
						{
							...datos,
							gapHorizontal: gapActual, // mantener el gap actual
						}
					);
				} else {
					// INVITADO (operador/observador): Solo guardar el color en preferencias personales
					if (datos.color && preferenciasVisuales?.guardarPreferenciasAlimentador) {
						await preferenciasVisuales.guardarPreferenciasAlimentador(
							alimentadorEnEdicion.id,
							{ color: datos.color }
						);
					}
				}
				cerrarModal("alimentador");                           // en edici√≥n, cerrar despu√©s de guardar
			}
		} catch (error) {
			console.error("Error guardando alimentador:", error);
			setGuardandoAlimentador(false);                       // desactivar skeleton si hay error
			// Aqu√≠ podr√≠as mostrar un toast de error
		} finally {
			// Desactivar skeleton despu√©s de un peque√±o delay para que se vea la transici√≥n
			if (modoAlimentador === "crear") {
				setTimeout(() => {
					setGuardandoAlimentador(false);
				}, 300);
			}
		}
	};

	const handleEliminarAlimentador = () => {
		if (!puestoSeleccionado || !alimentadorEnEdicion) return;

		// por seguridad, detiene mediciones antes de eliminar
		detenerMedicion(alimentadorEnEdicion.id, "rele");
		detenerMedicion(alimentadorEnEdicion.id, "analizador");

		eliminarAlimentador(puestoSeleccionado.id, alimentadorEnEdicion.id);
		cerrarModal("alimentador");
	};

	// ===== POLLING DE LECTURAS =====
	// Verifica si un alimentador est√° haciendo polling
	const estaPolling = (alimId) => !!alimentadoresPolling[alimId];

	// Obtiene el contador de lecturas de polling para un alimentador
	const obtenerContadorPolling = (alimId) => contadoresPolling[alimId] || 0;

	// Obtiene el error de LECTURA de un alimentador por zona
	// (errores de red NO activan el overlay de tarjeta, solo el banner global)
	// Devuelve objeto con:
	//   - superior/inferior: boolean - true si hay AL MENOS 1 error (para mostrar "ERROR" en box)
	//   - superiorCritico/inferiorCritico: boolean - true si hay 3+ errores (para mostrar overlay)
	const obtenerErrorPolling = (alimId) => {
		// Solo usamos contadoresErrorLectura (NO contadoresErrorRed)
		// Los errores de red se muestran en el banner global, no en las tarjetas
		const contadorSuperior = contadoresErrorLectura[`${alimId}_superior`] || 0;
		const contadorInferior = contadoresErrorLectura[`${alimId}_inferior`] || 0;

		// Si no hay errores de lectura en ninguna zona, devolver null
		if (contadorSuperior === 0 && contadorInferior === 0) return null;

		return {
			// Para mostrar "ERROR" en los boxes (desde el primer error de lectura)
			superior: contadorSuperior >= 1,
			inferior: contadorInferior >= 1,
			// Para mostrar overlay de ATENCI√ìN (despu√©s de 3 errores de lectura consecutivos)
			superiorCritico: contadorSuperior >= 3,
			inferiorCritico: contadorInferior >= 3,
		};
	};

	// Funci√≥n para obtener lecturas de un registrador y actualizar el estado
	const fetchLecturasRegistrador = useCallback(async (alimId, registradorId, zona = null) => {
		// Clave para el contador de errores: usa zona si est√° especificada
		const claveError = zona ? `${alimId}_${zona}` : `${alimId}_superior`; // default a superior si no hay zona

		try {
			const lecturas = await obtenerUltimasLecturasPorRegistrador(registradorId, 1);

			// Si el fetch fue exitoso, resetear errores de red para esta zona
			// y actualizar estado global de conexi√≥n
			setContadoresErrorRed((prev) => {
				if (prev[claveError]) {
					const nuevo = { ...prev };
					delete nuevo[claveError];
					// Si ya no hay errores de red en ninguna zona, conexi√≥n OK
					if (Object.keys(nuevo).length === 0) {
						setHayProblemaConexion(false);
					}
					return nuevo;
				}
				return prev;
			});

			// Si no hay lecturas disponibles, simplemente no hacer nada (no es un error)
			if (!lecturas || lecturas.length === 0) {
				return;
			}

			const lectura = lecturas[0];

			// Guardar lectura por zona si se especifica, o global si no
			const clavePolling = zona ? `${alimId}_${zona}` : alimId;
			setLecturasPolling((prev) => ({
				...prev,
				[clavePolling]: lectura,
			}));

			// Verificar si la lectura tiene error (exito === false)
			// Esto indica que el AGENTE no pudo leer del equipo Modbus
			const tieneErrorLectura = lectura.exito === false;

			if (tieneErrorLectura) {
				// Incrementar contador de errores de LECTURA (agente no pudo leer del Modbus)
				setContadoresErrorLectura((prev) => ({
					...prev,
					[claveError]: (prev[claveError] || 0) + 1,
				}));
				// NOTA: No incrementamos contadorPolling aqu√≠ para evitar m√∫ltiples incrementos
				// cuando hay varias zonas. El contador se incrementa en iniciarPolling.
				return; // No actualizar valores si hay error de lectura
			}

			// Si llegamos aqu√≠, la lectura es exitosa - resetear contador de errores de lectura
			setContadoresErrorLectura((prev) => {
				if (prev[claveError]) {
					const nuevo = { ...prev };
					delete nuevo[claveError];
					return nuevo;
				}
				return prev;
			});

			// Transformar los valores al formato esperado por calcularValoresLadoTarjeta
			// La lectura tiene: { id, registrador_id, timestamp, valores: [...], indice_inicial, cantidad_registros, ... }
			// El formato esperado es: { rele: [{ index, address, value }, ...] }
			if (lectura.valores && Array.isArray(lectura.valores)) {
				const indiceInicial = lectura.indice_inicial ?? 0;

				const registrosTransformados = lectura.valores.map((valor, idx) => ({
					index: idx,
					address: indiceInicial + idx,
					value: valor,
				}));

				// Actualizar registrosEnVivo acumulando con registros existentes
				// Esto permite que m√∫ltiples registradores contribuyan datos a la misma card
				actualizarRegistros(alimId, (prevRegistros) => {
					const registrosAnteriores = prevRegistros?.rele || [];
					// Filtrar registros anteriores que no est√©n en el rango del nuevo registrador
					// para evitar duplicados, luego agregar los nuevos
					const rangoNuevo = new Set(registrosTransformados.map(r => r.address));
					const registrosFiltrados = registrosAnteriores.filter(r => !rangoNuevo.has(r.address));
					return {
						rele: [...registrosFiltrados, ...registrosTransformados]
					};
				});

				// Guardar lectura en IndexedDB para historial (solo lecturas exitosas)
				// Se guarda por zona para poder consultar el historial por zona despu√©s
				guardarLecturaLocal(alimId, registradorId, zona, {
					timestamp: lectura.timestamp ? new Date(lectura.timestamp).getTime() : Date.now(),
					valores: lectura.valores,
					indiceInicial: indiceInicial,
					exito: true,
				});

				// NOTA: No incrementamos contadorPolling aqu√≠ para evitar m√∫ltiples incrementos
				// cuando hay varias zonas. El contador se incrementa en iniciarPolling.
			}
		} catch (error) {
			// Error de RED: el frontend no pudo comunicarse con el backend
			// (usuario sin internet, backend ca√≠do, timeout, etc.)
			console.error(`[Polling] Error de red obteniendo lecturas para alimentador ${alimId}:`, error);
			setContadoresErrorRed((prev) => ({
				...prev,
				[claveError]: (prev[claveError] || 0) + 1,
			}));
			// Marcar que hay problema de conexi√≥n global
			setHayProblemaConexion(true);
		}
	}, [actualizarRegistros, guardarLecturaLocal]);

	// Extrae los registrador_id √∫nicos del card_design de un alimentador
	const obtenerRegistradoresDeAlim = useCallback((alim) => {
		const registradores = [];
		const card_design = alim.card_design;

		const regSuperior = card_design?.superior?.registrador_id;
		const regInferior = card_design?.inferior?.registrador_id;

		if (regSuperior && regInferior) {
			// Ambas zonas tienen registrador configurado
			if (regSuperior === regInferior) {
				// Mismo registrador para ambas zonas
				registradores.push({ zona: "superior", zonas: ["superior", "inferior"], id: regSuperior });
			} else {
				// Registradores diferentes para cada zona
				registradores.push({ zona: "superior", id: regSuperior });
				registradores.push({ zona: "inferior", id: regInferior });
			}
		} else if (regSuperior) {
			// Solo hay registrador en superior - asumimos que cubre ambas zonas de la tarjeta
			registradores.push({ zona: "superior", zonas: ["superior", "inferior"], id: regSuperior });
		} else if (regInferior) {
			// Solo hay registrador en inferior - asumimos que cubre ambas zonas de la tarjeta
			registradores.push({ zona: "inferior", zonas: ["superior", "inferior"], id: regInferior });
		}

		// Compatibilidad: si no hay registradores en zonas, usar el de la ra√≠z (formato antiguo)
		if (registradores.length === 0 && alim.registrador_id) {
			registradores.push({ zona: "legacy", zonas: ["superior", "inferior"], id: alim.registrador_id });
		}

		return registradores;
	}, []);

	// Inicia el polling para un alimentador
	const iniciarPolling = useCallback((alim) => {
		const registradores = obtenerRegistradoresDeAlim(alim);

		if (registradores.length === 0) {
			console.warn(`[Polling] Alimentador ${alim.id} no tiene registradores configurados`);
			return;
		}

		if (!alim.intervalo_consulta_ms) {
			console.warn(`[Polling] Alimentador ${alim.id} no tiene intervalo de consulta configurado`);
			return;
		}

		// Limpiar intervalos existentes si hay
		if (pollingIntervalsRef.current[alim.id]) {
			// Puede ser un array de intervalos si hay m√∫ltiples registradores
			const intervalos = pollingIntervalsRef.current[alim.id];
			if (Array.isArray(intervalos)) {
				intervalos.forEach(clearInterval);
			} else {
				clearInterval(intervalos);
			}
		}
		// Limpiar intervalo del contador si existe
		if (contadorIntervalsRef.current[alim.id]) {
			clearInterval(contadorIntervalsRef.current[alim.id]);
		}

		// Crear intervalos para cada registrador √∫nico
		const intervalos = [];

		registradores.forEach(({ zona, zonas, id: registradorId }) => {
			// Si el registrador cubre m√∫ltiples zonas, usar ese array; si no, usar la zona individual
			const zonasACubrir = zonas || [zona];

			// Hacer la primera lectura inmediatamente para cada zona que cubre este registrador
			zonasACubrir.forEach((z) => {
				fetchLecturasRegistrador(alim.id, registradorId, z);
			});

			// Configurar intervalo para lecturas peri√≥dicas
			const intervalId = setInterval(() => {
				zonasACubrir.forEach((z) => {
					fetchLecturasRegistrador(alim.id, registradorId, z);
				});
			}, alim.intervalo_consulta_ms);

			intervalos.push(intervalId);
		});

		pollingIntervalsRef.current[alim.id] = intervalos.length === 1 ? intervalos[0] : intervalos;

		// Incrementar contador inmediatamente para la primera lectura
		setContadoresPolling((prev) => ({
			...prev,
			[alim.id]: (prev[alim.id] || 0) + 1,
		}));

		// Crear un intervalo separado SOLO para incrementar el contador (1 vez por ciclo)
		// Esto evita m√∫ltiples incrementos cuando hay varios registradores/zonas
		const contadorIntervalId = setInterval(() => {
			setContadoresPolling((prev) => ({
				...prev,
				[alim.id]: (prev[alim.id] || 0) + 1,
			}));
		}, alim.intervalo_consulta_ms);

		contadorIntervalsRef.current[alim.id] = contadorIntervalId;
	}, [fetchLecturasRegistrador, obtenerRegistradoresDeAlim]);

	// Detiene el polling para un alimentador
	const detenerPolling = useCallback((alimId) => {
		if (pollingIntervalsRef.current[alimId]) {
			// Puede ser un array de intervalos si hay m√∫ltiples registradores
			const intervalos = pollingIntervalsRef.current[alimId];
			if (Array.isArray(intervalos)) {
				intervalos.forEach(clearInterval);
			} else {
				clearInterval(intervalos);
			}
			delete pollingIntervalsRef.current[alimId];
		}
		// Limpiar el intervalo del contador de animaci√≥n
		if (contadorIntervalsRef.current[alimId]) {
			clearInterval(contadorIntervalsRef.current[alimId]);
			delete contadorIntervalsRef.current[alimId];
		}
		// Limpiar las lecturas de polling para ese alimentador (incluyendo las de zonas)
		setLecturasPolling((prev) => {
			const nuevo = { ...prev };
			delete nuevo[alimId];
			delete nuevo[`${alimId}_superior`];
			delete nuevo[`${alimId}_inferior`];
			delete nuevo[`${alimId}_legacy`];
			return nuevo;
		});
		// Resetear el contador de lecturas para ese alimentador
		setContadoresPolling((prev) => {
			const nuevo = { ...prev };
			delete nuevo[alimId];
			return nuevo;
		});
		// Limpiar contadores de errores de lectura para ese alimentador (ambas zonas)
		setContadoresErrorLectura((prev) => {
			const claveSup = `${alimId}_superior`;
			const claveInf = `${alimId}_inferior`;
			if (prev[claveSup] || prev[claveInf]) {
				const nuevo = { ...prev };
				delete nuevo[claveSup];
				delete nuevo[claveInf];
				return nuevo;
			}
			return prev;
		});
		// Limpiar contadores de errores de red para ese alimentador (ambas zonas)
		setContadoresErrorRed((prev) => {
			const claveSup = `${alimId}_superior`;
			const claveInf = `${alimId}_inferior`;
			if (prev[claveSup] || prev[claveInf]) {
				const nuevo = { ...prev };
				delete nuevo[claveSup];
				delete nuevo[claveInf];
				// Si ya no hay errores de red, actualizar estado global
				if (Object.keys(nuevo).length === 0) {
					setHayProblemaConexion(false);
				}
				return nuevo;
			}
			return prev;
		});
	}, []);

	// Alterna el polling de un alimentador (play/stop)
	const handlePlayStopClick = useCallback((alimId) => {
		const alimentador = buscarAlimentador(alimId);
		if (!alimentador) return;

		const estaActivo = alimentadoresPolling[alimId];

		if (estaActivo) {
			// Detener polling
			detenerPolling(alimId);
		} else {
			// Iniciar polling
			iniciarPolling(alimentador);
		}

		// Actualizar estado visual
		setAlimentadoresPolling((prev) => ({
			...prev,
			[alimId]: !prev[alimId],
		}));
	}, [alimentadoresPolling, buscarAlimentador, detenerPolling, iniciarPolling]);

	// Helper para limpiar intervalos (puede ser un solo intervalo o un array)
	const limpiarIntervalos = (intervalos) => {
		if (Array.isArray(intervalos)) {
			intervalos.forEach(clearInterval);
		} else {
			clearInterval(intervalos);
		}
	};

	// Limpiar todos los intervalos al desmontar el componente
	useEffect(() => {
		return () => {
			Object.values(pollingIntervalsRef.current).forEach(limpiarIntervalos);
		};
	}, []);

	// ===== DRAG & DROP =====
	const handleDragStartAlim = (alimId) => {
		alIniciarArrastre(alimId);                                    // guarda qu√© tarjeta se est√° arrastrando
	};

	const handleDragEndAlim = () => {
		alTerminarArrastre();                                         // limpia estado de drag
	};

	const handleDropAlim = (targetAlimId) => {
		if (!puestoSeleccionado || !elementoArrastrandoId) return;

		const nuevaLista = reordenarLista(
			puestoSeleccionado.alimentadores,
			elementoArrastrandoId,
			targetAlimId
		);                                                             // calcula nuevo orden interno

		// Resetear el gap de la tarjeta movida al valor por defecto
		establecerGap(elementoArrastrandoId, GAP_DEFAULT);

		reordenarAlimentadores(puestoSeleccionado.id, nuevaLista);     // guarda el nuevo orden en el contexto
		alTerminarArrastre();
	};

	const handleDropAlimAlFinal = () => {
		if (!puestoSeleccionado || !elementoArrastrandoId) return;

		const nuevaLista = moverAlFinal(
			puestoSeleccionado.alimentadores,
			elementoArrastrandoId
		);                                                             // mueve la tarjeta arrastrada al final

		// Resetear el gap de la tarjeta movida al valor por defecto
		establecerGap(elementoArrastrandoId, GAP_DEFAULT);

		reordenarAlimentadores(puestoSeleccionado.id, nuevaLista);
		alTerminarArrastre();
	};

	// Estado de carga (solo mostrar si NO estamos sincronizando)
	// Durante la sincronizaci√≥n, el overlay de "Guardando cambios..." se encarga del feedback
	if (cargando && !sincronizando) {
		return (
			<div className="alim-page alim-page--cargando">
				<div className="alim-loading">
					<div className="alim-loading__spinner"></div>
					<p>Cargando configuraci√≥n...</p>
				</div>
			</div>
		);
	}

	// Estado de error
	if (error) {
		return (
			<div className="alim-page alim-page--error">
				<div className="alim-error">
					<p>Error: {error}</p>
					<button onClick={() => window.location.reload()}>Reintentar</button>
				</div>
			</div>
		);
	}

	return (
		<div className="alim-page">
			{/* Overlay de guardando puestos (portal a body) */}
			{guardandoPuestos && ReactDOM.createPortal(
				<div className="guardar-overlay">
					<div className="guardar-overlay__contenido">
						<div className="guardar-overlay__spinner" />
						<span className="guardar-overlay__texto">Guardando cambios...</span>
					</div>
				</div>,
				document.body
			)}


			{/* ===== NAV SUPERIOR ===== */}
			<BarraNavegacion
				esCompacto={esCompacto}
				puestos={puestos}
				puestoSeleccionado={puestoSeleccionado}
				onSeleccionarPuesto={seleccionarPuesto}
				onAbrirModalNuevoPuesto={abrirModalNuevoPuesto}
				onAbrirModalEditarPuestos={abrirModalEditarPuestos}
				onAbrirModalConfigPuesto={abrirModalConfigPuesto}
				onAbrirModalConfigurarAgente={abrirModalConfigurarAgente}
				onAbrirModalGestionarAccesos={abrirModalGestionarAccesos}
				onAbrirModalPanelPermisos={abrirModalPanelPermisos}
				onSalir={handleSalir}
				onAbrirMenu={() => setMenuAbierto(true)}
				coloresSistema={COLORES_SISTEMA}
				estaPolling={estaPolling}
				onPlayStopClick={handlePlayStopClick}
			/>

			{/* ===== MENU LATERAL (modo compacto) ===== */}
			{/* En modo compacto (m√≥vil), NO se muestra la secci√≥n de Escala Global */}
			{/* La escala se fuerza a 1 autom√°ticamente (ver escalaGlobalEfectiva) */}
			{esCompacto && (
				<MenuLateral
					abierto={menuAbierto}
					onCerrar={() => setMenuAbierto(false)}
					puestos={puestos}
					puestoSeleccionado={puestoSeleccionado}
					onSeleccionarPuesto={seleccionarPuesto}
					onAbrirModalNuevoPuesto={abrirModalNuevoPuesto}
					onAbrirModalEditarPuestos={abrirModalEditarPuestos}
					onAbrirModalConfigurarAgente={abrirModalConfigurarAgente}
					onAbrirModalGestionarAccesos={abrirModalGestionarAccesos}
					onAbrirModalPanelPermisos={abrirModalPanelPermisos}
					onSalir={handleSalir}
					coloresSistema={COLORES_SISTEMA}
				/>
			)}

			{/* ===== MAIN ===== */}
			<main
				className="alim-main"
				style={{ backgroundColor: puestoSeleccionado ? (obtenerBgColorPuesto(puestoSeleccionado.id) || "#e5e7eb") : "#e5e7eb" }} // usa bgColor del puesto (con preferencias de invitado)
			>
				{/* Overlay de problema de conexi√≥n (errores de red) */}
				{hayProblemaConexion && (
					<div className="alim-overlay-conexion">
						<div className="alim-overlay-conexion__contenido">
							<span className="alim-overlay-conexion__icono">‚ö†</span>
							<span className="alim-overlay-conexion__titulo">SIN CONEXI√ìN</span>
							<span className="alim-overlay-conexion__texto">
								No se pueden obtener lecturas del servidor
							</span>
						</div>
					</div>
				)}

				{/* Caso 1: Sin workspace asignado */}
				{!configuracionSeleccionada ? (
					<div className="alim-sin-workspace">
						<h2>Sin acceso a workspaces</h2>
						<p>No tienes ning√∫n workspace asignado.</p>
						<p>Contacta a un administrador para que te asigne acceso a un workspace.</p>
						<button onClick={handleSalir}>Volver al inicio</button>
					</div>
				) : !puestoSeleccionado ? (
					/* Caso 2: Tiene workspace pero sin puestos */
					<div className="alim-empty-state">
						<p>
							No hay puestos creados. Haz clic en el boton "+" para agregar
							uno.
						</p>
					</div>
				) : (
					/* Caso 3: Tiene workspace y puestos */
					<>
						<GrillaTarjetas
							alimentadores={alimentadoresConPreferencias}
							lecturas={lecturasTarjetas}
							puestoId={puestoSeleccionado.id}
							workspaceId={configuracionSeleccionada?.id}
							elementoArrastrandoId={elementoArrastrandoId}
							onAbrirConfiguracion={abrirModalEditarAlim}
							onAbrirHistorial={(puestoId, alim) => {
								abrirVentana(alim, alim.card_design);
							}}
							onDragStart={handleDragStartAlim}
							onDragOver={alPasarPorEncima}
							onDrop={handleDropAlim}
							onDragEnd={handleDragEndAlim}
							skeletonCard={guardandoAlimentador ? <SkeletonCard /> : null}
							onDropAlFinal={handleDropAlimAlFinal}
							onAgregarNuevo={abrirModalNuevoAlim}
							puedeAgregarNuevo={
								configuracionSeleccionada?.esCreador
									? (rolGlobal === 'superadmin' || rolGlobal === 'admin')
									: (configuracionSeleccionada?.rol === 'admin')
							}
							// Observador no puede ver estad√≠sticas (ni global ni en workspace)
							esObservador={rolGlobal === 'observador' || configuracionSeleccionada?.rol === 'observador'}
							estaMidiendo={estaMidiendo}
							obtenerTimestampInicio={obtenerTimestampInicio}
							obtenerContadorLecturas={obtenerContadorLecturas}
							obtenerGap={obtenerGap}
							onGapChange={establecerGap}
							obtenerRowGap={obtenerRowGap}
							onRowGapChange={establecerRowGap}
							// Polling de lecturas
							estaPolling={estaPolling}
							onPlayStopClick={handlePlayStopClick}
							obtenerContadorPolling={obtenerContadorPolling}
							obtenerErrorPolling={obtenerErrorPolling}
							// Escala de tarjetas (usa wrapper que fuerza 1 en modo compacto/m√≥vil)
							obtenerEscalaEfectiva={obtenerEscalaEfectivaConModoCompacto}
							onEscalaChange={establecerEscalaTarjeta}
							ESCALA_MIN={ESCALA_MIN}
							ESCALA_MAX={ESCALA_MAX}
						/>
					</>
				)}
			</main>

			{/* ===== MODALES ===== */}
			<ModalNuevoPuesto
				abierto={estadoModalNuevoPuesto.abierto}
				onCerrar={() => cerrarModal("nuevoPuesto")}
				onCrear={handleCrearPuesto}
				coloresSistema={COLORES_SISTEMA}
			/>

			<ModalEditarPuestos
				abierto={estadoModalEditarPuestos.abierto}
				puestos={puestosConPreferencias}
				onCerrar={() => cerrarModal("editarPuestos")}
				onGuardar={handleGuardarPuestos}
				esCreador={configuracionSeleccionada?.esCreador}
				rolEnWorkspace={configuracionSeleccionada?.rol}
				// En modo compacto (m√≥vil), no mostrar controles de escala de puesto
				obtenerEscalaPuesto={!esCompacto ? obtenerEscalaPuesto : undefined}
				onEscalaPuestoChange={!esCompacto ? handleEscalaPuestoChange : undefined}
				ESCALA_MIN={ESCALA_MIN}
				ESCALA_MAX={ESCALA_MAX}
				// Estilos globales de tarjetas (pesta√±a Apariencia)
				estilosGlobales={estilosGlobales}
				onGuardarEstilos={guardarEstilosGlobales}
			/>

			<ModalConfiguracionAlimentador
				abierto={estadoModalAlimentador.abierto}
				puestoNombre={puestoSeleccionado?.nombre || ""}
				workspaceId={configuracionSeleccionada?.id}
				modo={modoAlimentador}
				initialData={alimentadorEnEdicion}
				onCancelar={() => cerrarModal("alimentador")}
				onConfirmar={handleGuardarAlimentador}
				onEliminar={handleEliminarAlimentador}
				esCreador={configuracionSeleccionada?.esCreador}
				rolEnWorkspace={configuracionSeleccionada?.rol}
			/>

			<ModalConfiguracionPuesto
				abierto={estadoModalConfigPuesto.abierto}
				puesto={puestoSeleccionado}
				onCerrar={() => cerrarModal("configPuesto")}
				estaPolling={estaPolling}
				onPlayStopClick={handlePlayStopClick}
				buscarRegistrador={buscarRegistrador}
			/>

			<ModalConfigurarAgente
				abierto={ventanaConfigAgente.abierta}
				workspaceId={ventanaConfigAgente.workspaceId}
				onCerrar={cerrarVentanaConfigAgente}
				minimizada={ventanaConfigAgente.minimizada}
				maximizada={ventanaConfigAgente.maximizada}
				posicion={ventanaConfigAgente.posicion}
				zIndex={ventanaConfigAgente.zIndex}
				onMinimizar={toggleMinimizarConfigAgente}
				onMaximizar={toggleMaximizarConfigAgente}
				onEnfocar={enfocarVentanaConfigAgente}
				onMover={moverVentanaConfigAgente}
			/>

			<ModalGestionarAccesos
				abierto={modalAccesosAbierto}
				workspaceId={configuracionSeleccionada?.id}
				workspaceNombre={configuracionSeleccionada?.nombre}
				usuarioActualId={perfil?.id}
				onCerrar={() => setModalAccesosAbierto(false)}
			/>

			<ModalPanelPermisos
				abierto={modalPanelPermisosAbierto}
				onCerrar={() => setModalPanelPermisosAbierto(false)}
			/>

			{/* Sistema de ventanas flotantes de historial */}
			<ContenedorVentanasHistorial
				listaVentanas={listaVentanas}
				ventanasMinimizadas={ventanasMinimizadas}
				cerrarVentana={cerrarVentana}
				toggleMinimizar={toggleMinimizar}
				toggleMaximizar={toggleMaximizar}
				enfocarVentana={enfocarVentana}
				moverVentana={moverVentana}
			/>
		</div>
	);
};

export default VistaAlimentadores;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (VistaAlimentadores.jsx)

 - Es el "tablero de control" visual de los alimentadores: aqu√≠ se ensamblan
   la barra de navegaci√≥n, el men√∫ lateral, la grilla de tarjetas y todos los
   modales de creaci√≥n/edici√≥n/mapeo.

 - Lee todos los datos y acciones desde `usarContextoAlimentadores()` y los
   reparte a los distintos componentes (nav, tarjetas, modales) sin guardar
   l√≥gica de negocio ac√° adentro.

 - `useGestorModales` centraliza qu√© modal est√° abierto y con qu√© datos, lo que
   permite abrir/cerrar cada uno con una simple clave (`"nuevoPuesto"`,
   `"editarPuestos"`, `"alimentador"`, `"mapeo"`).

 - `usarArrastrarSoltar` se encarga del drag & drop de tarjetas; esta vista solo
   coordina cu√°ndo llamar a `reordenarAlimentadores` con la nueva lista.

 - A nivel mental:
   * ContextoAlimentadores = sala de m√°quinas (datos + l√≥gica).
   * VistaAlimentadores = tablero de control que el usuario ve y manipula.
---------------------------------------------------------------------------*/}

{/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (VistaAlimentadores.jsx)

0) Visi√≥n general del archivo

   `VistaAlimentadores` es el ‚Äútablero de control‚Äù que ve el usuario:

   - Muestra:
       ‚Ä¢ barra superior con puestos y bot√≥n de salir,
       ‚Ä¢ men√∫ lateral en pantallas chicas,
       ‚Ä¢ grilla de tarjetas de alimentadores,
       ‚Ä¢ modales para crear/editar puestos,
       ‚Ä¢ modales para configurar alimentadores y mapear mediciones.

   - No calcula negocios pesados por su cuenta:
       ‚Ä¢ lee datos y funciones del contexto (`usarContextoAlimentadores`),
       ‚Ä¢ usa hooks auxiliares (`useGestorModales`, `usarArrastrarSoltar`),
       ‚Ä¢ y simplemente coordina qui√©n ve qu√©, y cu√°ndo.


1) Imports principales

   import React, { useEffect, useState } from "react";
   import { useNavigate } from "react-router-dom";
   import "./VistaAlimentadores.css";

   - React + hooks para estado y efectos (`useState`, `useEffect`).
   - `useNavigate` sirve para volver al login cuando el usuario quiere salir.
   - El CSS define el layout (grid, espaciados, colores de fondo, etc.).

   Luego se importan componentes de UI:

   - `BarraNavegacion`, `MenuLateral`, `GrillaTarjetas`,
   - `ModalNuevoPuesto`, `ModalEditarPuestos`,
   - `ModalConfiguracionAlimentador`, `ModalMapeoMediciones`.

   Y hooks/constantes de apoyo:

   - `COLORES_SISTEMA`              ‚Üí define la paleta que se usa para los puestos.
   - `usarArrastrarSoltar`          ‚Üí l√≥gica de drag & drop.
   - `usarContextoAlimentadores`    ‚Üí acceso a datos y acciones del contexto.
   - `useGestorModales`             ‚Üí qui√©n est√° abierto, con qu√© datos, etc.


2) Inicio del componente y lectura de contexto

   const VistaAlimentadores = () => {
     const navigate = useNavigate();

     const {
       puestos,
       puestoSeleccionado,
       agregarPuesto,
       seleccionarPuesto,
       actualizarPuestos,
       agregarAlimentador,
       actualizarAlimentador,
       eliminarAlimentador,
       reordenarAlimentadores,
       lecturasTarjetas,
       estaMidiendo,
       obtenerRegistros,
       obtenerTimestampInicio,
       obtenerContadorLecturas,
       alternarMedicion,
       detenerMedicion,
     } = usarContextoAlimentadores();

   - `useNavigate()`:
       ‚Ä¢ da la funci√≥n `navigate`, usada para volver al login (`navigate("/")`).

   - `usarContextoAlimentadores()`:
       ‚Ä¢ trae todo lo que el contexto ofrece:
           - datos: lista de `puestos`, `puestoSeleccionado`, `lecturasTarjetas`,
           - acciones sobre puestos y alimentadores,
           - acciones y helpers de mediciones (`estaMidiendo`, `obtenerRegistros`, etc.).

   En resumen: ac√° ‚Äúenchuf√°s‚Äù la vista al motor de datos.


3) Hook de drag & drop

   const {
     elementoArrastrandoId,
     alIniciarArrastre,
     alTerminarArrastre,
     alPasarPorEncima,
     reordenarLista,
     moverAlFinal,
   } = usarArrastrarSoltar();

   - `usarArrastrarSoltar` encapsula:
       ‚Ä¢ qu√© tarjeta se est√° arrastrando,
       ‚Ä¢ c√≥mo reordenar una lista,
       ‚Ä¢ c√≥mo mover un √≠tem al final.

   - Esta vista no se preocupa por los detalles internos de drag & drop:
       ‚Ä¢ solo llama a estas funciones en los momentos correctos (onDragStart, onDragOver, onDrop, etc.).


4) Gestor de modales

   const { abrirModal, cerrarModal, obtenerEstado } = useGestorModales();

   - `useGestorModales` es un ‚Äúmini gestor de ventanas‚Äù:
       ‚Ä¢ cada modal se identifica con una clave string:
           - "nuevoPuesto",
           - "editarPuestos",
           - "alimentador",
           - "mapeo".
       ‚Ä¢ cada clave tiene un estado `{ abierto, datos }`.

   - `abrirModal(id, datos?)`     ‚Üí abre el modal y puede asociarle datos.
   - `cerrarModal(id)`            ‚Üí lo cierra.
   - `obtenerEstado(id)`          ‚Üí devuelve siempre `{ abierto, datos }` (aunque nunca se haya usado).


5) Estados locales de layout (menu y modo compacto)

   const [menuAbierto, setMenuAbierto] = useState(false);
   const [esCompacto, setEsCompacto] = useState(false);

   - `menuAbierto`:
       ‚Ä¢ controla si el men√∫ lateral (drawer) est√° desplegado en modo mobile.

   - `esCompacto`:
       ‚Ä¢ indica si la pantalla se considera ‚Äúangosta‚Äù (por ejemplo mobile o tablet)
         y activa la versi√≥n con men√∫ lateral.


6) useEffect para detectar modo compacto (responsive)

   useEffect(() => {
     const actualizarModo = () => setEsCompacto(window.innerWidth < 900);
     actualizarModo();
     window.addEventListener("resize", actualizarModo);
     return () => window.removeEventListener("resize", actualizarModo);
   }, []);

   - Al montar la vista:
       ‚Ä¢ ejecuta `actualizarModo()` una vez para decidir si es compacto o no,
       ‚Ä¢ agrega un listener a `resize` para que, si cambia el tama√±o de ventana,
         se actualice `esCompacto`.

   - Al desmontar:
       ‚Ä¢ remueve el listener para evitar fugas de memoria o comportamientos raros.

   - Regla:
       ‚Ä¢ si el ancho de ventana es menor a 900 px ‚Üí `esCompacto = true`,
       ‚Ä¢ si no ‚Üí `esCompacto = false`.


7) Estado de modales (le√≠do desde useGestorModales)

   const estadoModalNuevoPuesto = obtenerEstado("nuevoPuesto");
   const estadoModalEditarPuestos = obtenerEstado("editarPuestos");
   const estadoModalAlimentador = obtenerEstado("alimentador");
   const estadoModalMapeo = obtenerEstado("mapeo");

   - Cada uno devuelve un objeto de la forma:
       { abierto: boolean, datos: any }

   - As√≠ se sabe:
       ‚Ä¢ si el modal est√° visible (`abierto`),
       ‚Ä¢ y qu√© datos se pasaron al abrirlo (`datos`).


8) Helpers para obtener un alimentador y derivar datos para modales

   const buscarAlimentador = (alimId) =>
     puestoSeleccionado?.alimentadores.find((a) => a.id === alimId) || null;

   const alimentadorEnEdicion = estadoModalAlimentador.datos?.alimentadorId
     ? buscarAlimentador(estadoModalAlimentador.datos.alimentadorId)
     : null;

   const modoAlimentador = estadoModalAlimentador.datos?.modo || "crear";

   const alimentadorParaMapeo = estadoModalMapeo.datos?.alimentadorId
     ? buscarAlimentador(estadoModalMapeo.datos.alimentadorId)
     : null;

   - `buscarAlimentador(alimId)`:
       ‚Ä¢ busca dentro de `puestoSeleccionado.alimentadores` el que tiene ese id,
       ‚Ä¢ si no existe o no hay puesto seleccionado, devuelve null.

   - `alimentadorEnEdicion`:
       ‚Ä¢ si el modal `"alimentador"` fue abierto con `{ alimentadorId }`,
         se busca ese alimentador y se usa como base para el formulario.

   - `modoAlimentador`:
       ‚Ä¢ puede ser "crear" o "editar",
       ‚Ä¢ seg√∫n c√≥mo se haya abierto el modal.

   - `alimentadorParaMapeo`:
       ‚Ä¢ similar a `alimentadorEnEdicion`, pero exclusivo para el modal de `"mapeo"`.


9) Navegaci√≥n: salir al login

   const handleSalir = () => navigate("/");

   - Se pasa a la barra superior y al men√∫ lateral.
   - Cuando se invoca, redirige a la ruta ra√≠z (login).


10) L√≥gica de modales de puestos

   const abrirModalNuevoPuesto = () => abrirModal("nuevoPuesto");
   const abrirModalEditarPuestos = () => abrirModal("editarPuestos");

   const handleCrearPuesto = (nombre, color) => {
     agregarPuesto(nombre, color);
     cerrarModal("nuevoPuesto");
   };

   const handleGuardarPuestos = (puestosEditados) => {
     actualizarPuestos(puestosEditados);
     cerrarModal("editarPuestos");
   };

   - `abrirModalNuevoPuesto`:
       ‚Ä¢ abre el modal de alta de puesto.

   - `abrirModalEditarPuestos`:
       ‚Ä¢ abre el modal de edici√≥n masiva (nombres, colores, etc.).

   - `handleCrearPuesto`:
       ‚Ä¢ llama a `agregarPuesto` del contexto,
       ‚Ä¢ cierra el modal.

   - `handleGuardarPuestos`:
       ‚Ä¢ recibe la lista editada desde el modal,
       ‚Ä¢ llama a `actualizarPuestos` para guardarla,
       ‚Ä¢ cierra el modal.


11) L√≥gica de modales de alimentadores

   const abrirModalNuevoAlim = () => abrirModal("alimentador", { modo: "crear" });

   const abrirModalEditarAlim = (_puestoId, alimentador) =>
     abrirModal("alimentador", { modo: "editar", alimentadorId: alimentador.id });

   const abrirModalMapeo = (_puestoId, alimentador) =>
     abrirModal("mapeo", { alimentadorId: alimentador.id });

   const handleGuardarAlimentador = (datos) => {
     if (!datos || !datos.nombre || !puestoSeleccionado) return;

     if (modoAlimentador === "crear") {
       agregarAlimentador(datos);
     } else if (alimentadorEnEdicion) {
       actualizarAlimentador(
         puestoSeleccionado.id,
         alimentadorEnEdicion.id,
         datos
       );
     }

     cerrarModal("alimentador");
   };

   const handleEliminarAlimentador = () => {
     if (!puestoSeleccionado || !alimentadorEnEdicion) return;

     detenerMedicion(alimentadorEnEdicion.id, "rele");
     detenerMedicion(alimentadorEnEdicion.id, "analizador");

     eliminarAlimentador(puestoSeleccionado.id, alimentadorEnEdicion.id);
     cerrarModal("alimentador");
   };

   const handleGuardarMapeo = (nuevoMapeo) => {
     if (!puestoSeleccionado || !alimentadorParaMapeo) return;

     actualizarAlimentador(puestoSeleccionado.id, alimentadorParaMapeo.id, {
       mapeoMediciones: nuevoMapeo,
     });
     cerrarModal("mapeo");
   };

   - Aperturas:
       ‚Ä¢ nuevo alimentador ‚Üí modo "crear",
       ‚Ä¢ editar alimentador ‚Üí modo "editar" + id del alimentador,
       ‚Ä¢ mapeo ‚Üí solo id del alimentador.

   - Guardar alimentador:
       ‚Ä¢ si el modo es "crear"       ‚Üí alta nueva,
       ‚Ä¢ si el modo es "editar"      ‚Üí actualiza el alimentador existente.

   - Eliminar alimentador:
       ‚Ä¢ por seguridad, corta medici√≥n de rele y analizador,
       ‚Ä¢ luego lo elimina del puesto.

   - Guardar mapeo:
       ‚Ä¢ actualiza solo `mapeoMediciones` del alimentador,
       ‚Ä¢ el resto de datos queda intacto.


12) L√≥gica de mediciones (rele y analizador)

   const handleAlternarMedicionRele = (alimId, overrideConfig) => {
     const alim = buscarAlimentador(alimId);
     if (!alim) return;
     alternarMedicion(alim, "rele", overrideConfig);
   };

   const handleAlternarMedicionAnalizador = (alimId, overrideConfig) => {
     const alim = buscarAlimentador(alimId);
     if (!alim) return;
     alternarMedicion(alim, "analizador", overrideConfig);
   };

   - Estas funciones:
       ‚Ä¢ buscan el alimentador por id,
       ‚Ä¢ llaman al helper `alternarMedicion` del contexto,
       ‚Ä¢ pasan el `overrideConfig` si viene desde el modal (periodo, ip, etc.).

   - La vista no decide si iniciar o detener:
       ‚Ä¢ solo dice ‚Äúaltern√°‚Äù, el hook resuelve.


13) L√≥gica de drag & drop

   const handleDragStartAlim = (alimId) => {
     alIniciarArrastre(alimId);
   };

   const handleDragEndAlim = () => {
     alTerminarArrastre();
   };

   const handleDropAlim = (targetAlimId) => {
     if (!puestoSeleccionado || !elementoArrastrandoId) return;

     const nuevaLista = reordenarLista(
       puestoSeleccionado.alimentadores,
       elementoArrastrandoId,
       targetAlimId
     );

     reordenarAlimentadores(puestoSeleccionado.id, nuevaLista);
     alTerminarArrastre();
   };

   const handleDropAlimAlFinal = () => {
     if (!puestoSeleccionado || !elementoArrastrandoId) return;

     const nuevaLista = moverAlFinal(
       puestoSeleccionado.alimentadores,
       elementoArrastrandoId
     );

     reordenarAlimentadores(puestoSeleccionado.id, nuevaLista);
     alTerminarArrastre();
   };

   - `handleDragStartAlim`:
       ‚Ä¢ se engancha a `onDragStart` de cada tarjeta,
       ‚Ä¢ marca qu√© alimentador se est√° arrastrando.

   - `handleDragEndAlim`:
       ‚Ä¢ limpia el estado de drag cuando termina el arrastre.

   - `handleDropAlim(targetAlimId)`:
       ‚Ä¢ se llama al soltar sobre otra tarjeta,
       ‚Ä¢ calcula el nuevo orden de la lista usando `reordenarLista`,
       ‚Ä¢ guarda ese orden con `reordenarAlimentadores` (contexto),
       ‚Ä¢ resetea el estado de drag.

   - `handleDropAlimAlFinal`:
       ‚Ä¢ se activa en la zona de ‚Äúsoltar para mandar al final‚Äù,
       ‚Ä¢ calcula la lista con `moverAlFinal`,
       ‚Ä¢ guarda el nuevo orden,
       ‚Ä¢ limpia estado de drag.


14) Render principal (JSX)

   return (
     <div className="alim-page">

       // NAV SUPERIOR 
       <BarraNavegacion ... />

       // MENU LATERAL (solo si esCompacto) 
       {esCompacto && <MenuLateral ... />}

       // MAIN 
       <main className="alim-main" style={{ backgroundColor: ... }}>
         { !puestoSeleccionado ? (
           // estado vac√≠o sin puestos
         ) : (
           <>
             { puestoSeleccionado.alimentadores.length === 0 && (
               // mensaje ‚Äúno hay alimentadores‚Äù
             )}

             <GrillaTarjetas
               // lista de alimentadores
               // lecturas procesadas
               // handlers de drag, de configuraci√≥n, de mapeo, etc.
             />
           </>
         )}
       </main>

       // MODALES 
       <ModalNuevoPuesto ... />
       <ModalEditarPuestos ... />
       <ModalConfiguracionAlimentador ... />
       <ModalMapeoMediciones ... />
     </div>
   );

   - La estructura visual queda as√≠:
       ‚Ä¢ `BarraNavegacion` arriba,
       ‚Ä¢ `MenuLateral` solo en modo compacto,
       ‚Ä¢ `main` con fondo seg√∫n `bgColor` del puesto,
       ‚Ä¢ `GrillaTarjetas` para las cards,
       ‚Ä¢ todos los modales montados al final (solo se ven cuando `abierto = true`).

   - `GrillaTarjetas` recibe:
       ‚Ä¢ alimentadores,
       ‚Ä¢ lecturas ya procesadas (`lecturasTarjetas`),
       ‚Ä¢ callbacks para abrir modales,
       ‚Ä¢ callbacks para drag & drop,
       ‚Ä¢ helpers de estado de medici√≥n y contadores.


15) Export

   export default VistaAlimentadores;

   - Exporta el componente para usarlo en la ruta `/alimentadores` de la app.
   - Es la vista principal del panel de alimentadores.

---------------------------------------------------------------------------------------*/}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ColorPickerSimple.css =====

/* src/paginas/PaginaAlimentadores/componentes/modales/ColorPickerSimple.css */
/* Estilos minimalistas para el selector de color */

.color-picker-simple {
	display: flex;
	flex-direction: column;
	gap: 1px;
	align-items: center;
}

.color-picker-simple-label {
	font-size: 14px;
	color: #94a3b8;
	font-weight: 500;
}

.color-picker-simple-wrapper {
	position: relative;
}

.color-picker-simple-button {
	width: 28px;
	height: 28px;
	border-radius: 50%;
	border: 2px solid #475569;
	cursor: pointer;
	transition: all 0.2s ease;
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.color-picker-simple-button:hover {
	transform: scale(1.1);
	border-color: #64748b;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.color-picker-simple-button:active {
	transform: scale(0.95);
}

.color-picker-simple-popover {
	position: fixed;
	z-index: 9999;
	padding: 8px;
	background: #1e293b;
	border-radius: 6px;
	box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
	border: 1px solid #334155;
	width: 240px;
}

/* Estilos para el picker de react-colorful */
.color-picker-simple-popover .react-colorful {
	width: 100%;
	height: 180px;
}

.color-picker-simple-popover .react-colorful__saturation {
	border-radius: 4px 4px 0 0;
	height: 140px;
}

.color-picker-simple-popover .react-colorful__hue {
	height: 16px;
	border-radius: 0 0 4px 4px;
	margin-top: 6px;
}

.color-picker-simple-popover .react-colorful__pointer {
	width: 18px;
	height: 18px;
}

/* Input de valor hexadecimal */
.color-picker-hex-input-wrapper {
	display: flex;
	gap: 4px;
	margin-top: 8px;
	align-items: center;
}

.color-picker-hex-input {
	flex: 1;
	background: #0f172a;
	border: 1.5px solid #64748b;
	border-radius: 4px;
	padding: 5px 6px;
	color: #e2e8f0;
	font-size: 12px;
	font-family: monospace;
	text-align: center;
	cursor: pointer;
	transition: all 0.2s ease;
}

.color-picker-hex-input:hover {
	border-color: #94a3b8;
	background: #1e293b;
}

.color-picker-hex-input:focus {
	outline: none;
	border-color: #06b6d4;
	background: #1e293b;
}

.color-picker-copy-btn {
	background: #334155;
	border: none;
	border-radius: 4px;
	padding: 6px 8px;
	font-size: 14px;
	cursor: pointer;
	transition: all 0.2s ease;
}

.color-picker-copy-btn:hover {
	background: #475569;
	transform: scale(1.05);
}

.color-picker-copy-btn:active {
	transform: scale(0.95);
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ColorPickerSimple.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ColorPickerSimple.jsx
// Componente minimalista de selector de color con picker inline

import React, { useState, useRef, useEffect } from "react";
import { createPortal } from "react-dom";
import { HexColorPicker, HexColorInput } from "react-colorful";
import "./ColorPickerSimple.css";

const ColorPickerSimple = ({ color, onChange, label, posicionArriba = false }) => {
	const [mostrarPicker, setMostrarPicker] = useState(false);
	const [posicion, setPosicion] = useState({ top: 0, left: 0 });
	const [valorHex, setValorHex] = useState(color);
	const pickerRef = useRef(null);
	const buttonRef = useRef(null);

	// Calcular posici√≥n del picker al abrirlo/cerrarlo (toggle)
	const togglePicker = (e) => {
		e.stopPropagation();

		// Si ya est√° abierto, cerrarlo
		if (mostrarPicker) {
			setMostrarPicker(false);
			return;
		}

		if (buttonRef.current) {
			const rect = buttonRef.current.getBoundingClientRect();
			// Altura aproximada del popover (picker + input hex)
			const alturaPopover = 260;
			const anchoPopover = 240;

			// Calcular posici√≥n vertical
			let top;
			if (posicionArriba) {
				top = rect.top - alturaPopover - 8;
				// Si no cabe arriba, mostrar abajo
				if (top < 10) {
					top = rect.bottom + 8;
				}
			} else {
				top = rect.bottom + 8;
				// Si no cabe abajo, mostrar arriba
				if (top + alturaPopover > window.innerHeight - 10) {
					top = rect.top - alturaPopover - 8;
				}
			}

			// Calcular posici√≥n horizontal centrada
			let left = rect.left + rect.width / 2 - anchoPopover / 2;
			// Asegurar que no se salga por la izquierda
			if (left < 10) {
				left = 10;
			}
			// Asegurar que no se salga por la derecha
			if (left + anchoPopover > window.innerWidth - 10) {
				left = window.innerWidth - anchoPopover - 10;
			}

			setPosicion({ top, left });
			setMostrarPicker(true);
		}
	};

	// Actualizar valor hex cuando cambia el color desde el picker
	const handleColorChange = (nuevoColor) => {
		setValorHex(nuevoColor);
		onChange(nuevoColor);
	};

	// Manejar cambio en el input de texto
	const handleInputChange = (e) => {
		const valor = e.target.value;
		setValorHex(valor);

		// Validar que sea un color hex v√°lido antes de notificar al padre
		if (/^#[0-9A-Fa-f]{6}$/.test(valor)) {
			onChange(valor);
		}
	};

	// Copiar al portapapeles
	const copiarColor = () => {
		navigator.clipboard.writeText(valorHex);
	};

	// Cerrar el picker al hacer click fuera
	useEffect(() => {
		if (!mostrarPicker) return;

		const handleClickOutside = (event) => {
			if (
				pickerRef.current &&
				!pickerRef.current.contains(event.target) &&
				buttonRef.current &&
				!buttonRef.current.contains(event.target)
			) {
				setMostrarPicker(false);
			}
		};

		// Agregar listener despu√©s de un peque√±o delay para evitar que el mismo click que abre el picker lo cierre
		const timeoutId = setTimeout(() => {
			document.addEventListener("mousedown", handleClickOutside);
		}, 10);

		return () => {
			clearTimeout(timeoutId);
			document.removeEventListener("mousedown", handleClickOutside);
		};
	}, [mostrarPicker]);

	return (
		<div className="color-picker-simple">
			<span className="color-picker-simple-label">{label}</span>
			<div className="color-picker-simple-wrapper">
				<button
					ref={buttonRef}
					type="button"
					className="color-picker-simple-button"
					style={{ backgroundColor: color }}
					onClick={togglePicker}
				/>
				{mostrarPicker &&
					createPortal(
						<div
							ref={pickerRef}
							className="color-picker-simple-popover"
							style={{ top: `${posicion.top}px`, left: `${posicion.left}px` }}
							onClick={(e) => e.stopPropagation()}
							onMouseDown={(e) => e.stopPropagation()}
						>
							<HexColorPicker color={color} onChange={handleColorChange} />
							<div className="color-picker-hex-input-wrapper">
								<input
									type="text"
									value={valorHex}
									onChange={handleInputChange}
									className="color-picker-hex-input"
									placeholder="#000000"
									maxLength={7}
								/>
								<button
									type="button"
									className="color-picker-copy-btn"
									onClick={copiarColor}
									title="Copiar color"
								>
									üìã
								</button>
							</div>
						</div>,
						document.body
					)}
			</div>
		</div>
	);
};

export default ColorPickerSimple;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ConfiguracionRele.css =====

/* ============================================================================
   ConfiguracionRele.css - Dise√±o Simplificado
   Estilos para el componente de configuraci√≥n de rel√©s basado en plantillas
   ============================================================================ */

.config-rele {
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 8px 0;
}

/* ============================================================================
   FILA SUPERIOR: Conexi√≥n + Plantilla lado a lado
   ============================================================================ */

.config-rele-row-superior {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}

/* Wrapper izquierdo contiene Conexi√≥n y Transformadores lado a lado */
.config-rele-col-izquierda {
  display: flex;
  flex-direction: row;
  gap: 16px;
}

/* Conexi√≥n ocupa el espacio que necesita */
.config-rele-col-izquierda .config-rele-seccion--conexion {
  flex: 0 0 auto;
}

/* Transformadores ocupa el resto */
.config-rele-col-izquierda .config-rele-seccion--transformadores {
  flex: 1;
}

.config-rele-seccion--conexion {
  /* Conexi√≥n a la izquierda - ancho basado en contenido */
}

.config-rele-seccion--transformadores {
  /* Transformadores en el centro */
}

.config-rele-seccion--plantilla {
  /* Plantilla a la derecha */
}

/* Fila inferior: Consola (izq) + Funcionalidades (der) lado a lado */
.config-rele-row-inferior {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  align-items: stretch;
}

.config-rele-seccion--consola {
  /* Consola a la izquierda */
  display: flex;
  flex-direction: column;
}

.config-rele-seccion--funcionalidades {
  /* Funcionalidades a la derecha */
  display: flex;
  flex-direction: column;
  overflow: hidden;
  max-height: 652px;
}

/* ============================================================================
   CONSOLA DE TEST
   ============================================================================ */

.config-rele-consola-container {
  display: flex;
  gap: 0;
  position: relative;
}

/* Resizer (splitter) entre los paneles */
.config-rele-resizer {
  width: 8px;
  background: #2a3447;
  cursor: col-resize;
  flex-shrink: 0;
  transition: background 0.2s;
  position: relative;
}

.config-rele-resizer::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 4px;
  height: 40px;
  background: #4b5567;
  border-radius: 2px;
}

.config-rele-resizer:hover {
  background: #3b4557;
}

.config-rele-resizer:hover::after {
  background: #6b7587;
}

.config-rele-resizer:active {
  background: #2563eb;
}

.config-rele-resizer:active::after {
  background: #93c5fd;
}

.config-rele-consola {
  flex: none;
  background: #0d1117;
  border: 1px solid #2a3447;
  border-radius: 6px;
  padding: 12px;
  height: 530px;
  max-height: 530px;
  overflow-y: scroll;
  font-family: "Consolas", "Monaco", "Courier New", monospace;
  font-size: 0.85rem;
  line-height: 1.5;
  /* Firefox scrollbar */
  scrollbar-width: auto;
  scrollbar-color: #4b5567 #1a1f2e;
}

/* Scrollbar personalizado para la consola - siempre visible */
.config-rele-consola::-webkit-scrollbar {
  width: 36px;
  background: #1a1f2e;
}

.config-rele-consola::-webkit-scrollbar-track {
  background: #1a1f2e;
  border-radius: 4px;
}

.config-rele-consola::-webkit-scrollbar-thumb {
  background: #5b6577;
  border-radius: 8px;
  border: 4px solid #1a1f2e;
}

.config-rele-consola::-webkit-scrollbar-thumb:hover {
  background: #4b5567;
}

/* Panel de registros (derecha de la consola) */
.config-rele-registros-panel {
  flex: none;
  background: #0d1117;
  border: 1px solid #2a3447;
  border-radius: 6px;
  padding: 12px;
  height: 530px;
  max-height: 530px;
  overflow-y: scroll;
  overflow-x: auto;
  font-family: "Consolas", "Monaco", "Courier New", monospace;
  font-size: 0.85rem;
  line-height: 1.5;
  scrollbar-width: auto;
  scrollbar-color: #4b5567 #1a1f2e;
}

.config-rele-registros-panel::-webkit-scrollbar {
  width: 12px;
  height: 12px;
  background: #1a1f2e;
}

.config-rele-registros-panel::-webkit-scrollbar-track {
  background: #1a1f2e;
  border-radius: 4px;
}

.config-rele-registros-panel::-webkit-scrollbar-thumb {
  background: #5b6577;
  border-radius: 6px;
  border: 2px solid #1a1f2e;
}

.config-rele-registros-panel::-webkit-scrollbar-thumb:hover {
  background: #6b7587;
}

.config-rele-registros-panel::-webkit-scrollbar-corner {
  background: #1a1f2e;
}

.config-rele-registros-vacio {
  color: #52525b;
  font-style: italic;
  text-align: center;
  padding-top: 80px;
}

/* Panel de funcionalidades con valores */
.config-rele-funcionalidades-valores {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.config-rele-valores-categoria {
  margin-bottom: 8px;
}

.config-rele-valores-categoria-titulo {
  color: #a1a1aa;
  font-weight: 600;
  font-size: 0.9rem;
  margin-bottom: 8px;
  padding-bottom: 4px;
  border-bottom: 1px solid #2a3447;
}

.config-rele-valores-func {
  margin-bottom: 12px;
}

.config-rele-valores-func-nombre {
  color: #93c5fd;
  font-weight: 500;
  font-size: 0.85rem;
  margin-bottom: 4px;
}

.config-rele-valores-registros {
  padding-left: 16px;
}

.config-rele-valores-registro {
  color: #fde68a;
  font-size: 0.85rem;
  padding: 2px 0;
}

/* Valor transformado con f√≥rmula TI/TV */
.config-rele-valor-transformado {
  color: #86efac;
  font-weight: 500;
  cursor: help;
}

.config-rele-registros-tabla {
  width: 100%;
  border-collapse: collapse;
  white-space: nowrap;
}

.config-rele-registros-tabla th {
  position: sticky;
  top: 0;
  background: #1a1f2e;
  color: #a1a1aa;
  font-weight: 500;
  font-size: 0.8rem;
  text-align: left;
  padding: 8px 10px;
  border-bottom: 1px solid #2a3447;
}

.config-rele-registros-tabla td {
  padding: 4px 10px;
  color: #e4e4e7;
  border-bottom: 1px solid #1a1f2e;
}

.config-rele-registros-tabla tr:hover td {
  background: rgba(37, 99, 235, 0.08);
}

.config-rele-registros-tabla .col-registro {
  color: #71717a;
  font-size: 0.8rem;
}

.config-rele-registros-tabla .col-decimal {
  color: #fde68a;
}

.config-rele-registros-tabla .col-hex {
  color: #93c5fd;
  font-size: 0.8rem;
}

.config-rele-consola-vacio {
  color: #52525b;
  font-style: italic;
  text-align: center;
  padding-top: 80px;
}

.config-rele-consola-linea {
  display: flex;
  gap: 8px;
  padding: 2px 0;
}

.config-rele-consola-timestamp {
  color: #6b7280;
  flex-shrink: 0;
}

.config-rele-consola-mensaje {
  word-break: break-word;
}

/* Tipos de log */
.config-rele-consola-linea--info .config-rele-consola-mensaje {
  color: #93c5fd;
}

.config-rele-consola-linea--success .config-rele-consola-mensaje {
  color: #86efac;
}

.config-rele-consola-linea--error .config-rele-consola-mensaje {
  color: #fca5a5;
}

.config-rele-consola-linea--data .config-rele-consola-mensaje {
  color: #fde68a;
}

/* Acciones de la consola */
.config-rele-consola-acciones {
  display: flex;
  gap: 10px;
  margin-top: 12px;
}

.config-rele-btn-test,
.config-rele-btn-csv,
.config-rele-btn-limpiar {
  padding: 10px 16px;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  border: none;
  transition: all 0.2s;
}

.config-rele-btn-test {
  background: #2563eb;
  color: white;
  flex: 1;
}

.config-rele-btn-test:hover:not(:disabled) {
  background: #1d4ed8;
}

.config-rele-btn-test:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.config-rele-btn-csv {
  background: #059669;
  color: white;
}

.config-rele-btn-csv:hover:not(:disabled) {
  background: #047857;
}

.config-rele-btn-csv:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.config-rele-btn-limpiar {
  background: #374151;
  color: #e4e4e7;
}

.config-rele-btn-limpiar:hover:not(:disabled) {
  background: #4b5563;
}

.config-rele-btn-limpiar:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* ============================================================================
   SECCIONES
   ============================================================================ */

.config-rele-seccion {
  background: #252b3b;
  border-radius: 8px;
  padding: 16px;
  border: 1px solid #2a3447;
}

.config-rele-seccion h6 {
  margin: 0 0 14px 0;
  font-size: 0.9rem;
  font-weight: 600;
  color: #e4e4e7;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Contador de funcionalidades */
.config-rele-contador {
  margin-left: auto;
  font-size: 0.8rem;
  font-weight: 400;
  color: #71717a;
  background: #1a1f2e;
  padding: 2px 8px;
  border-radius: 10px;
}

/* ============================================================================
   SECCI√ìN PLANTILLA
   ============================================================================ */

.config-rele-plantilla-row {
  display: flex;
  gap: 8px;
  align-items: center;
}

.config-rele-plantilla-row .config-rele-select {
  flex: 1;
  min-width: 0;
}

.config-rele-select {
  flex: 1;
  padding: 8px 10px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 6px;
  color: #e4e4e7;
  font-size: 0.85rem;
  cursor: pointer;
}

.config-rele-select:focus {
  outline: none;
  border-color: #2563eb;
}

.config-rele-select--error {
  border-color: #dc2626;
}

.config-rele-btn-plantilla {
  padding: 10px 12px;
  background: #2563eb;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 0.8rem;
  cursor: pointer;
  white-space: nowrap;
  transition: background 0.2s;
}

.config-rele-btn-plantilla:hover {
  background: #1d4ed8;
}

.config-rele-btn-plantilla--secundario {
  background: #374151;
}

.config-rele-btn-plantilla--secundario:hover {
  background: #4b5563;
}

/* Alertas y mensajes */
.config-rele-alerta {
  margin-top: 10px;
  padding: 10px 14px;
  background: rgba(220, 38, 38, 0.1);
  border: 1px solid #dc2626;
  border-radius: 6px;
  color: #fca5a5;
  font-size: 0.85rem;
}

.config-rele-mensaje {
  margin-top: 10px;
  padding: 10px 14px;
  background: rgba(37, 99, 235, 0.1);
  border: 1px solid #2563eb;
  border-radius: 6px;
  color: #93c5fd;
  font-size: 0.85rem;
}

.config-rele-plantilla-desc {
  margin-top: 10px;
  padding: 8px 12px;
  background: #1a1f2e;
  border-radius: 4px;
  color: #a1a1aa;
  font-size: 0.85rem;
  font-style: italic;
}

/* ============================================================================
   SECCI√ìN CONEXI√ìN MODBUS
   ============================================================================ */

.config-rele-conexion-fila {
  display: flex;
  align-items: flex-end;
  gap: 12px;
}

.config-rele-conexion-grupo {
  display: flex;
  align-items: flex-end;
  gap: 12px;
  background: #1a1f2e;
  padding: 10px 12px;
  border-radius: 6px;
  border: 1px solid #2a3447;
}

.config-rele-conexion-grupo .config-rele-campo-inline {
  flex: 0 0 auto;
  width: 60px;
}

/* Solo el primer grupo tiene IP que necesita ser m√°s ancho */
.config-rele-conexion-grupo:first-child .config-rele-campo-inline:first-child {
  width: 120px;
}

/* ============================================================================
   SECCI√ìN TRANSFORMADORES - COMPACTO
   ============================================================================ */

.config-rele-transformadores-compacto {
  display: flex;
  gap: 12px;
  align-items: flex-end;
  position: relative;
  background: #1a1f2e;
  padding: 10px 12px;
  border-radius: 6px;
  border: 1px solid #2a3447;
}

.config-rele-transformadores-compacto .config-rele-campo-inline {
  flex: 1;
}

.config-rele-btn-ver-transformadores {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 8px 10px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 6px;
  color: #e4e4e7;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
  width: 100%;
}

.config-rele-btn-ver-transformadores:hover {
  border-color: #2563eb;
  color: #93c5fd;
}

.config-rele-dropdown-arrow {
  font-size: 0.7rem;
  color: #71717a;
  transition: transform 0.2s;
}

.config-rele-dropdown-arrow.abierto {
  transform: rotate(180deg);
}

.config-rele-btn-editar-transformador {
  padding: 8px 10px;
  background: #374151;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.2s;
  font-size: 0.85rem;
}

.config-rele-btn-editar-transformador:hover {
  background: #4b5563;
}

/* Dropdown de transformadores */
.config-rele-transformadores-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 4px;
  background: #1e2433;
  border: 1px solid #2a3447;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  min-width: 250px;
  max-height: 300px;
  overflow-y: auto;
  z-index: 100;
}

.config-rele-dropdown-grupo {
  padding: 8px 0;
}

.config-rele-dropdown-grupo:not(:last-child) {
  border-bottom: 1px solid #2a3447;
}

.config-rele-dropdown-titulo {
  padding: 4px 12px;
  font-size: 0.7rem;
  font-weight: 600;
  color: #71717a;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.config-rele-dropdown-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  gap: 12px;
}

.config-rele-dropdown-item:hover {
  background: rgba(37, 99, 235, 0.1);
}

.config-rele-dropdown-nombre {
  color: #e4e4e7;
  font-size: 0.85rem;
}

.config-rele-dropdown-formula {
  color: #71717a;
  font-size: 0.75rem;
  font-family: "Consolas", "Monaco", monospace;
}

.config-rele-dropdown-vacio {
  padding: 16px 12px;
  color: #52525b;
  font-size: 0.85rem;
  text-align: center;
  font-style: italic;
}

/* ============================================================================
   CAMPOS INLINE
   ============================================================================ */

.config-rele-campo-inline {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.config-rele-campo-inline label {
  font-size: 0.75rem;
  color: #e4e4e7;
  white-space: nowrap;
  text-align: center;
}

.config-rele-campo-inline input {
  padding: 8px 4px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 6px;
  color: #e4e4e7;
  font-size: 0.8rem;
  text-align: center;
  width: 100%;
}

.config-rele-conexion-grupo .config-rele-campo-inline:first-child input {
  text-align: left;
  padding: 8px 10px;
}

.config-rele-campo-inline input:focus {
  outline: none;
  border-color: #2563eb;
}

.config-rele-campo-inline input::placeholder {
  color: #52525b;
}

.config-rele-campo-inline input:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Ocultar spinners en inputs number */
.config-rele-campo-inline input[type="number"]::-webkit-outer-spin-button,
.config-rele-campo-inline input[type="number"]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.config-rele-campo-inline input[type="number"] {
  -moz-appearance: textfield;
}

/* ============================================================================
   SECCI√ìN FUNCIONALIDADES
   ============================================================================ */

.config-rele-funcionalidades {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.config-rele-categoria {
  border: 1px solid #2a3447;
  border-radius: 6px;
  overflow: hidden;
  padding-bottom: 12px;
}

.config-rele-categoria-header {
  padding: 10px 14px;
  background: #1a1f2e;
  font-size: 0.85rem;
  color: #a1a1aa;
  font-weight: 500;
}

.config-rele-func-lista {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  padding: 12px 14px 0 14px;
}

.config-rele-func-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 14px;
  border-top: 1px solid #2a3447;
  transition: background 0.2s;
}

.config-rele-func-item:first-child {
  border-top: none;
}

.config-rele-func-item.activo {
  background: rgba(37, 99, 235, 0.1);
}

.config-rele-func-check {
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
}

.config-rele-func-check input[type="checkbox"] {
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: #2563eb;
}

.config-rele-func-nombre {
  color: #ffffff;
  font-size: 0.9rem;
  font-weight: 500;
}

.config-rele-func-registro {
  display: flex;
  align-items: center;
  gap: 8px;
}

.config-rele-func-registro label {
  font-size: 0.8rem;
  color: #71717a;
}

.config-rele-func-registro input {
  width: 70px;
  padding: 6px 8px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 4px;
  color: #e4e4e7;
  font-size: 0.85rem;
  text-align: center;
}

.config-rele-func-registro input:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.config-rele-func-registro input:focus {
  outline: none;
  border-color: #2563eb;
}

/* Ocultar spinners en inputs number */
.config-rele-func-registro input[type="number"]::-webkit-outer-spin-button,
.config-rele-func-registro input[type="number"]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.config-rele-func-registro input[type="number"] {
  -moz-appearance: textfield;
}

/* ============================================================================
   NUEVA ESTRUCTURA: FUNCIONALIDADES COMO CARDS
   ============================================================================ */

.config-rele-func-card {
  background: #1a1f2e;
  border-radius: 8px;
  padding: 12px;
  border: 1px solid #3b4557;
  transition: all 0.2s;
  flex: 0 0 auto;
}

.config-rele-func-card.activo {
  border-color: #2563eb;
  background: rgba(37, 99, 235, 0.08);
}

.config-rele-func-card.inactivo {
  opacity: 0.7;
  border-color: #3b4557;
}

.config-rele-func-header {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
  gap: 12px;
}

/* Contenido de la card: registros + transformador */
.config-rele-func-contenido {
  display: flex;
  align-items: stretch;
  gap: 12px;
  padding: 8px 4px;
}

/* Contenedor de registros */
.config-rele-registros {
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 6px;
  padding: 10px 14px;
  background: #0d1117;
  border-radius: 6px;
  border: 1px solid #2a3447;
}

/* Separador vertical con degradado */
.config-rele-func-separador-vertical {
  width: 1px;
  align-self: stretch;
  background: linear-gradient(
    to bottom,
    transparent 0%,
    #3b4557 20%,
    #4b5567 50%,
    #3b4557 80%,
    transparent 100%
  );
}

/* Contenedor del transformador */
.config-rele-func-transformador {
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 6px;
  padding: 10px 14px;
  background: #0d1117;
  border-radius: 6px;
  border: 1px solid #2a3447;
}

.config-rele-func-transformador-nombre {
  color: #93c5fd;
  font-weight: 500;
  font-size: 0.8rem;
  text-align: center;
}

.config-rele-func-transformador-formula {
  padding: 5px 10px;
  background: #252b3b;
  border: 1px solid #2a3447;
  border-radius: 4px;
  color: #e4e4e7;
  font-size: 0.85rem;
  font-family: "Consolas", "Monaco", monospace;
  pointer-events: none;
  width: auto;
  field-sizing: content;
  text-align: center;
}

.config-rele-registro-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.config-rele-registro-etiqueta {
  font-size: 0.85rem;
  color: #ffffff;
}

.config-rele-registro-input-grupo {
  display: flex;
  align-items: center;
  gap: 8px;
}

.config-rele-registro-separador {
  color: #52525b;
  font-size: 1.2rem;
}

.config-rele-registro-valor {
  width: 80px;
  padding: 6px 10px;
  background: #252b3b;
  border: 1px solid #2a3447;
  border-radius: 4px;
  color: #e4e4e7;
  font-size: 0.85rem;
  text-align: center;
}

.config-rele-registro-valor:focus {
  outline: none;
  border-color: #2563eb;
}

.config-rele-registro-valor:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Ocultar spinners */
.config-rele-registro-valor::-webkit-outer-spin-button,
.config-rele-registro-valor::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.config-rele-registro-valor {
  -moz-appearance: textfield;
}

/* ============================================================================
   TABLA DE FUNCIONALIDADES CON FILAS EXPANDIBLES
   ============================================================================ */

/* ============================================================================
   TABS DE FUNCIONALIDADES
   ============================================================================ */

.config-rele-tabs {
  display: flex;
  gap: 4px;
  margin-bottom: 16px;
  border-bottom: 1px solid #2a3447;
  padding-bottom: 0;
}

.config-rele-tab {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  color: #71717a;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s;
  margin-bottom: -1px;
}

.config-rele-tab:hover {
  color: #a1a1aa;
  background: rgba(255, 255, 255, 0.02);
}

.config-rele-tab.activo {
  color: #e4e4e7;
  border-bottom-color: #2563eb;
  background: rgba(37, 99, 235, 0.08);
}

.config-rele-tab-icono {
  font-size: 1rem;
}

.config-rele-tab-nombre {
  font-weight: 500;
}

.config-rele-tab-contador {
  background: #2a3447;
  color: #71717a;
  font-size: 0.75rem;
  padding: 2px 6px;
  border-radius: 10px;
  min-width: 20px;
  text-align: center;
}

.config-rele-tab.activo .config-rele-tab-contador {
  background: #2563eb;
  color: white;
}

.config-rele-tab-contenido {
  flex: 1;
  min-height: 0;
  overflow-y: auto;
  border: 1px solid #2a3447;
  border-radius: 6px;
  background: #1a1f2e;
  /* Scrollbar personalizado */
  scrollbar-width: thin;
  scrollbar-color: #4b5567 #1a1f2e;
}

.config-rele-tab-contenido::-webkit-scrollbar {
  width: 8px;
}

.config-rele-tab-contenido::-webkit-scrollbar-track {
  background: #1a1f2e;
  border-radius: 4px;
}

.config-rele-tab-contenido::-webkit-scrollbar-thumb {
  background: #4b5567;
  border-radius: 4px;
}

.config-rele-tab-contenido::-webkit-scrollbar-thumb:hover {
  background: #5b6577;
}

.config-rele-tab-vacio {
  text-align: center;
  color: #52525b;
  font-style: italic;
  padding: 40px 20px;
}

.config-rele-tabla-funcionalidades {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.config-rele-tabla-categoria {
  background: #1a1f2e;
  border-radius: 8px;
  border: 1px solid #2a3447;
  overflow: hidden;
}

.config-rele-tabla-categoria-header {
  padding: 10px 14px;
  background: #252b3b;
  border-bottom: 1px solid #2a3447;
  font-size: 0.85rem;
  color: #93c5fd;
  font-weight: 500;
}

.config-rele-tabla {
  width: 100%;
  border-collapse: collapse;
}

.config-rele-tabla thead {
  background: #161b26;
}

.config-rele-tabla th {
  padding: 10px 12px;
  text-align: left;
  font-size: 0.75rem;
  font-weight: 500;
  color: #71717a;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid #2a3447;
}

.config-rele-tabla-th-check {
  width: 40px;
  text-align: center;
}

.config-rele-tabla-th-nombre {
  min-width: 200px;
}

.config-rele-tabla-th-registros {
  min-width: 180px;
}

.config-rele-tabla-th-ti-tv {
  min-width: 140px;
}

/* Filas de la tabla */
.config-rele-tabla-fila {
  border-bottom: 1px solid #2a3447;
  transition: background 0.15s;
}

.config-rele-tabla-fila:last-child {
  border-bottom: none;
}

.config-rele-tabla-fila:hover {
  background: rgba(255, 255, 255, 0.02);
}

.config-rele-tabla-fila.activo {
  background: rgba(37, 99, 235, 0.05);
}

.config-rele-tabla-fila.inactivo {
  opacity: 0.6;
}

.config-rele-tabla-fila.expandida {
  background: rgba(37, 99, 235, 0.08);
}

/* Celdas */
.config-rele-tabla td {
  padding: 10px 12px;
  vertical-align: top;
  font-size: 0.85rem;
  color: #e4e4e7;
}

.config-rele-tabla-td-check {
  text-align: center;
  vertical-align: middle;
}

.config-rele-tabla-td-check input[type="checkbox"] {
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: #2563eb;
}

/* Bot√≥n expandir */
.config-rele-tabla-btn-expandir {
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  color: #e4e4e7;
  font-size: 0.9rem;
  cursor: pointer;
  padding: 0;
  text-align: left;
  width: 100%;
}

.config-rele-tabla-btn-expandir:hover .config-rele-tabla-nombre-texto {
  color: #93c5fd;
}

.config-rele-tabla-chevron {
  font-size: 0.6rem;
  color: #71717a;
  transition: transform 0.2s;
}

.config-rele-tabla-chevron.expandido {
  transform: rotate(90deg);
}

.config-rele-tabla-nombre-texto {
  font-weight: 500;
  transition: color 0.15s;
}

/* Contenido expandido */
.config-rele-tabla-expandido {
  padding: 8px;
  background: #0d1117;
  border-radius: 6px;
  border: 1px solid #2a3447;
}

/* Fila expandida ocupa todo el ancho */
.config-rele-tabla-fila-expandida {
  background: rgba(37, 99, 235, 0.05);
}

.config-rele-tabla-fila-expandida > td {
  padding: 10px 12px;
}

/* Subtabla de registros */
.config-rele-subtabla {
  width: 100%;
  border-collapse: collapse;
}

.config-rele-subtabla th {
  padding: 6px 10px;
  text-align: left;
  font-size: 0.7rem;
  font-weight: 500;
  color: #71717a;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid #2a3447;
  white-space: nowrap;
}

/* Columna Etiqueta: ancho peque√±o */
.config-rele-subtabla th:first-child,
.config-rele-subtabla td:first-child {
  width: 80px;
}

/* Columna Registro: ancho fijo */
.config-rele-subtabla th:nth-child(2),
.config-rele-subtabla td:nth-child(2) {
  width: 80px;
  text-align: center;
}

/* Columna TI/TV/Relaci√≥n: se estira */
.config-rele-subtabla th:last-child,
.config-rele-subtabla td:last-child {
  width: 100%;
}

.config-rele-subtabla td {
  padding: 6px 10px;
  font-size: 0.85rem;
  color: #a1a1aa;
  border-bottom: 1px solid rgba(42, 52, 71, 0.5);
  white-space: nowrap;
}

.config-rele-subtabla tr:last-child td {
  border-bottom: none;
}

.config-rele-subtabla-input {
  width: 80px;
  padding: 5px 8px;
  background: #252b3b;
  border: 1px solid #2a3447;
  border-radius: 4px;
  color: #e4e4e7;
  font-size: 0.85rem;
  text-align: center;
}

.config-rele-subtabla-input:focus {
  outline: none;
  border-color: #2563eb;
}

.config-rele-subtabla-input:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Ocultar spinners */
.config-rele-subtabla-input::-webkit-outer-spin-button,
.config-rele-subtabla-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.config-rele-subtabla-input {
  -moz-appearance: textfield;
}

/* Resumen de registros (colapsado) */
.config-rele-tabla-resumen {
  color: #71717a;
  font-size: 0.8rem;
  font-family: "Consolas", "Monaco", monospace;
}

/* Columna TI/TV */
.config-rele-tabla-transformador {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.config-rele-tabla-ti-tv-nombre {
  color: #93c5fd;
  font-size: 0.8rem;
  font-weight: 500;
}

.config-rele-tabla-ti-tv-formula {
  color: #71717a;
  font-size: 0.75rem;
  font-family: "Consolas", "Monaco", monospace;
}

.config-rele-tabla-sin-ti-tv {
  color: #52525b;
}

/* Transformador en subtabla (por registro) */
.config-rele-subtabla-transformador {
  display: flex;
  align-items: center;
  gap: 8px;
  color: #93c5fd;
  font-size: 0.8rem;
}

.config-rele-subtabla-formula {
  color: #71717a;
  font-size: 0.75rem;
  font-family: "Consolas", "Monaco", monospace;
}

.config-rele-subtabla-sin-ti {
  color: #52525b;
}

/* ============================================================================
   RESPONSIVE
   ============================================================================ */

@media (max-width: 900px) {
  .config-rele-row-superior {
    grid-template-columns: 1fr;
  }

  .config-rele-row-inferior {
    grid-template-columns: 1fr;
  }

  .config-rele-seccion--funcionalidades {
    min-height: 300px;
  }
}

@media (max-width: 600px) {
  .config-rele-conexion-grid {
    grid-template-columns: 1fr 1fr;
  }

  .config-rele-conexion-grid .config-rele-campo-inline:first-child {
    grid-column: 1 / -1;
  }

  .config-rele-registros-row {
    grid-template-columns: 1fr;
  }

  .config-rele-plantilla-row {
    flex-wrap: wrap;
  }

  .config-rele-select {
    width: 100%;
  }

  .config-rele-btn-plantilla {
    flex: 1;
  }

  .config-rele-func-item {
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
  }

  .config-rele-func-registro {
    width: 100%;
    justify-content: flex-end;
  }
}

/* ============================================================================
   INTERPRETACI√ìN DE REGISTROS REF615
   Estilos para mostrar la decodificaci√≥n binaria de registros de estado
   ============================================================================ */

/* Contenedor del registro con interpretaci√≥n */
.config-rele-valores-registro-container {
  margin-bottom: 8px;
}

/* Secci√≥n de interpretaci√≥n debajo del valor */
.config-rele-interpretacion {
  margin-top: 4px;
  margin-left: 8px;
  padding: 6px 10px;
  background: rgba(26, 31, 46, 0.8);
  border-left: 3px solid #4b5567;
  border-radius: 0 4px 4px 0;
}

/* Interpretaci√≥n especial (estado de interruptor, etc.) */
.config-rele-interpretacion-especial {
  font-size: 0.85rem;
  font-weight: 600;
  padding: 4px 8px;
  border-radius: 4px;
  display: inline-block;
}

.config-rele-interpretacion-especial .interpretacion-estado {
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Contenedor de bits activos */
.config-rele-interpretacion-bits {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

/* Badge/chip para cada bit activo */
.config-rele-bit {
  font-size: 0.75rem;
  padding: 3px 8px;
  border-radius: 4px;
  cursor: help;
  transition: transform 0.1s, box-shadow 0.1s;
}

.config-rele-bit:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

/* Sin se√±ales activas */
.config-rele-interpretacion-vacio {
  color: #52525b;
  font-size: 0.8rem;
  font-style: italic;
}

/* ============================================================================
   CLASES DE TIPO PARA BITS E INTERPRETACIONES
   ============================================================================ */

/* Estado OK / Normal */
.interpretacion-ok {
  background: rgba(34, 197, 94, 0.2);
  border-color: #22c55e;
  color: #86efac;
}

.interpretacion-ok .interpretacion-estado {
  color: #22c55e;
}

/* Estado normal (indicador de estado) */
.interpretacion-estado {
  background: rgba(59, 130, 246, 0.15);
  color: #93c5fd;
}

/* Informaci√≥n */
.interpretacion-info {
  background: rgba(59, 130, 246, 0.15);
  color: #93c5fd;
}

/* Advertencia / Warning */
.interpretacion-warning {
  background: rgba(234, 179, 8, 0.2);
  color: #fde68a;
}

.config-rele-interpretacion-especial.interpretacion-warning {
  border: 1px solid #ca8a04;
}

/* Alarma */
.interpretacion-alarma {
  background: rgba(239, 68, 68, 0.2);
  color: #fca5a5;
}

.config-rele-interpretacion-especial.interpretacion-alarma {
  border: 1px solid #dc2626;
}

/* Error */
.interpretacion-error {
  background: rgba(220, 38, 38, 0.25);
  color: #fca5a5;
  border: 1px solid rgba(220, 38, 38, 0.5);
}

.config-rele-interpretacion-especial.interpretacion-error {
  background: rgba(220, 38, 38, 0.3);
  border: 1px solid #dc2626;
  animation: pulse-error 2s infinite;
}

/* Desconocido */
.interpretacion-unknown {
  background: rgba(113, 113, 122, 0.2);
  color: #a1a1aa;
}

/* Animaci√≥n de pulso para errores */
@keyframes pulse-error {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.4);
  }
  50% {
    box-shadow: 0 0 0 4px rgba(220, 38, 38, 0);
  }
}

/* Ajustar borde izquierdo de interpretaci√≥n seg√∫n tipo m√°s grave */
.config-rele-interpretacion:has(.interpretacion-error) {
  border-left-color: #dc2626;
}

.config-rele-interpretacion:has(.interpretacion-alarma):not(:has(.interpretacion-error)) {
  border-left-color: #ef4444;
}

.config-rele-interpretacion:has(.interpretacion-warning):not(:has(.interpretacion-error)):not(:has(.interpretacion-alarma)) {
  border-left-color: #eab308;
}

.config-rele-interpretacion:has(.interpretacion-ok) {
  border-left-color: #22c55e;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ConfiguracionRele.jsx =====

import React, { useState, useEffect, useRef } from "react";
import { usePlantillasRele } from "../../hooks/usePlantillasRele";
import { useTransformadores } from "../../hooks/useTransformadores";
import { solicitarTestRegistrador, consultarTestRegistrador } from "../../../../servicios/apiService";
import {
  interpretarRegistro,
  categoriaRequiereInterpretacion,
  obtenerClaseTipo
} from "../../utilidades/interpreteRegistrosREF615";
import ModalPlantillasRele from "./ModalPlantillasRele";
import ModalTransformadores from "./ModalTransformadores";
import "./ConfiguracionRele.css";

// Categor√≠as disponibles para las funcionalidades
const CATEGORIAS = {
  mediciones: { id: "mediciones", nombre: "Mediciones", icono: "üìä" },
  estados: { id: "estados", nombre: "Estados y Alarmas", icono: "üö¶" },
  sistema: { id: "sistema", nombre: "Sistema", icono: "‚öôÔ∏è" },
};

/**
 * Componente simplificado para configurar un registrador de tipo Rel√© de Protecci√≥n.
 * Basado en plantillas personalizadas que el usuario crea y gestiona.
 *
 * @param {Object} configuracionInicial - Configuraci√≥n inicial del rel√© (para edici√≥n)
 * @param {Function} onChange - Callback al cambiar la configuraci√≥n
 * @param {string} agenteId - ID del agente (para futura integraci√≥n de test)
 */
const ConfiguracionRele = ({ configuracionInicial, onChange, agenteId }) => {
  // Hook de plantillas
  const {
    plantillas,
    cargando: cargandoPlantillas,
    crearPlantilla,
    actualizarPlantilla,
    eliminarPlantilla,
    obtenerPlantilla,
  } = usePlantillasRele();

  // Hook de transformadores
  const {
    transformadores,
    obtenerTIs,
    obtenerTVs,
    obtenerRelaciones,
    obtenerPorId: obtenerTransformadorPorId,
    crearTransformador,
    actualizarTransformador,
    eliminarTransformador,
  } = useTransformadores();

  // Ref para evitar bucle infinito en notificaci√≥n de cambios
  const configAnteriorRef = useRef(null);
  const inicializadoRef = useRef(false);
  const consolaRef = useRef(null);

  // Estado del modal de plantillas
  const [modalPlantillasAbierto, setModalPlantillasAbierto] = useState(false);
  const [plantillaParaEditar, setPlantillaParaEditar] = useState(null);

  // Estado del modal de transformadores
  const [modalTransformadoresAbierto, setModalTransformadoresAbierto] = useState(false);
  const [tipoTransformadorModal, setTipoTransformadorModal] = useState("TI");

  // Estado del dropdown de transformadores
  const [dropdownTransformadoresAbierto, setDropdownTransformadoresAbierto] = useState(false);
  const dropdownTransformadoresRef = useRef(null);

  // Estado para filas expandidas en la tabla de funcionalidades
  const [filasExpandidas, setFilasExpandidas] = useState(new Set());

  // Estado para el tab activo en funcionalidades
  const [tabFuncionalidadesActivo, setTabFuncionalidadesActivo] = useState("mediciones");

  // Estado de la consola de test
  const [consolaLogs, setConsolaLogs] = useState([]);
  const [ejecutandoTest, setEjecutandoTest] = useState(false);
  const [registrosCrudos, setRegistrosCrudos] = useState(null); // Datos del √∫ltimo test exitoso
  const [consolaWidth, setConsolaWidth] = useState(60); // Porcentaje del ancho de la consola
  const resizerRef = useRef(null);
  const containerRef = useRef(null);

  // Estado del formulario
  const [config, setConfig] = useState({
    plantillaId: "",
    conexion: {
      ip: "",
      puerto: 502,
      unitId: 1,
    },
    registroInicial: 120,
    cantidadRegistros: 80,
    intervalo: 60,
    transformadorTIId: "",
    transformadorTVId: "",
    funcionalidadesActivas: {},
  });

  // Cargar configuraci√≥n inicial si existe (solo una vez al montar)
  useEffect(() => {
    if (configuracionInicial && !inicializadoRef.current) {
      inicializadoRef.current = true;
      setConfig((prev) => ({
        ...prev,
        plantillaId: configuracionInicial.plantillaId || "",
        conexion: {
          ip: configuracionInicial.conexion?.ip || "",
          puerto: configuracionInicial.conexion?.puerto || 502,
          unitId: configuracionInicial.conexion?.unitId || 1,
        },
        registroInicial: configuracionInicial.registroInicial || 120,
        cantidadRegistros: configuracionInicial.cantidadRegistros || 80,
        intervalo: configuracionInicial.intervalo || 60,
        transformadorTIId: configuracionInicial.transformadorTIId || "",
        transformadorTVId: configuracionInicial.transformadorTVId || "",
        funcionalidadesActivas:
          configuracionInicial.funcionalidadesActivas || {},
      }));
      configAnteriorRef.current = JSON.stringify(configuracionInicial);
    }
  }, [configuracionInicial]);

  // Notificar cambios al padre
  useEffect(() => {
    if (!onChange) return;

    const configActualStr = JSON.stringify(config);

    if (configAnteriorRef.current !== configActualStr) {
      configAnteriorRef.current = configActualStr;
      onChange(config);
    }
  }, [config, onChange]);

  // Obtener la plantilla seleccionada
  const plantillaSeleccionada = config.plantillaId
    ? obtenerPlantilla(config.plantillaId)
    : null;

  // Generar configuraci√≥n inicial basada en una plantilla
  const generarConfigDesdeePlantilla = (plantilla) => {
    if (!plantilla) return {};

    const funcActivas = {};
    Object.entries(plantilla.funcionalidades || {}).forEach(([funcId, func]) => {
      if (func.habilitado !== false) {
        funcActivas[funcId] = {
          nombre: func.nombre,
          habilitado: true,
          registros: func.registros || [{ etiqueta: "", valor: func.registro || 0 }],
        };
      }
    });

    return funcActivas;
  };

  // Handlers
  const handlePlantillaChange = (e) => {
    const plantillaId = e.target.value;

    if (!plantillaId) {
      setConfig((prev) => ({
        ...prev,
        plantillaId: "",
        funcionalidadesActivas: {},
      }));
      return;
    }

    const plantilla = obtenerPlantilla(plantillaId);
    const funcionalidadesIniciales = generarConfigDesdeePlantilla(plantilla);

    setConfig((prev) => ({
      ...prev,
      plantillaId,
      funcionalidadesActivas: funcionalidadesIniciales,
    }));
  };

  const handleConexionChange = (campo, valor) => {
    setConfig((prev) => ({
      ...prev,
      conexion: {
        ...prev.conexion,
        [campo]: valor,
      },
    }));
  };

  const handleRegistroInicialChange = (valor) => {
    setConfig((prev) => ({
      ...prev,
      registroInicial: valor === "" ? "" : parseInt(valor) || 0,
    }));
  };

  const handleCantidadRegistrosChange = (valor) => {
    setConfig((prev) => ({
      ...prev,
      cantidadRegistros: valor === "" ? "" : parseInt(valor) || 0,
    }));
  };

  const handleIntervaloChange = (valor) => {
    setConfig((prev) => ({
      ...prev,
      intervalo: valor === "" ? "" : parseInt(valor) || 0,
    }));
  };

  const handleTransformadorTIChange = (id) => {
    setConfig((prev) => ({
      ...prev,
      transformadorTIId: id,
    }));
  };

  const handleTransformadorTVChange = (id) => {
    setConfig((prev) => ({
      ...prev,
      transformadorTVId: id,
    }));
  };

  // Abrir modal de transformadores
  const abrirModalTransformadores = (tipo) => {
    setTipoTransformadorModal(tipo);
    setModalTransformadoresAbierto(true);
    setDropdownTransformadoresAbierto(false);
  };

  // Cerrar dropdown al hacer click fuera
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownTransformadoresRef.current && !dropdownTransformadoresRef.current.contains(event.target)) {
        setDropdownTransformadoresAbierto(false);
      }
    };

    if (dropdownTransformadoresAbierto) {
      document.addEventListener("mousedown", handleClickOutside);
    }

    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [dropdownTransformadoresAbierto]);

  // Toggle habilitar/deshabilitar una funcionalidad
  const handleToggleFuncionalidad = (funcId) => {
    setConfig((prev) => {
      const estadoActual = prev.funcionalidadesActivas[funcId];
      const plantillaFunc = plantillaSeleccionada?.funcionalidades?.[funcId];

      if (estadoActual?.habilitado) {
        // Deshabilitar
        const nuevasFunc = { ...prev.funcionalidadesActivas };
        nuevasFunc[funcId] = { ...nuevasFunc[funcId], habilitado: false };
        return { ...prev, funcionalidadesActivas: nuevasFunc };
      } else {
        // Habilitar con registros de la plantilla
        return {
          ...prev,
          funcionalidadesActivas: {
            ...prev.funcionalidadesActivas,
            [funcId]: {
              nombre: plantillaFunc?.nombre || funcId,
              habilitado: true,
              registros: plantillaFunc?.registros || [{ etiqueta: "", valor: 0 }],
            },
          },
        };
      }
    });
  };

  // Cambiar valor de un registro espec√≠fico
  const handleCambiarRegistro = (funcId, regIndex, valor) => {
    setConfig((prev) => ({
      ...prev,
      funcionalidadesActivas: {
        ...prev.funcionalidadesActivas,
        [funcId]: {
          ...prev.funcionalidadesActivas[funcId],
          registros: prev.funcionalidadesActivas[funcId].registros.map((reg, idx) =>
            idx === regIndex
              ? { ...reg, valor: valor === "" ? "" : parseInt(valor) || 0 }
              : reg
          ),
        },
      },
    }));
  };

  // Toggle expandir/colapsar fila en la tabla de funcionalidades
  const toggleFilaExpandida = (funcId) => {
    setFilasExpandidas((prev) => {
      const nuevas = new Set(prev);
      if (nuevas.has(funcId)) {
        nuevas.delete(funcId);
      } else {
        nuevas.add(funcId);
      }
      return nuevas;
    });
  };

  // Handlers para el modal de plantillas
  const abrirModalCrear = () => {
    setPlantillaParaEditar(null);
    setModalPlantillasAbierto(true);
  };

  const abrirModalGestionar = () => {
    setPlantillaParaEditar(null);
    setModalPlantillasAbierto(true);
  };

  const handleCrearPlantilla = (datos) => {
    const nueva = crearPlantilla(datos);
    if (nueva) {
      // Seleccionar la plantilla reci√©n creada usando directamente los datos
      // (no podemos usar handlePlantillaChange porque el estado a√∫n no se actualiz√≥)
      const funcionalidadesIniciales = generarConfigDesdeePlantilla(nueva);
      setConfig((prev) => ({
        ...prev,
        plantillaId: nueva.id,
        funcionalidadesActivas: funcionalidadesIniciales,
      }));
    }
    return nueva;
  };

  const handleActualizarPlantilla = (id, datos) => {
    const exito = actualizarPlantilla(id, datos);
    if (exito && config.plantillaId === id) {
      // Si es la plantilla actualmente seleccionada, actualizar las funcionalidades
      // Construir la plantilla actualizada con los nuevos datos
      const plantillaActualizada = {
        id,
        ...datos,
        funcionalidades: datos.funcionalidades || {},
      };
      const funcionalidadesActualizadas = generarConfigDesdeePlantilla(plantillaActualizada);
      setConfig((prev) => ({
        ...prev,
        funcionalidadesActivas: funcionalidadesActualizadas,
      }));
    }
    return exito;
  };

  // Funciones de la consola
  const agregarLog = (mensaje, tipo = "info") => {
    const timestamp = new Date().toLocaleTimeString();
    setConsolaLogs((prev) => [...prev, { timestamp, mensaje, tipo }]);
    // Auto-scroll al final
    setTimeout(() => {
      if (consolaRef.current) {
        consolaRef.current.scrollTop = consolaRef.current.scrollHeight;
      }
    }, 50);
  };

  const limpiarConsola = () => {
    setConsolaLogs([]);
    setRegistrosCrudos(null);
  };

  // Manejadores del resizer
  const handleMouseDown = (e) => {
    e.preventDefault();
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";
  };

  const handleMouseMove = (e) => {
    if (!containerRef.current) return;
    const container = containerRef.current;
    const containerRect = container.getBoundingClientRect();
    const newWidth = ((e.clientX - containerRect.left) / containerRect.width) * 100;
    // Limitar entre 30% y 80%
    const clampedWidth = Math.min(80, Math.max(30, newWidth));
    setConsolaWidth(clampedWidth);
  };

  const handleMouseUp = () => {
    document.removeEventListener("mousemove", handleMouseMove);
    document.removeEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  };

  // Ejecutar test Modbus real usando el agente
  const ejecutarTest = async () => {
    // Validaciones
    if (!config.conexion.ip) {
      agregarLog("Error: Debes ingresar una IP", "error");
      return;
    }

    if (!agenteId) {
      agregarLog("Error: No hay agente configurado para ejecutar el test", "error");
      agregarLog("El test requiere un agente conectado para comunicarse con el rel√©", "info");
      return;
    }

    setEjecutandoTest(true);
    setRegistrosCrudos(null);
    limpiarConsola();

    const indiceInicial = config.registroInicial || 0;
    const cantidad = config.cantidadRegistros || 20;

    agregarLog(`Iniciando test de conexi√≥n...`, "info");
    agregarLog(`IP: ${config.conexion.ip}:${config.conexion.puerto} (Unit ID: ${config.conexion.unitId})`, "info");
    agregarLog(`Registros: ${indiceInicial} - ${indiceInicial + cantidad - 1} (${cantidad} registros)`, "info");
    agregarLog(`Agente: ${agenteId}`, "info");

    try {
      // Solicitar el test al agente
      agregarLog("Enviando solicitud al agente...", "info");

      const respuesta = await solicitarTestRegistrador(agenteId, {
        ip: config.conexion.ip,
        puerto: parseInt(config.conexion.puerto) || 502,
        unitId: parseInt(config.conexion.unitId) || 1,
        indiceInicial,
        cantidadRegistros: cantidad,
      });

      const testId = respuesta.testId;
      agregarLog(`Solicitud enviada (ID: ${testId})`, "success");
      agregarLog("Esperando respuesta del agente...", "info");

      // Polling para obtener resultado (max 30 segundos)
      const maxIntentos = 15;
      const intervaloMs = 2000;
      let intentos = 0;
      let resultado = null;

      while (intentos < maxIntentos) {
        await new Promise((resolve) => setTimeout(resolve, intervaloMs));
        intentos++;

        resultado = await consultarTestRegistrador(agenteId, testId);

        if (resultado.estado === "completado") {
          // Test exitoso
          const registros = resultado.valores || [];
          const tiempoMs = resultado.tiempo_respuesta_ms || 0;

          agregarLog(`Conexi√≥n exitosa (${tiempoMs}ms)`, "success");
          agregarLog(`Registros le√≠dos: ${registros.length}`, "success");

          // Mostrar TODOS los registros en la consola
          for (let i = 0; i < registros.length; i++) {
            const regNum = indiceInicial + i;
            const valor = registros[i];
            agregarLog(`  [${regNum}] = ${valor}`, "data");
          }

          // Guardar registros crudos para exportaci√≥n CSV
          setRegistrosCrudos({
            valores: registros,
            indiceInicial,
            ip: config.conexion.ip,
            puerto: config.conexion.puerto,
            tiempoMs,
          });

          agregarLog("Test completado exitosamente", "success");
          return;

        } else if (resultado.estado === "error" || resultado.estado === "timeout") {
          // Test fall√≥
          agregarLog(`Error: ${resultado.error_mensaje || "Error de conexi√≥n"}`, "error");
          if (resultado.tiempo_respuesta_ms) {
            agregarLog(`Tiempo transcurrido: ${resultado.tiempo_respuesta_ms}ms`, "info");
          }
          return;
        }

        // Si est√° pendiente/enviado/ejecutando, seguir esperando
        agregarLog(`Esperando... (${intentos}/${maxIntentos})`, "info");
      }

      // Timeout del polling
      agregarLog("Timeout: El agente no respondi√≥ a tiempo", "error");
      agregarLog("Verifica que el agente est√© conectado y el dispositivo sea accesible", "info");

    } catch (error) {
      agregarLog(`Error: ${error.message}`, "error");

      // Mensajes de ayuda seg√∫n el tipo de error
      if (error.message?.includes("esperar")) {
        agregarLog("Debes esperar antes de ejecutar otro test", "info");
      } else if (error.message?.includes("agente")) {
        agregarLog("Verifica que el agente est√© conectado", "info");
      }
    } finally {
      setEjecutandoTest(false);
    }
  };

  // Aplicar f√≥rmula de transformador a un valor
  const aplicarFormulaTransformador = (valor, transformadorId) => {
    if (valor === null || valor === undefined || !transformadorId) {
      return null;
    }

    const transformador = obtenerTransformadorPorId(transformadorId);
    if (!transformador || !transformador.formula) {
      return null;
    }

    try {
      // La f√≥rmula usa 'x' como variable para el valor
      // Ejemplo: "x * 200 / 1000"
      const x = valor;
      // eslint-disable-next-line no-new-func
      const resultado = new Function("x", `return ${transformador.formula}`)(x);
      return typeof resultado === "number" && !isNaN(resultado) ? resultado : null;
    } catch (error) {
      console.error("Error al aplicar f√≥rmula del transformador:", error);
      return null;
    }
  };

  // Exportar registros a CSV
  const exportarCSV = () => {
    if (!registrosCrudos || !registrosCrudos.valores || registrosCrudos.valores.length === 0) {
      agregarLog("No hay registros para exportar. Ejecuta un test primero.", "error");
      return;
    }

    const { valores, indiceInicial, ip, puerto, tiempoMs } = registrosCrudos;
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);

    // Crear contenido CSV con informaci√≥n detallada
    const cabecera = "Registro,Valor";
    const filas = valores.map((valor, idx) => {
      const registro = indiceInicial + idx;
      return `${registro},${valor}`;
    });

    // Agregar metadatos como comentarios al inicio
    const metadatos = [
      `# Test Modbus - RelayWatch`,
      `# Fecha: ${new Date().toLocaleString()}`,
      `# Dispositivo: ${ip}:${puerto}`,
      `# Registros: ${indiceInicial} - ${indiceInicial + valores.length - 1}`,
      `# Tiempo de respuesta: ${tiempoMs}ms`,
      `# Total registros: ${valores.length}`,
      "",
    ];

    const contenidoCSV = [...metadatos, cabecera, ...filas].join("\n");

    // Crear y descargar archivo
    const blob = new Blob([contenidoCSV], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `registros_${ip}_${puerto}_${timestamp}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    agregarLog(`CSV exportado: registros_${ip}_${puerto}_${timestamp}.csv`, "success");
  };

  // Verificar si la plantilla seleccionada a√∫n existe
  const plantillaNoEncontrada = config.plantillaId && !plantillaSeleccionada;

  // Obtener lista de funcionalidades de la plantilla
  const funcionalidadesPlantilla = plantillaSeleccionada
    ? Object.entries(plantillaSeleccionada.funcionalidades || {})
    : [];

  // Contar funcionalidades activas
  const cantidadActivas = Object.values(config.funcionalidadesActivas).filter(
    (f) => f.habilitado
  ).length;

  return (
    <div className="config-rele">
      {/* Fila superior: Conexi√≥n/Transformadores y Plantilla lado a lado */}
      <div className="config-rele-row-superior">
        {/* Columna izquierda: Conexi√≥n + Transformadores */}
        <div className="config-rele-col-izquierda">
          {/* Secci√≥n: Conexi√≥n Modbus TCP */}
          <div className="config-rele-seccion config-rele-seccion--conexion">
          <h6>üì° Conexi√≥n Modbus TCP</h6>
          <div className="config-rele-conexion-fila">
            {/* Grupo 1: Conexi√≥n */}
            <div className="config-rele-conexion-grupo">
              <div className="config-rele-campo-inline">
                <label>IP</label>
                <input
                  type="text"
                  value={config.conexion.ip}
                  onChange={(e) => handleConexionChange("ip", e.target.value)}
                  placeholder="172.16.0.1"
                />
              </div>
              <div className="config-rele-campo-inline">
                <label>Puerto</label>
                <input
                  type="number"
                  value={config.conexion.puerto}
                  onChange={(e) =>
                    handleConexionChange(
                      "puerto",
                      e.target.value === "" ? "" : parseInt(e.target.value)
                    )
                  }
                  placeholder="502"
                />
              </div>
              <div className="config-rele-campo-inline">
                <label>Unit ID</label>
                <input
                  type="number"
                  value={config.conexion.unitId}
                  onChange={(e) =>
                    handleConexionChange(
                      "unitId",
                      e.target.value === "" ? "" : parseInt(e.target.value)
                    )
                  }
                  placeholder="1"
                />
              </div>
            </div>
            {/* Grupo 2: Registros */}
            <div className="config-rele-conexion-grupo">
              <div className="config-rele-campo-inline">
                <label>Inicio</label>
                <input
                  type="number"
                  value={config.registroInicial}
                  onChange={(e) => handleRegistroInicialChange(e.target.value)}
                  placeholder="120"
                  min={0}
                />
              </div>
              <div className="config-rele-campo-inline">
                <label>Cant.</label>
                <input
                  type="number"
                  value={config.cantidadRegistros}
                  onChange={(e) => handleCantidadRegistrosChange(e.target.value)}
                  placeholder="80"
                  min={1}
                />
              </div>
            </div>
            {/* Grupo 3: Intervalo */}
            <div className="config-rele-conexion-grupo">
              <div className="config-rele-campo-inline">
                <label>Intervalo</label>
                <input
                  type="number"
                  value={config.intervalo}
                  onChange={(e) => handleIntervaloChange(e.target.value)}
                  placeholder="60"
                  min={1}
                />
              </div>
            </div>
          </div>
        </div>

        {/* Secci√≥n: Transformadores - Compacto */}
        <div className="config-rele-seccion config-rele-seccion--transformadores">
          <h6>‚ö° Relaciones de transformaci√≥n</h6>
          <div className="config-rele-transformadores-compacto" ref={dropdownTransformadoresRef}>
            <div className="config-rele-campo-inline">
              <label>TI / TV / Relaci√≥n [ x : y ]</label>
              <button
                type="button"
                className="config-rele-btn-ver-transformadores"
                onClick={() => setDropdownTransformadoresAbierto(!dropdownTransformadoresAbierto)}
              >
                <span>Ver disponibles ({obtenerTIs().length + obtenerTVs().length + obtenerRelaciones().length})</span>
                <span className={`config-rele-dropdown-arrow ${dropdownTransformadoresAbierto ? "abierto" : ""}`}>‚ñº</span>
              </button>
            </div>
            <button
              type="button"
              className="config-rele-btn-editar-transformador"
              onClick={() => abrirModalTransformadores("TI")}
              title="Gestionar transformadores"
            >
              ‚öôÔ∏è
            </button>

            {/* Dropdown con lista de transformadores */}
            {dropdownTransformadoresAbierto && (
              <div className="config-rele-transformadores-dropdown">
                {obtenerTIs().length > 0 && (
                  <div className="config-rele-dropdown-grupo">
                    <div className="config-rele-dropdown-titulo">T.I. (Intensidad)</div>
                    {obtenerTIs().map((t) => (
                      <div key={t.id} className="config-rele-dropdown-item">
                        <span className="config-rele-dropdown-nombre">{t.nombre}</span>
                        <span className="config-rele-dropdown-formula">{t.formula}</span>
                      </div>
                    ))}
                  </div>
                )}
                {obtenerTVs().length > 0 && (
                  <div className="config-rele-dropdown-grupo">
                    <div className="config-rele-dropdown-titulo">T.V. (Voltaje)</div>
                    {obtenerTVs().map((t) => (
                      <div key={t.id} className="config-rele-dropdown-item">
                        <span className="config-rele-dropdown-nombre">{t.nombre}</span>
                        <span className="config-rele-dropdown-formula">{t.formula}</span>
                      </div>
                    ))}
                  </div>
                )}
                {obtenerRelaciones().length > 0 && (
                  <div className="config-rele-dropdown-grupo">
                    <div className="config-rele-dropdown-titulo">Relaci√≥n [ x : y ]</div>
                    {obtenerRelaciones().map((t) => (
                      <div key={t.id} className="config-rele-dropdown-item">
                        <span className="config-rele-dropdown-nombre">{t.nombre}</span>
                        <span className="config-rele-dropdown-formula">{t.formula}</span>
                      </div>
                    ))}
                  </div>
                )}
                {obtenerTIs().length === 0 && obtenerTVs().length === 0 && obtenerRelaciones().length === 0 && (
                  <div className="config-rele-dropdown-vacio">
                    No hay transformadores configurados
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
        </div>

        {/* Secci√≥n: Plantilla - Derecha */}
        <div className="config-rele-seccion config-rele-seccion--plantilla">
          <h6>üìã Plantilla de Configuraci√≥n</h6>

          <div className="config-rele-plantilla-row">
            <select
              value={config.plantillaId}
              onChange={handlePlantillaChange}
              className={`config-rele-select ${
                plantillaNoEncontrada ? "config-rele-select--error" : ""
              }`}
            >
              <option value="">Seleccionar plantilla...</option>
              {plantillas.map((p) => (
                <option key={p.id} value={p.id}>
                  {p.nombre}
                </option>
              ))}
            </select>

            <button
              type="button"
              className="config-rele-btn-plantilla"
              onClick={abrirModalCrear}
              title="Nueva plantilla"
            >
              + Nueva
            </button>

            <button
              type="button"
              className="config-rele-btn-plantilla config-rele-btn-plantilla--secundario"
              onClick={abrirModalGestionar}
              title="Gestionar plantillas"
            >
              Gestionar
            </button>
          </div>

          {plantillaNoEncontrada && (
            <div className="config-rele-alerta">
              La plantilla seleccionada ya no existe. Selecciona otra.
            </div>
          )}

          {plantillas.length === 0 && !cargandoPlantillas && (
            <div className="config-rele-mensaje">
              No hay plantillas. Crea una para continuar.
            </div>
          )}

          {plantillaSeleccionada?.descripcion && (
            <div className="config-rele-plantilla-desc">
              {plantillaSeleccionada.descripcion}
            </div>
          )}
        </div>
      </div>

      {/* Fila inferior: Consola (izq) + Funcionalidades (der) lado a lado */}
      <div className="config-rele-row-inferior">
        {/* Secci√≥n: Consola de Test - Izquierda */}
        <div className="config-rele-seccion config-rele-seccion--consola">
          <h6>üñ•Ô∏è Consola de Test</h6>

          <div className="config-rele-consola-container" ref={containerRef}>
            {/* Panel izquierdo: Logs */}
            <div
              ref={consolaRef}
              className="config-rele-consola"
              style={{ width: `${consolaWidth}%` }}
            >
              {consolaLogs.length === 0 ? (
                <div className="config-rele-consola-vacio">
                  Presiona "Ejecutar Test" para probar la conexi√≥n Modbus
                </div>
              ) : (
                consolaLogs.map((log, index) => (
                  <div
                    key={index}
                    className={`config-rele-consola-linea config-rele-consola-linea--${log.tipo}`}
                  >
                    <span className="config-rele-consola-timestamp">[{log.timestamp}]</span>
                    <span className="config-rele-consola-mensaje">{log.mensaje}</span>
                  </div>
                ))
              )}
            </div>

            {/* Resizer */}
            <div
              ref={resizerRef}
              className="config-rele-resizer"
              onMouseDown={handleMouseDown}
            />

            {/* Panel derecho: Funcionalidades con valores */}
            <div
              className="config-rele-registros-panel"
              style={{ width: `${100 - consolaWidth}%` }}
            >
              {!registrosCrudos ? (
                <div className="config-rele-registros-vacio">
                  Los valores aparecer√°n aqu√≠ despu√©s del test
                </div>
              ) : !plantillaSeleccionada ? (
                <div className="config-rele-registros-vacio">
                  Selecciona una plantilla para ver las funcionalidades
                </div>
              ) : (
                <div className="config-rele-funcionalidades-valores">
                  {Object.values(CATEGORIAS).map((categoria) => {
                    // Filtrar funcionalidades activas de esta categor√≠a
                    const funcsActivas = funcionalidadesPlantilla.filter(
                      ([funcId, func]) => {
                        const estadoActivo = config.funcionalidadesActivas[funcId];
                        return (
                          estadoActivo?.habilitado &&
                          (func.categoria || "mediciones") === categoria.id
                        );
                      }
                    );

                    if (funcsActivas.length === 0) return null;

                    // Verificar si esta categor√≠a requiere interpretaci√≥n binaria
                    const requiereInterpretacion = categoriaRequiereInterpretacion(categoria.id);

                    return (
                      <div key={categoria.id} className="config-rele-valores-categoria">
                        <div className="config-rele-valores-categoria-titulo">
                          {categoria.nombre}
                        </div>
                        {funcsActivas.map(([funcId, plantillaFunc]) => {
                          const estadoActivo = config.funcionalidadesActivas[funcId];
                          // Usar registros de la plantilla para tener transformadorId actualizado
                          const registrosPlantilla = plantillaFunc.registros || [];
                          const registrosEstado = estadoActivo?.registros || [];
                          const registros = registrosPlantilla.map((regPlantilla, idx) => {
                            const regEstado = registrosEstado[idx];
                            return {
                              ...regPlantilla,
                              valor: regEstado?.valor ?? regPlantilla.valor,
                              etiqueta: regEstado?.etiqueta ?? regPlantilla.etiqueta,
                              transformadorId: regPlantilla.transformadorId,
                            };
                          });

                          return (
                            <div key={funcId} className="config-rele-valores-func">
                              <div className="config-rele-valores-func-nombre">
                                * {plantillaFunc.nombre}
                              </div>
                              <div className="config-rele-valores-registros">
                                {registros.map((reg, index) => {
                                  // Obtener el valor del registro desde registrosCrudos
                                  const regNum = reg.valor;
                                  const indiceEnArray = regNum - registrosCrudos.indiceInicial;
                                  const valorLeido =
                                    indiceEnArray >= 0 && indiceEnArray < registrosCrudos.valores.length
                                      ? registrosCrudos.valores[indiceEnArray]
                                      : null;

                                  // Aplicar transformador si el registro tiene uno asociado (solo para mediciones)
                                  // Nuevo: cada registro puede tener su propio transformadorId
                                  const transformadorId = reg.transformadorId || null;
                                  const valorTransformado = transformadorId && valorLeido !== null
                                    ? aplicarFormulaTransformador(valorLeido, transformadorId)
                                    : null;
                                  const transformador = transformadorId ? obtenerTransformadorPorId(transformadorId) : null;

                                  // Interpretar el registro si corresponde
                                  // Para el registro 172 (LEDs), usar etiquetas personalizadas de la plantilla si existen
                                  const etiquetasPersonalizadas = regNum === 172 && plantillaSeleccionada?.etiquetasBits
                                    ? plantillaSeleccionada.etiquetasBits
                                    : null;

                                  const interpretacion = requiereInterpretacion && valorLeido !== null
                                    ? interpretarRegistro(regNum, valorLeido, etiquetasPersonalizadas)
                                    : null;

                                  return (
                                    <div key={index} className="config-rele-valores-registro-container">
                                      <div className="config-rele-valores-registro">
                                        {reg.etiqueta || `Reg ${index + 1}`} [{regNum}] = {valorLeido !== null ? valorLeido : "‚Äî"}
                                        {/* Mostrar valor transformado si aplica */}
                                        {valorTransformado !== null && (
                                          <span className="config-rele-valor-transformado" title={`Transformado con ${transformador?.nombre}: ${transformador?.formula}`}>
                                            {" ‚Üí "}{valorTransformado.toFixed(2)}
                                          </span>
                                        )}
                                      </div>
                                      {/* Mostrar interpretaci√≥n si existe */}
                                      {interpretacion && interpretacion.tieneInterpretacion && (
                                        <div className="config-rele-interpretacion">
                                          {/* Interpretaci√≥n especial (como estado de interruptor, heartbeat, etc.) */}
                                          {interpretacion.interpretacionEspecial && (
                                            <div className={`config-rele-interpretacion-especial ${obtenerClaseTipo(interpretacion.interpretacionEspecial.clase)}`}>
                                              {interpretacion.interpretacionEspecial.icono && (
                                                <span className="interpretacion-icono">{interpretacion.interpretacionEspecial.icono}</span>
                                              )}
                                              <span className="interpretacion-estado">{interpretacion.interpretacionEspecial.estado}</span>
                                            </div>
                                          )}
                                          {/* Bits activos - NO mostrar si hay interpretaci√≥n especial con icono (ej: Heartbeat) */}
                                          {interpretacion.bitsActivos.length > 0 && !interpretacion.interpretacionEspecial?.icono && (
                                            <div className="config-rele-interpretacion-bits">
                                              {interpretacion.bitsActivos.map((bit, bitIdx) => (
                                                <span
                                                  key={bitIdx}
                                                  className={`config-rele-bit ${obtenerClaseTipo(bit.tipo)}`}
                                                  title={bit.descripcion}
                                                >
                                                  {bit.nombre}
                                                </span>
                                              ))}
                                            </div>
                                          )}
                                          {/* Sin se√±ales activas - solo si no hay interpretaci√≥n especial */}
                                          {interpretacion.bitsActivos.length === 0 && !interpretacion.interpretacionEspecial && (
                                            <div className="config-rele-interpretacion-vacio">
                                              Sin se√±ales activas
                                            </div>
                                          )}
                                        </div>
                                      )}
                                    </div>
                                  );
                                })}
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          </div>

          <div className="config-rele-consola-acciones">
            <button
              type="button"
              className="config-rele-btn-test"
              onClick={ejecutarTest}
              disabled={ejecutandoTest}
            >
              {ejecutandoTest ? "Ejecutando..." : "Ejecutar Test"}
            </button>
            <button
              type="button"
              className="config-rele-btn-csv"
              onClick={exportarCSV}
              disabled={!registrosCrudos}
              title={registrosCrudos ? `Exportar ${registrosCrudos.valores?.length || 0} registros` : "Ejecuta un test primero"}
            >
              Exportar CSV
            </button>
            <button
              type="button"
              className="config-rele-btn-limpiar"
              onClick={limpiarConsola}
              disabled={consolaLogs.length === 0 && !registrosCrudos}
            >
              Limpiar
            </button>
          </div>
        </div>

        {/* Secci√≥n: Funcionalidades a Monitorear - Tabs */}
        {plantillaSeleccionada && funcionalidadesPlantilla.length > 0 && (
          <div className="config-rele-seccion config-rele-seccion--funcionalidades">
            <h6>
              üîß Funcionalidades a Monitorear
              <span className="config-rele-contador">{cantidadActivas} activas</span>
            </h6>

            {/* Tabs de categor√≠as */}
            <div className="config-rele-tabs">
              {Object.values(CATEGORIAS).map((categoria) => {
                const funcsDeCategoria = funcionalidadesPlantilla.filter(
                  ([, func]) => (func.categoria || "mediciones") === categoria.id
                );
                const cantidadEnCategoria = funcsDeCategoria.length;

                if (cantidadEnCategoria === 0) return null;

                return (
                  <button
                    key={categoria.id}
                    type="button"
                    className={`config-rele-tab ${tabFuncionalidadesActivo === categoria.id ? "activo" : ""}`}
                    onClick={() => setTabFuncionalidadesActivo(categoria.id)}
                  >
                    <span className="config-rele-tab-icono">{categoria.icono}</span>
                    <span className="config-rele-tab-nombre">{categoria.nombre}</span>
                    <span className="config-rele-tab-contador">{cantidadEnCategoria}</span>
                  </button>
                );
              })}
            </div>

            {/* Contenido del tab activo */}
            <div className="config-rele-tab-contenido">
              {(() => {
                const categoriaActiva = CATEGORIAS[tabFuncionalidadesActivo];
                const funcsDeCategoria = funcionalidadesPlantilla.filter(
                  ([, func]) => (func.categoria || "mediciones") === tabFuncionalidadesActivo
                );

                if (funcsDeCategoria.length === 0) {
                  return (
                    <div className="config-rele-tab-vacio">
                      No hay funcionalidades en esta categor√≠a
                    </div>
                  );
                }

                return (
                  <table className="config-rele-tabla">
                    <thead>
                      <tr>
                        <th className="config-rele-tabla-th-check"></th>
                        <th className="config-rele-tabla-th-nombre">Funcionalidad</th>
                        <th className="config-rele-tabla-th-registros">Registros</th>
                        <th className="config-rele-tabla-th-ti-tv">TI / TV</th>
                      </tr>
                    </thead>
                    <tbody>
                      {funcsDeCategoria.map(([funcId, plantillaFunc]) => {
                        const estadoActivo = config.funcionalidadesActivas[funcId];
                        const estaHabilitado = estadoActivo?.habilitado || false;
                        // Usar registros de la plantilla que tienen los transformadorId actualizados
                        // y combinar con estado activo para mantener valores editados
                        const registrosPlantilla = plantillaFunc.registros || [];
                        const registrosEstado = estadoActivo?.registros || [];
                        // Combinar: usar estructura de plantilla pero permitir override del estado
                        const registros = registrosPlantilla.map((regPlantilla, idx) => {
                          const regEstado = registrosEstado[idx];
                          return {
                            ...regPlantilla,
                            // Si hay valor editado en estado, usarlo
                            valor: regEstado?.valor ?? regPlantilla.valor,
                            etiqueta: regEstado?.etiqueta ?? regPlantilla.etiqueta,
                            // El transformadorId siempre viene de la plantilla
                            transformadorId: regPlantilla.transformadorId,
                          };
                        });
                        const estaExpandida = filasExpandidas.has(funcId);

                        // Obtener los transformadores √∫nicos de los registros
                        const transformadoresUnicos = new Map();
                        registros.forEach((reg) => {
                          if (reg.transformadorId) {
                            const t = obtenerTransformadorPorId(reg.transformadorId);
                            if (t) transformadoresUnicos.set(reg.transformadorId, t);
                          }
                        });
                        const cantTransformadores = transformadoresUnicos.size;
                        const primerTransformador = cantTransformadores > 0
                          ? Array.from(transformadoresUnicos.values())[0]
                          : null;

                        // Resumen de registros para mostrar en la fila colapsada
                        const resumenRegistros = registros
                          .map((r) => `${r.etiqueta || "Reg"}: ${r.valor}`)
                          .join(" | ");

                        return (
                          <React.Fragment key={funcId}>
                            <tr
                              className={`config-rele-tabla-fila ${estaHabilitado ? "activo" : "inactivo"} ${estaExpandida ? "expandida" : ""}`}
                            >
                              <td className="config-rele-tabla-td-check">
                                <input
                                  type="checkbox"
                                  checked={estaHabilitado}
                                  onChange={() => handleToggleFuncionalidad(funcId)}
                                />
                              </td>
                              <td className="config-rele-tabla-td-nombre">
                                <button
                                  type="button"
                                  className="config-rele-tabla-btn-expandir"
                                  onClick={() => toggleFilaExpandida(funcId)}
                                >
                                  <span className={`config-rele-tabla-chevron ${estaExpandida ? "expandido" : ""}`}>
                                    ‚ñ∂
                                  </span>
                                  <span className="config-rele-tabla-nombre-texto">
                                    {plantillaFunc.nombre}
                                  </span>
                                </button>
                              </td>
                              <td className="config-rele-tabla-td-registros">
                                {!estaExpandida && (
                                  <span className="config-rele-tabla-resumen">
                                    {resumenRegistros}
                                  </span>
                                )}
                              </td>
                              <td className="config-rele-tabla-td-ti-tv">
                                {cantTransformadores > 1 ? (
                                  <div className="config-rele-tabla-transformador">
                                    <span className="config-rele-tabla-ti-tv-nombre">
                                      {cantTransformadores} diferentes
                                    </span>
                                    <span className="config-rele-tabla-ti-tv-formula">
                                      (ver detalle)
                                    </span>
                                  </div>
                                ) : primerTransformador ? (
                                  <div className="config-rele-tabla-transformador">
                                    <span className="config-rele-tabla-ti-tv-nombre">
                                      {primerTransformador.nombre}
                                    </span>
                                    <span className="config-rele-tabla-ti-tv-formula">
                                      {primerTransformador.formula}
                                    </span>
                                  </div>
                                ) : (
                                  <span className="config-rele-tabla-sin-ti-tv">‚Äî</span>
                                )}
                              </td>
                            </tr>
                            {/* Fila expandida con subtabla - ocupa todo el ancho */}
                            {estaExpandida && (
                              <tr className="config-rele-tabla-fila-expandida">
                                <td colSpan={4}>
                                  <div className="config-rele-tabla-expandido">
                                    <table className="config-rele-subtabla">
                                      <thead>
                                        <tr>
                                          <th>Etiqueta</th>
                                          <th>Registro</th>
                                          <th>TI / TV / Relaci√≥n</th>
                                        </tr>
                                      </thead>
                                      <tbody>
                                        {registros.map((reg, index) => {
                                          const transformadorReg = reg.transformadorId
                                            ? obtenerTransformadorPorId(reg.transformadorId)
                                            : null;
                                          return (
                                            <tr key={index}>
                                              <td>{reg.etiqueta || `Reg ${index + 1}`}</td>
                                              <td>{reg.valor}</td>
                                              <td>
                                                {transformadorReg ? (
                                                  <span className="config-rele-subtabla-transformador">
                                                    {transformadorReg.nombre}
                                                    <span className="config-rele-subtabla-formula">
                                                      {transformadorReg.formula}
                                                    </span>
                                                  </span>
                                                ) : (
                                                  <span className="config-rele-subtabla-sin-ti">‚Äî</span>
                                                )}
                                              </td>
                                            </tr>
                                          );
                                        })}
                                      </tbody>
                                    </table>
                                  </div>
                                </td>
                              </tr>
                            )}
                          </React.Fragment>
                        );
                      })}
                    </tbody>
                  </table>
                );
              })()}
            </div>
          </div>
        )}
      </div>

      {/* Modal de Gesti√≥n de Plantillas */}
      <ModalPlantillasRele
        abierto={modalPlantillasAbierto}
        onCerrar={() => {
          setModalPlantillasAbierto(false);
          setPlantillaParaEditar(null);
        }}
        plantillas={plantillas}
        onCrear={handleCrearPlantilla}
        onActualizar={handleActualizarPlantilla}
        onEliminar={eliminarPlantilla}
        plantillaEditando={plantillaParaEditar}
      />

      {/* Modal de Gesti√≥n de Transformadores */}
      <ModalTransformadores
        abierto={modalTransformadoresAbierto}
        onCerrar={() => setModalTransformadoresAbierto(false)}
        transformadores={transformadores}
        onCrear={crearTransformador}
        onActualizar={actualizarTransformador}
        onEliminar={eliminarTransformador}
        tipoInicial={tipoTransformadorModal}
      />
    </div>
  );
};

export default ConfiguracionRele;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ContenedorVentanasHistorial.jsx =====

/**
 * Contenedor para m√∫ltiples ventanas de historial flotantes
 * Incluye barra de tareas para ventanas minimizadas
 */

import VentanaHistorial from "./VentanaHistorial";
import "./VentanaHistorial.css";

const ContenedorVentanasHistorial = ({
  listaVentanas,
  ventanasMinimizadas,
  cerrarVentana,
  toggleMinimizar,
  toggleMaximizar,
  enfocarVentana,
  moverVentana,
}) => {
  return (
    <>
      {/* Renderizar ventanas abiertas (no minimizadas) */}
      {listaVentanas
        .filter((v) => !v.minimizada)
        .map((ventana) => (
          <VentanaHistorial
            key={ventana.id}
            ventana={ventana}
            onCerrar={() => cerrarVentana(ventana.id)}
            onMinimizar={() => toggleMinimizar(ventana.id)}
            onMaximizar={() => toggleMaximizar(ventana.id)}
            onEnfocar={() => enfocarVentana(ventana.id)}
            onMover={(pos) => moverVentana(ventana.id, pos)}
          />
        ))}

      {/* Barra de tareas para ventanas minimizadas */}
      {ventanasMinimizadas.length > 0 && (
        <div className="ventanas-barra-tareas">
          {ventanasMinimizadas.map((ventana) => (
            <div
              key={ventana.id}
              className="ventana-tarea"
              onClick={() => toggleMinimizar(ventana.id)}
            >
              <span className="ventana-tarea-icono">üìä</span>
              <span className="ventana-tarea-nombre">
                {ventana.alimentador?.nombre}
              </span>
              <button
                type="button"
                className="ventana-tarea-cerrar"
                onClick={(e) => {
                  e.stopPropagation();
                  cerrarVentana(ventana.id);
                }}
              >
                √ó
              </button>
            </div>
          ))}
        </div>
      )}
    </>
  );
};

export default ContenedorVentanasHistorial;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigInforme.css =====

/* Modal de configuraci√≥n de informe */

.modal-config-informe-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  backdrop-filter: blur(2px);
}

.modal-config-informe {
  background: #1e293b;
  border-radius: 12px;
  width: 90%;
  max-width: 500px;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
  border: 1px solid #334155;
  overflow: hidden;
}

.modal-config-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 1.25rem;
  background: #0f172a;
  border-bottom: 1px solid #334155;
}

.modal-config-header h3 {
  margin: 0;
  font-size: 1rem;
  font-weight: 600;
  color: #f1f5f9;
}

.modal-config-cerrar {
  background: none;
  border: none;
  color: #94a3b8;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 0;
  line-height: 1;
  transition: color 0.15s;
}

.modal-config-cerrar:hover {
  color: #f1f5f9;
}

.modal-config-contenido {
  padding: 1.25rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.modal-config-info {
  background: #0f172a;
  padding: 0.75rem 1rem;
  border-radius: 8px;
  border: 1px solid #334155;
}

.modal-config-info p {
  margin: 0;
  padding: 0.25rem 0;
  font-size: 0.85rem;
  color: #cbd5e1;
}

.modal-config-info strong {
  color: #94a3b8;
}

.modal-config-campo {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.modal-config-campo label {
  font-size: 0.85rem;
  font-weight: 500;
  color: #94a3b8;
}

.modal-config-campo input[type="text"] {
  padding: 0.6rem 0.75rem;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 6px;
  color: #f1f5f9;
  font-size: 0.9rem;
  transition: border-color 0.15s, box-shadow 0.15s;
}

.modal-config-campo input[type="text"]:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}

.modal-config-campo input[type="text"]::placeholder {
  color: #64748b;
}

.modal-config-intervalos {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.modal-config-intervalo {
  padding: 0.5rem 0.75rem;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 6px;
  color: #cbd5e1;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s;
}

.modal-config-intervalo:hover:not(:disabled) {
  background: #1e3a5f;
  border-color: #3b82f6;
}

.modal-config-intervalo.seleccionado {
  background: #3b82f6;
  border-color: #3b82f6;
  color: #ffffff;
}

.modal-config-intervalo:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.modal-config-preview {
  text-align: center;
  padding: 0.5rem;
  background: #0f172a;
  border-radius: 6px;
  font-size: 0.85rem;
  color: #94a3b8;
}

.modal-config-preview strong {
  color: #10b981;
}

.modal-config-footer {
  display: flex;
  justify-content: flex-end;
  gap: 0.75rem;
  padding: 1rem 1.25rem;
  background: #0f172a;
  border-top: 1px solid #334155;
}

.modal-config-btn {
  padding: 0.6rem 1.25rem;
  border: none;
  border-radius: 6px;
  font-size: 0.85rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
}

.modal-config-btn.cancelar {
  background: #334155;
  color: #cbd5e1;
}

.modal-config-btn.cancelar:hover {
  background: #475569;
}

.modal-config-btn.generar {
  background: #10b981;
  color: #ffffff;
}

.modal-config-btn.generar:hover:not(:disabled) {
  background: #059669;
}

.modal-config-btn.generar:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigInforme.jsx =====

/**
 * Modal de configuraci√≥n para generar informes Excel
 * Permite configurar: solicitante, intervalo de muestreo
 */

import { useState, useMemo, useEffect } from "react";
import PropTypes from "prop-types";
import { INTERVALOS_INFORME } from "../../constantes/historialConfig";
import { generarImagenGrafico } from "../../utilidades/generarGraficoInforme";
import "./ModalConfigInforme.css";

/**
 * Determina qu√© intervalos est√°n habilitados seg√∫n la duraci√≥n del per√≠odo
 * @param {number} duracionMs - Duraci√≥n en milisegundos
 * @returns {number[]} - Array de IDs de intervalos habilitados
 */
const obtenerIntervalosHabilitados = (duracionMs) => {
  const duracionHoras = duracionMs / (1000 * 60 * 60);

  if (duracionHoras <= 1) {
    // Hasta 1 hora: solo 15 min
    return [15];
  } else if (duracionHoras <= 2) {
    // M√°s de 1h hasta 2h: 15 min o 30 min
    return [15, 30];
  } else if (duracionHoras <= 6) {
    // M√°s de 2h hasta 6h: 15, 30 min o 1 hora
    return [15, 30, 60];
  } else if (duracionHoras <= 12) {
    // M√°s de 6h hasta 12h: 30 min o 1 hora
    return [30, 60];
  } else if (duracionHoras <= 24) {
    // M√°s de 12h hasta 24h: 30 min, 1 hora o 3 horas
    return [30, 60, 180];
  } else if (duracionHoras <= 48) {
    // M√°s de 24h hasta 48h: 3 horas o 6 horas
    return [180, 360];
  } else {
    // M√°s de 48h (7 d√≠as o m√°s): 3, 6 o 12 horas
    return [180, 360, 720];
  }
};

const ModalConfigInforme = ({
  visible,
  onCerrar,
  onGenerar,
  datos,
  nombreAlimentador,
  tituloMedicion,
  tipoGrafico = "line",
}) => {
  const [solicitadoPor, setSolicitadoPor] = useState("");
  const [intervaloSeleccionado, setIntervaloSeleccionado] = useState(null);
  const [generando, setGenerando] = useState(false);

  // Calcular duraci√≥n del per√≠odo de datos
  const { duracionMs, fechaInicio, fechaFin } = useMemo(() => {
    if (!datos || datos.length === 0) {
      return { duracionMs: 0, fechaInicio: null, fechaFin: null };
    }

    const timestamps = datos.map((d) => new Date(d.x).getTime());
    const min = Math.min(...timestamps);
    const max = Math.max(...timestamps);

    return {
      duracionMs: max - min,
      fechaInicio: new Date(min),
      fechaFin: new Date(max),
    };
  }, [datos]);

  // Intervalos habilitados seg√∫n la duraci√≥n
  const intervalosHabilitados = useMemo(() => {
    return obtenerIntervalosHabilitados(duracionMs);
  }, [duracionMs]);

  // Seleccionar autom√°ticamente el primer intervalo habilitado si no hay selecci√≥n v√°lida
  useEffect(() => {
    if (
      intervalosHabilitados.length > 0 &&
      (!intervaloSeleccionado || !intervalosHabilitados.includes(intervaloSeleccionado))
    ) {
      setIntervaloSeleccionado(intervalosHabilitados[0]);
    }
  }, [intervalosHabilitados, intervaloSeleccionado]);

  // Filtrar datos seg√∫n el intervalo seleccionado
  // Optimizado: usa muestreo por salto de √≠ndice para datasets grandes
  const datosFiltrados = useMemo(() => {
    if (!datos || datos.length === 0 || !intervaloSeleccionado) return [];

    const intervaloMs = intervaloSeleccionado * 60 * 1000;

    // Para datasets peque√±os (< 1000 puntos), usar filtrado tradicional
    if (datos.length < 1000) {
      let ultimoTimestamp = 0;
      return datos.filter((punto) => {
        const timestamp = new Date(punto.x).getTime();
        if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs) {
          ultimoTimestamp = timestamp;
          return true;
        }
        return false;
      });
    }

    // Para datasets grandes, calcular paso estimado y usar muestreo por √≠ndice
    // Esto reduce de O(n) a O(n/paso) iteraciones
    const primerTs = new Date(datos[0].x).getTime();
    const ultimoTs = new Date(datos[datos.length - 1].x).getTime();
    const duracionTotal = ultimoTs - primerTs;

    if (duracionTotal <= 0) return [datos[0]];

    // Estimar el intervalo promedio entre puntos
    const intervaloPromedio = duracionTotal / (datos.length - 1);
    // Calcular paso aproximado de √≠ndices
    const pasoEstimado = Math.max(1, Math.floor(intervaloMs / intervaloPromedio));

    const resultado = [];
    let ultimoTimestamp = 0;

    // Iterar con saltos, pero verificar timestamp real para precisi√≥n
    for (let i = 0; i < datos.length; i += pasoEstimado) {
      const punto = datos[i];
      const timestamp = new Date(punto.x).getTime();

      if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs * 0.9) {
        resultado.push(punto);
        ultimoTimestamp = timestamp;
      }
    }

    return resultado;
  }, [datos, intervaloSeleccionado]);

  const handleGenerar = async () => {
    setGenerando(true);

    try {
      // Generar imagen del gr√°fico con los datos filtrados del modal
      const imagenGrafico = await generarImagenGrafico(datosFiltrados, {
        tipo: tipoGrafico,
        titulo: "", // Sin t√≠tulo en el gr√°fico, ya est√° en el Excel
      });

      onGenerar({
        solicitadoPor: solicitadoPor.trim() || "No especificado",
        intervalo: intervaloSeleccionado,
        datosFiltrados,
        fechaInicio,
        fechaFin,
        imagenGrafico,
      });
      onCerrar();
    } catch (err) {
      console.error("Error generando informe:", err);
    } finally {
      setGenerando(false);
    }
  };

  if (!visible) return null;

  const formatearFecha = (fecha) => {
    if (!fecha) return "--";
    return fecha.toLocaleString("es-AR", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  const duracionTexto = () => {
    const horas = Math.floor(duracionMs / (1000 * 60 * 60));
    const minutos = Math.floor((duracionMs % (1000 * 60 * 60)) / (1000 * 60));

    if (horas >= 24) {
      const dias = Math.floor(horas / 24);
      const horasRestantes = horas % 24;
      return `${dias} d√≠a${dias > 1 ? "s" : ""} ${horasRestantes}h`;
    }
    return `${horas}h ${minutos}min`;
  };

  return (
    <div className="modal-config-informe-overlay" onClick={onCerrar}>
      <div className="modal-config-informe" onClick={(e) => e.stopPropagation()}>
        <header className="modal-config-header">
          <h3>Configurar Informe</h3>
          <button type="button" className="modal-config-cerrar" onClick={onCerrar}>
            √ó
          </button>
        </header>

        <div className="modal-config-contenido">
          {/* Info del informe */}
          <div className="modal-config-info">
            <p>
              <strong>Registros para:</strong> {nombreAlimentador}
            </p>
            <p>
              <strong>Medici√≥n:</strong> {tituloMedicion}
            </p>
            <p>
              <strong>Per√≠odo:</strong> {formatearFecha(fechaInicio)} - {formatearFecha(fechaFin)}
            </p>
            <p>
              <strong>Duraci√≥n:</strong> {duracionTexto()}
            </p>
          </div>

          {/* Solicitado por */}
          <div className="modal-config-campo">
            <label htmlFor="solicitadoPor">Solicitado por:</label>
            <input
              type="text"
              id="solicitadoPor"
              value={solicitadoPor}
              onChange={(e) => setSolicitadoPor(e.target.value)}
              placeholder="Nombre del solicitante"
              autoFocus
            />
          </div>

          {/* Intervalo de muestreo */}
          <div className="modal-config-campo">
            <label>Intervalo de muestreo:</label>
            <div className="modal-config-intervalos">
              {INTERVALOS_INFORME.map((intervalo) => {
                const habilitado = intervalosHabilitados.includes(intervalo.id);
                const seleccionado = intervaloSeleccionado === intervalo.id;

                return (
                  <button
                    key={intervalo.id}
                    type="button"
                    className={`modal-config-intervalo ${seleccionado ? "seleccionado" : ""}`}
                    disabled={!habilitado}
                    onClick={() => setIntervaloSeleccionado(intervalo.id)}
                  >
                    {intervalo.label}
                  </button>
                );
              })}
            </div>
          </div>

          {/* Preview de registros */}
          <div className="modal-config-preview">
            <span>
              Registros en el informe: <strong>{datosFiltrados.length}</strong>
            </span>
          </div>
        </div>

        <footer className="modal-config-footer">
          <button type="button" className="modal-config-btn cancelar" onClick={onCerrar}>
            Cancelar
          </button>
          <button
            type="button"
            className="modal-config-btn generar"
            onClick={handleGenerar}
            disabled={datosFiltrados.length === 0 || generando}
          >
            {generando ? "Generando..." : "Generar Informe"}
          </button>
        </footer>
      </div>
    </div>
  );
};

ModalConfigInforme.propTypes = {
  visible: PropTypes.bool.isRequired,
  onCerrar: PropTypes.func.isRequired,
  onGenerar: PropTypes.func.isRequired,
  datos: PropTypes.arrayOf(
    PropTypes.shape({
      x: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.number]),
      y: PropTypes.number,
    })
  ),
  nombreAlimentador: PropTypes.string,
  tituloMedicion: PropTypes.string,
  tipoGrafico: PropTypes.oneOf(["line", "area", "bar"]),
};

ModalConfigInforme.defaultProps = {
  datos: [],
  nombreAlimentador: "Alimentador",
  tituloMedicion: "Medici√≥n",
  tipoGrafico: "line",
};

export default ModalConfigInforme;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionAlimentador.css =====

/* src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionAlimentador.css */
/* Estilo oscuro consistente con ModalEditarPuestos */

/* Overlay oscuro */
.alim-modal-overlay {
   position: fixed;
   top: 0;
   left: 0;
   right: 0;
   bottom: 0;
   background: rgba(0, 0, 0, 0.7);
   display: flex;
   align-items: center;
   justify-content: center;
   z-index: 1000;
}

/* Contenedor principal del modal */
.alim-modal {
   border-radius: 18px;
   padding: 1.0rem 1.3rem;
   box-shadow: 0 18px 45px rgba(15, 23, 42, 0.35);
   max-width: 503px;
   width: 100%;
   box-sizing: border-box;
   background: #28374e;
   color: #e2e8f0;
}

.alim-modal h2 {
   margin: 0 0 0.9rem 0;
   font-size: 1.2rem;
   font-weight: 600;
   color: #e2e8f0;
}

/* Contenido del modal */
.alim-modal-content {
   display: flex;
   flex-direction: column;
   gap: 0.6rem;
}

/* ============================================ */
/* Formulario datos b√°sicos (nombre + color)   */
/* ============================================ */
.alim-form-basicos {
   display: flex;
   flex-direction: column;
   gap: 0.9rem;
}

.alim-modal-label {
   display: flex;
   flex-direction: column;
   gap: 0.4rem;
   font-size: 0.85rem;
   color: #94a3b8;
   font-weight: 500;
}

.alim-modal-label .alim-modal-input {
   padding: 0.6rem 0.9rem;
   border-radius: 8px;
   border: 1px solid #475569;
   background: #1e293b;
   color: #e2e8f0;
   font-size: 0.95rem;
}

.alim-modal-label .alim-modal-input:focus {
   outline: none;
   border-color: #06b6d4;
   box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.3);
}

.alim-modal-label .alim-modal-input::placeholder {
   color: #64748b;
}

/* Grilla de colores */
.alim-color-grid {
   display: flex;
   flex-wrap: wrap;
   gap: 0.4rem;
   align-items: center;
}

.alim-color-swatch {
   width: 1.6rem;
   height: 1.6rem;
   border-radius: 50%;
   border: 2px solid transparent;
   padding: 0;
   cursor: pointer;
   transition: transform 0.15s, border-color 0.15s;
}

.alim-color-swatch:hover {
   transform: scale(1.1);
}

.alim-color-swatch-selected {
   border-color: #ffffff;
   box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
}

/* Picker de color flotante */
.alim-color-picker-popover {
   margin-top: 0.5rem;
}

.alim-color-custom {
   background: conic-gradient(
      from 90deg,
      hsl(0, 100%, 50%),
      hsl(30, 100%, 50%),
      hsl(60, 100%, 50%),
      hsl(90, 100%, 50%),
      hsl(120, 100%, 50%),
      hsl(150, 100%, 50%),
      hsl(180, 100%, 50%),
      hsl(210, 100%, 50%),
      hsl(240, 100%, 50%),
      hsl(270, 100%, 50%),
      hsl(300, 100%, 50%),
      hsl(330, 100%, 50%),
      hsl(360, 100%, 50%)
   );
   position: relative;
   overflow: hidden;
   background-size: 150% 150%;
   background-position: center;
}

.alim-color-custom.alim-color-swatch-selected::after {
   content: '';
   position: absolute;
   top: 50%;
   left: 50%;
   transform: translate(-50%, -50%);
   width: 8px;
   height: 8px;
   border-radius: 50%;
   background: white;
   box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
}

/* Preview del color seleccionado */
.alim-color-preview {
   width: 110px;
   height: 26px;
   border-radius: 6px;
   border: 2px solid #475569;
   margin-left: auto;
   transition: background-color 0.15s ease;
   box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
   display: flex;
   align-items: center;
   justify-content: center;
}

.alim-color-preview-text {
   color: white;
   font-weight: 700;
   font-size: 0.75rem;
   text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
   letter-spacing: 0.5px;
}

/* Fila del alimentador */
.alim-modal-fila {
   display: flex;
   align-items: center;
   flex-wrap: wrap;
   gap: 0.9rem;
   padding: 0.8rem 0.7rem;
   border-radius: 14px;
   background: #0f172a;
   border: 1px solid #334155;
   box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
}

/* Input del nombre */
.alim-modal-input-nombre {
   flex: 1;
   min-width: 140px;
   padding: 0.55rem 0.9rem;
   border-radius: 8px;
   border: 1px solid #475569;
   background: #26354b;
   color: #e2e8f0;
   font-size: 0.9rem;
}

.alim-modal-input-nombre::placeholder {
   color: #64748b;
}

.alim-modal-input-nombre:focus {
   outline: none;
   border-color: #06b6d4;
   box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.3);
   background: #0f172a;
}

/* Contenedor de colores */
.alim-modal-colores {
   display: flex;
   align-items: center;
   gap: 0.5rem;
   flex: 1;
}

.alim-modal-color-label {
   font-size: 0.75rem;
   color: #94a3b8;
}

.alim-modal-color-grid {
   display: flex;
   gap: 0.3rem;
}

.alim-modal-color-swatch {
   width: 1.5rem;
   height: 1.5rem;
   border-radius: 50%;
   border: 2px solid transparent;
   padding: 0;
   cursor: pointer;
   transition: transform 0.15s, border-color 0.15s;
}

.alim-modal-color-swatch:hover {
   transform: scale(1.1);
}

.alim-modal-color-swatch-selected {
   border-color: #ffffff;
   box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
}

/* Bot√≥n de color personalizado (rueda de colores) */
.alim-modal-color-custom-wrapper {
   position: relative;
   margin-left: auto;
}

.alim-modal-color-custom {
   background: conic-gradient(
      from 90deg,
      hsl(0, 100%, 50%),
      hsl(30, 100%, 50%),
      hsl(60, 100%, 50%),
      hsl(90, 100%, 50%),
      hsl(120, 100%, 50%),
      hsl(150, 100%, 50%),
      hsl(180, 100%, 50%),
      hsl(210, 100%, 50%),
      hsl(240, 100%, 50%),
      hsl(270, 100%, 50%),
      hsl(300, 100%, 50%),
      hsl(330, 100%, 50%),
      hsl(360, 100%, 50%)
   );
   position: relative;
   overflow: hidden;
   /* Escalar el gradiente para que el centro no se vea */
   background-size: 150% 150%;
   background-position: center;
}

/* Cuando est√° seleccionado un color personalizado, mostrar un indicador peque√±o */
.alim-modal-color-custom.alim-modal-color-swatch-selected::after {
   content: '';
   position: absolute;
   top: 50%;
   left: 50%;
   transform: translate(-50%, -50%);
   width: 8px;
   height: 8px;
   border-radius: 50%;
   background: white;
   box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
}



/* Bot√≥n Eliminar inline */
.alim-modal-btn-eliminar {
   padding: 0.55rem 0.9rem;
   border-radius: 8px;
   border: 1px solid #fca5a5;
   background-color: #fee2e2;
   color: #b91c1c;
   font-size: 0.8rem;
   font-weight: 700;
   cursor: pointer;
   white-space: nowrap;
}

.alim-modal-btn-eliminar:hover {
   background-color: #fecaca;
}

/* Contenedor de botones de acci√≥n */
.alim-modal-actions {
   display: flex;
   justify-content: space-between;
   align-items: center;
   gap: 0.6rem;
   margin-top: 1.5rem;
   margin-bottom: 0.1rem;
}

/* Contenedor derecho para Cancelar y Guardar */
.alim-modal-actions-right {
   display: flex;
   gap: 0.6rem;
   margin-left: auto;
}

/* Botones base */
.alim-modal-btn {
   min-width: 96px;
   padding: 0.5rem 1.1rem;
   border-radius: 8px;
   border: none;
   font-size: 0.9rem;
   font-weight: 500;
   cursor: pointer;
}

/* Bot√≥n Cancelar */
.alim-modal-btn-cancelar {
   background-color: #334155;
   color: #e2e8f0;
}

.alim-modal-btn-cancelar:hover {
   background-color: #475569;
}

/* Bot√≥n Guardar */
.alim-modal-btn-guardar {
   background-color: #0ea5e9;
   color: #ffffff;
   box-shadow: 0 10px 22px rgba(14, 165, 233, 0.1);
}

.alim-modal-btn-guardar:hover {
   background-color: #0284c7;
}

/* ============================================ */
/* Modal grande (con secciones de configuraci√≥n) */
/* ============================================ */

.alim-modal--grande {
   max-width: 700px;
   max-height: 90vh;
   overflow-y: auto;
}

.alim-modal--grande .alim-modal-content {
   gap: 1rem;
}

/* Secciones del modal */
.alim-modal-seccion {
   background: #0f172a;
   border: 1px solid #334155;
   border-radius: 12px;
   padding: 1rem;
}


.alim-modal-seccion-titulo {
   margin: 0 0 0.75rem 0;
   font-size: 0.95rem;
   font-weight: 600;
   color: #94a3b8;
}

.alim-modal-seccion-ayuda {
   margin: 0 0 1rem 0;
   font-size: 0.8rem;
   color: #64748b;
}

/* Campos gen√©ricos */
.alim-modal-campo {
   display: flex;
   flex-direction: column;
   gap: 0.3rem;
   margin-bottom: 0.75rem;
}

.alim-modal-campo:last-child {
   margin-bottom: 0;
}

.alim-modal-campo label {
   font-size: 0.75rem;
   color: #94a3b8;
   font-weight: 500;
}

.alim-modal-campo--small {
   max-width: 120px;
}

.alim-modal-campo-ayuda {
   font-size: 0.7rem;
   color: #64748b;
}

/* Inputs y selects */
.alim-modal-input,
.alim-modal-select,
.alim-modal-input-numero {
   padding: 0.5rem 0.75rem;
   border-radius: 6px;
   border: 1px solid #475569;
   background: #1e293b;
   color: #e2e8f0;
   font-size: 0.85rem;
}

.alim-modal-input:focus,
.alim-modal-select:focus,
.alim-modal-input-numero:focus {
   outline: none;
   border-color: #06b6d4;
   box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.2);
}

.alim-modal-input::placeholder {
   color: #64748b;
}

.alim-modal-input-numero {
   max-width: 150px;
}

/* Wrapper para intervalo + checkboxes de ocultar */
.alim-modal-intervalo-wrapper {
   display: flex;
   align-items: flex-start;
   gap: 2rem;
}

.alim-modal-intervalo-wrapper > .alim-modal-campo {
   flex: 1;
}

/* Checkboxes para ocultar zonas */
.alim-modal-ocultar-zonas {
   display: flex;
   flex-direction: column;
   gap: 0.5rem;
   padding: 0.5rem 0.75rem;
   background: rgba(255, 255, 255, 0.03);
   border-radius: 8px;
   border: 1px solid #334155;
   align-self: flex-start;
   margin-top: -1.5rem;
}

.alim-modal-ocultar-zonas-titulo {
   font-size: 0.75rem;
   color: #94a3b8;
   font-weight: 500;
   margin-bottom: 0.25rem;
}

.alim-modal-ocultar-zona-item {
   display: flex;
   align-items: center;
   gap: 0.5rem;
   cursor: pointer;
   font-size: 0.8rem;
   color: #e2e8f0;
   padding: 0.25rem 0;
}

.alim-modal-ocultar-zona-item:hover {
   color: #f1f5f9;
}

.alim-modal-ocultar-zona-item input[type="checkbox"] {
   width: 16px;
   height: 16px;
   cursor: pointer;
   accent-color: #fbbf24;
}


/* Estados de carga y avisos */
.alim-modal-cargando {
   color: #94a3b8;
   font-size: 0.85rem;
   font-style: italic;
}

.alim-modal-aviso {
   color: #fbbf24;
   font-size: 0.85rem;
   padding: 0.75rem;
   background: rgba(251, 191, 36, 0.1);
   border-radius: 8px;
   border: 1px solid rgba(251, 191, 36, 0.3);
}

/* ============================================ */
/* Secci√≥n de registrador */
/* ============================================ */

.alim-modal-registrador-detalles {
   background: #1e293b;
   border-radius: 8px;
   padding: 0.75rem;
   margin-bottom: 0.75rem;
}

.alim-modal-registrador-info {
   display: flex;
   flex-wrap: wrap;
   gap: 1rem;
   font-size: 0.8rem;
   color: #94a3b8;
   margin-bottom: 0.75rem;
}

.alim-modal-registrador-info strong {
   color: #e2e8f0;
}

/* √çndices arrastrables */
.alim-modal-indices {
   border-top: 1px solid #334155;
   padding-top: 0.75rem;
}

.alim-modal-indices-label {
   font-size: 0.75rem;
   color: #94a3b8;
   display: block;
   margin-bottom: 0.5rem;
}

.alim-modal-indices-chips {
   display: flex;
   flex-wrap: wrap;
   gap: 0.4rem;
}

.alim-modal-indice-chip {
   display: inline-flex;
   align-items: center;
   justify-content: center;
   min-width: 2.5rem;
   padding: 0.3rem 0.5rem;
   background: #0ea5e9;
   color: white;
   font-size: 0.75rem;
   font-weight: 600;
   border-radius: 4px;
   cursor: grab;
   transition: transform 0.15s, background-color 0.15s;
   user-select: none;
}

.alim-modal-indice-chip:hover {
   background: #0284c7;
   transform: scale(1.05);
}

.alim-modal-indice-chip:active {
   cursor: grabbing;
   transform: scale(0.95);
}

/* ============================================ */
/* Secci√≥n de dise√±o de card */
/* ============================================ */

.alim-modal-card-section {
   background: #1e293b;
   border-radius: 8px;
   padding: 0.5rem 0.75rem;
   margin-bottom: 0.75rem;
}

.alim-modal-card-section:last-child {
   margin-bottom: 0;
}

.alim-modal-card-section--expandido {
   padding: 0.75rem;
}

/* Secci√≥n marcada como oculta */
.alim-modal-card-section--oculto {
   opacity: 0.6;
}

.alim-modal-card-section-header {
   display: flex;
   align-items: center;
   gap: 0.5rem;
   cursor: pointer;
   user-select: none;
   background: transparent;
   border: none;
   padding: 0;
   width: 100%;
   text-align: left;
}

.alim-modal-card-section-header:hover {
   opacity: 0.85;
}

.alim-modal-card-section-arrow {
   font-size: 0.65rem;
   color: #94a3b8;
   transition: transform 0.2s ease;
   flex-shrink: 0;
}

.alim-modal-card-section-arrow--expandido {
   transform: rotate(90deg);
}

.alim-modal-card-section-titulo {
   font-size: 0.85rem;
   font-weight: 600;
   color: #e2e8f0;
}

.alim-modal-card-section-registrador {
   margin-left: auto;
   font-size: 0.75rem;
   font-weight: 400;
   color: #94a3b8;
   background: #334155;
   padding: 0.15rem 0.5rem;
   border-radius: 4px;
}

/* Badge que indica secci√≥n oculta */
.alim-modal-card-section-oculto-badge {
   margin-left: auto;
   font-size: 0.65rem;
   font-weight: 600;
   color: #fbbf24;
   background: rgba(251, 191, 36, 0.15);
   padding: 0.15rem 0.5rem;
   border-radius: 4px;
   letter-spacing: 0.05em;
}

.alim-modal-card-section-content {
   margin-top: 0.75rem;
   padding-top: 0.75rem;
   border-top: 1px solid #334155;
}

.alim-modal-card-section h4 {
   margin: 0 0 0.75rem 0;
   font-size: 0.85rem;
   font-weight: 600;
   color: #e2e8f0;
}

.alim-modal-card-header {
   display: flex;
   align-items: flex-end;
   gap: 0.5rem;
   margin-bottom: 0.75rem;
}

.alim-modal-card-header .alim-modal-campo {
   flex: 1;
   margin-bottom: 0;
}

.alim-modal-card-header .alim-modal-campo--small {
   flex: 0 0 auto;
   width: 90px;
}

/* Boxes de configuraci√≥n */
.alim-modal-boxes {
   display: flex;
   flex-direction: column;
   gap: 0.5rem;
}

.alim-modal-box {
   background: #0f172a;
   border: 1px solid #334155;
   border-radius: 8px;
   padding: 0.5rem 0.6rem;
}

.alim-modal-box-titulo {
   display: block;
   font-size: 0.7rem;
   color: #94a3b8;
   margin-bottom: 0.3rem;
   font-weight: 500;
}

.alim-modal-box-row {
   display: flex;
   align-items: center;
   gap: 0.4rem;
}

.alim-modal-box-check {
   display: flex;
   align-items: center;
   cursor: pointer;
   flex-shrink: 0;
}

.alim-modal-box-check input[type="checkbox"] {
   width: 1rem;
   height: 1rem;
   accent-color: #0ea5e9;
   margin: 0;
}

.alim-modal-box-label {
   width: 110px;
   min-width: 110px;
   flex-shrink: 0;
}

.alim-modal-box-indice-wrapper {
   position: relative;
   display: flex;
   align-items: center;
   flex-shrink: 0;
}

.alim-modal-box-indice {
   width: 70px;
   min-width: 70px;
   flex-shrink: 0;
   text-align: center;
   transition: background-color 0.2s, border-color 0.2s;
   /* Ocultar flechas del input number */
   -moz-appearance: textfield;
}

.alim-modal-box-indice::-webkit-outer-spin-button,
.alim-modal-box-indice::-webkit-inner-spin-button {
   -webkit-appearance: none;
   margin: 0;
}

.alim-modal-box-indice:hover {
   border-color: #0ea5e9;
   background: #0f172a;
}

/* Estilo para √≠ndice duplicado */
.alim-modal-box-indice--duplicado {
   border-color: #f59e0b !important;
   background-color: #422006 !important;
}

.alim-modal-box-indice--duplicado:focus {
   border-color: #d97706 !important;
   box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.3);
}

/* Icono de advertencia */
.alim-modal-box-warning {
   position: relative;
   margin-left: 4px;
   font-size: 0.75rem;
   cursor: help;
   z-index: 10;
}

/* Tooltip de advertencia */
.alim-modal-box-warning-tooltip {
   position: absolute;
   bottom: calc(100% + 8px);
   left: 50%;
   transform: translateX(-50%);
   background-color: #78350f;
   color: #ffffff;
   padding: 0.4rem 0.6rem;
   border-radius: 6px;
   font-size: 0.7rem;
   white-space: nowrap;
   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
   z-index: 200;
   animation: tooltipEntrada 0.15s ease-out;
}

.alim-modal-box-warning-tooltip::after {
   content: "";
   position: absolute;
   top: 100%;
   left: 50%;
   transform: translateX(-50%);
   border: 5px solid transparent;
   border-top-color: #78350f;
}

@keyframes tooltipEntrada {
   from {
      opacity: 0;
      transform: translateX(-50%) translateY(5px);
   }
   to {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
   }
}

.alim-modal-box-formula {
   flex: 1;
   min-width: 85px;
}

/* Responsive */
@media (max-width: 520px) {
   .alim-modal {
      max-width: 100vw;
      margin: 0 0.5rem;
      padding: 1rem 0.9rem;
   }

   .alim-modal-fila {
      flex-direction: column;
      align-items: stretch;
      gap: 0.7rem;
      padding: 0.9rem 1rem;
   }

   .alim-modal-input-nombre {
      width: 100%;
   }

   .alim-modal-colores {
      justify-content: center;
   }

   .alim-modal-btn-eliminar {
      width: 100%;
      text-align: center;
   }

   .alim-modal-actions {
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.8rem;
   }

   .alim-modal-btn {
      min-width: 120px;
   }
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionAlimentador.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionAlimentador.jsx
// Modal unificado para configurar alimentador: nombre, color, registrador y dise√±o de card

import { useEffect, useState, useRef } from "react";
import { HexColorPicker } from "react-colorful";
import "./ModalConfiguracionAlimentador.css";
import "./ColorPickerSimple.css";
import { COLORES_SISTEMA } from "../../constantes/colores";
import {
	listarAgentesWorkspace,
	listarRegistradoresAgente,
} from "../../../../servicios/apiService";

// Opciones predefinidas para el t√≠tulo del bloque (magnitudes t√≠picas)
const OPCIONES_TITULO = [
	{ id: "tension_linea", label: "Tensi√≥n de l√≠nea (kV)" },
	{ id: "tension_entre_lineas", label: "Tensi√≥n entre l√≠neas (kV)" },
	{ id: "corriente_132", label: "Corriente de l√≠nea (A) (en 13,2 kV)" },
	{ id: "corriente_33", label: "Corriente de l√≠nea (A) (en 33 kV)" },
	{ id: "potencia_activa", label: "Potencia activa (kW)" },
	{ id: "potencia_reactiva", label: "Potencia reactiva (kVAr)" },
	{ id: "potencia_aparente", label: "Potencia aparente (kVA)" },
	{ id: "factor_potencia", label: "Factor de Potencia" },
	{ id: "frecuencia", label: "Frecuencia (Hz)" },
	{ id: "corriente_neutro", label: "Corriente de Neutro (A)" },
	{ id: "custom", label: "Otro (personalizado)..." },
];

// Placeholders sugeridos para las etiquetas de cada box
const PLACEHOLDERS_BOX = ["Ej: R o L1", "Ej: S o L2", "Ej: T o L3", "Ej: Total"];

// Dise√±o por defecto para un lado de la card
const crearSideDesignDefault = (tituloId = "corriente_132") => ({
	tituloId,
	tituloCustom: "",
	registrador_id: null, // cada zona tiene su propio registrador
	cantidad: 3,
	oculto: false, // si true, oculta t√≠tulo y boxes de esta zona en la tarjeta
	boxes: [
		{ enabled: false, label: "", indice: null, formula: "" },
		{ enabled: false, label: "", indice: null, formula: "" },
		{ enabled: false, label: "", indice: null, formula: "" },
		{ enabled: false, label: "", indice: null, formula: "" },
	],
});

// Dise√±o por defecto para toda la card
const crearCardDesignDefault = () => ({
	superior: crearSideDesignDefault("corriente_132"),
	inferior: crearSideDesignDefault("tension_linea"),
});

const ModalConfiguracionAlimentador = ({
	abierto,
	puestoNombre,
	workspaceId,
	modo = "crear",
	initialData,
	onCancelar,
	onConfirmar,
	onEliminar,
	// Props de permisos
	esCreador = false,           // si el usuario es creador del workspace
	rolEnWorkspace = null,       // rol del usuario en el workspace (admin, operador, observador)
}) => {
	// Determinar permisos seg√∫n rol
	const esAdmin = esCreador || rolEnWorkspace === 'admin';
	// Admin puede todo, operador y observador solo pueden cambiar el color
	const puedeEditarNombre = esAdmin;
	const puedeEditarDiseno = esAdmin;
	const puedeEliminar = esAdmin;
	const puedeEditarIntervalo = esAdmin;
	const puedeOcultarZonas = esAdmin;
	// === Estado b√°sico ===
	const [nombre, setNombre] = useState("");
	const [color, setColor] = useState(COLORES_SISTEMA[0]);
	const [mostrarPicker, setMostrarPicker] = useState(false);
	const [colorPersonalizado, setColorPersonalizado] = useState("#ff6b6b");
	const [valorHex, setValorHex] = useState("#ff6b6b");
	const pickerRef = useRef(null);
	const pickerBtnRef = useRef(null);

	// === Estado de registrador ===
	const [agentesVinculados, setAgentesVinculados] = useState([]);
	const [registradoresPorAgente, setRegistradoresPorAgente] = useState({});
	const [cargandoAgentes, setCargandoAgentes] = useState(false);

	// === Estado de configuraci√≥n ===
	const [intervaloConsultaSeg, setIntervaloConsultaSeg] = useState(60); // en segundos (default 60, m√≠nimo 5)
	const [cardDesign, setCardDesign] = useState(crearCardDesignDefault());

	// === Helpers ===
	const esColorPersonalizado = !COLORES_SISTEMA.includes(color);

	// === Detecci√≥n de √≠ndices duplicados ===
	const detectarIndicesDuplicados = () => {
		const indicesUsados = [];
		const duplicados = [];

		// Recolectar √≠ndices de parte superior
		const boxesSuperior = cardDesign.superior?.boxes || [];
		boxesSuperior.forEach((box, idx) => {
			if (box.indice !== null && box.indice !== undefined && box.indice !== "") {
				const clave = String(box.indice);
				const info = { zona: "superior", boxNum: idx + 1, indice: box.indice };

				const existente = indicesUsados.find((r) => r.clave === clave);
				if (existente) {
					duplicados.push({ ...info, duplicadoCon: existente.info });
				} else {
					indicesUsados.push({ clave, info });
				}
			}
		});

		// Recolectar √≠ndices de parte inferior
		const boxesInferior = cardDesign.inferior?.boxes || [];
		boxesInferior.forEach((box, idx) => {
			if (box.indice !== null && box.indice !== undefined && box.indice !== "") {
				const clave = String(box.indice);
				const info = { zona: "inferior", boxNum: idx + 1, indice: box.indice };

				const existente = indicesUsados.find((r) => r.clave === clave);
				if (existente) {
					duplicados.push({ ...info, duplicadoCon: existente.info });
				} else {
					indicesUsados.push({ clave, info });
				}
			}
		});

		return duplicados;
	};

	const indicesDuplicados = detectarIndicesDuplicados();

	// Crear set de claves duplicadas
	const clavesDuplicadas = new Set();
	indicesDuplicados.forEach((dup) => {
		clavesDuplicadas.add(`${dup.zona}-${dup.boxNum - 1}-${dup.indice}`);
		clavesDuplicadas.add(`${dup.duplicadoCon.zona}-${dup.duplicadoCon.boxNum - 1}-${dup.duplicadoCon.indice}`);
	});

	// Verificar si un √≠ndice espec√≠fico est√° duplicado
	const estaIndiceDuplicado = (zona, index, indice) => {
		if (indice === null || indice === undefined || indice === "") return false;
		const clave = `${zona}-${index}-${indice}`;
		return clavesDuplicadas.has(clave);
	};

	// Obtener mensaje de duplicado para tooltip
	const obtenerMensajeDuplicado = (zona, index, indice) => {
		if (indice === null || indice === undefined || indice === "") return "";
		const dup = indicesDuplicados.find(
			(d) => d.zona === zona && d.boxNum === index + 1 && d.indice === indice
		);
		if (dup) {
			return `Este √≠ndice ya est√° usado en ${dup.duplicadoCon.zona === "superior" ? "Parte superior" : "Parte inferior"} Box ${dup.duplicadoCon.boxNum}`;
		}
		// Tambi√©n puede ser el √≠ndice original que tiene duplicados
		const original = indicesDuplicados.find(
			(d) => d.duplicadoCon.zona === zona && d.duplicadoCon.boxNum === index + 1 && d.duplicadoCon.indice === indice
		);
		if (original) {
			return `Este √≠ndice tambi√©n se usa en ${original.zona === "superior" ? "Parte superior" : "Parte inferior"} Box ${original.boxNum}`;
		}
		return "";
	};

	// Agrupar todos los registradores para los selects
	const todosRegistradores = [];
	for (const agente of agentesVinculados) {
		const regs = registradoresPorAgente[agente.id] || [];
		for (const reg of regs) {
			todosRegistradores.push({ ...reg, agenteNombre: agente.nombre });
		}
	}

	// Buscar registrador por ID
	const buscarRegistrador = (regId) => {
		if (!regId) return null;
		return todosRegistradores.find((r) => r.id === regId) || null;
	};

	// Generar √≠ndices arrastrables para una zona espec√≠fica
	const obtenerIndicesZona = (zona) => {
		const regId = cardDesign[zona]?.registrador_id;
		const reg = buscarRegistrador(regId);
		if (!reg) return [];
		return Array.from(
			{ length: reg.cantidad_registros },
			(_, i) => reg.indice_inicial + i
		);
	};

	// === Cargar agentes vinculados ===
	useEffect(() => {
		if (!abierto || !workspaceId) return;

		const cargarAgentes = async () => {
			setCargandoAgentes(true);
			try {
				const agentes = await listarAgentesWorkspace(workspaceId);
				setAgentesVinculados(agentes || []);

				// Cargar registradores de cada agente
				const registradoresMap = {};
				for (const agente of agentes || []) {
					try {
						const regs = await listarRegistradoresAgente(agente.id);
						registradoresMap[agente.id] = regs || [];
					} catch (err) {
						console.error(`Error cargando registradores del agente ${agente.id}:`, err);
						registradoresMap[agente.id] = [];
					}
				}
				setRegistradoresPorAgente(registradoresMap);
			} catch (err) {
				console.error("Error cargando agentes:", err);
			} finally {
				setCargandoAgentes(false);
			}
		};

		cargarAgentes();
	}, [abierto, workspaceId]);

	// === Cargar datos iniciales ===
	useEffect(() => {
		if (!abierto) return;

		if (initialData) {
			setNombre(initialData.nombre || "");
			setColor(initialData.color || COLORES_SISTEMA[0]);
			// Convertir ms a segundos para la UI
			const intervaloMs = initialData.intervalo_consulta_ms || 60000;
			setIntervaloConsultaSeg(Math.max(5, Math.round(intervaloMs / 1000)));

			// Cargar card_design con compatibilidad hacia atr√°s
			let design = initialData.card_design || crearCardDesignDefault();

			// Migraci√≥n: si existe registrador_id en ra√≠z (formato antiguo), moverlo a las zonas
			if (initialData.registrador_id && !design.superior?.registrador_id && !design.inferior?.registrador_id) {
				design = {
					...design,
					superior: { ...design.superior, registrador_id: initialData.registrador_id },
					inferior: { ...design.inferior, registrador_id: initialData.registrador_id },
				};
			}

			setCardDesign(design);
		} else {
			setNombre("");
			setColor(COLORES_SISTEMA[0]);
			setIntervaloConsultaSeg(60); // default 60 segundos
			setCardDesign(crearCardDesignDefault());
		}
	}, [abierto, initialData]);

	// === Handlers color ===
	const handleHexInputChange = (e) => {
		const valor = e.target.value;
		setValorHex(valor);
		if (/^#[0-9A-Fa-f]{6}$/.test(valor)) {
			setColor(valor);
			setColorPersonalizado(valor);
		}
	};

	const copiarColor = () => {
		navigator.clipboard.writeText(color);
	};

	// Cerrar picker al hacer click fuera
	useEffect(() => {
		const handleClickOutside = (event) => {
			if (
				pickerRef.current &&
				!pickerRef.current.contains(event.target) &&
				pickerBtnRef.current &&
				!pickerBtnRef.current.contains(event.target)
			) {
				setMostrarPicker(false);
			}
		};

		if (mostrarPicker) {
			document.addEventListener("mousedown", handleClickOutside);
		}
		return () => document.removeEventListener("mousedown", handleClickOutside);
	}, [mostrarPicker]);

	// === Handler registrador por zona ===
	const handleSeleccionarRegistradorZona = (zona, regId) => {
		actualizarSide(zona, "registrador_id", regId || null);
	};

	// === Handlers card design ===
	const actualizarSide = (zona, campo, valor) => {
		setCardDesign((prev) => ({
			...prev,
			[zona]: {
				...prev[zona],
				[campo]: valor,
			},
		}));
	};

	const actualizarBox = (zona, index, campo, valor) => {
		setCardDesign((prev) => {
			const newBoxes = [...prev[zona].boxes];
			newBoxes[index] = { ...newBoxes[index], [campo]: valor };
			return {
				...prev,
				[zona]: {
					...prev[zona],
					boxes: newBoxes,
				},
			};
		});
	};

	// === Drag & Drop ===
	const handleDragStart = (e, indice) => {
		e.dataTransfer.setData("text/plain", String(indice));
		e.dataTransfer.effectAllowed = "copy";
	};

	const handleDragOver = (e) => {
		e.preventDefault();
		e.dataTransfer.dropEffect = "copy";
	};

	const handleDrop = (e, zona, boxIndex) => {
		e.preventDefault();
		const indice = parseInt(e.dataTransfer.getData("text/plain"), 10);
		if (!isNaN(indice)) {
			actualizarBox(zona, boxIndex, "indice", indice);
		}
	};

	// === Submit ===
	const handleSubmit = (e) => {
		e.preventDefault();
		const limpioNombre = nombre.trim();
		if (!limpioNombre) return;

		onConfirmar({
			nombre: limpioNombre,
			color,
			intervalo_consulta_ms: intervaloConsultaSeg * 1000, // convertir a ms para guardar
			card_design: cardDesign, // registrador_id est√° dentro de cada zona (superior/inferior)
		});
	};

	const handleEliminarClick = () => {
		if (!onEliminar) return;
		const seguro = window.confirm("¬øSeguro que quer√©s eliminar este alimentador?");
		if (seguro) {
			onEliminar();
		}
	};

	if (!abierto) return null;

	return (
		<div className="alim-modal-overlay">
			<div className="alim-modal alim-modal--grande">
				<h2>
					{modo === "editar" ? "Editar alimentador" : "Nuevo alimentador"}
					{puestoNombre && `: ${puestoNombre}`}
				</h2>

				<form onSubmit={handleSubmit}>
					<div className="alim-modal-content">
						{/* === SECCI√ìN: Nombre y Color === */}
						<div className="alim-modal-seccion">
							<div className="alim-modal-campo">
								<label>Nombre del Alimentador</label>
								<input
									id="nombre-alimentador"
									type="text"
									className="alim-modal-input"
									value={nombre}
									onChange={(e) => setNombre(e.target.value)}
									placeholder="Ej: ALIMENTADOR 1"
									required
									autoComplete="off"
									autoCorrect="off"
									spellCheck={false}
									autoFocus={puedeEditarNombre}
									disabled={!puedeEditarNombre}
								/>
							</div>

							<div className="alim-color-grid">
								{COLORES_SISTEMA.map((c) => (
									<button
										key={c}
										type="button"
										className={`alim-color-swatch ${
											color === c ? "alim-color-swatch-selected" : ""
										}`}
										style={{ backgroundColor: c }}
										onClick={() => {
											setColor(c);
											setMostrarPicker(false);
										}}
										aria-label={`Elegir color ${c}`}
									/>
								))}
								{/* Bot√≥n color personalizado */}
								<button
									ref={pickerBtnRef}
									type="button"
									className={`alim-color-swatch alim-color-custom ${
										esColorPersonalizado ? "alim-color-swatch-selected" : ""
									}`}
									onClick={() => {
										setMostrarPicker(!mostrarPicker);
										if (!mostrarPicker) {
											setValorHex(color);
										}
									}}
									aria-label="Color personalizado"
								/>
								{/* Preview del color seleccionado */}
								<div
									className="alim-color-preview"
									style={{ backgroundColor: color }}
									title={color}
								>
									<span className="alim-color-preview-text">COLOR</span>
								</div>
							</div>
							{/* Picker flotante */}
							{mostrarPicker && (
								<div
									ref={pickerRef}
									className="color-picker-simple-popover alim-color-picker-popover"
								>
									<HexColorPicker
										color={color}
										onChange={(nuevoColor) => {
											setColor(nuevoColor);
											setColorPersonalizado(nuevoColor);
											setValorHex(nuevoColor);
										}}
									/>
									<div className="color-picker-hex-input-wrapper">
										<input
											type="text"
											value={valorHex}
											onChange={handleHexInputChange}
											className="color-picker-hex-input"
											placeholder="#000000"
											maxLength={7}
										/>
										<button
											type="button"
											className="color-picker-copy-btn"
											onClick={copiarColor}
											title="Copiar color"
										>
											üìã
										</button>
									</div>
								</div>
							)}
						</div>

						{/* === SECCI√ìN: Dise√±o de Card (solo visible para admin/creador) === */}
						{puedeEditarDiseno && (
							<div className="alim-modal-seccion">
								<h3 className="alim-modal-seccion-titulo">Dise√±o de la tarjeta</h3>

								{cargandoAgentes ? (
									<p className="alim-modal-cargando">Cargando registradores...</p>
								) : agentesVinculados.length === 0 ? (
									<p className="alim-modal-aviso">
										No hay agentes vinculados a este workspace. Vincul√° un agente desde el
										panel de configuraci√≥n para poder asignar registradores.
									</p>
								) : (
									<>
										<p className="alim-modal-seccion-ayuda">
											Seleccion√° un registrador para cada zona y arrastr√° los √≠ndices a los campos.
										</p>

										{/* Parte Superior */}
										<SeccionCardDesign
											titulo="Parte superior"
											zona="superior"
											design={cardDesign.superior}
											registradores={todosRegistradores}
											registradorActual={buscarRegistrador(cardDesign.superior?.registrador_id)}
											indicesDisponibles={obtenerIndicesZona("superior")}
											onChangeRegistrador={(regId) => handleSeleccionarRegistradorZona("superior", regId)}
											onChangeTitulo={(val) => actualizarSide("superior", "tituloId", val)}
											onChangeTituloCustom={(val) =>
												actualizarSide("superior", "tituloCustom", val)
											}
											onChangeCantidad={(val) => actualizarSide("superior", "cantidad", val)}
											onChangeBox={(idx, campo, val) => actualizarBox("superior", idx, campo, val)}
											onDragOver={handleDragOver}
											onDrop={(e, idx) => handleDrop(e, "superior", idx)}
											onDragStart={handleDragStart}
											estaIndiceDuplicado={estaIndiceDuplicado}
											obtenerMensajeDuplicado={obtenerMensajeDuplicado}
										/>

										{/* Parte Inferior */}
										<SeccionCardDesign
											titulo="Parte inferior"
											zona="inferior"
											design={cardDesign.inferior}
											registradores={todosRegistradores}
											registradorActual={buscarRegistrador(cardDesign.inferior?.registrador_id)}
											indicesDisponibles={obtenerIndicesZona("inferior")}
											onChangeRegistrador={(regId) => handleSeleccionarRegistradorZona("inferior", regId)}
											onChangeTitulo={(val) => actualizarSide("inferior", "tituloId", val)}
											onChangeTituloCustom={(val) =>
												actualizarSide("inferior", "tituloCustom", val)
											}
											onChangeCantidad={(val) => actualizarSide("inferior", "cantidad", val)}
											onChangeBox={(idx, campo, val) => actualizarBox("inferior", idx, campo, val)}
											onDragOver={handleDragOver}
											onDrop={(e, idx) => handleDrop(e, "inferior", idx)}
											onDragStart={handleDragStart}
											estaIndiceDuplicado={estaIndiceDuplicado}
											obtenerMensajeDuplicado={obtenerMensajeDuplicado}
										/>
									</>
								)}
							</div>
						)}

						{/* === SECCI√ìN: Intervalo de consulta + Ocultar zonas (solo para admin u operador) === */}
						{(puedeEditarIntervalo || puedeOcultarZonas) && (
							<div className="alim-modal-seccion">
								<h3 className="alim-modal-seccion-titulo">Intervalo de consulta</h3>
								<div className="alim-modal-intervalo-wrapper">
									<div className="alim-modal-campo">
										<label>Segundos entre consultas a la Base de Datos</label>
										<input
											type="number"
											className="alim-modal-input-numero"
											value={intervaloConsultaSeg}
											onChange={(e) => {
												const valor = Number(e.target.value);
												setIntervaloConsultaSeg(Math.max(5, valor)); // m√≠nimo 5 segundos
											}}
											min={5}
											step={1}
											disabled={!puedeEditarIntervalo}
										/>
										<span className="alim-modal-campo-ayuda">
											Cada cu√°nto el frontend consulta la √∫ltima lectura (m√≠n. 5s)
										</span>
									</div>

									{/* Checkboxes para ocultar zonas */}
									<div className="alim-modal-ocultar-zonas">
										<span className="alim-modal-ocultar-zonas-titulo">Ocultar en tarjeta</span>
										<label className={`alim-modal-ocultar-zona-item ${!puedeOcultarZonas ? 'alim-modal-ocultar-zona-item--disabled' : ''}`}>
											<input
												type="checkbox"
												checked={cardDesign.superior?.oculto || false}
												onChange={(e) => actualizarSide("superior", "oculto", e.target.checked)}
												disabled={!puedeOcultarZonas}
											/>
											<span>Parte superior</span>
										</label>
										<label className={`alim-modal-ocultar-zona-item ${!puedeOcultarZonas ? 'alim-modal-ocultar-zona-item--disabled' : ''}`}>
											<input
												type="checkbox"
												checked={cardDesign.inferior?.oculto || false}
												onChange={(e) => actualizarSide("inferior", "oculto", e.target.checked)}
												disabled={!puedeOcultarZonas}
											/>
											<span>Parte inferior</span>
										</label>
									</div>
								</div>
							</div>
						)}
					</div>

					{/* Botones inferiores */}
					<div className="alim-modal-actions">
						{/* Bot√≥n eliminar a la izquierda (solo en modo edici√≥n y si tiene permisos) */}
						{modo === "editar" && puedeEliminar && (
							<button
								type="button"
								className="alim-modal-btn-eliminar"
								onClick={handleEliminarClick}
							>
								Eliminar
							</button>
						)}

						<div className="alim-modal-actions-right">
							<button
								type="button"
								className="alim-modal-btn alim-modal-btn-cancelar"
								onClick={onCancelar}
							>
								Cancelar
							</button>

							<button type="submit" className="alim-modal-btn alim-modal-btn-guardar">
								Guardar
							</button>
						</div>
					</div>
				</form>
			</div>
		</div>
	);
};

// === Subcomponente: Secci√≥n de dise√±o de card (superior/inferior) ===
const SeccionCardDesign = ({
	titulo,
	zona,
	design,
	registradores,
	registradorActual,
	indicesDisponibles,
	onChangeRegistrador,
	onChangeTitulo,
	onChangeTituloCustom,
	onChangeCantidad,
	onChangeBox,
	onDragOver,
	onDrop,
	onDragStart,
	estaIndiceDuplicado,
	obtenerMensajeDuplicado,
}) => {
	const [expandido, setExpandido] = useState(false);
	const [tooltipIdx, setTooltipIdx] = useState(null); // √≠ndice del box que muestra tooltip
	const cant = design.cantidad || 3;
	const estaOculto = design.oculto || false;

	return (
		<div className={`alim-modal-card-section ${expandido ? "alim-modal-card-section--expandido" : ""} ${estaOculto ? "alim-modal-card-section--oculto" : ""}`}>
			<button
				type="button"
				className="alim-modal-card-section-header"
				onClick={() => setExpandido(!expandido)}
			>
				<span className={`alim-modal-card-section-arrow ${expandido ? "alim-modal-card-section-arrow--expandido" : ""}`}>
					‚ñ∂
				</span>
				<span className="alim-modal-card-section-titulo">{titulo}</span>
				{registradorActual && !estaOculto && (
					<span className="alim-modal-card-section-registrador">
						{registradorActual.nombre}
					</span>
				)}
				{estaOculto && (
					<span className="alim-modal-card-section-oculto-badge">
						OCULTO
					</span>
				)}
			</button>

			{expandido && (
				<div className="alim-modal-card-section-content">
					{/* Selector de registrador para esta zona */}
					<div className="alim-modal-campo">
						<label>Registrador</label>
						<select
							className="alim-modal-select"
							value={design.registrador_id || ""}
							onChange={(e) => onChangeRegistrador(e.target.value)}
						>
							<option value="">-- Sin registrador --</option>
							{registradores.map((reg) => (
								<option key={reg.id} value={reg.id}>
									{reg.nombre} ({reg.agenteNombre}) - {reg.ip}:{reg.puerto} | Reg:{" "}
									{reg.indice_inicial}-{reg.indice_inicial + reg.cantidad_registros - 1}
								</option>
							))}
						</select>
					</div>

					{/* √çndices arrastrables del registrador seleccionado */}
					{registradorActual && indicesDisponibles.length > 0 && (
						<div className="alim-modal-indices">
							<span className="alim-modal-indices-label">
								√çndices arrastrables:
							</span>
							<div className="alim-modal-indices-chips">
								{indicesDisponibles.map((indice) => (
									<span
										key={indice}
										className="alim-modal-indice-chip"
										draggable
										onDragStart={(e) => onDragStart(e, indice)}
									>
										{indice}
									</span>
								))}
							</div>
						</div>
					)}

					<div className="alim-modal-card-header">
						<div className="alim-modal-campo">
							<label>T√≠tulo</label>
							<select
								className="alim-modal-select"
								value={design.tituloId || "corriente_132"}
								onChange={(e) => onChangeTitulo(e.target.value)}
							>
								{OPCIONES_TITULO.map((op) => (
									<option key={op.id} value={op.id}>
										{op.label}
									</option>
								))}
							</select>
						</div>

						{design.tituloId === "custom" && (
							<div className="alim-modal-campo">
								<label>T√≠tulo personalizado</label>
								<input
									type="text"
									className="alim-modal-input"
									placeholder="Ej: CONSUMO (A)"
									value={design.tituloCustom || ""}
									onChange={(e) => onChangeTituloCustom(e.target.value)}
								/>
							</div>
						)}

						<div className="alim-modal-campo alim-modal-campo--small">
							<label>Cantidad boxes</label>
							<select
								className="alim-modal-select"
								value={cant}
								onChange={(e) => onChangeCantidad(Number(e.target.value))}
							>
								{[1, 2, 3, 4].map((n) => (
									<option key={n} value={n}>
										{n}
									</option>
								))}
							</select>
						</div>
					</div>

					<div className="alim-modal-boxes">
						{Array.from({ length: cant }).map((_, idx) => {
							const box = design.boxes[idx] || {};
							return (
								<div key={`${zona}-box-${idx}`} className="alim-modal-box">
									<span className="alim-modal-box-titulo">Box {idx + 1}</span>
									<div className="alim-modal-box-row">
										<label className="alim-modal-box-check">
											<input
												type="checkbox"
												checked={!!box.enabled}
												onChange={(e) => onChangeBox(idx, "enabled", e.target.checked)}
											/>
										</label>

										<input
											type="text"
											className="alim-modal-input alim-modal-box-label"
											placeholder={PLACEHOLDERS_BOX[idx] || `Ej: R o L1`}
											value={box.label || ""}
											onChange={(e) => onChangeBox(idx, "label", e.target.value)}
										/>

										<div className="alim-modal-box-indice-wrapper">
										<input
											type="number"
											className={`alim-modal-input alim-modal-box-indice ${estaIndiceDuplicado(zona, idx, box.indice) ? "alim-modal-box-indice--duplicado" : ""}`}
											placeholder="√çndice"
											value={box.indice ?? ""}
											onChange={(e) =>
												onChangeBox(idx, "indice", e.target.value ? Number(e.target.value) : null)
											}
											onDragOver={onDragOver}
											onDrop={(e) => onDrop(e, idx)}
										/>
										{estaIndiceDuplicado(zona, idx, box.indice) && (
											<span
												className="alim-modal-box-warning"
												onMouseEnter={() => setTooltipIdx(idx)}
												onMouseLeave={() => setTooltipIdx(null)}
											>
												‚ö†Ô∏è
												{tooltipIdx === idx && (
													<div className="alim-modal-box-warning-tooltip">
														{obtenerMensajeDuplicado(zona, idx, box.indice)}
													</div>
												)}
											</span>
										)}
									</div>

										<input
											type="text"
											className="alim-modal-input alim-modal-box-formula"
											placeholder="F√≥rmula (ej: x*250/1000)"
											value={box.formula || ""}
											onChange={(e) => onChangeBox(idx, "formula", e.target.value)}
										/>
									</div>
								</div>
							);
						})}
					</div>
				</div>
			)}
		</div>
	);
};

export default ModalConfiguracionAlimentador;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionPuesto.css =====

/* ModalConfiguracionPuesto.css */

/* ===== OVERLAY ===== */
.puesto-modal-overlay {
	position: fixed;
	inset: 0;
	background: rgba(0, 0, 0, 0.6);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 1000;
	padding: 1rem;
	pointer-events: none;
}

/* ===== MODAL CONTAINER ===== */
.puesto-modal {
	background: #1e293b;
	border-radius: 12px;
	min-width: 550px;
	max-width: 95vw;
	max-height: 90vh;
	display: flex;
	flex-direction: column;
	box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
	overflow: hidden;
	pointer-events: auto;
	transition: box-shadow 0.2s;
}

.puesto-modal--arrastrando {
	box-shadow: 0 35px 60px -15px rgba(0, 0, 0, 0.7);
	user-select: none;
}

/* ===== HEADER ===== */
.puesto-modal__header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 1rem 1.5rem;
	background: #0f172a;
	border-bottom: 1px solid #334155;
}

.puesto-modal__title {
	margin: 0;
	font-size: 1.1rem;
	font-weight: 600;
	color: #f1f5f9;
}

.puesto-modal__close {
	background: none;
	border: none;
	color: #94a3b8;
	font-size: 1.5rem;
	cursor: pointer;
	padding: 0.25rem 0.5rem;
	line-height: 1;
	transition: color 0.2s;
}

.puesto-modal__close:hover {
	color: #f1f5f9;
}

/* Header Actions Container */
.puesto-modal__header-actions {
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

/* ===== CONTENT ===== */
.puesto-modal__content {
	flex: 1;
	overflow: auto;
	padding: 1rem;
}

.puesto-modal__empty {
	text-align: center;
	color: #94a3b8;
	padding: 2rem;
	font-size: 0.95rem;
}

/* ===== CARDS CONTAINER ===== */
.puesto-cards {
	display: flex;
	flex-direction: column;
	gap: 0.75rem;
}

/* ===== CARD ===== */
.puesto-card {
	background: #0f172a;
	border: 1px solid #475569;
	border-left: 4px solid #475569;
	border-bottom: 2px solid #475569;
	border-radius: 8px;
	overflow: hidden;
}

/* Card Header */
.puesto-card__header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.5rem 1rem;
	background: #0f172a;
}

.puesto-card__header-right {
	display: flex;
	align-items: center;
	gap: 0.5rem;
}

.puesto-card__periodo-badge {
	background: #334155;
	color: #94a3b8;
	padding: 0.25rem 0.5rem;
	border-radius: 4px;
	font-size: 0.75rem;
	font-weight: 600;
	min-width: 40px;
	text-align: center;
}

/* Master Play/Stop Button (Global - Header) */
.puesto-card__master-btn {
	padding: 0.5rem 0.75rem;
	background: #1e3a5f;
	border: 1px solid #3b82f6;
	border-radius: 4px;
	color: #60a5fa;
	font-size: 1rem;
	cursor: pointer;
	transition: background 0.2s, transform 0.1s, border-color 0.2s;
	line-height: 1;
}

.puesto-card__master-btn:hover {
	background: #2563eb;
	color: #fff;
}

.puesto-card__master-btn:active {
	transform: scale(0.95);
}

.puesto-card__master-btn--stop {
	background: #5f1e1e;
	border-color: #ef4444;
	color: #f87171;
}

.puesto-card__master-btn--stop:hover {
	background: #dc2626;
	color: #fff;
}

.puesto-card__master-btn--disabled {
	background: #374151;
	border-color: #4b5563;
	color: #ef4444;
	cursor: not-allowed;
	opacity: 0.7;
}

/* Master Text Button (Card - INICIAR/PARAR) */
.puesto-card__master-btn-text {
	padding: 0.25rem 0.6rem;
	background: #1e3a5f;
	border: 1px solid #3b82f6;
	border-radius: 4px;
	color: #60a5fa;
	font-size: 0.65rem;
	font-weight: 600;
	letter-spacing: 0.5px;
	cursor: pointer;
	transition: background 0.2s, transform 0.1s, border-color 0.2s;
	line-height: 1;
}

.puesto-card__master-btn-text:hover {
	background: #2563eb;
	color: #fff;
}

.puesto-card__master-btn-text:active {
	transform: scale(0.95);
}

.puesto-card__master-btn-text--stop {
	background: #5f1e1e;
	border-color: #ef4444;
	color: #f87171;
}

.puesto-card__master-btn-text--stop:hover {
	background: #dc2626;
	color: #fff;
}

.puesto-card__master-btn-text--disabled {
	background: #374151;
	border-color: #4b5563;
	color: #6b7280;
	cursor: not-allowed;
	opacity: 0.7;
}

.puesto-card__master-btn-text--disabled:hover {
	background: #374151;
	color: #6b7280;
}

.puesto-card__master-btn--disabled:hover {
	background: #374151;
	color: #ef4444;
}

.puesto-card__nombre {
	font-weight: 600;
	font-size: 0.9rem;
	color: #f1f5f9;
}

/* Card Body */
.puesto-card__body {
	padding: 0.6rem 0.8rem;
	display: flex;
	flex-direction: column;
	gap: 0.5rem;
	background-color: #1e293b;
}

/* Zonas container - Superior e Inferior lado a lado */
.puesto-card__zonas {
	display: flex;
	gap: 0.75rem;
}

/* Cada zona */
.puesto-card__zona {
	flex: 1;
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 0.4rem;
}

/* Nombre del registrador */
.puesto-card__registrador {
	background: #334155;
	color: #e2e8f0;
	padding: 0.4rem 0.6rem;
	border-radius: 4px;
	font-size: 0.75rem;
	text-align: center;
	width: 100%;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	border: 1px solid #475569;
}

/* Row (Superior / Inferior) */
.puesto-card__row {
	display: flex;
	align-items: center;
	gap: 0.5rem;
}

.puesto-card__field--tipo {
	flex: 0 0 85px;
	display: flex;
	align-items: center;
}

/* Badges para tipo Superior/Inferior */
.puesto-card__tipo-badge {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	width: 85px;
	height: 30px;
	border-radius: 4px;
	font-size: 0.7rem;
	font-weight: 600;
	text-align: center;
	text-transform: uppercase;
	letter-spacing: 0.5px;
	box-sizing: border-box;
}

.puesto-card__tipo-badge--superior {
	background: #1e3a5f;
	color: #60a5fa;
	border: 1px solid #3b82f6;
}

.puesto-card__tipo-badge--inferior {
	background: #3d1e5f;
	color: #c084fc;
	border: 1px solid #8b5cf6;
}

/* Input readonly */
.puesto-card__input--readonly {
	background: #334155 !important;
	color: #94a3b8 !important;
	cursor: default;
	border-color: #475569 !important;
}

/* Fields container */
.puesto-card__fields {
	display: flex;
	align-items: center;
	gap: 0.5rem;
	flex: 1;
}

/* Field */
.puesto-card__field {
	display: flex;
	flex-direction: column;
	gap: 0.15rem;
}

.puesto-card__field--registrador {
	flex: 1;
	min-width: 200px;
}

.puesto-card__field--periodo {
	flex: 0 0 85px;
}

.puesto-card__field label {
	font-size: 0.65rem;
	color: #e2e8f0;
	font-weight: 600;
	text-transform: uppercase;
	letter-spacing: 0.5px;
	text-align: center;
}

.puesto-card__field input {
	width: 100%;
	height: 30px;
	padding: 0 0.5rem;
	background: #1e293b;
	border: 1px solid #475569;
	border-radius: 4px;
	color: #f1f5f9;
	font-size: 0.8rem;
	text-align: center;
	transition: border-color 0.2s, box-shadow 0.2s;
	box-sizing: border-box;
}

/* Input de registrador: texto alineado a la izquierda con ellipsis */
.puesto-card__field--registrador input {
	text-align: left;
	text-overflow: ellipsis;
	overflow: hidden;
	white-space: nowrap;
}

.puesto-card__field input:focus {
	outline: none;
	border-color: #3b82f6;
	box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}

.puesto-card__field input::placeholder {
	color: #475569;
}

/* Remove spinner from number inputs */
.puesto-card__field input[type="number"]::-webkit-outer-spin-button,
.puesto-card__field input[type="number"]::-webkit-inner-spin-button {
	-webkit-appearance: none;
	margin: 0;
}

.puesto-card__field input[type="number"] {
	-moz-appearance: textfield;
}

/* ===== PLAY/STOP BUTTON ===== */
.puesto-card__play-btn {
	width: 28px;
	height: 28px;
	padding: 0;
	background: #1e3a5f;
	border: 1px solid #3b82f6;
	border-radius: 4px;
	color: #60a5fa;
	font-size: 0.75rem;
	cursor: pointer;
	transition: background 0.2s, transform 0.1s, border-color 0.2s;
	display: flex;
	align-items: center;
	justify-content: center;
	flex-shrink: 0;
}

.puesto-card__play-btn:hover {
	background: #2563eb;
	color: #fff;
}

.puesto-card__play-btn:active {
	transform: scale(0.95);
}

.puesto-card__play-btn--stop {
	background: #5f1e1e;
	border-color: #ef4444;
	color: #f87171;
}

.puesto-card__play-btn--stop:hover {
	background: #dc2626;
	color: #fff;
}

.puesto-card__play-btn--disabled {
	background: #374151;
	border-color: #4b5563;
	color: #ef4444;
	cursor: not-allowed;
	opacity: 0.7;
}

.puesto-card__play-btn--disabled:hover {
	background: #374151;
	color: #ef4444;
}

/* ===== FOOTER ===== */
.puesto-modal__footer {
	display: flex;
	justify-content: flex-end;
	gap: 0.75rem;
	padding: 1rem 1.5rem;
	background: #0f172a;
	border-top: 1px solid #334155;
}

.puesto-modal__btn {
	padding: 0.6rem 1.25rem;
	border: none;
	border-radius: 6px;
	font-size: 0.9rem;
	font-weight: 500;
	cursor: pointer;
	transition: background 0.2s, transform 0.1s;
}

.puesto-modal__btn:active {
	transform: scale(0.98);
}

.puesto-modal__btn--cancelar,
.puesto-modal__btn--cerrar {
	background: #475569;
	color: #f1f5f9;
}

.puesto-modal__btn--cancelar:hover,
.puesto-modal__btn--cerrar:hover {
	background: #64748b;
}

.puesto-modal__btn--descartar {
	background: #dc2626;
	color: #fff;
}

.puesto-modal__btn--descartar:hover {
	background: #b91c1c;
}

.puesto-modal__btn--disabled {
	opacity: 0.5;
	cursor: not-allowed;
}

.puesto-modal__btn--disabled:hover {
	background: #dc2626;
}

/* ===== CONFIRMATION DIALOG ===== */
.puesto-confirmacion-overlay {
	position: fixed;
	inset: 0;
	background: rgba(0, 0, 0, 0.75);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 1100;
}

.puesto-confirmacion {
	background: #1e293b;
	border-radius: 12px;
	padding: 1.5rem;
	max-width: 400px;
	width: 90%;
	text-align: center;
	box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
	border: 1px solid #334155;
}

.puesto-confirmacion__icono {
	font-size: 2.5rem;
	margin-bottom: 0.75rem;
}

.puesto-confirmacion__titulo {
	margin: 0 0 0.5rem 0;
	font-size: 1.1rem;
	font-weight: 600;
	color: #f1f5f9;
}

.puesto-confirmacion__mensaje {
	margin: 0 0 1.25rem 0;
	font-size: 0.9rem;
	color: #94a3b8;
	line-height: 1.5;
}

.puesto-confirmacion__botones {
	display: flex;
	justify-content: center;
	gap: 0.75rem;
}

.puesto-confirmacion__btn {
	padding: 0.6rem 1.25rem;
	border: none;
	border-radius: 6px;
	font-size: 0.9rem;
	font-weight: 500;
	cursor: pointer;
	transition: background 0.2s, transform 0.1s;
}

.puesto-confirmacion__btn:active {
	transform: scale(0.98);
}

.puesto-confirmacion__btn--cancelar {
	background: #475569;
	color: #f1f5f9;
}

.puesto-confirmacion__btn--cancelar:hover {
	background: #64748b;
}

.puesto-confirmacion__btn--aceptar {
	background: #dc2626;
	color: #fff;
}

.puesto-confirmacion__btn--aceptar:hover {
	background: #b91c1c;
}

/* ===== RESPONSIVE M√ìVIL ===== */
@media (max-width: 600px) {
	/* Modal a pantalla completa */
	.puesto-modal-overlay {
		padding: 0;
	}

	.puesto-modal {
		min-width: 100%;
		max-width: 100%;
		height: 100vh;
		height: 100dvh;
		max-height: 100vh;
		max-height: 100dvh;
		border-radius: 0;
		display: flex;
		flex-direction: column;
	}

	/* Header compacto */
	.puesto-modal__header {
		padding: 0.75rem 1rem;
		flex-shrink: 0;
	}

	.puesto-modal__title {
		font-size: 0.95rem;
	}

	/* Contenido scrolleable */
	.puesto-modal__content {
		flex: 1;
		padding: 0.75rem;
		overflow-y: auto;
		-webkit-overflow-scrolling: touch;
	}

	/* Cards m√°s compactas */
	.puesto-cards {
		gap: 0.75rem;
	}

	.puesto-card {
		border-radius: 10px;
	}

	.puesto-card__header {
		padding: 0.6rem 0.75rem;
	}

	.puesto-card__nombre {
		font-size: 0.9rem;
		font-weight: 600;
	}

	.puesto-card__body {
		padding: 0.5rem 0.6rem 0.75rem;
	}

	/* Zonas lado a lado en m√≥vil */
	.puesto-card__zonas {
		gap: 0.5rem;
	}

	.puesto-card__zona {
		gap: 0.3rem;
	}

	.puesto-card__tipo-badge {
		width: 100%;
		height: 24px;
		font-size: 0.6rem;
	}

	.puesto-card__registrador {
		font-size: 0.7rem;
		padding: 0.35rem 0.4rem;
	}

	/* Footer fijo abajo */
	.puesto-modal__footer {
		padding: 0.75rem 1rem;
		flex-shrink: 0;
		justify-content: center;
	}

	.puesto-modal__btn {
		padding: 0.6rem 1.5rem;
		font-size: 0.85rem;
		flex: 1;
		max-width: 200px;
	}

	/* Botones play/stop */
	.puesto-card__play-btn {
		width: 30px;
		height: 30px;
		font-size: 0.8rem;
	}

	.puesto-card__periodo-badge {
		font-size: 0.7rem;
		padding: 0.2rem 0.4rem;
		min-width: 35px;
	}

	.puesto-card__master-btn {
		padding: 0.5rem 0.7rem;
		font-size: 0.95rem;
	}
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionPuesto.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionPuesto.jsx

import React, { useEffect, useState, useRef } from "react";
import "./ModalConfiguracionPuesto.css";

/**
 * Modal de vista r√°pida del puesto.
 * Muestra el estado de cada alimentador con sus registradores asignados (solo lectura).
 * Permite controlar el polling de cada card y de todo el puesto.
 */
const ModalConfiguracionPuesto = ({
	abierto,
	puesto,
	onCerrar,
	// Polling
	estaPolling,              // (alimId) => boolean
	onPlayStopClick,          // (alimId) => void - alterna polling de un alimentador
	// Para obtener nombres de registradores
	buscarRegistrador,        // (regId) => registrador | null
}) => {
	// Estado para arrastrar el modal
	const [posicion, setPosicion] = useState({ x: 0, y: 0 });
	const [arrastrando, setArrastrando] = useState(false);
	const offsetRef = useRef({ x: 0, y: 0 });
	const modalRef = useRef(null);

	// Resetear posici√≥n al abrir el modal
	useEffect(() => {
		if (abierto) {
			setPosicion({ x: 0, y: 0 });
		}
	}, [abierto]);

	// Manejadores de arrastre
	const handleMouseDown = (e) => {
		if (e.target.closest('.puesto-modal__close') || e.target.closest('input') || e.target.closest('button')) {
			return;
		}
		setArrastrando(true);
		offsetRef.current = {
			x: e.clientX - posicion.x,
			y: e.clientY - posicion.y,
		};
	};

	const handleMouseMove = (e) => {
		if (!arrastrando) return;
		setPosicion({
			x: e.clientX - offsetRef.current.x,
			y: e.clientY - offsetRef.current.y,
		});
	};

	const handleMouseUp = () => {
		setArrastrando(false);
	};

	useEffect(() => {
		if (arrastrando) {
			window.addEventListener('mousemove', handleMouseMove);
			window.addEventListener('mouseup', handleMouseUp);
		}
		return () => {
			window.removeEventListener('mousemove', handleMouseMove);
			window.removeEventListener('mouseup', handleMouseUp);
		};
	}, [arrastrando]);

	// Helper para obtener registrador_id de una zona (con compatibilidad legacy)
	const obtenerRegistradorIdZona = (alim, zona) => {
		// Primero intentar obtener de card_design
		const regIdZona = alim.card_design?.[zona]?.registrador_id;
		if (regIdZona) return regIdZona;

		// Fallback: usar registrador_id de la ra√≠z (formato legacy)
		return alim.registrador_id || null;
	};

	if (!abierto || !puesto) return null;

	const alimentadores = puesto.alimentadores || [];

	// Helper para verificar si un alimentador puede hacer polling
	const puedeHacerPolling = (alim) => {
		if (!alim.intervalo_consulta_ms || alim.intervalo_consulta_ms <= 0) return false;

		const cardDesign = alim.card_design || {};
		const superior = cardDesign.superior || {};
		const inferior = cardDesign.inferior || {};

		const tieneRegistrador = !!superior.registrador_id || !!inferior.registrador_id || !!alim.registrador_id;
		if (!tieneRegistrador) return false;

		// Verificar que al menos un box est√© habilitado con √≠ndice v√°lido
		const boxesSuperior = superior.boxes || [];
		const boxesInferior = inferior.boxes || [];
		const todosLosBoxes = [...boxesSuperior, ...boxesInferior];

		const tieneBoxHabilitado = todosLosBoxes.some(
			(box) => box.enabled && box.indice !== null && box.indice !== undefined && box.indice !== ""
		);

		return tieneBoxHabilitado;
	};

	// Obtener nombre del registrador para mostrar
	const obtenerInfoRegistrador = (alim, zona) => {
		const regId = obtenerRegistradorIdZona(alim, zona);
		if (!regId || !buscarRegistrador) return "Sin asignar";
		const reg = buscarRegistrador(regId);
		if (!reg) return "Sin asignar";

		// Solo mostrar el nombre del registrador
		return reg.nombre;
	};

	// ===== BOT√ìN MAESTRO GLOBAL =====
	const alimentadoresConPolling = alimentadores.filter(puedeHacerPolling);
	const hayAlgunoPolling = alimentadoresConPolling.some((alim) => estaPolling?.(alim.id));
	const hayAlgunaCardDisponible = alimentadoresConPolling.length > 0;

	const handleMaestroGlobal = () => {
		if (!hayAlgunaCardDisponible) return;

		if (hayAlgunoPolling) {
			// Detener todos los que est√°n en polling
			alimentadoresConPolling.forEach((alim) => {
				if (estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		} else {
			// Iniciar todos los disponibles
			alimentadoresConPolling.forEach((alim) => {
				if (!estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		}
	};

	return (
		<div className="puesto-modal-overlay">
			<div
				ref={modalRef}
				className={`puesto-modal ${arrastrando ? 'puesto-modal--arrastrando' : ''}`}
				style={{
					transform: `translate(${posicion.x}px, ${posicion.y}px)`,
				}}
				onClick={(e) => e.stopPropagation()}
			>
				{/* Header */}
				<div
					className="puesto-modal__header"
					onMouseDown={handleMouseDown}
					style={{ cursor: 'move' }}
				>
					<h2 className="puesto-modal__title">
						Configuraci√≥n del Puesto: {puesto?.nombre || ""}
					</h2>
					<div className="puesto-modal__header-actions">
						{/* Bot√≥n maestro global */}
						<button
							type="button"
							className={`puesto-card__master-btn ${hayAlgunoPolling ? "puesto-card__master-btn--stop" : ""} ${!hayAlgunaCardDisponible ? "puesto-card__master-btn--disabled" : ""}`}
							onClick={handleMaestroGlobal}
							disabled={!hayAlgunaCardDisponible}
							title={!hayAlgunaCardDisponible ? "Sin alimentadores con configuraci√≥n v√°lida" : hayAlgunoPolling ? "Detener todas las lecturas" : "Iniciar todas las lecturas"}
						>
							{!hayAlgunaCardDisponible ? "‚äò" : hayAlgunoPolling ? "‚èπ" : "‚ñ∂"}
						</button>
						<button
							type="button"
							className="puesto-modal__close"
							onClick={onCerrar}
							aria-label="Cerrar"
						>
							√ó
						</button>
					</div>
				</div>

				{/* Contenido */}
				<div
					className="puesto-modal__content"
					style={{ backgroundColor: puesto?.bgColor || "#1e293b" }}
				>
					{alimentadores.length === 0 ? (
						<p className="puesto-modal__empty">
							No hay alimentadores en este puesto.
						</p>
					) : (
						<div className="puesto-cards">
							{alimentadores.map((alim) => {
								const periodoSeg = alim.intervalo_consulta_ms
									? Math.round(alim.intervalo_consulta_ms / 1000)
									: null;
								const puedePolling = puedeHacerPolling(alim);
								const polling = estaPolling?.(alim.id);

								return (
									<div
										key={alim.id}
										className="puesto-card"
										style={{
											borderLeftColor: alim.color || "#22c55e",
											borderBottomColor: alim.color || "#22c55e",
										}}
									>
										{/* Header de la card: Nombre + Play + Per√≠odo */}
										<div className="puesto-card__header">
											<span className="puesto-card__nombre">{alim.nombre}</span>
											<div className="puesto-card__header-right">
												<button
													type="button"
													className={`puesto-card__play-btn ${polling ? "puesto-card__play-btn--stop" : ""} ${!puedePolling ? "puesto-card__play-btn--disabled" : ""}`}
													onClick={() => puedePolling && onPlayStopClick?.(alim.id)}
													disabled={!puedePolling}
													title={!puedePolling ? "Configuraci√≥n incompleta" : polling ? "Detener lectura" : "Iniciar lectura"}
												>
													{!puedePolling ? "‚äò" : polling ? "‚èπ" : "‚ñ∂"}
												</button>
												<span className="puesto-card__periodo-badge">
													{periodoSeg ? `${periodoSeg}s` : "-"}
												</span>
											</div>
										</div>

										{/* Contenido: Superior e Inferior lado a lado */}
										<div className="puesto-card__body">
											<div className="puesto-card__zonas">
												{/* Zona Superior */}
												<div className="puesto-card__zona">
													<span className="puesto-card__tipo-badge puesto-card__tipo-badge--superior">
														Superior
													</span>
													<span className="puesto-card__registrador" title={obtenerInfoRegistrador(alim, "superior")}>
														{obtenerInfoRegistrador(alim, "superior")}
													</span>
												</div>

												{/* Zona Inferior */}
												<div className="puesto-card__zona">
													<span className="puesto-card__tipo-badge puesto-card__tipo-badge--inferior">
														Inferior
													</span>
													<span className="puesto-card__registrador" title={obtenerInfoRegistrador(alim, "inferior")}>
														{obtenerInfoRegistrador(alim, "inferior")}
													</span>
												</div>
											</div>
										</div>
									</div>
								);
							})}
						</div>
					)}
				</div>

				{/* Footer */}
				<div className="puesto-modal__footer">
					<button
						type="button"
						className="puesto-modal__btn puesto-modal__btn--cerrar"
						onClick={onCerrar}
					>
						Cerrar
					</button>
				</div>
			</div>
		</div>
	);
};

export default ModalConfiguracionPuesto;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigurarAgente.css =====

/* src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigurarAgente.css */
/* Estilos para la ventana flotante de configuraci√≥n de agentes */

/* ============================================ */
/* Variables CSS para el tema                  */
/* ============================================ */
:root {
  --ca-bg-primary: #1e293b;
  --ca-bg-secondary: #334155;
  --ca-bg-tertiary: #475569;
  --ca-bg-dark: #0f172a;
  --ca-border-color: #475569;
  --ca-border-light: rgba(255, 255, 255, 0.05);
  --ca-text-primary: #e2e8f0;
  --ca-text-secondary: #94a3b8;
  --ca-text-muted: #64748b;
  --ca-accent-blue: #0ea5e9;
  --ca-accent-green: #22c55e;
  --ca-accent-yellow: #fbbf24;
  --ca-accent-red: #ef4444;
  --ca-shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.4);
  --ca-transition-fast: 0.15s ease;
  --ca-border-radius: 8px;
}

/* ============================================ */
/* Ventana Flotante (reemplaza overlay+modal)  */
/* ============================================ */
.config-agente-ventana {
  background: var(--ca-bg-dark);
  border-radius: var(--ca-border-radius);
  box-shadow: var(--ca-shadow-lg), 0 0 0 1px var(--ca-border-light);
  display: flex;
  flex-direction: column;
  min-width: 600px;
  min-height: 400px;
  overflow: hidden;
  color: var(--ca-text-primary);
  animation: config-agente-aparecer 0.2s ease-out;
}

.config-agente-ventana--maximizada {
  border-radius: 0;
}

.config-agente-ventana--arrastrando {
  opacity: 0.9;
  cursor: grabbing;
}

.config-agente-ventana--redimensionando {
  user-select: none;
}

@keyframes config-agente-aparecer {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* ============================================ */
/* Header arrastrable                          */
/* ============================================ */
.config-agente-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.5rem 0.75rem;
  background: linear-gradient(180deg, var(--ca-bg-secondary) 0%, var(--ca-bg-primary) 100%);
  border-bottom: 1px solid var(--ca-border-color);
  cursor: grab;
  user-select: none;
  flex-shrink: 0;
}

.config-agente-ventana--arrastrando .config-agente-header {
  cursor: grabbing;
}

.config-agente-titulo {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.config-agente-icono {
  font-size: 1rem;
}

.config-agente-header h2 {
  margin: 0;
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--ca-text-primary);
}

/* ============================================ */
/* Controles de Ventana (min/max/cerrar)       */
/* ============================================ */
.config-agente-controles-ventana {
  display: flex;
  gap: 0.25rem;
}

.config-agente-btn-ventana {
  width: 24px;
  height: 24px;
  border: none;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 1rem;
  line-height: 1;
  transition: all var(--ca-transition-fast);
}

.config-agente-btn-ventana--minimizar {
  background: var(--ca-bg-tertiary);
  color: var(--ca-text-primary);
}

.config-agente-btn-ventana--minimizar:hover {
  background: var(--ca-accent-yellow);
  color: var(--ca-bg-dark);
}

.config-agente-btn-ventana--maximizar {
  background: var(--ca-bg-tertiary);
  color: var(--ca-text-primary);
}

.config-agente-btn-ventana--maximizar:hover {
  background: var(--ca-accent-green);
  color: var(--ca-bg-dark);
}

.config-agente-btn-ventana--cerrar {
  background: var(--ca-bg-tertiary);
  color: var(--ca-text-primary);
}

.config-agente-btn-ventana--cerrar:hover {
  background: var(--ca-accent-red);
  color: #ffffff;
}

/* ============================================ */
/* Handle de Resize                            */
/* ============================================ */
.config-agente-resize-handle {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 20px;
  height: 20px;
  cursor: nwse-resize;
  background: linear-gradient(
    135deg,
    transparent 0%,
    transparent 50%,
    var(--ca-bg-tertiary) 50%,
    var(--ca-bg-tertiary) 100%
  );
  border-bottom-right-radius: var(--ca-border-radius);
  opacity: 0.6;
  transition: opacity var(--ca-transition-fast);
}

.config-agente-resize-handle:hover {
  opacity: 1;
}

.config-agente-resize-handle::before {
  content: '';
  position: absolute;
  bottom: 4px;
  right: 4px;
  width: 8px;
  height: 8px;
  border-right: 2px solid var(--ca-text-secondary);
  border-bottom: 2px solid var(--ca-text-secondary);
}

/* Bot√≥n cerrar antiguo (para compatibilidad) */
.config-agente-cerrar {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  border: none;
  color: #64748b;
  font-size: 1.5rem;
  cursor: pointer;
  border-radius: 6px;
  transition: background 0.15s, color 0.15s;
}

.config-agente-cerrar:hover {
  background: #1e293b;
  color: #e2e8f0;
}

/* ============================================ */
/* Pesta√±as (Tabs)                             */
/* ============================================ */
.config-agente-tabs {
  display: flex;
  background: #1e293b;
  border-bottom: 1px solid #334155;
  flex-shrink: 0;
}

.config-agente-tab {
  flex: 1;
  padding: 0.85rem 1rem;
  background: transparent;
  border: none;
  color: #94a3b8;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
  border-bottom: 2px solid transparent;
}

.config-agente-tab:hover {
  background: #334155;
  color: #e2e8f0;
}

.config-agente-tab--activa {
  color: #0ea5e9;
  border-bottom-color: #0ea5e9;
  background: #0f172a;
}

.config-agente-tab--activa:hover {
  background: #0f172a;
}

/* ============================================ */
/* Contenido Principal                         */
/* ============================================ */
.config-agente-contenido {
  flex: 1;
  overflow-y: auto;
  padding: 1.25rem 1.5rem;
}

.config-agente-seccion {
  min-height: 300px;
}

/* ============================================ */
/* Estado de Carga                             */
/* ============================================ */
.config-agente-cargando {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.75rem;
  padding: 3rem;
  color: #94a3b8;
}

.config-agente-spinner {
  width: 20px;
  height: 20px;
  border: 2px solid #334155;
  border-top-color: #0ea5e9;
  border-radius: 50%;
  animation: config-agente-spin 0.8s linear infinite;
}

@keyframes config-agente-spin {
  to { transform: rotate(360deg); }
}

.config-agente-spinner-mini {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid #334155;
  border-top-color: #0ea5e9;
  border-radius: 50%;
  animation: config-agente-spin 0.8s linear infinite;
}

/* ============================================ */
/* Alertas (Error y √âxito)                     */
/* ============================================ */
.config-agente-alerta {
  padding: 1rem;
  border-radius: 8px;
  margin-bottom: 1rem;
  animation: config-agente-aparecer 0.2s ease-out;
}

.config-agente-alerta--error {
  background: #7f1d1d;
  border: 1px solid #ef4444;
  color: #fca5a5;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.config-agente-alerta--error button {
  background: transparent;
  border: none;
  color: #fca5a5;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 0 0.5rem;
}

.config-agente-alerta--exito {
  background: #14532d;
  border: 1px solid #22c55e;
  color: #86efac;
}

.config-agente-alerta-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.5rem;
}

.config-agente-alerta-header button {
  background: transparent;
  border: none;
  color: #86efac;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 0;
}

.config-agente-alerta p {
  margin: 0 0 0.75rem 0;
  font-size: 0.85rem;
}

.config-agente-clave-box {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  background: #1e293b;
  border-radius: 6px;
  padding: 0.75rem;
}

.config-agente-clave-box code {
  flex: 1;
  font-family: monospace;
  font-size: 0.85rem;
  color: #f1f5f9;
  word-break: break-all;
}

.config-agente-clave-box button {
  padding: 0.4rem 0.8rem;
  background: #334155;
  color: #e2e8f0;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: background 0.15s;
}

.config-agente-clave-box button:hover {
  background: #475569;
}

/* ============================================ */
/* Estado Vac√≠o                                */
/* ============================================ */
.config-agente-vacio {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 280px;
  padding: 2rem;
  text-align: center;
  color: #64748b;
}

.config-agente-vacio-icono {
  font-size: 3rem;
  margin-bottom: 1rem;
  opacity: 0.6;
}

.config-agente-vacio p {
  margin: 0 0 1rem 0;
  font-size: 1rem;
  color: #94a3b8;
}

.config-agente-hint {
  font-size: 0.85rem !important;
  color: #64748b !important;
}

.config-agente-instruccion {
  color: #94a3b8;
  font-size: 0.9rem;
  margin: 0 0 1.25rem 0;
  text-align: center;
}

/* ============================================ */
/* Lista de Agentes                            */
/* ============================================ */
.config-agente-lista {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

/* ============================================ */
/* Card de Agente                              */
/* ============================================ */
.config-agente-card {
  background: #1e293b;
  border-radius: 10px;
  padding: 1rem 1.25rem;
  border: 1px solid #334155;
  transition: border-color 0.15s;
}

.config-agente-card:hover {
  border-color: #475569;
}

.config-agente-card--disponible {
  border-color: #0ea5e933;
}

.config-agente-card--disponible:hover {
  border-color: #0ea5e966;
}

.config-agente-card--admin {
  border-left: 3px solid #f59e0b;
}

.config-agente-card-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
}

.config-agente-card-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex: 1;
  min-width: 0;
}

.config-agente-card-info h3 {
  margin: 0;
  font-size: 1rem;
  font-weight: 600;
  color: #e2e8f0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.config-agente-card-acciones {
  display: flex;
  gap: 0.4rem;
  flex-shrink: 0;
}

.config-agente-card-desc {
  margin: 0.5rem 0 0 0;
  font-size: 0.85rem;
  color: #94a3b8;
}

.config-agente-card-version {
  margin: 0.4rem 0 0 0;
  font-size: 0.75rem;
  color: #64748b;
  font-family: monospace;
}

/* ============================================ */
/* Estado de Conexi√≥n                          */
/* ============================================ */
.config-agente-estado {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.75rem;
  padding: 0.2rem 0.6rem;
  border-radius: 20px;
  white-space: nowrap;
}

.config-agente-estado--conectado {
  background: #14532d;
  color: #86efac;
}

.config-agente-estado--desconectado {
  background: #7f1d1d;
  color: #fca5a5;
}

.config-agente-estado-punto {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: currentColor;
}

.config-agente-estado--conectado .config-agente-estado-punto {
  animation: config-agente-pulse 2s infinite;
}

@keyframes config-agente-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* Badge inactivo */
.config-agente-badge {
  font-size: 0.7rem;
  padding: 0.15rem 0.5rem;
  border-radius: 4px;
  white-space: nowrap;
}

.config-agente-badge--inactivo {
  background: #334155;
  color: #94a3b8;
}

/* ============================================ */
/* Botones                                     */
/* ============================================ */
.config-agente-btn {
  padding: 0.55rem 1rem;
  border-radius: 6px;
  border: none;
  font-size: 0.85rem;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.15s, opacity 0.15s;
}

.config-agente-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.config-agente-btn--primario {
  background: #0369a1;
  color: #fff;
}

.config-agente-btn--primario:hover:not(:disabled) {
  background: #0284c7;
}

.config-agente-btn--secundario {
  background: #334155;
  color: #e2e8f0;
}

.config-agente-btn--secundario:hover:not(:disabled) {
  background: #475569;
}

.config-agente-btn--vincular {
  background: #0ea5e9;
  color: #fff;
}

.config-agente-btn--vincular:hover:not(:disabled) {
  background: #0284c7;
}

.config-agente-btn--crear {
  width: 100%;
  padding: 0.75rem 1rem;
  background: linear-gradient(135deg, #0ea5e9 0%, #0369a1 100%);
  color: #fff;
  font-size: 0.9rem;
  margin-bottom: 1.25rem;
}

.config-agente-btn--crear:hover:not(:disabled) {
  background: linear-gradient(135deg, #38bdf8 0%, #0284c7 100%);
}

/* Bot√≥n √≠cono */
.config-agente-btn-icon {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #334155;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background 0.15s, transform 0.1s;
  color: #e2e8f0;
}

.config-agente-btn-icon:hover {
  background: #475569;
  transform: scale(1.05);
}

.config-agente-btn-icon--danger {
  color: #f87171;
}

.config-agente-btn-icon--danger:hover {
  background: #7f1d1d;
}

/* Bot√≥n desvincular deshabilitado para admin invitados */
.config-agente-btn-icon--disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.config-agente-btn-icon--disabled:hover {
  background: transparent;
  transform: none;
}

/* ============================================ */
/* Registradores dentro de Card                */
/* ============================================ */
.config-agente-card-regs {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid #334155;
  animation: config-agente-aparecer 0.2s ease-out;
}

.config-agente-card-regs h4 {
  margin: 0 0 0.75rem 0;
  font-size: 0.85rem;
  font-weight: 600;
  color: #94a3b8;
}

.config-agente-regs-vacio {
  color: #64748b;
  font-size: 0.85rem;
  text-align: center;
  padding: 1rem;
  background: #0f172a;
  border-radius: 6px;
}

.config-agente-regs-lista {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.config-agente-reg-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.6rem 0.75rem;
  background: #0f172a;
  border-radius: 6px;
  font-size: 0.85rem;
}

.config-agente-reg-estado {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #475569;
  flex-shrink: 0;
}

.config-agente-reg-estado--activo {
  background: #22c55e;
  box-shadow: 0 0 6px rgba(34, 197, 94, 0.5);
  animation: config-agente-pulse 2s infinite;
}

.config-agente-reg-tipo {
  font-size: 1rem;
  flex-shrink: 0;
}

.config-agente-reg-nombre {
  color: #e2e8f0;
  font-weight: 500;
}

/* Registrador de tipo rel√© */
.config-agente-reg-item--rele {
  border-left: 2px solid #f59e0b;
}

.config-agente-reg-detalle {
  color: #64748b;
  font-family: monospace;
  font-size: 0.8rem;
  margin-left: auto;
}

/* ============================================ */
/* Formulario Crear Agente                     */
/* ============================================ */
.config-agente-form {
  background: #1e293b;
  border-radius: 10px;
  padding: 1.25rem;
  margin-bottom: 1.5rem;
  border: 1px solid #334155;
}

.config-agente-form h4 {
  margin: 0 0 1rem 0;
  font-size: 1rem;
  font-weight: 600;
  color: #e2e8f0;
}

.config-agente-form-grupo {
  display: flex;
  flex-direction: column;
  gap: 0.4rem;
  margin-bottom: 1rem;
}

.config-agente-form-grupo label {
  font-size: 0.85rem;
  color: #94a3b8;
  font-weight: 500;
}

.config-agente-form-grupo input {
  padding: 0.6rem 0.9rem;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 6px;
  color: #e2e8f0;
  font-size: 0.9rem;
  transition: border-color 0.15s, background 0.15s;
}

.config-agente-form-grupo input:focus {
  outline: none;
  border-color: #0ea5e9;
  background: #1a2744;
}

.config-agente-form-grupo input:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.config-agente-form-grupo input::placeholder {
  color: #64748b;
}

.config-agente-form-acciones {
  display: flex;
  gap: 0.75rem;
  justify-content: flex-end;
  align-items: center;
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid #334155;
}

/* Cuando hay elementos a la izquierda (ej: bot√≥n Test), usar space-between */
.config-agente-form-acciones:has(> .config-agente-btn--test) {
  justify-content: space-between;
}

.config-agente-form-acciones-derecha {
  display: flex;
  gap: 0.75rem;
}

/* ============================================ */
/* Panel Admin - Lista de Agentes              */
/* ============================================ */
.config-agente-admin-lista {
  margin-top: 1rem;
}

.config-agente-admin-lista h4 {
  margin: 0 0 1rem 0;
  font-size: 0.95rem;
  font-weight: 600;
  color: #94a3b8;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #334155;
}

/* ============================================ */
/* Responsive                                  */
/* ============================================ */
/* ============================================ */
/* Registradores - Contenedor y Form           */
/* ============================================ */
.config-agente-regs-contenedor {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.config-agente-btn--agregar-reg {
  padding: 0.5rem 0.75rem;
  background: #0f766e;
  color: #fff;
  font-size: 0.8rem;
  width: fit-content;
}

.config-agente-btn--agregar-reg:hover:not(:disabled) {
  background: #0d9488;
}

/* Toolbar de registradores */
.config-agente-regs-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  align-items: center;
  justify-content: space-between;
}

.config-agente-regs-toolbar-acciones {
  display: flex;
  gap: 0.5rem;
}

.config-agente-btn--iniciar-todos {
  padding: 0.4rem 0.6rem;
  background: #166534;
  color: #fff;
  font-size: 0.75rem;
  display: flex;
  align-items: center;
  gap: 0.3rem;
}

.config-agente-btn--iniciar-todos:hover:not(:disabled) {
  background: #15803d;
}

.config-agente-btn--parar-todos {
  padding: 0.4rem 0.6rem;
  background: #991b1b;
  color: #fff;
  font-size: 0.75rem;
  display: flex;
  align-items: center;
  gap: 0.3rem;
}

.config-agente-btn--parar-todos:hover:not(:disabled) {
  background: #b91c1c;
}

.config-agente-reg-form {
  background: #0f172a;
  border-radius: 8px;
  padding: 1rem;
  border: 1px solid #0ea5e933;
  margin-bottom: 0.5rem;
}

.config-agente-reg-form h5 {
  margin: 0 0 0.75rem 0;
  font-size: 0.9rem;
  font-weight: 600;
  color: #0ea5e9;
}

/* ============================================ */
/* Select de Tipo de Dispositivo               */
/* ============================================ */
.config-agente-tipo-row {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 1rem;
}

.config-agente-tipo-label {
  color: #ffffff;
  font-size: 0.85rem;
  font-weight: 500;
  white-space: nowrap;
}

.config-agente-select-tipo {
  flex: 1;
  max-width: 280px;
  padding: 0.5rem 0.75rem;
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 6px;
  color: #e2e8f0;
  font-size: 0.85rem;
  cursor: pointer;
  transition: border-color 0.15s ease;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2394a3b8' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 0.75rem center;
  padding-right: 2rem;
}

.config-agente-select-tipo:hover {
  border-color: #475569;
}

.config-agente-select-tipo:focus {
  outline: none;
  border-color: #0ea5e9;
}

.config-agente-select-tipo:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.config-agente-select-tipo option {
  background: #1e293b;
  color: #e2e8f0;
  padding: 0.5rem;
}

/* ============================================ */
/* Formulario Analizador de Redes - Redise√±o   */
/* ============================================ */
.config-agente-analizador {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.config-agente-analizador-nombre {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}

.config-agente-analizador-nombre label {
  font-size: 0.75rem;
  color: #94a3b8;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

.config-agente-analizador-nombre input {
  padding: 0.6rem 0.8rem;
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 6px;
  color: #f1f5f9;
  font-size: 0.9rem;
  transition: border-color 0.15s;
}

.config-agente-analizador-nombre input:focus {
  outline: none;
  border-color: #0ea5e9;
}

.config-agente-analizador-nombre input::placeholder {
  color: #475569;
}

.config-agente-analizador-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(200px, 280px));
  gap: 1rem;
  justify-content: start;
}

.config-agente-analizador-seccion {
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 8px;
  padding: 0.875rem;
}

.config-agente-analizador-seccion h6 {
  margin: 0 0 0.75rem 0;
  font-size: 0.8rem;
  font-weight: 600;
  color: #e2e8f0;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #334155;
}

.config-agente-analizador-campos {
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
}

.config-agente-campo-inline {
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

.config-agente-campo-inline label {
  font-size: 0.85rem;
  color: #ffffff;
  min-width: 80px;
  white-space: nowrap;
  text-align: right;
}

.config-agente-campo-inline label::after {
  content: " :";
}

.config-agente-campo-inline input {
  flex: 1;
  padding: 0.45rem 0.6rem;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 4px;
  color: #f1f5f9;
  font-size: 0.85rem;
  max-width: 120px;
  transition: border-color 0.15s;
}

.config-agente-campo-inline input:focus {
  outline: none;
  border-color: #0ea5e9;
}

.config-agente-campo-inline input::placeholder {
  color: #475569;
}

/* Inputs m√°s cortos para valores num√©ricos peque√±os */
.config-agente-analizador-seccion:last-child .config-agente-campo-inline input {
  max-width: 80px;
}

/* Input con sufijo (ej: "seg") */
.config-agente-input-con-sufijo {
  display: flex;
  align-items: stretch;
  max-width: 100px;
}

.config-agente-input-con-sufijo input {
  flex: 1;
  max-width: none;
  border-radius: 4px 0 0 4px;
  border-right: none;
}

.config-agente-input-con-sufijo span {
  display: flex;
  align-items: center;
  padding: 0 0.5rem;
  background: #334155;
  border: 1px solid #334155;
  border-radius: 0 4px 4px 0;
  font-size: 0.7rem;
  color: #94a3b8;
}

/* Responsive */
@media (max-width: 600px) {
  .config-agente-analizador-grid {
    grid-template-columns: 1fr;
  }
}

/* ============================================ */
/* Registradores - Item con acciones           */
/* ============================================ */
.config-agente-reg-item--admin {
  justify-content: space-between;
}

.config-agente-reg-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex: 1;
  min-width: 0;
}

.config-agente-reg-acciones {
  display: flex;
  gap: 0.35rem;
  flex-shrink: 0;
}

.config-agente-reg-acciones .config-agente-btn-icon {
  width: 28px;
  height: 28px;
  font-size: 0.8rem;
}

.config-agente-btn-icon--success {
  color: #22c55e;
}

.config-agente-btn-icon--success:hover {
  background: #14532d;
}

.config-agente-btn-icon--test {
  color: #60a5fa;
}

.config-agente-btn-icon--test:hover {
  background: #1e3a5f;
}

/* Bot√≥n Test en formulario */
.config-agente-btn--test {
  background: #0369a1;
  color: #fff;
}

.config-agente-btn--test:hover:not(:disabled) {
  background: #0284c7;
}

/* ============================================ */
/* Test de Registrador - Modal                 */
/* ============================================ */
.config-agente-test-overlay {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  border-radius: 14px;
}

.config-agente-test-modal {
  background: #1e293b;
  border-radius: 12px;
  width: 90%;
  max-width: 450px;
  border: 1px solid #334155;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  animation: config-agente-aparecer 0.2s ease-out;
}

.config-agente-test-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid #334155;
}

.config-agente-test-header h3 {
  margin: 0;
  font-size: 1rem;
  font-weight: 600;
  color: #e2e8f0;
}

.config-agente-test-contenido {
  padding: 1.25rem;
}

.config-agente-test-info {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  margin-bottom: 1.25rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #334155;
}

.config-agente-test-info strong {
  color: #e2e8f0;
  font-size: 1rem;
}

.config-agente-test-detalle {
  color: #64748b;
  font-family: monospace;
  font-size: 0.85rem;
}

.config-agente-test-exito,
.config-agente-test-error {
  text-align: center;
}

.config-agente-test-icono {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  margin: 0 auto 1rem;
  background: linear-gradient(135deg, #166534 0%, #15803d 100%);
  color: #fff;
  box-shadow: 0 4px 15px rgba(34, 197, 94, 0.3);
}

.config-agente-test-icono--error {
  background: linear-gradient(135deg, #991b1b 0%, #b91c1c 100%);
  box-shadow: 0 4px 15px rgba(248, 113, 113, 0.3);
}

.config-agente-test-exito h4,
.config-agente-test-error h4 {
  margin: 0 0 0.5rem 0;
  font-size: 1.1rem;
  color: #e2e8f0;
}

.config-agente-test-tiempo {
  color: #94a3b8;
  font-size: 0.9rem;
  margin: 0;
}

.config-agente-test-mensaje {
  color: #f87171;
  font-size: 0.9rem;
  margin: 0.5rem 0;
  padding: 0.75rem;
  background: rgba(248, 113, 113, 0.1);
  border-radius: 6px;
}

.config-agente-test-valores {
  margin-top: 1.25rem;
  text-align: left;
}

.config-agente-test-valores h5 {
  margin: 0 0 0.75rem 0;
  font-size: 0.85rem;
  color: #94a3b8;
  font-weight: 500;
}

.config-agente-test-valores-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
  gap: 0.5rem;
  max-height: 200px;
  overflow-y: auto;
  padding: 0.5rem;
  background: #0f172a;
  border-radius: 6px;
}

.config-agente-test-valor {
  display: flex;
  flex-direction: column;
  padding: 0.4rem;
  background: #1e293b;
  border-radius: 4px;
  text-align: center;
}

.config-agente-test-valor-idx {
  font-size: 0.7rem;
  color: #64748b;
  font-family: monospace;
}

.config-agente-test-valor-num {
  font-size: 0.9rem;
  color: #22c55e;
  font-family: monospace;
  font-weight: 600;
}

.config-agente-test-acciones {
  padding: 1rem 1.25rem;
  border-top: 1px solid #334155;
  display: flex;
  justify-content: flex-end;
}

/* ============================================ */
/* Test de Registrador - Progreso              */
/* ============================================ */
.config-agente-test-progreso {
  position: fixed;
  bottom: 2rem;
  right: 2rem;
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 10px;
  padding: 1rem 1.25rem;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
  z-index: 100;
  animation: config-agente-aparecer 0.2s ease-out;
}

.config-agente-test-progreso-contenido {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex-wrap: wrap;
}

.config-agente-test-progreso-contenido span {
  color: #94a3b8;
  font-size: 0.85rem;
}

.config-agente-test-progreso-barra {
  width: 150px;
  height: 4px;
  background: #334155;
  border-radius: 2px;
  overflow: hidden;
}

.config-agente-test-progreso-fill {
  height: 100%;
  background: linear-gradient(90deg, #0ea5e9 0%, #22c55e 100%);
  border-radius: 2px;
  transition: width 0.35s ease-out;
}

/* ============================================ */
/* Campo nombre para registradores de tipo rel√©*/
/* ============================================ */
.config-agente-rele-nombre {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  margin-bottom: 1rem;
}

.config-agente-rele-nombre label {
  font-size: 0.75rem;
  color: #94a3b8;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

.config-agente-rele-nombre input {
  padding: 0.6rem 0.8rem;
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 6px;
  color: #f1f5f9;
  font-size: 0.9rem;
  transition: border-color 0.15s;
}

.config-agente-rele-nombre input:focus {
  outline: none;
  border-color: #0ea5e9;
}

.config-agente-rele-nombre input::placeholder {
  color: #475569;
}

/* ============================================ */
/* Responsive                                  */
/* ============================================ */
@media (max-width: 600px) {
  .config-agente-modal {
    max-width: 100%;
    width: 100%;
    min-height: unset;
    max-height: 100vh;
    border-radius: 0;
  }

  .config-agente-header {
    padding: 1rem;
  }

  .config-agente-tabs {
    overflow-x: auto;
  }

  .config-agente-tab {
    padding: 0.75rem 0.5rem;
    font-size: 0.8rem;
    white-space: nowrap;
  }

  .config-agente-contenido {
    padding: 1rem;
  }

  .config-agente-card-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.75rem;
  }

  .config-agente-card-acciones {
    width: 100%;
    justify-content: flex-end;
  }

  .config-agente-form-acciones {
    flex-direction: column-reverse;
  }

  .config-agente-form-acciones .config-agente-btn {
    width: 100%;
  }

  .config-agente-reg-form-grid {
    grid-template-columns: 1fr 1fr;
  }

  .config-agente-reg-item--admin {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }

  .config-agente-reg-acciones {
    width: 100%;
    justify-content: flex-end;
  }
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigurarAgente.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigurarAgente.jsx
// Ventana flotante para configurar agentes con pesta√±as din√°micas seg√∫n rol
// Soporta: arrastrar, minimizar, maximizar, redimensionar, m√∫ltiples instancias

import React, { useState, useEffect, useCallback, useRef } from "react";
import {
  // Nueva arquitectura
  listarAgentesWorkspace,
  listarAgentesDisponibles,
  vincularAgenteWorkspace,
  desvincularAgenteWorkspace,
  listarTodosLosAgentes,
  crearAgente,
  eliminarAgente,
  rotarClaveAgentePorId,
  listarRegistradoresAgente,
  crearRegistradorAgente,
  actualizarRegistradorAgente,
  eliminarRegistradorAgente,
  toggleRegistradorAgente,
  solicitarTestRegistrador,
  consultarTestRegistrador,
} from "../../../../servicios/apiService";
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import ConfiguracionRele from "./ConfiguracionRele";
import "./ModalConfigurarAgente.css";

/**
 * Modal para configurar agentes con pesta√±as seg√∫n rol del usuario.
 *
 * Pesta√±as:
 * - "Agentes Vinculados": Todos los roles con acceso al workspace
 * - "Vincular Agente": Solo creador del workspace o superadmin
 * - "Panel SuperAdmin": Solo Superadmin (CRUD de agentes y registradores)
 *
 * NOTA: Un admin invitado puede ver los agentes vinculados pero NO puede
 * vincular ni desvincular agentes. Solo el creador del workspace o superadmin
 * tienen esa capacidad.
 */
const ModalConfigurarAgente = ({
  abierto,
  workspaceId,
  onCerrar,
  // Props para comportamiento de ventana flotante
  minimizada = false,
  maximizada = false,
  posicion = { x: 100, y: 50 },
  zIndex = 1000,
  onMinimizar,
  onMaximizar,
  onEnfocar,
  onMover,
}) => {
  const { rolGlobal, configuracionSeleccionada } = usarContextoConfiguracion();

  // Refs para drag y resize
  const ventanaRef = useRef(null);
  const headerRef = useRef(null);

  // Estados para drag
  const [arrastrando, setArrastrando] = useState(false);
  const [offsetArrastre, setOffsetArrastre] = useState({ x: 0, y: 0 });

  // Estados para resize
  const [redimensionando, setRedimensionando] = useState(false);
  const [dimensiones, setDimensiones] = useState({ width: 900, height: 600 });
  const [dimensionesIniciales, setDimensionesIniciales] = useState({ width: 0, height: 0 });
  const [posicionInicialResize, setPosicionInicialResize] = useState({ x: 0, y: 0 });

  // Determinar permisos seg√∫n rol
  // - rolGlobal: rol del usuario en el sistema
  // - configuracionSeleccionada?.rol: rol del usuario EN ESTE WORKSPACE
  const esSuperadmin = rolGlobal === 'superadmin';
  const rolEnWorkspace = configuracionSeleccionada?.rol;
  const esAdmin = esSuperadmin || rolEnWorkspace === 'admin';

  // Solo el creador del workspace o superadmin pueden vincular/desvincular agentes
  const esCreadorWorkspace = configuracionSeleccionada?.esCreador === true;
  const puedeVincularDesvincular = esSuperadmin || esCreadorWorkspace;

  // La pesta√±a "Vincular Agente" solo se muestra si puede vincular
  const puedeVincular = puedeVincularDesvincular;

  // Pesta√±as disponibles seg√∫n rol
  const pestanasDisponibles = [
    { id: 'vinculados', label: 'Agentes Vinculados', visible: true },
    { id: 'vincular', label: 'Vincular Agente', visible: puedeVincular },
    { id: 'admin', label: 'Panel SuperAdmin', visible: esSuperadmin },
  ].filter(p => p.visible);

  // Estado
  const [pestanaActiva, setPestanaActiva] = useState('vinculados');
  const [cargando, setCargando] = useState(false);
  const [error, setError] = useState(null);

  // Datos
  const [agentesVinculados, setAgentesVinculados] = useState([]);
  const [agentesDisponibles, setAgentesDisponibles] = useState([]);
  const [todosAgentes, setTodosAgentes] = useState([]);
  const [registradoresAgente, setRegistradoresAgente] = useState({});

  // Estado para crear agente
  const [mostrarFormCrear, setMostrarFormCrear] = useState(false);
  const [nuevoAgente, setNuevoAgente] = useState({ nombre: '', descripcion: '' });
  const [creando, setCreando] = useState(false);
  const [claveGenerada, setClaveGenerada] = useState(null);

  // Estado para expandir registradores
  const [agenteExpandido, setAgenteExpandido] = useState(null);

  // Estado para CRUD de registradores
  const [mostrarFormRegistrador, setMostrarFormRegistrador] = useState(null); // null | agenteId
  const [registradorEditando, setRegistradorEditando] = useState(null);
  const [nuevoRegistrador, setNuevoRegistrador] = useState({
    nombre: '',
    tipo: 'modbus',
    tipoDispositivo: 'analizador', // 'analizador' | 'rele'
    ip: '',
    puerto: '',
    unitId: '',
    indiceInicial: '',
    cantidadRegistros: '',
    intervaloSegundos: '',
    // Configuraci√≥n espec√≠fica para rel√©s de protecci√≥n
    configuracionRele: null,
  });
  const [guardandoRegistrador, setGuardandoRegistrador] = useState(false);
  const [registradorProcesando, setRegistradorProcesando] = useState(null); // ID del registrador que est√° procesando

  // Estado para test de registrador
  const [testEnCurso, setTestEnCurso] = useState(null); // { agenteId, registradorId, testId, estado, progreso }
  const [resultadoTest, setResultadoTest] = useState(null); // Resultado del test para mostrar en modal

  // Cargar datos al abrir
  useEffect(() => {
    if (abierto && workspaceId) {
      cargarDatos();
    }
  }, [abierto, workspaceId]);

  // Resetear estado al cerrar
  useEffect(() => {
    if (!abierto) {
      setPestanaActiva('vinculados');
      setError(null);
      setMostrarFormCrear(false);
      setClaveGenerada(null);
      setAgenteExpandido(null);
      setMostrarFormRegistrador(null);
      setRegistradorEditando(null);
      resetFormRegistrador();
      setTestEnCurso(null);
      setResultadoTest(null);
    }
  }, [abierto]);

  // Reset form de registrador
  const resetFormRegistrador = () => {
    setNuevoRegistrador({
      nombre: '',
      tipo: 'modbus',
      tipoDispositivo: 'analizador',
      ip: '',
      puerto: '',
      unitId: '',
      indiceInicial: '',
      cantidadRegistros: '',
      intervaloSegundos: '',
      configuracionRele: null,
    });
    setRegistradorEditando(null);
  };

  const cargarDatos = async () => {
    setCargando(true);
    setError(null);

    try {
      // Cargar agentes vinculados al workspace
      const vinculados = await listarAgentesWorkspace(workspaceId);
      setAgentesVinculados(vinculados || []);

      // Si puede vincular, cargar disponibles
      if (puedeVincular) {
        const disponibles = await listarAgentesDisponibles();
        // Filtrar los que ya est√°n vinculados
        const idsVinculados = new Set((vinculados || []).map(a => a.id));
        setAgentesDisponibles((disponibles || []).filter(a => !idsVinculados.has(a.id)));
      }

      // Si es superadmin, cargar todos
      if (esSuperadmin) {
        const todos = await listarTodosLosAgentes();
        setTodosAgentes(todos || []);
      }
    } catch (err) {
      console.error('Error cargando datos:', err);
      setError(err.message || 'Error cargando datos');
    } finally {
      setCargando(false);
    }
  };

  // Vincular agente al workspace
  const handleVincular = async (agenteId) => {
    try {
      setCargando(true);
      await vincularAgenteWorkspace(workspaceId, agenteId);
      await cargarDatos();
      setPestanaActiva('vinculados');
    } catch (err) {
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Desvincular agente del workspace
  const handleDesvincular = async (agenteId) => {
    if (!confirm('¬øDesvincular este agente del workspace?')) return;

    try {
      setCargando(true);
      await desvincularAgenteWorkspace(workspaceId, agenteId);
      await cargarDatos();
    } catch (err) {
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Crear nuevo agente (superadmin)
  const handleCrearAgente = async (e) => {
    e.preventDefault();
    if (!nuevoAgente.nombre.trim()) return;

    try {
      setCreando(true);
      setError(null);
      const resultado = await crearAgente(nuevoAgente.nombre, nuevoAgente.descripcion);
      setClaveGenerada(resultado.claveSecreta);
      setNuevoAgente({ nombre: '', descripcion: '' });
      await cargarDatos();
    } catch (err) {
      setError(err.message);
    } finally {
      setCreando(false);
    }
  };

  // Eliminar agente (superadmin)
  const handleEliminarAgente = async (agenteId, nombre) => {
    if (!confirm(`¬øEliminar el agente "${nombre}"? Esta acci√≥n no se puede deshacer.`)) return;

    try {
      setCargando(true);
      await eliminarAgente(agenteId);
      await cargarDatos();
    } catch (err) {
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Rotar clave de agente (superadmin)
  const handleRotarClave = async (agenteId) => {
    if (!confirm('¬øRotar la clave del agente? Deber√°s actualizar el agente con la nueva clave.')) return;

    try {
      setCargando(true);
      const resultado = await rotarClaveAgentePorId(agenteId);
      setClaveGenerada(resultado.nuevaClave);
    } catch (err) {
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Cargar registradores de un agente
  const toggleRegistradores = async (agenteId) => {
    if (agenteExpandido === agenteId) {
      setAgenteExpandido(null);
      setMostrarFormRegistrador(null);
      return;
    }

    try {
      if (!registradoresAgente[agenteId]) {
        const regs = await listarRegistradoresAgente(agenteId);
        setRegistradoresAgente(prev => ({ ...prev, [agenteId]: regs }));
      }
      setAgenteExpandido(agenteId);
    } catch (err) {
      console.error('Error cargando registradores:', err);
    }
  };

  // Recargar registradores de un agente
  const recargarRegistradores = async (agenteId) => {
    try {
      const regs = await listarRegistradoresAgente(agenteId);
      setRegistradoresAgente(prev => ({ ...prev, [agenteId]: regs }));
    } catch (err) {
      console.error('Error recargando registradores:', err);
    }
  };

  // Crear o editar registrador
  const handleGuardarRegistrador = async (e, agenteId) => {
    e.preventDefault();

    // Validaci√≥n b√°sica
    if (!nuevoRegistrador.nombre.trim()) return;

    // Para rel√©s, la validaci√≥n de conexi√≥n viene del componente ConfiguracionRele
    const esRele = nuevoRegistrador.tipoDispositivo === 'rele';

    if (esRele) {
      // Validar que tenga configuraci√≥n de rel√© con plantilla seleccionada
      const configRele = nuevoRegistrador.configuracionRele;
      if (!configRele || !configRele.plantillaId) {
        setError('Debes seleccionar una plantilla de configuraci√≥n');
        return;
      }
      if (!configRele.conexion?.ip) {
        setError('Debes configurar la IP del rel√©');
        return;
      }
    } else {
      // Para analizadores, validar campos tradicionales
      if (!nuevoRegistrador.ip.trim() || !nuevoRegistrador.puerto || !nuevoRegistrador.indiceInicial || !nuevoRegistrador.cantidadRegistros) return;
    }

    try {
      setGuardandoRegistrador(true);
      setError(null);

      // Preparar datos seg√∫n tipo de dispositivo
      let datos;

      if (esRele) {
        // Para rel√©s, usar la configuraci√≥n del componente ConfiguracionRele (nuevo formato con plantillas)
        const configRele = nuevoRegistrador.configuracionRele;
        datos = {
          nombre: nuevoRegistrador.nombre,
          tipo: 'modbus',
          tipoDispositivo: 'rele',
          ip: configRele.conexion.ip,
          puerto: String(configRele.conexion.puerto || 502),
          unitId: String(configRele.conexion.unitId || 1),
          indiceInicial: String(configRele.registroInicial || 120),
          cantidadRegistros: String(configRele.cantidadRegistros || 80),
          intervaloSegundos: '60', // Default, se puede agregar al formulario si es necesario
          configuracionRele: configRele,
        };
      } else {
        // Para analizadores, usar formato tradicional
        datos = {
          ...nuevoRegistrador,
          tipoDispositivo: 'analizador',
          unitId: nuevoRegistrador.unitId || '1',
          intervaloSegundos: nuevoRegistrador.intervaloSegundos || '60',
        };
      }

      if (registradorEditando) {
        // Editar
        await actualizarRegistradorAgente(agenteId, registradorEditando.id, datos);
      } else {
        // Crear
        await crearRegistradorAgente(agenteId, datos);
      }

      await recargarRegistradores(agenteId);
      setMostrarFormRegistrador(null);
      resetFormRegistrador();
    } catch (err) {
      setError(err.message);
    } finally {
      setGuardandoRegistrador(false);
    }
  };

  // Editar registrador
  const handleEditarRegistrador = (reg) => {
    setRegistradorEditando(reg);
    setNuevoRegistrador({
      nombre: reg.nombre || '',
      tipo: reg.tipo || 'modbus',
      tipoDispositivo: reg.tipo_dispositivo || 'analizador',
      ip: reg.ip || '',
      puerto: String(reg.puerto || '502'),
      unitId: String(reg.unit_id || '1'),
      indiceInicial: String(reg.indice_inicial || '0'),
      cantidadRegistros: String(reg.cantidad_registros || '10'),
      intervaloSegundos: String(reg.intervalo_segundos || '60'),
      configuracionRele: reg.configuracion_rele || null,
    });
    setMostrarFormRegistrador(reg.agente_id);
  };

  // Eliminar registrador
  const handleEliminarRegistrador = async (agenteId, registradorId, nombre) => {
    if (!confirm(`¬øEliminar el registrador "${nombre}"?`)) return;

    try {
      setCargando(true);
      await eliminarRegistradorAgente(agenteId, registradorId);
      await recargarRegistradores(agenteId);
    } catch (err) {
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Toggle activo registrador
  const handleToggleRegistrador = async (agenteId, registradorId) => {
    try {
      setRegistradorProcesando(registradorId);
      await toggleRegistradorAgente(agenteId, registradorId);
      await recargarRegistradores(agenteId);
    } catch (err) {
      setError(err.message);
    } finally {
      setRegistradorProcesando(null);
    }
  };

  // Iniciar o parar todos los registradores de un agente
  const handleToggleTodosRegistradores = async (agenteId, iniciar) => {
    const regs = registradoresAgente[agenteId] || [];
    const registrosAToggle = regs.filter(r => iniciar ? !r.activo : r.activo);

    if (registrosAToggle.length === 0) return;

    try {
      setRegistradorProcesando('todos');
      // Toggle cada registrador que necesite cambiar
      for (const reg of registrosAToggle) {
        await toggleRegistradorAgente(agenteId, reg.id);
      }
      await recargarRegistradores(agenteId);
    } catch (err) {
      setError(err.message);
    } finally {
      setRegistradorProcesando(null);
    }
  };

  // Test de conexi√≥n de registrador (usa datos del formulario)
  const handleTestRegistrador = async (agenteId) => {
    // Verificar si ya hay un test en curso
    if (testEnCurso) {
      return;
    }

    // Validar que los campos requeridos est√©n completos
    if (!nuevoRegistrador.ip.trim() || !nuevoRegistrador.puerto || !nuevoRegistrador.indiceInicial || !nuevoRegistrador.cantidadRegistros) {
      setError('Completa IP, Puerto, √çndice Inicial y Cantidad de Registros para hacer el test');
      return;
    }

// Crear objeto con datos del formulario (fuera del try para usar en catch)
    const datosTest = {
      nombre: nuevoRegistrador.nombre || 'Test',
      ip: nuevoRegistrador.ip,
      puerto: parseInt(nuevoRegistrador.puerto),
      unit_id: parseInt(nuevoRegistrador.unitId) || 1,
      indice_inicial: parseInt(nuevoRegistrador.indiceInicial),
      cantidad_registros: parseInt(nuevoRegistrador.cantidadRegistros),
    };

    try {
      setTestEnCurso({
        agenteId,
        registradorId: 'form',
        testId: null,
        estado: 'solicitando',
        progreso: 0,
      });
      setResultadoTest(null);
      setError(null);

      // Solicitar el test
      const respuesta = await solicitarTestRegistrador(agenteId, {
        ip: datosTest.ip,
        puerto: datosTest.puerto,
        unitId: datosTest.unit_id,
        indiceInicial: datosTest.indice_inicial,
        cantidadRegistros: datosTest.cantidad_registros,
      });

      const { testId, timeoutSegundos } = respuesta;

      setTestEnCurso(prev => ({
        ...prev,
        testId,
        estado: 'esperando',
        progreso: 0,
      }));

      // Polling del resultado
      const tiempoInicio = Date.now();
      const tiempoMaximo = (timeoutSegundos || 30) * 1000;
      const intervalo = 1000; // Consultar cada segundo

      const poll = async () => {
        const tiempoTranscurrido = Date.now() - tiempoInicio;

        if (tiempoTranscurrido > tiempoMaximo) {
          setTestEnCurso(null);
          setResultadoTest({
            exito: false,
            estado: 'timeout',
            error_mensaje: 'El agente no respondi√≥ a tiempo',
            registrador: datosTest,
          });
          return;
        }

        try {
          const resultado = await consultarTestRegistrador(agenteId, testId);

          // Actualizar progreso
          const progreso = Math.min((tiempoTranscurrido / tiempoMaximo) * 100, 95);
          setTestEnCurso(prev => prev ? { ...prev, progreso } : null);

          if (resultado.estado === 'completado' || resultado.estado === 'error' || resultado.estado === 'timeout') {
            // Primero llevar la barra a 100%
            setTestEnCurso(prev => prev ? { ...prev, progreso: 100 } : null);

            // Esperar un momento para que se vea la barra llena antes de mostrar el resultado
            setTimeout(() => {
              setTestEnCurso(null);
              setResultadoTest({
                ...resultado,
                exito: resultado.estado === 'completado',
                registrador: datosTest,
              });
            }, 400);
          } else {
            // Seguir esperando
            setTimeout(poll, intervalo);
          }
        } catch (err) {
          setTestEnCurso(null);
          setResultadoTest({
            exito: false,
            estado: 'error',
            error_mensaje: err.message,
            registrador: datosTest,
          });
        }
      };

      // Iniciar polling
      setTimeout(poll, intervalo);

    } catch (err) {
      setTestEnCurso(null);

      // Manejar error de cooldown
      if (err.message?.includes('esperar')) {
        setResultadoTest({
          exito: false,
          estado: 'cooldown',
          error_mensaje: err.message,
          registrador: datosTest,
        });
      } else {
        setError(err.message);
      }
    }
  };

  // Copiar al portapapeles
  const copiarAlPortapapeles = (texto) => {
    navigator.clipboard.writeText(texto);
  };

  // --- Drag & Drop ---
  const handleMouseDown = (e) => {
    if (maximizada) return;
    if (e.target.closest("button")) return;
    if (onEnfocar) onEnfocar();
    setArrastrando(true);
    const rect = ventanaRef.current.getBoundingClientRect();
    setOffsetArrastre({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    });
  };

  useEffect(() => {
    if (!arrastrando) return;

    const handleMouseMove = (e) => {
      const newX = Math.max(0, e.clientX - offsetArrastre.x);
      const newY = Math.max(0, e.clientY - offsetArrastre.y);
      if (onMover) {
        onMover({ x: newX, y: newY });
      }
    };

    const handleMouseUp = () => {
      setArrastrando(false);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [arrastrando, offsetArrastre, onMover]);

  // --- Resize ---
  const handleResizeMouseDown = (e) => {
    if (maximizada) return;
    e.preventDefault();
    e.stopPropagation();
    setRedimensionando(true);
    setPosicionInicialResize({ x: e.clientX, y: e.clientY });
    const rect = ventanaRef.current.getBoundingClientRect();
    setDimensionesIniciales({ width: rect.width, height: rect.height });
  };

  useEffect(() => {
    if (!redimensionando) return;

    const handleMouseMove = (e) => {
      const deltaX = e.clientX - posicionInicialResize.x;
      const deltaY = e.clientY - posicionInicialResize.y;
      const newWidth = Math.max(600, dimensionesIniciales.width + deltaX);
      const newHeight = Math.max(400, dimensionesIniciales.height + deltaY);
      setDimensiones({ width: newWidth, height: newHeight });
    };

    const handleMouseUp = () => {
      setRedimensionando(false);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [redimensionando, posicionInicialResize, dimensionesIniciales]);

  // Manejadores para minimizar/maximizar (con fallbacks internos si no se proveen)
  const handleMinimizar = useCallback(() => {
    if (onMinimizar) onMinimizar();
  }, [onMinimizar]);

  const handleMaximizar = useCallback(() => {
    if (onMaximizar) onMaximizar();
  }, [onMaximizar]);

  const handleEnfocar = useCallback(() => {
    if (onEnfocar) onEnfocar();
  }, [onEnfocar]);

  if (!abierto) return null;
  if (minimizada) return null;

  // Renderizar indicador de estado de conexi√≥n
  const renderEstadoConexion = (agente) => (
    <span className={`config-agente-estado ${agente.conectado ? 'config-agente-estado--conectado' : 'config-agente-estado--desconectado'}`}>
      <span className="config-agente-estado-punto"></span>
      {agente.conectado ? 'Conectado' : 'Desconectado'}
    </span>
  );

  // Renderizar lista de registradores (con acciones opcionales para superadmin)
  const renderRegistradores = (agenteId, conAcciones = false) => {
    const regs = registradoresAgente[agenteId] || [];
    const hayActivos = regs.some(r => r.activo);
    const hayInactivos = regs.some(r => !r.activo);

    return (
      <div className="config-agente-regs-contenedor">
        {/* Botones de acci√≥n (solo en panel superadmin) */}
        {conAcciones && (
          <div className="config-agente-regs-toolbar">
            <button
              className="config-agente-btn config-agente-btn--agregar-reg"
              onClick={() => {
                resetFormRegistrador();
                setMostrarFormRegistrador(agenteId);
              }}
            >
              + Agregar Registrador
            </button>
            {regs.length > 0 && (
              <div className="config-agente-regs-toolbar-acciones">
                {hayInactivos && (
                  <button
                    className="config-agente-btn config-agente-btn--iniciar-todos"
                    onClick={() => handleToggleTodosRegistradores(agenteId, true)}
                    disabled={registradorProcesando === 'todos'}
                    title="Iniciar todos los registradores pausados"
                  >
                    {registradorProcesando === 'todos' ? (
                      <span className="config-agente-spinner-mini"></span>
                    ) : '‚ñ∂'} Iniciar todos
                  </button>
                )}
                {hayActivos && (
                  <button
                    className="config-agente-btn config-agente-btn--parar-todos"
                    onClick={() => handleToggleTodosRegistradores(agenteId, false)}
                    disabled={registradorProcesando === 'todos'}
                    title="Pausar todos los registradores activos"
                  >
                    {registradorProcesando === 'todos' ? (
                      <span className="config-agente-spinner-mini"></span>
                    ) : '‚è∏'} Pausar todos
                  </button>
                )}
              </div>
            )}
          </div>
        )}

        {/* Formulario crear/editar registrador */}
        {conAcciones && mostrarFormRegistrador === agenteId && (
          <form className="config-agente-reg-form" onSubmit={(e) => handleGuardarRegistrador(e, agenteId)}>
            <h5>{registradorEditando ? 'Editar Registrador' : 'Nuevo Registrador'}</h5>

            {/* Selector de tipo de dispositivo */}
            <div className="config-agente-tipo-row">
              <label className="config-agente-tipo-label">Tipo de Dispositivo:</label>
              <select
                value={nuevoRegistrador.tipoDispositivo}
                onChange={e => setNuevoRegistrador(prev => ({
                  ...prev,
                  tipoDispositivo: e.target.value,
                  configuracionRele: e.target.value === 'analizador' ? null : prev.configuracionRele,
                }))}
                disabled={guardandoRegistrador}
                className="config-agente-select-tipo"
              >
                <option value="analizador">üìä Analizador de Redes</option>
                <option value="rele">üõ°Ô∏è Rel√© de Protecci√≥n</option>
              </select>
            </div>

            {/* Formulario para Analizador de Redes */}
            {nuevoRegistrador.tipoDispositivo === 'analizador' && (
              <div className="config-agente-analizador">
                {/* Nombre del registrador */}
                <div className="config-agente-analizador-nombre">
                  <label>Nombre del Registrador</label>
                  <input
                    type="text"
                    value={nuevoRegistrador.nombre}
                    onChange={e => setNuevoRegistrador(prev => ({ ...prev, nombre: e.target.value }))}
                    placeholder="Ej: Analizador Trafo 1"
                    disabled={guardandoRegistrador}
                  />
                </div>

                {/* Secciones en dos columnas */}
                <div className="config-agente-analizador-grid">
                  {/* Secci√≥n Conexi√≥n */}
                  <div className="config-agente-analizador-seccion">
                    <h6>üì° Conexi√≥n Modbus TCP</h6>
                    <div className="config-agente-analizador-campos">
                      <div className="config-agente-campo-inline">
                        <label>IP</label>
                        <input
                          type="text"
                          value={nuevoRegistrador.ip}
                          onChange={e => setNuevoRegistrador(prev => ({ ...prev, ip: e.target.value }))}
                          placeholder="192.168.1.100"
                          disabled={guardandoRegistrador}
                        />
                      </div>
                      <div className="config-agente-campo-inline">
                        <label>Puerto</label>
                        <input
                          type="number"
                          value={nuevoRegistrador.puerto}
                          onChange={e => setNuevoRegistrador(prev => ({ ...prev, puerto: e.target.value }))}
                          placeholder="502"
                          disabled={guardandoRegistrador}
                        />
                      </div>
                      <div className="config-agente-campo-inline">
                        <label>Unit ID</label>
                        <input
                          type="number"
                          value={nuevoRegistrador.unitId}
                          onChange={e => setNuevoRegistrador(prev => ({ ...prev, unitId: e.target.value }))}
                          placeholder="1"
                          disabled={guardandoRegistrador}
                        />
                      </div>
                    </div>
                  </div>

                  {/* Secci√≥n Registros */}
                  <div className="config-agente-analizador-seccion">
                    <h6>üìã Registros Modbus</h6>
                    <div className="config-agente-analizador-campos">
                      <div className="config-agente-campo-inline">
                        <label>√çndice Inicial</label>
                        <input
                          type="number"
                          value={nuevoRegistrador.indiceInicial}
                          onChange={e => setNuevoRegistrador(prev => ({ ...prev, indiceInicial: e.target.value }))}
                          placeholder="0"
                          disabled={guardandoRegistrador}
                        />
                      </div>
                      <div className="config-agente-campo-inline">
                        <label>Cantidad</label>
                        <input
                          type="number"
                          value={nuevoRegistrador.cantidadRegistros}
                          onChange={e => setNuevoRegistrador(prev => ({ ...prev, cantidadRegistros: e.target.value }))}
                          placeholder="20"
                          disabled={guardandoRegistrador}
                        />
                      </div>
                      <div className="config-agente-campo-inline">
                        <label>Intervalo</label>
                        <div className="config-agente-input-con-sufijo">
                          <input
                            type="number"
                            value={nuevoRegistrador.intervaloSegundos}
                            onChange={e => setNuevoRegistrador(prev => ({ ...prev, intervaloSegundos: e.target.value }))}
                            placeholder="60"
                            disabled={guardandoRegistrador}
                          />
                          <span>seg</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="config-agente-form-acciones">
                  <button
                    type="button"
                    className="config-agente-btn config-agente-btn--test"
                    onClick={() => handleTestRegistrador(agenteId)}
                    disabled={guardandoRegistrador || testEnCurso || !nuevoRegistrador.ip.trim() || !nuevoRegistrador.puerto || !nuevoRegistrador.indiceInicial || !nuevoRegistrador.cantidadRegistros}
                    title="Probar conexi√≥n antes de guardar"
                  >
                    {testEnCurso ? 'Probando...' : 'Test'}
                  </button>
                  <div className="config-agente-form-acciones-derecha">
                    <button
                      type="button"
                      className="config-agente-btn config-agente-btn--secundario"
                      onClick={() => {
                        setMostrarFormRegistrador(null);
                        resetFormRegistrador();
                      }}
                      disabled={guardandoRegistrador || testEnCurso}
                    >
                      Cancelar
                    </button>
                    <button
                      type="submit"
                      className="config-agente-btn config-agente-btn--primario"
                      disabled={guardandoRegistrador || testEnCurso || !nuevoRegistrador.nombre.trim() || !nuevoRegistrador.ip.trim() || !nuevoRegistrador.puerto || !nuevoRegistrador.indiceInicial || !nuevoRegistrador.cantidadRegistros}
                    >
                      {guardandoRegistrador ? 'Guardando...' : (registradorEditando ? 'Guardar' : 'Crear')}
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Formulario para Rel√© de Protecci√≥n */}
            {nuevoRegistrador.tipoDispositivo === 'rele' && (
              <>
                {/* Nombre del registrador (compartido con analizadores) */}
                <div className="config-agente-rele-nombre">
                  <label>Nombre del Registrador</label>
                  <input
                    type="text"
                    value={nuevoRegistrador.nombre}
                    onChange={e => setNuevoRegistrador(prev => ({ ...prev, nombre: e.target.value }))}
                    placeholder="Ej: Rel√© REF615 Bah√≠a 1"
                    disabled={guardandoRegistrador}
                  />
                </div>
                <ConfiguracionRele
                  configuracionInicial={nuevoRegistrador.configuracionRele}
                  onChange={(config) => setNuevoRegistrador(prev => ({
                    ...prev,
                    configuracionRele: config,
                  }))}
                  agenteId={agenteId}
                />
                <div className="config-agente-form-acciones">
                  <div className="config-agente-form-acciones-derecha">
                    <button
                      type="button"
                      className="config-agente-btn config-agente-btn--secundario"
                      onClick={() => {
                        setMostrarFormRegistrador(null);
                        resetFormRegistrador();
                      }}
                      disabled={guardandoRegistrador}
                    >
                      Cancelar
                    </button>
                    <button
                      type="submit"
                      className="config-agente-btn config-agente-btn--primario"
                      disabled={guardandoRegistrador || !nuevoRegistrador.nombre.trim() || !nuevoRegistrador.configuracionRele}
                    >
                      {guardandoRegistrador ? 'Guardando...' : (registradorEditando ? 'Guardar' : 'Crear')}
                    </button>
                  </div>
                </div>
              </>
            )}
          </form>
        )}

        {/* Lista de registradores */}
        {regs.length === 0 ? (
          <div className="config-agente-regs-vacio">Sin registradores configurados</div>
        ) : (
          <div className="config-agente-regs-lista">
            {regs.map(reg => {
              const esRele = reg.tipo_dispositivo === 'rele';
              const configRele = reg.configuracion_rele;

              return (
                <div key={reg.id} className={`config-agente-reg-item ${conAcciones ? 'config-agente-reg-item--admin' : ''} ${esRele ? 'config-agente-reg-item--rele' : ''}`}>
                  <div className="config-agente-reg-info">
                    <span
                      className={`config-agente-reg-estado ${reg.activo ? 'config-agente-reg-estado--activo' : ''}`}
                      title={reg.activo ? 'Activo' : 'Inactivo'}
                    ></span>
                    <span className="config-agente-reg-tipo" title={esRele ? 'Rel√© de Protecci√≥n' : 'Analizador de Redes'}>
                      {esRele ? 'üõ°Ô∏è' : 'üìä'}
                    </span>
                    <span className="config-agente-reg-nombre">{reg.nombre}</span>
                    {esRele && configRele ? (
                      <span className="config-agente-reg-detalle">
                        {reg.ip}:{reg.puerto} | {configRele.modeloId} - {configRele.configuracionId} | {reg.intervalo_segundos}s
                      </span>
                    ) : (
                      <span className="config-agente-reg-detalle">
                        {reg.ip}:{reg.puerto} | Reg: {reg.indice_inicial}-{reg.indice_inicial + reg.cantidad_registros - 1} | {reg.intervalo_segundos}s
                      </span>
                    )}
                  </div>
                  {conAcciones && (
                  <div className="config-agente-reg-acciones">
                    <button
                      className={`config-agente-btn-icon ${reg.activo ? 'config-agente-btn-icon--success' : ''}`}
                      onClick={() => handleToggleRegistrador(agenteId, reg.id)}
                      title={reg.activo ? 'Desactivar' : 'Activar'}
                      disabled={registradorProcesando === reg.id}
                    >
                      {registradorProcesando === reg.id ? (
                        <span className="config-agente-spinner-mini"></span>
                      ) : (
                        reg.activo ? '‚è∏' : '‚ñ∂'
                      )}
                    </button>
                    <button
                      className="config-agente-btn-icon"
                      onClick={() => handleEditarRegistrador({ ...reg, agente_id: agenteId })}
                      title="Editar"
                      disabled={registradorProcesando === reg.id}
                    >
                      ‚úèÔ∏è
                    </button>
                    <button
                      className="config-agente-btn-icon config-agente-btn-icon--danger"
                      onClick={() => handleEliminarRegistrador(agenteId, reg.id, reg.nombre)}
                      title="Eliminar"
                      disabled={registradorProcesando === reg.id}
                    >
                      üóë
                    </button>
                  </div>
                  )}
                </div>
              );
            })}
          </div>
        )}
      </div>
    );
  };

  // Estilo din√°mico de la ventana
  const estiloVentana = maximizada
    ? { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, width: "100%", height: "100%", zIndex }
    : {
        position: "fixed",
        top: posicion.y,
        left: posicion.x,
        width: dimensiones.width,
        height: dimensiones.height,
        zIndex,
      };

  return (
    <div
      ref={ventanaRef}
      className={`config-agente-ventana ${maximizada ? "config-agente-ventana--maximizada" : ""} ${arrastrando ? "config-agente-ventana--arrastrando" : ""} ${redimensionando ? "config-agente-ventana--redimensionando" : ""}`}
      style={estiloVentana}
      onMouseDown={handleEnfocar}
    >
      {/* Header arrastrable */}
      <header
        ref={headerRef}
        className="config-agente-header"
        onMouseDown={handleMouseDown}
      >
        <div className="config-agente-titulo">
          <span className="config-agente-icono">‚öôÔ∏è</span>
          <h2>Configuraci√≥n de Agentes</h2>
        </div>
        <div className="config-agente-controles-ventana">
          <button
            type="button"
            className="config-agente-btn-ventana config-agente-btn-ventana--minimizar"
            onClick={handleMinimizar}
            title="Minimizar"
          >
            <span>‚îÄ</span>
          </button>
          <button
            type="button"
            className="config-agente-btn-ventana config-agente-btn-ventana--maximizar"
            onClick={handleMaximizar}
            title={maximizada ? "Restaurar" : "Maximizar"}
          >
            <span>{maximizada ? "‚ùê" : "‚ñ°"}</span>
          </button>
          <button
            type="button"
            className="config-agente-btn-ventana config-agente-btn-ventana--cerrar"
            onClick={onCerrar}
            title="Cerrar"
          >
            <span>√ó</span>
          </button>
        </div>
      </header>

        {/* Pesta√±as */}
        <div className="config-agente-tabs">
          {pestanasDisponibles.map(p => (
            <button
              key={p.id}
              className={`config-agente-tab ${pestanaActiva === p.id ? 'config-agente-tab--activa' : ''}`}
              onClick={() => setPestanaActiva(p.id)}
            >
              {p.label}
            </button>
          ))}
        </div>

        {/* Contenido */}
        <div className="config-agente-contenido">
          {/* Alerta de clave generada */}
          {claveGenerada && (
            <div className="config-agente-alerta config-agente-alerta--exito">
              <div className="config-agente-alerta-header">
                <strong>Clave del Agente</strong>
                <button onClick={() => setClaveGenerada(null)}>√ó</button>
              </div>
              <p>Guarda esta clave, no se mostrar√° de nuevo:</p>
              <div className="config-agente-clave-box">
                <code>{claveGenerada}</code>
                <button onClick={() => copiarAlPortapapeles(claveGenerada)}>Copiar</button>
              </div>
            </div>
          )}

          {/* Error */}
          {error && (
            <div className="config-agente-alerta config-agente-alerta--error">
              {error}
              <button onClick={() => setError(null)}>√ó</button>
            </div>
          )}

          {/* Cargando */}
          {cargando && (
            <div className="config-agente-cargando">
              <span className="config-agente-spinner"></span>
              Cargando...
            </div>
          )}

          {/* ========== PESTA√ëA: AGENTES VINCULADOS ========== */}
          {pestanaActiva === 'vinculados' && !cargando && (
            <div className="config-agente-seccion">
              {agentesVinculados.length === 0 ? (
                <div className="config-agente-vacio">
                  <span className="config-agente-vacio-icono">üì°</span>
                  <p>No hay agentes vinculados a este workspace</p>
                  {puedeVincular && (
                    <button
                      className="config-agente-btn config-agente-btn--primario"
                      onClick={() => setPestanaActiva('vincular')}
                    >
                      Vincular un Agente
                    </button>
                  )}
                  {!puedeVincular && (
                    <p className="config-agente-hint">Contacta a un administrador para vincular agentes.</p>
                  )}
                </div>
              ) : (
                <div className="config-agente-lista">
                  {agentesVinculados.map(agente => (
                    <div key={agente.id} className="config-agente-card">
                      <div className="config-agente-card-header">
                        <div className="config-agente-card-info">
                          <h3>{agente.nombre}</h3>
                          {renderEstadoConexion(agente)}
                        </div>
                        <div className="config-agente-card-acciones">
                          <button
                            className="config-agente-btn-icon"
                            onClick={() => toggleRegistradores(agente.id)}
                            title="Ver registradores"
                          >
                            {agenteExpandido === agente.id ? '‚ñ≤' : '‚ñº'}
                          </button>
                          {/* El bot√≥n desvincular es visible para admins, pero solo funciona para creador/superadmin */}
                          {esAdmin && (
                            <button
                              className={`config-agente-btn-icon config-agente-btn-icon--danger ${!puedeVincularDesvincular ? 'config-agente-btn-icon--disabled' : ''}`}
                              onClick={() => {
                                if (puedeVincularDesvincular) {
                                  handleDesvincular(agente.id);
                                } else {
                                  alert('Solo el administrador que cre√≥ el workspace puede desvincular agentes.');
                                }
                              }}
                              title={puedeVincularDesvincular ? 'Desvincular' : 'Solo el creador del workspace puede desvincular'}
                            >
                              ‚úï
                            </button>
                          )}
                        </div>
                      </div>
                      {agente.descripcion && (
                        <p className="config-agente-card-desc">{agente.descripcion}</p>
                      )}
                      {agenteExpandido === agente.id && (
                        <div className="config-agente-card-regs">
                          <h4>Registradores</h4>
                          {renderRegistradores(agente.id)}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}

          {/* ========== PESTA√ëA: VINCULAR AGENTE ========== */}
          {pestanaActiva === 'vincular' && !cargando && (
            <div className="config-agente-seccion">
              <p className="config-agente-instruccion">
                Selecciona un agente disponible para vincularlo a este workspace.
              </p>
              {agentesDisponibles.length === 0 ? (
                <div className="config-agente-vacio">
                  <span className="config-agente-vacio-icono">üîç</span>
                  <p>No hay agentes disponibles para vincular</p>
                  {esSuperadmin && (
                    <button
                      className="config-agente-btn config-agente-btn--primario"
                      onClick={() => setPestanaActiva('admin')}
                    >
                      Crear nuevo Agente
                    </button>
                  )}
                </div>
              ) : (
                <div className="config-agente-lista">
                  {agentesDisponibles.map(agente => (
                    <div key={agente.id} className="config-agente-card config-agente-card--disponible">
                      <div className="config-agente-card-header">
                        <div className="config-agente-card-info">
                          <h3>{agente.nombre}</h3>
                          {renderEstadoConexion(agente)}
                        </div>
                        <button
                          className="config-agente-btn config-agente-btn--vincular"
                          onClick={() => handleVincular(agente.id)}
                        >
                          Vincular
                        </button>
                      </div>
                      {agente.descripcion && (
                        <p className="config-agente-card-desc">{agente.descripcion}</p>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}

          {/* ========== PESTA√ëA: PANEL ADMIN ========== */}
          {pestanaActiva === 'admin' && !cargando && (
            <div className="config-agente-seccion">
              {/* Formulario crear agente */}
              {!mostrarFormCrear ? (
                <button
                  className="config-agente-btn config-agente-btn--crear"
                  onClick={() => setMostrarFormCrear(true)}
                >
                  + Crear Nuevo Agente
                </button>
              ) : (
                <form className="config-agente-form" onSubmit={handleCrearAgente}>
                  <h4>Nuevo Agente</h4>
                  <div className="config-agente-form-grupo">
                    <label>Nombre *</label>
                    <input
                      type="text"
                      value={nuevoAgente.nombre}
                      onChange={e => setNuevoAgente(prev => ({ ...prev, nombre: e.target.value }))}
                      placeholder="Ej: Agente Subestaci√≥n Norte"
                      disabled={creando}
                    />
                  </div>
                  <div className="config-agente-form-grupo">
                    <label>Descripci√≥n</label>
                    <input
                      type="text"
                      value={nuevoAgente.descripcion}
                      onChange={e => setNuevoAgente(prev => ({ ...prev, descripcion: e.target.value }))}
                      placeholder="Descripci√≥n opcional"
                      disabled={creando}
                    />
                  </div>
                  <div className="config-agente-form-acciones">
                    <button
                      type="button"
                      className="config-agente-btn config-agente-btn--secundario"
                      onClick={() => setMostrarFormCrear(false)}
                      disabled={creando}
                    >
                      Cancelar
                    </button>
                    <button
                      type="submit"
                      className="config-agente-btn config-agente-btn--primario"
                      disabled={creando || !nuevoAgente.nombre.trim()}
                    >
                      {creando ? 'Creando...' : 'Crear Agente'}
                    </button>
                  </div>
                </form>
              )}

              {/* Lista de todos los agentes */}
              <div className="config-agente-admin-lista">
                <h4>Todos los Agentes del Sistema</h4>
                {todosAgentes.length === 0 ? (
                  <div className="config-agente-vacio">
                    <p>No hay agentes en el sistema</p>
                  </div>
                ) : (
                  <div className="config-agente-lista">
                    {todosAgentes.map(agente => (
                      <div key={agente.id} className="config-agente-card config-agente-card--admin">
                        <div className="config-agente-card-header">
                          <div className="config-agente-card-info">
                            <h3>{agente.nombre}</h3>
                            {renderEstadoConexion(agente)}
                            {!agente.activo && (
                              <span className="config-agente-badge config-agente-badge--inactivo">Inactivo</span>
                            )}
                          </div>
                          <div className="config-agente-card-acciones">
                            <button
                              className="config-agente-btn-icon"
                              onClick={() => toggleRegistradores(agente.id)}
                              title="Ver registradores"
                            >
                              {agenteExpandido === agente.id ? '‚ñ≤' : '‚ñº'}
                            </button>
                            <button
                              className="config-agente-btn-icon"
                              onClick={() => handleRotarClave(agente.id)}
                              title="Rotar clave"
                            >
                              üîë
                            </button>
                            <button
                              className="config-agente-btn-icon config-agente-btn-icon--danger"
                              onClick={() => handleEliminarAgente(agente.id, agente.nombre)}
                              title="Eliminar"
                            >
                              üóë
                            </button>
                          </div>
                        </div>
                        {agente.descripcion && (
                          <p className="config-agente-card-desc">{agente.descripcion}</p>
                        )}
                        {agenteExpandido === agente.id && (
                          <div className="config-agente-card-regs">
                            <h4>Registradores</h4>
                            {renderRegistradores(agente.id, true)}
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        {/* Modal de resultado del test */}
        {resultadoTest && (
          <div className="config-agente-test-overlay" onClick={() => setResultadoTest(null)}>
            <div className="config-agente-test-modal" onClick={e => e.stopPropagation()}>
              <div className="config-agente-test-header">
                <h3>Resultado del Test</h3>
                <button className="config-agente-cerrar" onClick={() => setResultadoTest(null)}>√ó</button>
              </div>
              <div className="config-agente-test-contenido">
                <div className="config-agente-test-info">
                  <strong>{resultadoTest.registrador?.nombre}</strong>
                  <span className="config-agente-test-detalle">
                    {resultadoTest.registrador?.ip}:{resultadoTest.registrador?.puerto}
                  </span>
                </div>

                {resultadoTest.exito ? (
                  <div className="config-agente-test-exito">
                    <div className="config-agente-test-icono">‚úì</div>
                    <h4>Conexi√≥n Exitosa</h4>
                    <p className="config-agente-test-tiempo">
                      Tiempo de respuesta: <strong>{resultadoTest.tiempo_respuesta_ms}ms</strong>
                    </p>
                    {resultadoTest.valores && resultadoTest.valores.length > 0 && (
                      <div className="config-agente-test-valores">
                        <h5>Valores le√≠dos ({resultadoTest.valores.length} registros):</h5>
                        <div className="config-agente-test-valores-grid">
                          {resultadoTest.valores.map((valor, idx) => (
                            <div key={idx} className="config-agente-test-valor">
                              <span className="config-agente-test-valor-idx">
                                [{resultadoTest.registrador?.indice_inicial + idx}]
                              </span>
                              <span className="config-agente-test-valor-num">{valor}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                ) : (
                  <div className="config-agente-test-error">
                    <div className="config-agente-test-icono config-agente-test-icono--error">‚úó</div>
                    <h4>
                      {resultadoTest.estado === 'timeout' && 'Tiempo Agotado'}
                      {resultadoTest.estado === 'cooldown' && 'Espera Requerida'}
                      {resultadoTest.estado === 'error' && 'Error de Conexi√≥n'}
                    </h4>
                    <p className="config-agente-test-mensaje">{resultadoTest.error_mensaje}</p>
                    {resultadoTest.tiempo_respuesta_ms && (
                      <p className="config-agente-test-tiempo">
                        Tiempo transcurrido: {resultadoTest.tiempo_respuesta_ms}ms
                      </p>
                    )}
                  </div>
                )}
              </div>
              <div className="config-agente-test-acciones">
                <button
                  className="config-agente-btn config-agente-btn--primario"
                  onClick={() => setResultadoTest(null)}
                >
                  Cerrar
                </button>
              </div>
            </div>
          </div>
        )}

      {/* Indicador de test en progreso */}
      {testEnCurso && (
        <div className="config-agente-test-progreso">
          <div className="config-agente-test-progreso-contenido">
            <span className="config-agente-spinner"></span>
            <span>Esperando respuesta del agente...</span>
            <div className="config-agente-test-progreso-barra">
              <div
                className="config-agente-test-progreso-fill"
                style={{ width: `${testEnCurso.progreso}%` }}
              ></div>
            </div>
          </div>
        </div>
      )}

      {/* Handle de resize en esquina inferior derecha */}
      {!maximizada && (
        <div
          className="config-agente-resize-handle"
          onMouseDown={handleResizeMouseDown}
          title="Arrastrar para redimensionar"
        />
      )}
    </div>
  );
};

export default ModalConfigurarAgente;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfirmacion.css =====

/* src/paginas/PaginaAlimentadores/componentes/modales/ModalConfirmacion.css */
/* Estilos para el modal de confirmaci√≥n - mismo estilo que ModalEditarPuestos */

/* Fondo oscuro del overlay */
.confirmacion-fondo-oscuro {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1100; /* Mayor que el men√∫ del selector */
}

/* Contenedor principal del modal */
.confirmacion-contenedor {
  border-radius: 18px;
  padding: 1.5rem 1.8rem;
  box-shadow: 0 18px 45px rgba(15, 23, 42, 0.35);
  max-width: 400px;
  width: 90%;
  box-sizing: border-box;
  background: #0f172a;
  color: #e2e8f0;
  animation: confirmacion-aparecer 0.2s ease-out;
}

@keyframes confirmacion-aparecer {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.confirmacion-contenedor h2 {
  margin: 0 0 1rem 0;
  font-size: 1.2rem;
  font-weight: 600;
  color: #e2e8f0;
}

/* Mensaje de confirmaci√≥n */
.confirmacion-mensaje {
  margin: 0 0 1.5rem 0;
  font-size: 0.95rem;
  color: #94a3b8;
  line-height: 1.5;
}

/* Contenedor de botones de acci√≥n */
.confirmacion-acciones {
  display: flex;
  justify-content: flex-end;
  gap: 0.8rem;
}

/* Botones base */
.confirmacion-boton {
  min-width: 100px;
  padding: 0.6rem 1.2rem;
  border-radius: 8px;
  border: none;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.15s ease;
}

/* Bot√≥n Cancelar: gris oscuro */
.confirmacion-cancelar {
  background-color: #334155;
  color: #e2e8f0;
}

.confirmacion-cancelar:hover {
  background-color: #475569;
}

/* Bot√≥n Confirmar: celeste (acci√≥n normal) */
.confirmacion-confirmar {
  background-color: #0ea5e9;
  color: #ffffff;
  box-shadow: 0 4px 12px rgba(14, 165, 233, 0.25);
}

.confirmacion-confirmar:hover {
  background-color: #0284c7;
}

/* Bot√≥n Peligro: rojo (para acciones destructivas) */
.confirmacion-peligro {
  background-color: #dc2626;
  color: #ffffff;
  box-shadow: 0 4px 12px rgba(220, 38, 38, 0.25);
}

.confirmacion-peligro:hover {
  background-color: #b91c1c;
}

/* Responsive */
@media (max-width: 480px) {
  .confirmacion-contenedor {
    padding: 1.2rem 1rem;
    margin: 0 0.5rem;
  }

  .confirmacion-acciones {
    flex-direction: column;
    gap: 0.6rem;
  }

  .confirmacion-boton {
    width: 100%;
    min-width: unset;
  }
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfirmacion.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfirmacion.jsx
// Modal de confirmaci√≥n reutilizable con estilo oscuro

import React from "react";
import "./ModalConfirmacion.css";

/**
 * Modal de confirmaci√≥n gen√©rico.
 * Muestra un mensaje y dos botones: Cancelar y Confirmar.
 */
const ModalConfirmacion = ({
  abierto,
  titulo = "Confirmar acci√≥n",
  mensaje,
  textoConfirmar = "Confirmar",
  textoCancelar = "Cancelar",
  onConfirmar,
  onCancelar,
  peligroso = false, // Si es true, el bot√≥n de confirmar ser√° rojo
}) => {
  if (!abierto) return null;

  return (
    <div className="confirmacion-fondo-oscuro">
      <div className="confirmacion-contenedor">
        <h2>{titulo}</h2>
        <p className="confirmacion-mensaje">{mensaje}</p>

        <div className="confirmacion-acciones">
          <button
            type="button"
            className="confirmacion-boton confirmacion-cancelar"
            onClick={onCancelar}
          >
            {textoCancelar}
          </button>
          <button
            type="button"
            className={`confirmacion-boton ${peligroso ? "confirmacion-peligro" : "confirmacion-confirmar"}`}
            onClick={onConfirmar}
          >
            {textoConfirmar}
          </button>
        </div>
      </div>
    </div>
  );
};

export default ModalConfirmacion;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalEditarPuestos.css =====

/* src/paginas/PaginaAlimentadores/componentes/modales/ModalEditarPuestos.css */
/*
  NOTA SOBRE ESTE ARCHIVO (ModalEditarPuestos.css)
  - Estilos espec√≠ficos del modal para editar puestos: define el contenedor
    oscuro, la lista de filas editables, los pickers de color y el bot√≥n
    "Eliminar".

  - Usa nombres √∫nicos con prefijo "editar-" para evitar conflictos con
    otros archivos CSS de modales.

  - Incluye una secci√≥n `@media (max-width: 520px)` que reorganiza los
    controles en columna y en grid para que sea c√≥modo usarlo en pantallas
    chicas (celular / tablet).
*/

/* Fondo oscuro del overlay */
.editar-fondo-oscuro {
   position: fixed;
   top: 0;
   left: 0;
   right: 0;
   bottom: 0;
   background: rgba(0, 0, 0, 0.7);
   display: flex;
   align-items: center;
   justify-content: center;
   z-index: 1000;
}

/* Contenedor principal del modal */
.editar-contenedor {
   border-radius: 18px;
   padding: 1.0rem 1.3rem;
   box-shadow: 0 18px 45px rgba(15, 23, 42, 0.35);
   max-width: 503px;
   width: 100%;
   box-sizing: border-box;
   background: #28374e;
   color: #e2e8f0;
   transition: max-width 0.2s ease;
}

/* Modal m√°s ancho cuando est√° en la pesta√±a de Apariencia */
/* Necesita espacio para: controles (~380px) + gap (24px) + tarjeta (304px) + padding */
.editar-contenedor--apariencia {
   max-width: 900px;
}

.editar-contenedor h2 {
   margin: 0 0 0.9rem 0;
   font-size: 1.2rem;
   font-weight: 600;
   color: #e2e8f0;
}

/* =========================================================
   SISTEMA DE TABS
   ========================================================= */
.editar-tabs {
   display: flex;
   border: 1px solid #475569;
   border-radius: 8px;
   overflow: hidden;
   margin-bottom: 1rem;
}

.editar-tab {
   flex: 1;
   padding: 0.6rem 1rem;
   background: transparent;
   border: none;
   border-right: 1px solid #475569;
   color: #94a3b8;
   font-size: 0.85rem;
   font-weight: 500;
   cursor: pointer;
   transition: all 0.15s ease;
}

.editar-tab:last-child {
   border-right: none;
}

.editar-tab:hover:not(.editar-tab--activo) {
   background: rgba(148, 163, 184, 0.1);
   color: #e2e8f0;
}

.editar-tab--activo {
   background: #0ea5e9;
   color: #ffffff;
}

/* Lista de puestos a editar */
.editar-lista {
   display: flex;
   flex-direction: column;
   gap: 0.6rem;
}

/* Cada fila de edicion (desktop) */
.editar-fila {
   display: flex;
   align-items: flex-end;
   flex-wrap: wrap;
   gap: 0.9rem;
   padding: 0.8rem 0.5rem 0.8rem 0.7rem;
   border-radius: 14px;
   background: #0f172a;
   border: 1px solid #334155;
   box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
}

.editar-fila:hover {
   background: #1e293b;
   border-color: #475569;
   box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

/* Input del nombre del puesto */
.editar-nombre {
   flex: 1;
   min-width: 120px;
   max-width: 240px;
   padding: 0.55rem 0.9rem;
   border-radius: 8px;
   border: 1px solid #475569;
   background:  #26354b;
   color: #e2e8f0;
   font-size: 0.9rem;
}

.editar-nombre:focus {
   outline: none;
   border-color: #06b6d4;
   box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.3);
   background: #0f172a;
}

/* Contenedor de controles: colores + boton eliminar (desktop) */
.editar-controles {
   display: flex;
   align-items: flex-end;
   gap: 0.8rem;
   flex-shrink: 0;
   justify-content: flex-end;
}

/* Control de escala por puesto */
.editar-escala {
   display: flex;
   flex-direction: column;
   align-items: center;
   gap: 2px;
}

.editar-escala-label {
   font-size: 14px;
   color: #94a3b8;
   font-weight: 500;
}

.editar-escala-input {
   width: 60px;
   padding: 0.4rem 0.5rem;
   border-radius: 6px;
   border: 1px solid #475569;
   background: #1e293b;
   color: #e2e8f0;
   font-size: 0.85rem;
   text-align: center;
   font-family: "DS-Digital", "Courier New", monospace;
}

/* Ocultar flechas del input number */
.editar-escala-input::-webkit-outer-spin-button,
.editar-escala-input::-webkit-inner-spin-button {
   -webkit-appearance: none;
   margin: 0;
}
.editar-escala-input[type="number"] {
   -moz-appearance: textfield;
   appearance: textfield;
}

.editar-escala-input:focus {
   outline: none;
   border-color: #60a5fa;
   box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.3);
}

/* Boton ELIMINAR */
.editar-eliminar {
   padding: 0.55rem 0.9rem;
   border-radius: 8px;
   border: 1px solid #fca5a5;
   background-color: #fee2e2;
   color: #b91c1c;
   font-size: 0.8rem;
   font-weight: 700;
   cursor: pointer;
   white-space: nowrap;
}

.editar-eliminar:hover {
   background-color: #fecaca;
}

/* Contenedor de botones de acci√≥n */
.editar-acciones {
	display: flex;
   justify-content: flex-end;
   gap: 0.6rem;
   margin-top: 1.5rem;
   margin-bottom: 0.1rem;
}

/* Botones base */
.editar-boton {
   min-width: 96px;
   padding: 0.5rem 1.1rem;
   border-radius: 8px;
   border: none;
   font-size: 0.9rem;
   font-weight: 500;
   cursor: pointer;
}

/* Boton Cancelar: gris oscuro */
.editar-cancelar {
   background-color: #334155;
   color: #e2e8f0;
}

.editar-cancelar:hover {
   background-color: #475569;
}

/* Boton Guardar: celeste */
.editar-guardar {
   background-color: #0ea5e9;
   color: #ffffff;
   box-shadow: 0 10px 22px rgba(14, 165, 233, 0.1);
}

.editar-guardar:hover {
   background-color: #0284c7;
}

/* =========================================================
   MODAL "EDITAR PUESTOS" RESPONSIVE
   ========================================================= */
@media (max-width: 520px) {
   /* El modal ocupa casi todo el ancho de la pantalla */
   .editar-contenedor {
      max-width: calc(100vw - 1rem);
      max-height: calc(100vh - 2rem);
      max-height: calc(100dvh - 2rem);
      margin: 0.5rem;
      padding: 1rem 0.9rem;
      display: flex;
      flex-direction: column;
      overflow: hidden;
   }

   /* En modo m√≥vil, la pesta√±a Apariencia NO debe hacer el modal m√°s ancho */
   .editar-contenedor--apariencia {
      max-width: calc(100vw - 1rem);
   }

   /* Lista de puestos con scroll */
   .editar-lista {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      max-height: calc(100vh - 14rem);
      max-height: calc(100dvh - 14rem);
   }

   /* Cada fila pasa a columna, con mas aire */
   .editar-fila {
      flex-direction: column;
      align-items: stretch;
      gap: 0.7rem;
      padding: 0.9rem 1rem;
   }

   /* Input a lo ancho, quitando max-width y usando box-sizing */
   .editar-nombre {
      width: 100%;
      max-width: none;
      box-sizing: border-box;
   }

   /* Contenedor de colores + eliminar en GRID:
	   fila 1 -> Boton | Fondo
	   fila 2 -> Eliminar ocupando todo el ancho */
   .editar-controles {
      width: 100%;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      column-gap: 0.9rem;
      row-gap: 0.5rem;
      align-items: center;
      margin-top: 0.2rem;
   }

   /* Boton eliminar ocupa las 2 columnas (todo el ancho) */
   .editar-eliminar {
      grid-column: 1 / -1;
      width: 100%;
      text-align: center;
      justify-content: center;
      margin-top: 0.1rem;
   }

   /* Botones inferiores siempre visibles (no scroll) */
   .editar-acciones {
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.8rem;
      flex-shrink: 0;
      padding-top: 0.5rem;
      margin-top: 1rem;
   }

   .editar-boton {
      min-width: 120px;
   }
}

/* =========================================================
   OVERLAY DE GUARDANDO
   ========================================================= */

/* Contenedor cuando est√° guardando */
.editar-contenedor--guardando {
   position: relative;
}

/* Overlay semitransparente sobre el contenido */
.editar-overlay-guardando {
   position: absolute;
   top: 0;
   left: 0;
   right: 0;
   bottom: 0;
   background: rgba(15, 23, 42, 0.85);
   border-radius: 18px;
   display: flex;
   flex-direction: column;
   align-items: center;
   justify-content: center;
   gap: 16px;
   z-index: 10;
}

/* Spinner animado */
.editar-overlay-spinner {
   width: 40px;
   height: 40px;
   border: 3px solid rgba(255, 255, 255, 0.2);
   border-top-color: #0ea5e9;
   border-radius: 50%;
   animation: editar-spin 0.8s linear infinite;
}

@keyframes editar-spin {
   to {
      transform: rotate(360deg);
   }
}

/* Texto del overlay */
.editar-overlay-texto {
   color: #f1f5f9;
   font-size: 1rem;
   font-weight: 500;
}

/* Botones deshabilitados durante guardado */
.editar-boton:disabled {
   opacity: 0.6;
   cursor: not-allowed;
}

.editar-eliminar:disabled {
   opacity: 0.5;
   cursor: not-allowed;
}

.editar-nombre:disabled {
   opacity: 0.6;
   cursor: not-allowed;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalEditarPuestos.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalEditarPuestos.jsx

import React, { useState, useEffect } from "react";      // React + hooks para estado y efectos
import "./ModalEditarPuestos.css";                       // estilos espec√≠ficos de este modal
import ColorPickerSimple from "./ColorPickerSimple";     // selector de color minimalista
import TabApariencia from "./TabApariencia";             // pesta√±a de apariencia global

// Componente interno para el input de escala con estado local
const InputEscala = ({ valor, onChange, min, max }) => {
	const [valorLocal, setValorLocal] = useState(valor?.toString() ?? "1");

	// Sincronizar cuando cambia el valor externo
	useEffect(() => {
		setValorLocal(valor?.toString() ?? "1");
	}, [valor]);

	const aplicarCambio = () => {
		const valorNum = parseFloat(valorLocal);
		if (!isNaN(valorNum)) {
			const valorClamped = Math.max(min, Math.min(max, valorNum));
			onChange(valorClamped);
			setValorLocal(valorClamped.toString());
		} else {
			// Si no es v√°lido, restaurar al valor original
			setValorLocal(valor?.toString() ?? "1");
		}
	};

	const handleKeyDown = (e) => {
		if (e.key === "Enter") {
			aplicarCambio();
			e.target.blur();
		}
	};

	return (
		<input
			type="number"
			step="0.1"
			min={min}
			max={max}
			value={valorLocal}
			onChange={(e) => setValorLocal(e.target.value)}
			onBlur={aplicarCambio}
			onKeyDown={handleKeyDown}
			className="editar-escala-input"
		/>
	);
};

const ModalEditarPuestos = ({
	abierto,                                              // si es false, el modal no se renderiza
	puestos,                                              // lista original de puestos proveniente del contexto
	onCerrar,                                             // callback para cerrar sin guardar
	onGuardar,                                            // callback que recibe los puestos modificados
	esCreador,                                            // si el usuario es creador del workspace
	rolEnWorkspace,                                       // rol del usuario en el workspace (admin, operador, observador)
	// Props de escala por puesto
	obtenerEscalaPuesto,                                  // (puestoId) => number | undefined
	onEscalaPuestoChange,                                 // (puestoId, escala) => void
	ESCALA_MIN = 0.5,
	ESCALA_MAX = 2.0,
	// Props de estilos globales (para pesta√±a Apariencia)
	estilosGlobales,                                      // objeto con estilos actuales
	onGuardarEstilos,                                     // callback para guardar todos los estilos
}) => {
	const [puestosEditados, setPuestosEditados] = useState([]); // copia editable local
	const [tabActiva, setTabActiva] = useState("puestos");      // "puestos" o "apariencia"

	// Solo el creador o admin en el workspace pueden editar nombres y eliminar puestos
	// Operador y observador solo pueden cambiar colores y escala (son preferencias de usuario)
	const puedeEditarNombre = esCreador || rolEnWorkspace === 'admin';

	useEffect(() => {
		if (abierto) {
			// cuando se abre, clono el array de puestos para no mutar el original
			setPuestosEditados(puestos.map((p) => ({ ...p })));
		}
	}, [abierto, puestos]);

	const handleSubmit = () => {
		onGuardar(puestosEditados);                       // devuelvo al caller la versi√≥n editada
	};

	const cambiarNombre = (id, nombreNuevo) => {
		// recorro el array y s√≥lo modifico el puesto que coincide por id
		setPuestosEditados((prev) =>
			prev.map((p) => (p.id === id ? { ...p, nombre: nombreNuevo } : p))
		);
	};

	const cambiarColorBoton = (id, colorNuevo) => {
		setPuestosEditados((prev) =>
			prev.map((p) => (p.id === id ? { ...p, color: colorNuevo } : p))
		);
	};

	const cambiarColorFondo = (id, colorNuevo) => {
		setPuestosEditados((prev) =>
			prev.map((p) => (p.id === id ? { ...p, bgColor: colorNuevo } : p))
		);
	};

	const eliminar = (id) => {
		// filtro el puesto con ese id para "borrarlo" de la lista local
		setPuestosEditados((prev) => prev.filter((p) => p.id !== id));
	};

	if (!abierto) return null;                            // si no est√° abierto, no dibujo nada

	// Clase condicional para hacer el modal m√°s ancho en la pesta√±a de Apariencia
	const clasesContenedor = `editar-contenedor${tabActiva === "apariencia" ? " editar-contenedor--apariencia" : ""}`;

	return (
		<div className="editar-fondo-oscuro">
			<div className={clasesContenedor}>
				<h2>Configuraci√≥n</h2>

				{/* Sistema de tabs */}
				<div className="editar-tabs">
					<button
						type="button"
						className={`editar-tab ${tabActiva === "puestos" ? "editar-tab--activo" : ""}`}
						onClick={() => setTabActiva("puestos")}
					>
						Puestos
					</button>
					<button
						type="button"
						className={`editar-tab ${tabActiva === "apariencia" ? "editar-tab--activo" : ""}`}
						onClick={() => setTabActiva("apariencia")}
					>
						Apariencia
					</button>
				</div>

				{/* Contenido de la tab activa */}
				{tabActiva === "puestos" ? (
					<div className="editar-lista">
						{puestosEditados.map((p) => (
							<div key={p.id} className="editar-fila">
								<input
									type="text"
									className="editar-nombre"
									value={p.nombre}
									onChange={(e) => cambiarNombre(p.id, e.target.value)} // actualiza nombre en la copia local
									disabled={!puedeEditarNombre}                         // solo admin/superadmin pueden editar nombre
								/>

								<div className="editar-controles">
									<ColorPickerSimple
										color={p.color || "#22c55e"}
										onChange={(newColor) => cambiarColorBoton(p.id, newColor)}
										label="Bot√≥n"
									/>

									<ColorPickerSimple
										color={p.bgColor || "#e5e7eb"}
										onChange={(newColor) => cambiarColorFondo(p.id, newColor)}
										label="Fondo"
									/>

									{/* Control de escala por puesto */}
									{obtenerEscalaPuesto && onEscalaPuestoChange && (
										<div className="editar-escala">
											<label className="editar-escala-label">(0.5 - 2)</label>
											<InputEscala
												valor={obtenerEscalaPuesto(p.id) ?? 1.0}
												onChange={(nuevoValor) => onEscalaPuestoChange(p.id, nuevoValor)}
												min={ESCALA_MIN}
												max={ESCALA_MAX}
											/>
										</div>
									)}

									{/* Solo admin/superadmin pueden eliminar puestos */}
									{puedeEditarNombre && (
										<button
											type="button"
											className="editar-eliminar"
											onClick={() => eliminar(p.id)}             // elimina el puesto de la lista local
										>
											Eliminar
										</button>
									)}
								</div>
							</div>
						))}
					</div>
				) : (
					/* Pesta√±a de Apariencia - tiene su propio footer con botones */
					estilosGlobales && (
						<TabApariencia
							estilosIniciales={estilosGlobales}
							onGuardar={(nuevosEstilos) => {
								onGuardarEstilos(nuevosEstilos);
								onCerrar();
							}}
							onCancelar={onCerrar}
						/>
					)
				)}

				{/* Solo mostrar botones para la pesta√±a de Puestos */}
				{tabActiva === "puestos" && (
					<div className="editar-acciones">
						<button
							type="button"
							className="editar-boton editar-cancelar"
							onClick={onCerrar}
						>
							Cancelar
						</button>
						<button
							type="button"
							className="editar-boton editar-guardar"
							onClick={handleSubmit}
						>
							Guardar
						</button>
					</div>
				)}
			</div>
		</div>
	);
};

export default ModalEditarPuestos;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (ModalEditarPuestos.jsx)

 - Este modal funciona como un "panel de edici√≥n masiva" para todos los puestos:
   permite renombrarlos, cambiar el color del bot√≥n y el color de fondo, o
   directamente eliminarlos.

 - Al abrirse (`abierto === true`), clona el array `puestos` en `puestosEditados`
   para trabajar siempre sobre una copia local y no mutar el estado global
   del contexto hasta que realmente aprieto "Guardar".

 - Cada helper (`cambiarNombre`, `cambiarColorBoton`, `cambiarColorFondo`,
   `eliminar`) modifica s√≥lo el puesto indicado buscando por `id` y usando
   funciones de actualizaci√≥n inmutables (`map` / `filter`).

 - Al confirmar, `handleSubmit` llama a `onGuardar(puestosEditados)` y el
   componente padre decide c√≥mo persistir esos cambios (por ejemplo, usando
   `usarPuestos` y guardando en localStorage).

 - Si alguna vez quiero agregar m√°s propiedades editables (por ejemplo, un
   "orden" o una descripci√≥n), basta con extender el objeto `p` y agregar
   los campos en esta lista, manteniendo el mismo patr√≥n de edici√≥n local.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (ModalEditarPuestos.jsx)

0) Visi√≥n general del componente

   `ModalEditarPuestos` es un panel de edici√≥n masiva de puestos. Permite:

   - Cambiar el nombre de cada puesto.
   - Cambiar el color del bot√≥n del puesto (color principal).
   - Cambiar el color de fondo asociado a ese puesto.
   - Eliminar puestos completos de la lista.

   La gracia es que todo se hace sobre una copia local (`puestosEditados`) y
   reci√©n cuando el usuario pulsa ‚ÄúGuardar‚Äù se env√≠an los cambios al exterior.


1) Props del componente

   const ModalEditarPuestos = ({
     abierto,
     puestos,
     onCerrar,
     onGuardar,
   }) => { ... }

   - `abierto` (boolean):
       ‚Ä¢ Si es false    ‚Üí el modal no se renderiza (devuelve `null`).
       ‚Ä¢ Si es true     ‚Üí se dibuja overlay + contenido del modal.

   - `puestos` (array):
       ‚Ä¢ Lista de puestos que viene del contexto/global.
       ‚Ä¢ Cada elemento suele ser algo como:
         { id, nombre, color, bgColor, ... }.

   - `onCerrar()`:
       ‚Ä¢ Se llama al pulsar ‚ÄúCancelar‚Äù o cuando se quiera cerrar sin guardar.

   - `onGuardar(puestosEditados)`:
       ‚Ä¢ Recibe la versi√≥n editada de la lista de puestos,
       ‚Ä¢ El padre (VistaAlimentadores / usarPuestos) decide c√≥mo persistirla
         (estado global, localStorage, etc.).


2) Estado local y sincronizaci√≥n al abrir

   const [puestosEditados, setPuestosEditados] = useState([]);

   - `puestosEditados` es una copia editable de `puestos`:
       ‚Ä¢ Esto evita modificar directamente el array original del contexto.
       ‚Ä¢ Permite descartar cambios f√°cilmente si el usuario cancela.

   useEffect(() => {
     if (abierto) {
       setPuestosEditados(puestos.map((p) => ({ ...p })));
     }
   }, [abierto, puestos]);

   - Cuando el modal se abre (`abierto` pasa a true):

       1) Se recorre `puestos` y se crea un nuevo array con copias
          superficiales de cada puesto (`{ ...p }`).
       2) Se guarda en `puestosEditados`.

   - De esta forma:
       ‚Ä¢ el usuario siempre edita la versi√≥n m√°s actual de la lista,
       ‚Ä¢ y no hay riesgo de mutar accidentalmente el array original.


3) Handlers de actualizaci√≥n

   3.1) handleSubmit

   const handleSubmit = () => {
     onGuardar(puestosEditados);
   };

   - Se ejecuta al pulsar el bot√≥n ‚ÄúGuardar‚Äù.
   - Entrega la lista `puestosEditados` al exterior.
   - A partir de ah√≠, el componente padre decide:
       ‚Ä¢ actualizar el contexto (`actualizarPuestos`),
       ‚Ä¢ cerrar el modal,
       ‚Ä¢ y persistir si hace falta.

   3.2) cambiarNombre(id, nombreNuevo)

   - Busca el puesto con ese `id` y actualiza solo su `nombre`:

       setPuestosEditados((prev) =>
         prev.map((p) => p.id === id ? { ...p, nombre: nombreNuevo } : p)
       );

   - Se apoya en:
       ‚Ä¢ `map` ‚Üí devuelve un nuevo array,
       ‚Ä¢ spread `{ ...p, nombre: nombreNuevo }` ‚Üí respeta inmutabilidad.

   3.3) cambiarColorBoton(id, colorNuevo)

   - Mismo patr√≥n que `cambiarNombre`, pero actualizando `color`.

   3.4) cambiarColorFondo(id, colorNuevo)

   - Mismo patr√≥n, pero actualizando `bgColor`, que es el color de fondo
     del puesto (usado luego en el `<main>` de VistaAlimentadores).

   3.5) eliminar(id)

   - Elimina el puesto con ese `id` de la copia local:

       setPuestosEditados((prev) => prev.filter((p) => p.id !== id));

   - Solo afecta al listado interno del modal; el estado global no se toca
     hasta que se pulsa ‚ÄúGuardar‚Äù.


4) L√≥gica de renderizado condicional

   if (!abierto) return null;

   - Si el modal no est√° abierto, no se renderiza nada.
   - Esto ahorra trabajo de React y evita que el overlay interfiera con la UI.


5) Estructura JSX del modal

   5.1) Overlay y contenedor

   - `<div className="alim-modal-overlay">`:
       ‚Ä¢ fondo semitransparente que oscurece la pantalla.

   - `<div className="alim-modal">`:
       ‚Ä¢ caja blanca centrada donde vive el contenido del modal.

   5.2) Lista editable de puestos

   {puestosEditados.map((p) => (
     <div key={p.id} className="alim-edit-row">
       <input ... value={p.nombre} onChange={(e) => cambiarNombre(...)} />
       ...
       <input type="color" ... value={p.color} onChange={...} />
       <input type="color" ... value={p.bgColor || "#e5e7eb"} onChange={...} />
       <button onClick={() => eliminar(p.id)}>Eliminar</button>
     </div>
   ))}

   - Por cada puesto se dibuja una fila con:

       ‚Ä¢ Input de texto para el nombre:
           - enlazado a `p.nombre`,
           - cualquier cambio llama a `cambiarNombre`.

       ‚Ä¢ Dos ‚Äúpickers‚Äù de color:
           - uno para el color del bot√≥n (`p.color`),
           - otro para el color de fondo (`p.bgColor` o gris claro por defecto).
           - ambos actualizan la copia local por medio de sus handlers.

       ‚Ä¢ Bot√≥n ‚ÄúEliminar‚Äù:
           - quita el puesto de `puestosEditados`.
           - la eliminaci√≥n real se consolida solo si se pulsa ‚ÄúGuardar‚Äù.

   5.3) Botones de acci√≥n

   - Bot√≥n ‚ÄúCancelar‚Äù:
       ‚Ä¢ type="button",
       ‚Ä¢ llama a `onCerrar`,
       ‚Ä¢ descarta cualquier cambio hecho desde que se abri√≥ el modal.

   - Bot√≥n ‚ÄúGuardar‚Äù:
       ‚Ä¢ type="button",
       ‚Ä¢ llama a `handleSubmit`,
       ‚Ä¢ env√≠a `puestosEditados` al padre para que los persista.

---------------------------------------------------------------------------*/
// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalGestionarAccesos.css =====

/* src/paginas/PaginaAlimentadores/componentes/modales/ModalGestionarAccesos.css */
/* Estilos espec√≠ficos del modal de gesti√≥n de accesos */

.modal-accesos {
  max-width: 550px;
  width: 95%;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
}

/* Header */
.modal-accesos__header {
  padding-bottom: 0.75rem;
  border-bottom: 1px solid #374151;
  margin-bottom: 1rem;
}

.modal-accesos__header h2 {
  margin: 0 0 0.25rem 0;
  font-size: 1.25rem;
  color: #f3f4f6;
}

.modal-accesos__workspace-nombre {
  font-size: 0.875rem;
  color: #9ca3af;
}

/* Contenido scrolleable */
.modal-accesos__contenido {
  flex: 1;
  overflow-y: auto;
  padding-right: 0.5rem;
}

/* Secciones */
.modal-accesos__seccion {
  margin-bottom: 1.5rem;
}

.modal-accesos__seccion h3 {
  font-size: 0.9rem;
  font-weight: 600;
  color: #d1d5db;
  margin: 0 0 0.75rem 0;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* Form de invitaci√≥n */
.modal-accesos__form-invitar {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.modal-accesos__form-invitar .alim-modal-input {
  flex: 1;
  min-width: 200px;
}

.modal-accesos__form-invitar .alim-modal-select {
  width: 140px;
  padding: 0.5rem;
  border: 1px solid #374151;
  border-radius: 6px;
  background-color: #1f2937;
  color: #f3f4f6;
  font-size: 0.875rem;
}

.modal-accesos__btn-invitar {
  padding: 0.5rem 1rem;
  background-color: #3b82f6;
  color: white;
  border: none;
  border-radius: 6px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.15s;
  white-space: nowrap;
}

.modal-accesos__btn-invitar:hover:not(:disabled) {
  background-color: #2563eb;
}

.modal-accesos__btn-invitar:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Mensajes */
.modal-accesos__mensaje {
  margin-top: 0.5rem;
  padding: 0.5rem 0.75rem;
  border-radius: 4px;
  font-size: 0.875rem;
}

.modal-accesos__mensaje--error {
  background-color: rgba(239, 68, 68, 0.1);
  color: #f87171;
  border: 1px solid rgba(239, 68, 68, 0.2);
}

.modal-accesos__mensaje--exito {
  background-color: rgba(34, 197, 94, 0.1);
  color: #4ade80;
  border: 1px solid rgba(34, 197, 94, 0.2);
}

/* Estados de carga/error/vac√≠o */
.modal-accesos__cargando,
.modal-accesos__vacio {
  text-align: center;
  padding: 1.5rem;
  color: #9ca3af;
  font-size: 0.875rem;
}

.modal-accesos__error {
  text-align: center;
  padding: 1rem;
  color: #f87171;
  font-size: 0.875rem;
}

.modal-accesos__error button {
  margin-top: 0.5rem;
  padding: 0.25rem 0.75rem;
  background-color: #374151;
  color: #f3f4f6;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* Lista de usuarios */
.modal-accesos__lista {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.modal-accesos__usuario {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem;
  background-color: #1f2937;
  border: 1px solid #374151;
  border-radius: 8px;
  gap: 0.75rem;
}

.modal-accesos__usuario-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex: 1;
  min-width: 0;
}

.modal-accesos__usuario-icono {
  font-size: 1.25rem;
  flex-shrink: 0;
}

.modal-accesos__usuario-datos {
  display: flex;
  flex-direction: column;
  min-width: 0;
}

.modal-accesos__usuario-nombre {
  font-weight: 500;
  color: #f3f4f6;
  font-size: 0.9rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.modal-accesos__usuario-email {
  font-size: 0.8rem;
  color: #9ca3af;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.modal-accesos__usuario-acciones {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex-shrink: 0;
}

.modal-accesos__select-rol {
  padding: 0.35rem 0.5rem;
  border: 1px solid #374151;
  border-radius: 4px;
  background-color: #111827;
  color: #f3f4f6;
  font-size: 0.8rem;
  cursor: pointer;
}

.modal-accesos__select-rol:hover {
  border-color: #4b5563;
}

.modal-accesos__btn-eliminar {
  width: 28px;
  height: 28px;
  padding: 0;
  border: none;
  border-radius: 4px;
  background-color: transparent;
  color: #9ca3af;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-accesos__btn-eliminar:hover {
  background-color: rgba(239, 68, 68, 0.1);
  color: #f87171;
}

/* Footer */
.modal-accesos__footer {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid #374151;
  display: flex;
  justify-content: flex-end;
}

/* Responsive */
@media (max-width: 500px) {
  .modal-accesos__form-invitar {
    flex-direction: column;
  }

  .modal-accesos__form-invitar .alim-modal-input,
  .modal-accesos__form-invitar .alim-modal-select {
    width: 100%;
  }

  .modal-accesos__usuario {
    flex-direction: column;
    align-items: flex-start;
  }

  .modal-accesos__usuario-acciones {
    width: 100%;
    justify-content: flex-end;
    margin-top: 0.5rem;
  }
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalGestionarAccesos.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalGestionarAccesos.jsx
// Modal para gestionar usuarios con acceso a un workspace

import React, { useState, useEffect } from "react";
import "./ModalConfiguracionAlimentador.css"; // estilos base del modal
import "./ModalGestionarAccesos.css";         // estilos espec√≠ficos
import {
  obtenerPermisosWorkspace,
  agregarPermisoWorkspace,
  actualizarPermisoWorkspace,
  eliminarPermisoWorkspace,
} from "../../../../servicios/apiService";

/**
 * Modal para gestionar los accesos (permisos) de usuarios a un workspace.
 * Permite ver usuarios con acceso, invitar nuevos y cambiar/revocar roles.
 */
const ModalGestionarAccesos = ({
  abierto,
  onCerrar,
  workspaceId,
  workspaceNombre,
  usuarioActualId,
}) => {
  // Estado
  const [permisos, setPermisos] = useState([]);
  const [cargando, setCargando] = useState(false);
  const [error, setError] = useState(null);

  // Form de invitaci√≥n
  const [emailInvitar, setEmailInvitar] = useState("");
  const [rolInvitar, setRolInvitar] = useState("observador");
  const [invitando, setInvitando] = useState(false);
  const [errorInvitar, setErrorInvitar] = useState(null);
  const [exitoInvitar, setExitoInvitar] = useState(null);

  // Roles disponibles para asignar (no incluye superadmin)
  const rolesDisponibles = [
    { codigo: "observador", nombre: "Observador", descripcion: "Solo puede ver datos" },
    { codigo: "operador", nombre: "Operador", descripcion: "Puede operar mediciones" },
    { codigo: "admin", nombre: "Administrador", descripcion: "Puede gestionar el workspace" },
  ];

  // Cargar permisos al abrir
  useEffect(() => {
    if (abierto && workspaceId) {
      cargarPermisos();
    }
  }, [abierto, workspaceId]);

  // Limpiar estado al cerrar
  useEffect(() => {
    if (!abierto) {
      setEmailInvitar("");
      setRolInvitar("observador");
      setErrorInvitar(null);
      setExitoInvitar(null);
    }
  }, [abierto]);

  const cargarPermisos = async () => {
    try {
      setCargando(true);
      setError(null);
      const data = await obtenerPermisosWorkspace(workspaceId);
      setPermisos(data);
    } catch (err) {
      console.error("Error cargando permisos:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  const handleInvitar = async (e) => {
    e.preventDefault();
    const email = emailInvitar.trim().toLowerCase();

    if (!email) {
      setErrorInvitar("Ingresa un email");
      return;
    }

    try {
      setInvitando(true);
      setErrorInvitar(null);
      setExitoInvitar(null);

      const nuevoPermiso = await agregarPermisoWorkspace(workspaceId, email, rolInvitar);

      // Agregar a la lista o actualizar si ya exist√≠a
      setPermisos(prev => {
        const existe = prev.find(p => p.usuario_id === nuevoPermiso.usuario_id);
        if (existe) {
          return prev.map(p => p.usuario_id === nuevoPermiso.usuario_id ? nuevoPermiso : p);
        }
        return [...prev, nuevoPermiso];
      });

      setEmailInvitar("");
      setExitoInvitar(`Usuario ${email} agregado correctamente`);

      // Limpiar mensaje de √©xito despu√©s de 3s
      setTimeout(() => setExitoInvitar(null), 3000);
    } catch (err) {
      console.error("Error invitando usuario:", err);
      setErrorInvitar(err.message);
    } finally {
      setInvitando(false);
    }
  };

  const handleCambiarRol = async (permisoId, nuevoRol) => {
    try {
      const actualizado = await actualizarPermisoWorkspace(permisoId, nuevoRol);
      setPermisos(prev => prev.map(p => p.id === permisoId ? actualizado : p));
    } catch (err) {
      console.error("Error actualizando rol:", err);
      setError(err.message);
    }
  };

  const handleEliminarAcceso = async (permisoId, nombreUsuario) => {
    if (!confirm(`¬øEliminar el acceso de ${nombreUsuario} a este workspace?`)) {
      return;
    }

    try {
      await eliminarPermisoWorkspace(permisoId);
      setPermisos(prev => prev.filter(p => p.id !== permisoId));
    } catch (err) {
      console.error("Error eliminando acceso:", err);
      setError(err.message);
    }
  };

  if (!abierto) return null;

  return (
    <div className="alim-modal-overlay">
      <div className="alim-modal modal-accesos">
        {/* Header */}
        <div className="modal-accesos__header">
          <h2>Permisos para Workspace: {workspaceNombre}</h2>
        </div>

        {/* Contenido */}
        <div className="modal-accesos__contenido">
          {/* Secci√≥n: Invitar usuario */}
          <div className="modal-accesos__seccion">
            <h3>Invitar Usuario</h3>
            <form className="modal-accesos__form-invitar" onSubmit={handleInvitar}>
              <input
                type="email"
                className="alim-modal-input"
                placeholder="Ingrese el email del usuario a invitar"
                value={emailInvitar}
                onChange={(e) => setEmailInvitar(e.target.value)}
                disabled={invitando}
              />
              <select
                className="alim-modal-select"
                value={rolInvitar}
                onChange={(e) => setRolInvitar(e.target.value)}
                disabled={invitando}
              >
                {rolesDisponibles.map(r => (
                  <option key={r.codigo} value={r.codigo}>
                    {r.nombre}
                  </option>
                ))}
              </select>
              <button
                type="submit"
                className="modal-accesos__btn-invitar"
                disabled={invitando || !emailInvitar.trim()}
              >
                {invitando ? "Invitando..." : "Invitar"}
              </button>
            </form>

            {errorInvitar && (
              <div className="modal-accesos__mensaje modal-accesos__mensaje--error">
                {errorInvitar}
              </div>
            )}
            {exitoInvitar && (
              <div className="modal-accesos__mensaje modal-accesos__mensaje--exito">
                {exitoInvitar}
              </div>
            )}
          </div>

          {/* Secci√≥n: Lista de usuarios */}
          <div className="modal-accesos__seccion">
            <h3>Usuarios con acceso</h3>

            {cargando ? (
              <div className="modal-accesos__cargando">Cargando...</div>
            ) : error ? (
              <div className="modal-accesos__error">
                Error: {error}
                <button onClick={cargarPermisos}>Reintentar</button>
              </div>
            ) : permisos.filter(p => p.usuario_id !== usuarioActualId).length === 0 ? (
              <div className="modal-accesos__vacio">
                No hay otros usuarios con acceso a este workspace.
              </div>
            ) : (
              <ul className="modal-accesos__lista">
                {permisos.filter(p => p.usuario_id !== usuarioActualId).map(permiso => (
                  <li key={permiso.id} className="modal-accesos__usuario">
                    <div className="modal-accesos__usuario-info">
                      <span className="modal-accesos__usuario-icono">üë§</span>
                      <div className="modal-accesos__usuario-datos">
                        <span className="modal-accesos__usuario-nombre">
                          {permiso.usuarios?.nombre || "Sin nombre"}
                        </span>
                        <span className="modal-accesos__usuario-email">
                          {permiso.usuarios?.email}
                        </span>
                      </div>
                    </div>

                    <div className="modal-accesos__usuario-acciones">
                      <select
                        className="modal-accesos__select-rol"
                        value={permiso.rol}
                        onChange={(e) => handleCambiarRol(permiso.id, e.target.value)}
                      >
                        {rolesDisponibles.map(r => (
                          <option key={r.codigo} value={r.codigo}>
                            {r.nombre}
                          </option>
                        ))}
                      </select>
                      <button
                        type="button"
                        className="modal-accesos__btn-eliminar"
                        onClick={() => handleEliminarAcceso(
                          permiso.id,
                          permiso.usuarios?.nombre || permiso.usuarios?.email
                        )}
                        title="Eliminar acceso"
                      >
                        ‚úï
                      </button>
                    </div>
                  </li>
                ))}
              </ul>
            )}
          </div>
        </div>

        {/* Footer */}
        <div className="modal-accesos__footer">
          <button
            type="button"
            className="alim-modal-btn alim-modal-btn-secondary"
            onClick={onCerrar}
          >
            Cerrar
          </button>
        </div>
      </div>
    </div>
  );
};

export default ModalGestionarAccesos;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalGestionModelosRele.css =====

/**
 * Estilos para el Modal de Gesti√≥n de Modelos de Rel√©
 * Dise√±o wizard con pasos para crear modelos personalizados
 */

/* ============================================
   OVERLAY Y CONTENEDOR MODAL
   ============================================ */

.gestion-modelo-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1100;
  padding: 1rem;
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.gestion-modelo-modal {
  position: relative;
  background: #1e293b;
  border-radius: 12px;
  width: 100%;
  max-width: 800px;
  max-height: 85vh;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
  border: 1px solid #334155;
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* ============================================
   HEADER
   ============================================ */

.gestion-modelo-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid #334155;
  background: #0f172a;
  border-radius: 12px 12px 0 0;
}

.gestion-modelo-header h2 {
  margin: 0;
  font-size: 1.1rem;
  font-weight: 600;
  color: #f1f5f9;
}

.gestion-modelo-cerrar {
  background: none;
  border: none;
  color: #64748b;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 0.25rem;
  line-height: 1;
  border-radius: 4px;
  transition: all 0.15s;
}

.gestion-modelo-cerrar:hover {
  color: #f1f5f9;
  background: #334155;
}

/* ============================================
   INDICADOR DE PASOS
   ============================================ */

.gestion-modelo-pasos {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem 1.25rem;
  background: #0f172a;
  border-bottom: 1px solid #334155;
  gap: 0.5rem;
}

.gestion-modelo-paso {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  opacity: 0.5;
  transition: all 0.2s;
}

.gestion-modelo-paso.activo {
  opacity: 1;
}

.gestion-modelo-paso.completado .paso-numero {
  background: #10b981;
  border-color: #10b981;
}

.paso-numero {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: #1e293b;
  border: 2px solid #475569;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  font-weight: 600;
  color: #94a3b8;
  transition: all 0.2s;
}

.gestion-modelo-paso.activo .paso-numero {
  background: #0ea5e9;
  border-color: #0ea5e9;
  color: white;
}

.paso-texto {
  font-size: 0.7rem;
  color: #94a3b8;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.gestion-modelo-paso.activo .paso-texto {
  color: #f1f5f9;
}

.paso-linea {
  width: 40px;
  height: 2px;
  background: #334155;
  margin: 0 0.25rem;
  margin-bottom: 1rem;
}

/* ============================================
   CONTENIDO
   ============================================ */

.gestion-modelo-contenido {
  flex: 1;
  overflow-y: auto;
  padding: 1.25rem;
}

.gestion-modelo-seccion h3 {
  margin: 0 0 0.75rem 0;
  font-size: 0.95rem;
  color: #f1f5f9;
  font-weight: 600;
}

.gestion-modelo-seccion h4 {
  margin: 1rem 0 0.5rem 0;
  font-size: 0.85rem;
  color: #94a3b8;
  font-weight: 500;
}

.gestion-modelo-hint {
  font-size: 0.8rem;
  color: #64748b;
  margin-bottom: 1rem;
  line-height: 1.4;
}

/* Error */
.gestion-modelo-error {
  background: #450a0a;
  border: 1px solid #dc2626;
  color: #fca5a5;
  padding: 0.75rem 1rem;
  border-radius: 6px;
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 0.85rem;
}

.gestion-modelo-error button {
  background: none;
  border: none;
  color: #fca5a5;
  cursor: pointer;
  font-size: 1.2rem;
  padding: 0;
  line-height: 1;
}

/* ============================================
   GRID DE CAMPOS
   ============================================ */

.gestion-modelo-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.75rem;
}

.gestion-modelo-campo {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.gestion-modelo-campo label {
  font-size: 0.75rem;
  color: #94a3b8;
  font-weight: 500;
}

.gestion-modelo-campo input,
.gestion-modelo-campo select {
  padding: 0.5rem 0.75rem;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 6px;
  color: #f1f5f9;
  font-size: 0.85rem;
  transition: border-color 0.15s;
}

.gestion-modelo-campo input:focus,
.gestion-modelo-campo select:focus {
  outline: none;
  border-color: #0ea5e9;
}

.gestion-modelo-campo input::placeholder {
  color: #475569;
}

/* ============================================
   CAPACIDADES (CHECKBOXES)
   ============================================ */

.gestion-modelo-capacidades {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
}

.capacidad-check {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
  font-size: 0.85rem;
  color: #cbd5e1;
  padding: 0.4rem 0.75rem;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 6px;
  transition: all 0.15s;
}

.capacidad-check:hover {
  border-color: #475569;
}

.capacidad-check input[type="checkbox"] {
  width: 16px;
  height: 16px;
  accent-color: #0ea5e9;
  cursor: pointer;
}

/* ============================================
   GRUPOS DE REGISTROS
   ============================================ */

.registro-grupo {
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 8px;
  margin-bottom: 0.75rem;
  overflow: hidden;
}

.registro-grupo-header {
  padding: 0.75rem 1rem;
  background: #1e293b;
  border-bottom: 1px solid #334155;
}

.registro-grupo-header strong {
  color: #f1f5f9;
  font-size: 0.85rem;
}

.registro-campos {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 0.75rem;
  padding: 1rem;
}

.registro-campo {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.registro-campo label {
  font-size: 0.7rem;
  color: #64748b;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

.registro-campo input,
.registro-campo select {
  padding: 0.4rem 0.5rem;
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 4px;
  color: #f1f5f9;
  font-size: 0.85rem;
  width: 100%;
}

.registro-campo input:focus,
.registro-campo select:focus {
  outline: none;
  border-color: #0ea5e9;
}

.registro-campo input[type="number"] {
  text-align: center;
  -moz-appearance: textfield;
}

/* Ocultar flechas spinner en inputs num√©ricos */
.registro-campo input[type="number"]::-webkit-outer-spin-button,
.registro-campo input[type="number"]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.form-proteccion input[type="number"] {
  -moz-appearance: textfield;
}

.form-proteccion input[type="number"]::-webkit-outer-spin-button,
.form-proteccion input[type="number"]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.registro-hint {
  font-size: 0.65rem;
  color: #64748b;
  margin-top: 0.25rem;
}

/* ============================================
   LISTA DE PROTECCIONES
   ============================================ */

.protecciones-lista {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1rem;
  max-height: 300px;
  overflow-y: auto;
}

.protecciones-vacio {
  padding: 1.5rem;
  text-align: center;
  color: #64748b;
  font-size: 0.85rem;
  background: #0f172a;
  border: 1px dashed #334155;
  border-radius: 6px;
}

.proteccion-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.5rem 0.75rem;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 6px;
}

.proteccion-item-info {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex: 1;
}

.proteccion-severidad {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}

.proteccion-codigo {
  font-family: monospace;
  font-size: 0.75rem;
  color: #0ea5e9;
  background: #0c4a6e;
  padding: 0.15rem 0.4rem;
  border-radius: 3px;
}

.proteccion-nombre {
  font-size: 0.8rem;
  color: #cbd5e1;
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.proteccion-ansi {
  font-size: 0.7rem;
  color: #64748b;
}

.proteccion-item-registros {
  display: flex;
  gap: 0.75rem;
  font-size: 0.7rem;
  color: #64748b;
  font-family: monospace;
}

.proteccion-eliminar {
  background: none;
  border: none;
  color: #64748b;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 0.25rem;
  line-height: 1;
  border-radius: 4px;
  transition: all 0.15s;
}

.proteccion-eliminar:hover {
  color: #ef4444;
  background: #450a0a;
}

/* Bot√≥n agregar protecci√≥n */
.btn-agregar-proteccion {
  width: 100%;
  padding: 0.75rem;
  background: #0c4a6e;
  border: 1px dashed #0ea5e9;
  border-radius: 6px;
  color: #7dd3fc;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s;
}

.btn-agregar-proteccion:hover {
  background: #0e527a;
}

/* ============================================
   FORMULARIO DE PROTECCI√ìN
   ============================================ */

.form-proteccion {
  background: #0f172a;
  border: 1px solid #0ea5e9;
  border-radius: 8px;
  padding: 1rem;
}

.form-proteccion h4 {
  margin: 0 0 0.75rem 0;
  font-size: 0.85rem;
  color: #7dd3fc;
}

/* Filas del formulario de protecci√≥n */
.form-proteccion-row {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
  flex-wrap: wrap;
}

/* Fila 1: Identificaci√≥n - C√≥digo peque√±o, Nombre largo, NombreCorto mediano, ANSI peque√±o */
.form-proteccion-row--identificacion {
  align-items: flex-end;
}

.form-proteccion-row--identificacion .campo-codigo {
  flex: 0 0 100px;
}

.form-proteccion-row--identificacion .campo-nombre {
  flex: 1;
  min-width: 160px;
}

.form-proteccion-row--identificacion .campo-nombre-corto {
  flex: 0 0 100px;
}

.form-proteccion-row--identificacion .campo-ansi {
  flex: 0 0 55px;
}

/* Fila 2: Registros y clasificaci√≥n - todos compactos */
.form-proteccion-row--registros {
  align-items: flex-end;
}

.form-proteccion-row--registros .campo-registro,
.form-proteccion-row--registros .campo-bit {
  flex: 0 0 75px;
}

.form-proteccion-row--registros .campo-severidad {
  flex: 0 0 100px;
}

.form-proteccion-row--registros .campo-categoria {
  flex: 1;
  min-width: 120px;
}

/* Labels blancos en formulario de protecci√≥n */
.form-proteccion label {
  color: #f1f5f9;
}

/* Labels centrados en fila de registros */
.form-proteccion-row--registros label {
  text-align: center;
}

/* Legacy grid - mantener por compatibilidad */
.form-proteccion-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 0.5rem;
  margin-bottom: 0.75rem;
}

.form-proteccion-acciones {
  display: flex;
  justify-content: flex-end;
  gap: 0.5rem;
  padding-top: 0.75rem;
  border-top: 1px solid #334155;
}

.form-proteccion-acciones .btn-cancelar {
  padding: 0.4rem 0.75rem;
  background: transparent;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #94a3b8;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s;
}

.form-proteccion-acciones .btn-cancelar:hover {
  background: #334155;
  color: #f1f5f9;
}

.form-proteccion-acciones .btn-agregar {
  padding: 0.4rem 0.75rem;
  background: #0ea5e9;
  border: none;
  border-radius: 4px;
  color: white;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s;
}

.form-proteccion-acciones .btn-agregar:hover {
  background: #0284c7;
}

/* ============================================
   FOOTER
   ============================================ */

.gestion-modelo-footer {
  display: flex;
  align-items: center;
  padding: 1rem 1.25rem;
  border-top: 1px solid #334155;
  background: #0f172a;
  border-radius: 0 0 12px 12px;
}

.footer-espaciador {
  flex: 1;
}

.gestion-modelo-footer .btn-secundario {
  padding: 0.6rem 1rem;
  background: transparent;
  border: 1px solid #475569;
  border-radius: 6px;
  color: #94a3b8;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s;
}

.gestion-modelo-footer .btn-secundario:hover {
  background: #334155;
  color: #f1f5f9;
}

.gestion-modelo-footer .btn-primario {
  padding: 0.6rem 1.25rem;
  background: #0ea5e9;
  border: none;
  border-radius: 6px;
  color: white;
  font-size: 0.85rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
}

.gestion-modelo-footer .btn-primario:hover {
  background: #0284c7;
}

.gestion-modelo-footer .btn-primario:disabled {
  background: #475569;
  cursor: not-allowed;
  opacity: 0.7;
}

.gestion-modelo-footer .btn-guardar {
  background: #10b981;
}

.gestion-modelo-footer .btn-guardar:hover:not(:disabled) {
  background: #059669;
}

/* ============================================
   VISTA LISTA DE MODELOS
   ============================================ */

.gestion-modelo-lista {
  min-height: 200px;
}

.lista-modelos-vacia {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 3rem 1rem;
  text-align: center;
  color: #64748b;
}

.lista-vacia-icono {
  font-size: 3rem;
  margin-bottom: 1rem;
  opacity: 0.5;
}

.lista-modelos-vacia p {
  margin: 0;
  font-size: 0.95rem;
  color: #94a3b8;
}

.lista-vacia-hint {
  font-size: 0.8rem !important;
  color: #64748b !important;
  margin-top: 0.25rem !important;
}

.lista-modelos {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.lista-modelo-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 8px;
  transition: all 0.15s;
}

.lista-modelo-item:hover {
  border-color: #475569;
  background: #1e293b;
}

.lista-modelo-info {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex: 1;
}

.lista-modelo-icono {
  font-size: 1.25rem;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #1e293b;
  border-radius: 6px;
}

.lista-modelo-detalles {
  display: flex;
  flex-direction: column;
  gap: 0.1rem;
}

.lista-modelo-nombre {
  font-size: 0.9rem;
  font-weight: 500;
  color: #f1f5f9;
}

.lista-modelo-fabricante {
  font-size: 0.75rem;
  color: #64748b;
}

.lista-modelo-configs {
  font-size: 0.7rem;
  color: #64748b;
  background: #1e293b;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  margin-left: auto;
  margin-right: 1rem;
}

.lista-modelo-config-info {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  margin-left: auto;
  margin-right: 1rem;
  gap: 0.15rem;
  background: #1e293b;
  padding: 0.4rem 0.75rem;
  border-radius: 6px;
  min-width: 80px;
  border: 1px solid #334155;
}

.lista-modelo-config-nombre {
  font-size: 0.8rem;
  color: #e2e8f0;
  font-weight: 500;
}

.lista-modelo-protecciones {
  font-size: 0.7rem;
  color: #94a3b8;
}

.lista-modelo-acciones {
  display: flex;
  gap: 0.35rem;
}

.btn-lista-editar,
.btn-lista-eliminar {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  border: 1px solid #334155;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.15s;
}

.btn-lista-editar:hover {
  background: #0ea5e9;
  border-color: #0ea5e9;
}

.btn-lista-eliminar:hover {
  background: #dc2626;
  border-color: #dc2626;
}

/* ============================================
   MODAL CONFIRMAR ELIMINAR
   ============================================ */

.gestion-modelo-confirmar-eliminar {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  border-radius: 12px;
}

.confirmar-eliminar-contenido {
  background: #1e293b;
  border: 1px solid #dc2626;
  border-radius: 8px;
  padding: 1.5rem;
  text-align: center;
  max-width: 320px;
}

.confirmar-eliminar-icono {
  font-size: 2rem;
  display: block;
  margin-bottom: 0.75rem;
}

.confirmar-eliminar-contenido p {
  margin: 0 0 1rem 0;
  color: #f1f5f9;
  font-size: 0.9rem;
}

.confirmar-eliminar-acciones {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
}

.confirmar-eliminar-acciones .btn-cancelar {
  padding: 0.5rem 1rem;
  background: transparent;
  border: 1px solid #475569;
  border-radius: 6px;
  color: #94a3b8;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s;
}

.confirmar-eliminar-acciones .btn-cancelar:hover {
  background: #334155;
  color: #f1f5f9;
}

.confirmar-eliminar-acciones .btn-eliminar {
  padding: 0.5rem 1rem;
  background: #dc2626;
  border: none;
  border-radius: 6px;
  color: white;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s;
}

.confirmar-eliminar-acciones .btn-eliminar:hover {
  background: #b91c1c;
}

/* ============================================
   RESPONSIVE
   ============================================ */

@media (max-width: 600px) {
  .gestion-modelo-modal {
    max-height: 90vh;
  }

  .gestion-modelo-grid {
    grid-template-columns: 1fr;
  }

  .gestion-modelo-pasos {
    padding: 0.75rem;
  }

  .paso-texto {
    display: none;
  }

  .paso-linea {
    margin-bottom: 0;
  }

  .registro-campos {
    grid-template-columns: repeat(2, 1fr);
  }

  .proteccion-item {
    flex-direction: column;
    align-items: flex-start;
  }

  .proteccion-item-registros {
    width: 100%;
    justify-content: flex-start;
    margin-top: 0.25rem;
  }

  /* Formulario protecci√≥n responsive */
  .form-proteccion-row--identificacion {
    flex-direction: column;
  }

  .form-proteccion-row--identificacion .campo-codigo,
  .form-proteccion-row--identificacion .campo-nombre,
  .form-proteccion-row--identificacion .campo-nombre-corto,
  .form-proteccion-row--identificacion .campo-ansi {
    flex: 1 1 100%;
  }

  .form-proteccion-row--registros {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
  }

  .form-proteccion-row--registros .campo-registro,
  .form-proteccion-row--registros .campo-bit,
  .form-proteccion-row--registros .campo-severidad,
  .form-proteccion-row--registros .campo-categoria {
    flex: none;
  }

  .form-proteccion-row--registros .campo-categoria {
    grid-column: span 3;
  }
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalHistorial.css =====

/**
 * Estilos para el Modal de Historial
 * Sigue el tema oscuro del proyecto
 */

/* Overlay */
.historial-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.75);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 1rem;
}

/* Modal container */
.historial-modal {
  background: #1e293b;
  border-radius: 12px;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
  max-width: 900px;
  width: 100%;
  max-height: 90vh;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  animation: historial-aparecer 0.2s ease-out;
}

@keyframes historial-aparecer {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* Header */
.historial-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  border-bottom: 1px solid #334155;
  background: #28374e;
  border-radius: 12px 12px 0 0;
}

.historial-modal-titulo {
  display: flex;
  align-items: baseline;
  gap: 0.75rem;
}

.historial-modal-titulo h2 {
  margin: 0;
  font-size: 1.1rem;
  font-weight: 600;
  color: #e2e8f0;
}

.historial-modal-subtitulo {
  font-size: 0.9rem;
  color: #94a3b8;
}

.historial-modal-cerrar {
  background: transparent;
  border: 1px solid #475569;
  color: #94a3b8;
  width: 32px;
  height: 32px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1.25rem;
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
}

.historial-modal-cerrar:hover {
  background: #334155;
  color: #e2e8f0;
  border-color: #64748b;
}

/* Content */
.historial-modal-content {
  padding: 1.25rem;
  flex: 1;
  overflow-y: auto;
}

/* Selectores */
.historial-selectores {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 1rem;
  padding: 1rem;
  background: #0f172a;
  border-radius: 8px;
}

.historial-selector-grupo {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  min-width: 140px;
}

.historial-selector-grupo label {
  font-size: 0.75rem;
  color: #64748b;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.025em;
}

/* Tabs de zona */
.historial-tabs {
  display: flex;
  border: 1px solid #475569;
  border-radius: 6px;
  overflow: hidden;
  flex-wrap: wrap;
}

.historial-tab {
  padding: 0.5rem 1rem;
  background: transparent;
  border: none;
  color: #94a3b8;
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.15s ease;
  flex: 1;
  min-width: 120px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.historial-tab:not(:last-child) {
  border-right: 1px solid #475569;
}

.historial-tab:hover:not(:disabled) {
  background: #334155;
}

.historial-tab--activo {
  background: #0ea5e9;
  color: #ffffff;
}

.historial-tab:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Selector de zona - layout horizontal */
.historial-selector-zona {
  flex: 1;
  min-width: 280px;
}

/* Select y input */
.historial-select,
.historial-input {
  padding: 0.5rem 0.75rem;
  background: #1e293b;
  border: 1px solid #475569;
  border-radius: 6px;
  color: #e2e8f0;
  font-size: 0.85rem;
  min-width: 160px;
  transition: border-color 0.15s ease;
}

.historial-select:focus,
.historial-input:focus {
  outline: none;
  border-color: #0ea5e9;
}

.historial-select option {
  background: #1e293b;
  color: #e2e8f0;
}

/* Fechas personalizadas */
.historial-fechas-custom {
  display: flex;
  gap: 0.75rem;
  align-items: flex-end;
  width: 100%;
  margin-top: 0.5rem;
}

.historial-btn-buscar {
  padding: 0.5rem 1rem;
  background: #0ea5e9;
  border: none;
  border-radius: 6px;
  color: #ffffff;
  font-size: 0.85rem;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.15s ease;
}

.historial-btn-buscar:hover:not(:disabled) {
  background: #0284c7;
}

.historial-btn-buscar:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Barra de precarga de 48h (dentro de selectores) */
.historial-precarga {
  width: 100%;
  padding-top: 0.75rem;
  margin-top: 0.5rem;
  border-top: 1px solid #334155;
}

.historial-precarga-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.5rem;
}

.historial-precarga-acciones {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.historial-btn-limpiar {
  padding: 0.25rem 0.5rem;
  background: transparent;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #94a3b8;
  font-size: 0.7rem;
  cursor: pointer;
  transition: all 0.15s ease;
}

.historial-btn-limpiar:hover:not(:disabled) {
  background: #334155;
  color: #e2e8f0;
  border-color: #64748b;
}

.historial-btn-limpiar:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.historial-precarga-label {
  font-size: 0.8rem;
  color: #94a3b8;
  font-weight: 500;
}

.historial-precarga-ok {
  display: flex;
  align-items: center;
  gap: 0.35rem;
  color: #22c55e;
  font-size: 0.8rem;
  font-weight: 600;
}

.historial-precarga-check {
  width: 16px;
  height: 16px;
}

.historial-precarga-porcentaje {
  color: #0ea5e9;
  font-size: 0.85rem;
  font-weight: 600;
  font-family: "DS-Digital", "Courier New", monospace;
}

.historial-precarga-pendiente {
  color: #64748b;
  font-size: 0.8rem;
}

.historial-precarga-barra {
  height: 6px;
  background: #334155;
  border-radius: 3px;
  overflow: hidden;
}

.historial-precarga-progreso {
  height: 100%;
  background: linear-gradient(90deg, #0ea5e9, #38bdf8);
  border-radius: 3px;
  transition: width 0.3s ease;
}

.historial-precarga-progreso--completo {
  background: linear-gradient(90deg, #22c55e, #4ade80);
}

/* Indicador de fuente de datos */
.historial-fuente {
  padding: 0.5rem 1rem;
  border-radius: 6px;
  font-size: 0.8rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}

.historial-fuente--local {
  background: rgba(34, 197, 94, 0.12);
  color: #22c55e;
  border: 1px solid rgba(34, 197, 94, 0.25);
}

.historial-fuente--remoto {
  background: rgba(14, 165, 233, 0.12);
  color: #0ea5e9;
  border: 1px solid rgba(14, 165, 233, 0.25);
}

.historial-fuente--mixto {
  background: rgba(251, 191, 36, 0.12);
  color: #fbbf24;
  border: 1px solid rgba(251, 191, 36, 0.25);
}

.historial-fuente--error {
  background: rgba(239, 68, 68, 0.12);
  color: #ef4444;
  border: 1px solid rgba(239, 68, 68, 0.25);
}

/* Contenedor del gr√°fico */
.historial-grafico-container {
  min-height: 350px;
  background: #0f172a;
  border-radius: 8px;
  padding: 0.75rem;
  margin-bottom: 1rem;
}

/* Estados de carga/error/vac√≠o */
.historial-estado {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 300px;
  gap: 1rem;
  color: #94a3b8;
}

.historial-estado--error {
  color: #ef4444;
}

.historial-estado button {
  padding: 0.5rem 1rem;
  background: #334155;
  border: none;
  color: #e2e8f0;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85rem;
  transition: background 0.15s ease;
}

.historial-estado button:hover {
  background: #475569;
}

/* Spinner */
.historial-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid #334155;
  border-top-color: #0ea5e9;
  border-radius: 50%;
  animation: historial-spin 1s linear infinite;
}

@keyframes historial-spin {
  to {
    transform: rotate(360deg);
  }
}

/* Estad√≠sticas */
.historial-stats {
  display: flex;
  gap: 1.5rem;
  justify-content: center;
  flex-wrap: wrap;
  padding: 0.75rem 1rem;
  background: #0f172a;
  border-radius: 8px;
}

.historial-stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 70px;
}

.historial-stat-label {
  font-size: 0.7rem;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.03em;
}

.historial-stat-valor {
  font-family: "DS-Digital", "Courier New", monospace;
  font-size: 1.15rem;
  color: #e2e8f0;
  font-weight: 500;
}

/* Acciones */
.historial-modal-acciones {
  display: flex;
  justify-content: flex-end;
  gap: 0.6rem;
  padding: 1rem 1.25rem;
  border-top: 1px solid #334155;
  background: #1e293b;
  border-radius: 0 0 12px 12px;
}

.historial-btn {
  padding: 0.55rem 1.1rem;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;
  min-width: 100px;
}

.historial-btn--primario {
  background: #0ea5e9;
  color: #ffffff;
}

.historial-btn--primario:hover:not(:disabled) {
  background: #0284c7;
}

.historial-btn--secundario {
  background: #334155;
  color: #e2e8f0;
}

.historial-btn--secundario:hover:not(:disabled) {
  background: #475569;
}

.historial-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Responsive */
@media (max-width: 640px) {
  .historial-modal-overlay {
    padding: 0.5rem;
  }

  .historial-modal {
    max-height: 95vh;
  }

  .historial-modal-header {
    padding: 0.75rem 1rem;
  }

  .historial-modal-titulo {
    flex-direction: column;
    gap: 0.25rem;
  }

  .historial-modal-titulo h2 {
    font-size: 1rem;
  }

  .historial-modal-content {
    padding: 1rem;
  }

  .historial-selectores {
    flex-direction: column;
    gap: 0.75rem;
    padding: 0.75rem;
  }

  .historial-selector-grupo {
    min-width: 100%;
  }

  .historial-select,
  .historial-input {
    width: 100%;
  }

  .historial-fechas-custom {
    flex-direction: column;
  }

  .historial-btn-buscar {
    width: 100%;
  }

  .historial-grafico-container {
    min-height: 280px;
    padding: 0.5rem;
  }

  .historial-stats {
    gap: 1rem;
    padding: 0.5rem 0.75rem;
  }

  .historial-stat {
    min-width: 60px;
  }

  .historial-stat-valor {
    font-size: 1rem;
  }

  .historial-modal-acciones {
    flex-wrap: wrap;
    justify-content: center;
    padding: 0.75rem 1rem;
  }

  .historial-btn {
    flex: 1;
    min-width: 80px;
  }
}

/* Scrollbar personalizada */
.historial-modal::-webkit-scrollbar {
  width: 8px;
}

.historial-modal::-webkit-scrollbar-track {
  background: #1e293b;
}

.historial-modal::-webkit-scrollbar-thumb {
  background: #475569;
  border-radius: 4px;
}

.historial-modal::-webkit-scrollbar-thumb:hover {
  background: #64748b;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalHistorial.jsx =====

/**
 * Modal para visualizar el historial de lecturas con gr√°ficos
 * Muestra el PROMEDIO de los valores de cada zona (superior/inferior)
 * aplicando las f√≥rmulas configuradas en cada box
 */

import { useState, useEffect, useMemo, useCallback } from "react";
import Chart from "react-apexcharts";
import { useHistorialLocal } from "../../hooks/useHistorialLocal";
import { aplicarFormula } from "../../utilidades/calculosFormulas";
import { exportarCSV } from "../../utilidades/exportarCSV";
import { TITULOS_MEDICIONES } from "../../constantes/titulosMediciones";
import "./ModalHistorial.css";

// Opciones de rango predefinidas
const RANGOS_TIEMPO = [
  { id: "1h", label: "√öltima hora", ms: 60 * 60 * 1000 },
  { id: "2h", label: "√öltimas 2 horas", ms: 2 * 60 * 60 * 1000 },
  { id: "6h", label: "√öltimas 6 horas", ms: 6 * 60 * 60 * 1000 },
  { id: "12h", label: "√öltimas 12 horas", ms: 12 * 60 * 60 * 1000 },
  { id: "24h", label: "√öltimas 24 horas", ms: 24 * 60 * 60 * 1000 },
  { id: "48h", label: "√öltimas 48 horas", ms: 48 * 60 * 60 * 1000 },
  { id: "7d", label: "√öltimos 7 d√≠as", ms: 7 * 24 * 60 * 60 * 1000 },
  { id: "custom", label: "Personalizado", ms: null },
];

/**
 * Obtiene el t√≠tulo de una zona del cardDesign
 */
const obtenerTituloZona = (cardDesign, zona) => {
  const config = cardDesign?.[zona];
  if (!config) return zona === "superior" ? "Parte Superior" : "Parte Inferior";

  // Si tiene t√≠tulo custom
  if (config.tituloCustom && config.tituloCustom.trim()) {
    return config.tituloCustom;
  }

  // Si tiene tituloId, buscar en las constantes
  if (config.tituloId && TITULOS_MEDICIONES[config.tituloId]) {
    return TITULOS_MEDICIONES[config.tituloId];
  }

  return zona === "superior" ? "Parte Superior" : "Parte Inferior";
};

/**
 * Calcula el promedio de los valores de una zona, aplicando f√≥rmulas
 * Descarta valores que resulten en 0 despu√©s de aplicar la f√≥rmula
 */
const calcularPromedioZona = (lectura, zonaConfig) => {
  if (!lectura?.valores || !Array.isArray(lectura.valores)) return null;
  if (!zonaConfig?.boxes) return null;

  const indiceInicial = lectura.indiceInicial ?? lectura.indice_inicial ?? 0;
  const valoresCalculados = [];

  zonaConfig.boxes.forEach((box) => {
    if (!box.enabled) return;

    const registro = box.registro ?? box.indice;
    if (registro === null || registro === undefined) return;

    const indiceEnArray = registro - indiceInicial;
    if (indiceEnArray < 0 || indiceEnArray >= lectura.valores.length) return;

    const valorCrudo = lectura.valores[indiceEnArray];
    if (valorCrudo === null || valorCrudo === undefined) return;

    // Aplicar f√≥rmula
    const valorCalculado = aplicarFormula(box.formula || "x", valorCrudo);

    // Descartar valores nulos, NaN o 0
    if (valorCalculado !== null && !Number.isNaN(valorCalculado) && valorCalculado !== 0) {
      valoresCalculados.push(valorCalculado);
    }
  });

  if (valoresCalculados.length === 0) return null;

  // Calcular promedio
  const suma = valoresCalculados.reduce((a, b) => a + b, 0);
  return suma / valoresCalculados.length;
};

const ModalHistorial = ({ abierto, onCerrar, alimentador, cardDesign }) => {
  // Hook DEBE estar antes de cualquier return condicional (React Rules of Hooks)
  const {
    obtenerDatosGrafico,
    cargando,
    error,
    // Precarga 48h
    precargar48h,
    resetearPrecarga,
    precargaProgreso,
    precargaCompleta,
    precargando,
    // Limpiar cache
    limpiarCacheCompleto,
    estadisticas,
  } = useHistorialLocal();

  // Estado del selector
  const [rangoSeleccionado, setRangoSeleccionado] = useState("1h");
  const [fechaDesde, setFechaDesde] = useState("");
  const [fechaHasta, setFechaHasta] = useState("");
  const [zonaSeleccionada, setZonaSeleccionada] = useState("superior");

  // Datos del gr√°fico
  const [datosGrafico, setDatosGrafico] = useState([]);
  const [fuenteDatos, setFuenteDatos] = useState(null);

  // Obtener t√≠tulos de las zonas
  const tituloSuperior = useMemo(
    () => obtenerTituloZona(cardDesign, "superior"),
    [cardDesign]
  );
  const tituloInferior = useMemo(
    () => obtenerTituloZona(cardDesign, "inferior"),
    [cardDesign]
  );

  // T√≠tulo de la zona seleccionada (para el gr√°fico)
  const tituloZonaActual = zonaSeleccionada === "superior" ? tituloSuperior : tituloInferior;

  // Verificar si hay zona configurada
  const zonaDisponible = useCallback((zona) => {
    const config = cardDesign?.[zona];
    return config?.boxes?.some((b) => b.enabled);
  }, [cardDesign]);

  // Obtener registrador_id de la zona (con fallback al registrador del alimentador)
  const obtenerRegistradorZona = useCallback((zona) => {
    // Primero buscar en la zona espec√≠fica del cardDesign
    const regIdZona = cardDesign?.[zona]?.registrador_id;
    if (regIdZona) return regIdZona;

    // Fallback: usar registrador_id del alimentador (formato legacy o √∫nico registrador)
    return alimentador?.registrador_id || null;
  }, [cardDesign, alimentador]);

  // Cargar datos cuando cambia la selecci√≥n
  const cargarDatos = useCallback(async () => {
    if (!alimentador?.id) return;

    const registradorId = obtenerRegistradorZona(zonaSeleccionada);

    if (!registradorId) {
      setDatosGrafico([]);
      setFuenteDatos(null);
      return;
    }

    const ahora = Date.now();
    const rango = RANGOS_TIEMPO.find((r) => r.id === rangoSeleccionado);

    let desde, hasta;
    if (rangoSeleccionado === "custom" && fechaDesde && fechaHasta) {
      desde = new Date(fechaDesde).getTime();
      hasta = new Date(fechaHasta).getTime();
    } else if (rango?.ms) {
      desde = ahora - rango.ms;
      hasta = ahora;
    } else {
      return;
    }

    // Si la precarga de 48h est√° completa, forzar solo datos locales
    const forzarSoloLocal = precargaCompleta;

    const { datos, fuente } = await obtenerDatosGrafico(
      alimentador.id,
      registradorId,
      zonaSeleccionada,
      desde,
      hasta,
      forzarSoloLocal
    );

    // Transformar datos calculando el promedio de la zona
    const zonaConfig = cardDesign?.[zonaSeleccionada];

    const datosTransformados = datos
      .map((lectura) => {
        const promedio = calcularPromedioZona(lectura, zonaConfig);

        if (promedio === null) return null;

        return {
          x: new Date(lectura.timestamp),
          y: promedio,
        };
      })
      .filter((d) => d !== null);

    setDatosGrafico(datosTransformados);
    setFuenteDatos(fuente);
  }, [
    alimentador,
    cardDesign,
    rangoSeleccionado,
    fechaDesde,
    fechaHasta,
    zonaSeleccionada,
    obtenerDatosGrafico,
    obtenerRegistradorZona,
    precargaCompleta,
  ]);

  // Resetear a 1h y resetear precarga cuando se abre/cierra el modal
  useEffect(() => {
    if (abierto) {
      setRangoSeleccionado("1h");
    } else {
      // Al cerrar, resetear estado de precarga
      resetearPrecarga();
    }
  }, [abierto, resetearPrecarga]);

  // Iniciar precarga de 48h autom√°ticamente al abrir el modal
  useEffect(() => {
    if (!abierto || !alimentador?.id) return;

    // Obtener registradores de ambas zonas
    const registradorSuperior = obtenerRegistradorZona("superior");
    const registradorInferior = obtenerRegistradorZona("inferior");

    // Iniciar precarga
    precargar48h(alimentador.id, registradorSuperior, registradorInferior);
  }, [abierto, alimentador?.id, obtenerRegistradorZona, precargar48h]);

  // Cargar datos al abrir o cambiar selecci√≥n
  useEffect(() => {
    if (abierto) {
      cargarDatos();
    }
  }, [abierto, cargarDatos]);

  // Configuraci√≥n de ApexCharts
  const opcionesGrafico = useMemo(
    () => ({
      chart: {
        id: "historial-lecturas",
        type: "line",
        height: 350,
        zoom: {
          enabled: true,
          type: "x",
          autoScaleYaxis: true,
        },
        toolbar: {
          show: true,
          tools: {
            download: true,
            selection: true,
            zoom: true,
            zoomin: true,
            zoomout: true,
            pan: true,
            reset: true,
          },
          autoSelected: "zoom",
        },
        background: "#0f172a",
        foreColor: "#e2e8f0",
        animations: {
          enabled: true,
          speed: 500,
        },
      },
      stroke: {
        curve: "smooth",
        width: 2,
      },
      colors: ["#0ea5e9"],
      xaxis: {
        type: "datetime",
        labels: {
          style: { colors: "#94a3b8" },
          datetimeUTC: false,
          datetimeFormatter: {
            year: "yyyy",
            month: "MMM 'yy",
            day: "dd MMM",
            hour: "HH:mm",
          },
        },
        axisBorder: { color: "#334155" },
        axisTicks: { color: "#334155" },
      },
      yaxis: {
        labels: {
          style: { colors: "#94a3b8" },
          formatter: (val) => (val != null ? val.toFixed(2) : "--"),
        },
      },
      grid: {
        borderColor: "#334155",
        strokeDashArray: 3,
      },
      tooltip: {
        theme: "dark",
        x: { format: "dd/MM/yyyy HH:mm:ss" },
        y: {
          formatter: (val) => (val != null ? val.toFixed(4) : "--"),
        },
      },
      dataLabels: {
        enabled: false,
      },
      markers: {
        size: 0,
        hover: { size: 5 },
      },
      noData: {
        text: "No hay datos disponibles",
        style: {
          color: "#94a3b8",
          fontSize: "14px",
        },
      },
    }),
    []
  );

  const seriesGrafico = useMemo(
    () => [
      {
        name: `Promedio ${tituloZonaActual}`,
        data: datosGrafico,
      },
    ],
    [datosGrafico, tituloZonaActual]
  );

  // Calcular estad√≠sticas del gr√°fico
  const estadisticasGrafico = useMemo(() => {
    if (datosGrafico.length === 0) return null;

    const valores = datosGrafico.map((d) => d.y);
    const min = Math.min(...valores);
    const max = Math.max(...valores);
    const suma = valores.reduce((a, b) => a + b, 0);
    const promedio = suma / valores.length;

    return {
      puntos: datosGrafico.length,
      min: min.toFixed(2),
      max: max.toFixed(2),
      promedio: promedio.toFixed(2),
    };
  }, [datosGrafico]);

  // Handler exportar CSV
  const handleExportarCSV = () => {
    if (datosGrafico.length === 0) return;

    const nombreArchivo = `historial_${alimentador?.nombre || "alimentador"}_${
      zonaSeleccionada
    }_${Date.now()}`;

    exportarCSV(datosGrafico, nombreArchivo, {
      columnas: ["timestamp", "valor"],
      etiquetas: {
        timestamp: "Fecha/Hora",
        valor: `Promedio ${tituloZonaActual}`,
      },
    });
  };

  // Early return DESPU√âS de todos los hooks (React Rules of Hooks)
  if (!abierto) return null;

  return (
    <div className="historial-modal-overlay">
      <div className="historial-modal">
        <header className="historial-modal-header">
          <div className="historial-modal-titulo">
            <h2>Historial de Lecturas</h2>
            <span className="historial-modal-subtitulo">
              {alimentador?.nombre}
            </span>
          </div>
          <button
            type="button"
            className="historial-modal-cerrar"
            onClick={onCerrar}
          >
            &times;
          </button>
        </header>

        <div className="historial-modal-content">
          {/* Selectores */}
          <div className="historial-selectores">
            {/* Selector de zona con t√≠tulos */}
            <div className="historial-selector-grupo historial-selector-zona">
              <label>Medici√≥n</label>
              <div className="historial-tabs">
                <button
                  type="button"
                  className={`historial-tab ${
                    zonaSeleccionada === "superior" ? "historial-tab--activo" : ""
                  }`}
                  onClick={() => setZonaSeleccionada("superior")}
                  disabled={!zonaDisponible("superior")}
                  title={tituloSuperior}
                >
                  {tituloSuperior}
                </button>
                <button
                  type="button"
                  className={`historial-tab ${
                    zonaSeleccionada === "inferior" ? "historial-tab--activo" : ""
                  }`}
                  onClick={() => setZonaSeleccionada("inferior")}
                  disabled={!zonaDisponible("inferior")}
                  title={tituloInferior}
                >
                  {tituloInferior}
                </button>
              </div>
            </div>

            {/* Selector de rango de tiempo */}
            <div className="historial-selector-grupo">
              <label>Rango de tiempo</label>
              <select
                className="historial-select"
                value={rangoSeleccionado}
                onChange={(e) => setRangoSeleccionado(e.target.value)}
              >
                {RANGOS_TIEMPO.map((r) => (
                  <option key={r.id} value={r.id}>
                    {r.label}
                  </option>
                ))}
              </select>
            </div>

            {/* Fechas personalizadas */}
            {rangoSeleccionado === "custom" && (
              <div className="historial-fechas-custom">
                <div className="historial-selector-grupo">
                  <label>Desde</label>
                  <input
                    type="datetime-local"
                    className="historial-input"
                    value={fechaDesde}
                    onChange={(e) => setFechaDesde(e.target.value)}
                  />
                </div>
                <div className="historial-selector-grupo">
                  <label>Hasta</label>
                  <input
                    type="datetime-local"
                    className="historial-input"
                    value={fechaHasta}
                    onChange={(e) => setFechaHasta(e.target.value)}
                  />
                </div>
                <button
                  type="button"
                  className="historial-btn-buscar"
                  onClick={cargarDatos}
                  disabled={!fechaDesde || !fechaHasta}
                >
                  Buscar
                </button>
              </div>
            )}

            {/* Barra de progreso de precarga de 48h */}
            <div className="historial-precarga">
              <div className="historial-precarga-header">
                <span className="historial-precarga-label">
                  Cache local (48h){estadisticas?.totalLecturas ? ` - ${estadisticas.totalLecturas} registros` : ""}:
                </span>
                <div className="historial-precarga-acciones">
                  {precargaCompleta ? (
                    <span className="historial-precarga-ok">
                      <svg
                        className="historial-precarga-check"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="3"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <polyline points="20 6 9 17 4 12"></polyline>
                      </svg>
                      Completo
                    </span>
                  ) : precargando ? (
                    <span className="historial-precarga-porcentaje">
                      {precargaProgreso}%
                    </span>
                  ) : (
                    <span className="historial-precarga-pendiente">Pendiente</span>
                  )}
                  <button
                    type="button"
                    className="historial-btn-limpiar"
                    onClick={async () => {
                      if (window.confirm("¬øLimpiar todo el cache local? Se volver√°n a descargar los datos.")) {
                        await limpiarCacheCompleto();
                        // Reiniciar precarga
                        const registradorSuperior = obtenerRegistradorZona("superior");
                        const registradorInferior = obtenerRegistradorZona("inferior");
                        precargar48h(alimentador.id, registradorSuperior, registradorInferior);
                      }
                    }}
                    disabled={precargando}
                    title="Limpiar cache local"
                  >
                    Limpiar
                  </button>
                </div>
              </div>
              <div className="historial-precarga-barra">
                <div
                  className={`historial-precarga-progreso ${
                    precargaCompleta ? "historial-precarga-progreso--completo" : ""
                  }`}
                  style={{ width: `${precargaProgreso}%` }}
                ></div>
              </div>
            </div>
          </div>

          {/* Indicador de fuente de datos */}
          {fuenteDatos && (
            <div className={`historial-fuente historial-fuente--${fuenteDatos}`}>
              {fuenteDatos === "local" && precargaCompleta && "Datos de cache local (precarga completa)"}
              {fuenteDatos === "local" && !precargaCompleta && "Datos de cache local (tiempo real)"}
              {fuenteDatos === "remoto" && "Datos de base de datos"}
              {fuenteDatos === "mixto" && "Datos combinados (local + BD)"}
              {fuenteDatos === "error" && "Error cargando datos"}
            </div>
          )}

          {/* Gr√°fico */}
          <div className="historial-grafico-container">
            {cargando ? (
              <div className="historial-estado">
                <div className="historial-spinner"></div>
                <span>Cargando datos...</span>
              </div>
            ) : error ? (
              <div className="historial-estado historial-estado--error">
                <span>Error: {error}</span>
                <button onClick={cargarDatos}>Reintentar</button>
              </div>
            ) : datosGrafico.length === 0 ? (
              <div className="historial-estado">
                <span>No hay datos para el rango seleccionado</span>
              </div>
            ) : (
              <Chart
                options={opcionesGrafico}
                series={seriesGrafico}
                type="line"
                height={350}
              />
            )}
          </div>

          {/* Estad√≠sticas */}
          {estadisticasGrafico && (
            <div className="historial-stats">
              <div className="historial-stat">
                <span className="historial-stat-label">Puntos</span>
                <span className="historial-stat-valor">{estadisticasGrafico.puntos}</span>
              </div>
              <div className="historial-stat">
                <span className="historial-stat-label">M√≠n</span>
                <span className="historial-stat-valor">{estadisticasGrafico.min}</span>
              </div>
              <div className="historial-stat">
                <span className="historial-stat-label">M√°x</span>
                <span className="historial-stat-valor">{estadisticasGrafico.max}</span>
              </div>
              <div className="historial-stat">
                <span className="historial-stat-label">Promedio</span>
                <span className="historial-stat-valor">{estadisticasGrafico.promedio}</span>
              </div>
            </div>
          )}
        </div>

        {/* Acciones */}
        <div className="historial-modal-acciones">
          <button
            type="button"
            className="historial-btn historial-btn--secundario"
            onClick={cargarDatos}
            disabled={cargando}
          >
            Actualizar
          </button>
          <button
            type="button"
            className="historial-btn historial-btn--secundario"
            onClick={onCerrar}
          >
            Cerrar
          </button>
          <button
            type="button"
            className="historial-btn historial-btn--primario"
            onClick={handleExportarCSV}
            disabled={datosGrafico.length === 0}
          >
            Exportar CSV
          </button>
        </div>
      </div>
    </div>
  );
};

export default ModalHistorial;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalNuevoPuesto.css =====

/* src/paginas/PaginaAlimentadores/componentes/modales/ModalNuevoPuesto.css */
/*
   Estilos espec√≠ficos del modal "Nuevo Puesto".
   Los estilos base del modal vienen de ModalConfiguracionAlimentador.css
   Los estilos del picker vienen de ColorPickerSimple.css
*/

/* Tama√±o compacto para este modal */
.alim-modal.alim-modal-sm {
   max-width: 480px;
}

/* ===== Contenedor principal con borde ===== */
.nuevo-puesto-contenedor {
   background: #0f172a;
   border: 1px solid #334155;
   border-radius: 12px;
   padding: 1rem;
}

/* Input con mismo fondo que el modal */
.nuevo-puesto-contenedor .alim-modal-input {
   background: #28374e !important;
   border: 1px solid #475569;
   border-radius: 8px;
}

/* ===== Secci√≥n de selecci√≥n de color ===== */

.nuevo-puesto-color-section {
   display: flex;
   align-items: center;
   gap: 1rem;
   margin-top: 1rem;
}

/* Grid de colores predefinidos */
.nuevo-puesto-color-grid {
   display: flex;
   flex-wrap: wrap;
   gap: 0.4rem;
   align-items: center;
}

/* Cada c√≠rculo de color */
.nuevo-puesto-color-swatch {
   width: 1.5rem;
   height: 1.5rem;
   border-radius: 50%;
   border: 2px solid transparent;
   cursor: pointer;
   padding: 0;
   transition: transform 0.15s ease, border-color 0.15s ease;
}

.nuevo-puesto-color-swatch:hover {
   transform: scale(1.15);
}

.nuevo-puesto-color-swatch--selected {
   border-color: #fff;
   box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.6);
}

/* Wrapper del picker personalizado */
.nuevo-puesto-picker-wrapper {
   margin-left: auto;
}

/* Preview del color seleccionado */
.nuevo-puesto-color-preview {
   width: 90px;
   height: 1.8rem;
   border-radius: 6px;
   display: flex;
   align-items: center;
   justify-content: center;
   border: 2px solid #475569;
   margin-left: auto;
}

.nuevo-puesto-color-preview-text {
   font-size: 0.7rem;
   font-weight: 700;
   letter-spacing: 0.08em;
   color: #fff;
   text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
}

/* C√≠rculo multicolor (arco√≠ris) para el picker dentro del grid */
.nuevo-puesto-color-grid .color-picker-simple {
   margin-top: 0;
   gap: 0;
}

.nuevo-puesto-color-grid .color-picker-simple-wrapper {
   display: flex;
   align-items: center;
}

.nuevo-puesto-color-grid .color-picker-simple-button {
   width: 1.5rem !important;
   height: 1.5rem !important;
   min-width: 1.5rem;
   min-height: 1.5rem;
   background: conic-gradient(
      from 0deg,
      red, yellow, lime, aqua, blue, magenta, red
   ) !important;
   border: none !important;
   box-shadow: none !important;
   padding: 0 !important;
}

/* Botones de acci√≥n juntos a la derecha */
.alim-modal-sm .alim-modal-actions {
   justify-content: flex-end;
}

/* Bot√≥n cancelar m√°s oscuro */
.alim-modal-sm .alim-modal-btn-cancelar {
   background-color: #1e293b;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalNuevoPuesto.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalNuevoPuesto.jsx

import React, { useState } from "react";
import "./ModalConfiguracionAlimentador.css"; // estilos base del modal (overlay, fondo, input, etc.)
import "./ModalNuevoPuesto.css";              // estilos espec√≠ficos del modal nuevo puesto
import ColorPickerSimple from "./ColorPickerSimple"; // componente reutilizable del picker

/**
 * Modal para crear un nuevo puesto.
 * Permite ingresar nombre y seleccionar color.
 */
const ModalNuevoPuesto = ({
	abierto,                                   // boolean: controla si el modal se muestra
	onCerrar,                                  // callback para cerrar sin crear
	onCrear,                                   // callback que recibe (nombre, color)
	coloresSistema,                            // array de colores disponibles
}) => {
	const [nombrePuesto, setNombrePuesto] = useState("");
	const [colorPuesto, setColorPuesto] = useState(coloresSistema[0]);

	const handleSubmit = (e) => {
		e.preventDefault();
		const nombre = nombrePuesto.trim();
		if (!nombre) return;

		onCrear(nombre, colorPuesto);

		// Limpiar (el cierre lo maneja el padre)
		setNombrePuesto("");
		setColorPuesto(coloresSistema[0]);
	};

	const handleCerrar = () => {
		setNombrePuesto("");
		setColorPuesto(coloresSistema[0]);
		onCerrar();
	};

	if (!abierto) return null;

	return (
		<div className="alim-modal-overlay">
			<div className="alim-modal alim-modal-sm">
				<h2>Nuevo Puesto</h2>
				<form onSubmit={handleSubmit}>
					<div className="nuevo-puesto-contenedor">
						<label className="alim-modal-label">
							Nombre del Puesto
							<input
								type="text"
								className="alim-modal-input"
								value={nombrePuesto}
								onChange={(e) => setNombrePuesto(e.target.value)}
								placeholder="Ej: PUESTO 1"
								autoFocus
							/>
						</label>

						<div className="nuevo-puesto-color-section">
							{/* Grid de colores predefinidos */}
							<div className="nuevo-puesto-color-grid">
								{coloresSistema.slice(0, 8).map((c) => (
									<button
										key={c}
										type="button"
										className={`nuevo-puesto-color-swatch ${
											colorPuesto === c ? "nuevo-puesto-color-swatch--selected" : ""
										}`}
										style={{ backgroundColor: c }}
										onClick={() => setColorPuesto(c)}
										aria-label={`Elegir color ${c}`}
									/>
								))}
								{/* Picker personalizado (c√≠rculo multicolor) */}
								<ColorPickerSimple
									color={colorPuesto}
									onChange={setColorPuesto}
									label=""
								/>
							</div>

							{/* Preview del color seleccionado */}
							<div
								className="nuevo-puesto-color-preview"
								style={{ backgroundColor: colorPuesto }}
								title={colorPuesto}
							>
								<span className="nuevo-puesto-color-preview-text">COLOR</span>
							</div>
						</div>
					</div>

					<div className="alim-modal-actions">
						<button
							type="button"
							className="alim-modal-btn alim-modal-btn-cancelar"
							onClick={handleCerrar}
						>
							Cancelar
						</button>
						<button
							type="submit"
							className="alim-modal-btn alim-modal-btn-guardar"
						>
							Crear
						</button>
					</div>
				</form>
			</div>
		</div>
	);
};

export default ModalNuevoPuesto;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalPanelPermisos.css =====

/**
 * Estilos para ModalPanelPermisos - Panel de gesti√≥n de permisos
 * Dise√±o Master-Detail: Lista de usuarios + Panel de detalles
 */

/* ============================================
   OVERLAY Y MODAL PRINCIPAL
   ============================================ */

.permisos-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 2rem;
}

.permisos-modal {
  background: #1e293b;
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.05);
  display: flex;
  flex-direction: column;
  min-width: 700px;
  min-height: 450px;
  width: 1000px;
  height: 650px;
  overflow: hidden;
  resize: both;
}

/* ============================================
   HEADER
   ============================================ */

.permisos-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  background: linear-gradient(180deg, #334155 0%, #1e293b 100%);
  border-bottom: 1px solid #475569;
  flex-shrink: 0;
}

.permisos-titulo {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.permisos-icono {
  font-size: 1.1rem;
}

.permisos-nombre {
  font-size: 0.95rem;
  font-weight: 600;
  color: #e2e8f0;
}

.permisos-controles {
  display: flex;
  gap: 0.25rem;
}

.permisos-btn-control,
.permisos-btn-cerrar {
  width: 28px;
  height: 28px;
  border: none;
  border-radius: 4px;
  background: #475569;
  color: #e2e8f0;
  cursor: pointer;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
}

.permisos-btn-control:hover {
  background: #64748b;
}

.permisos-btn-cerrar:hover {
  background: #ef4444;
  color: #ffffff;
}

/* ============================================
   ESTADOS DE VENTANA
   ============================================ */

.permisos-modal--arrastrando {
  user-select: none;
  cursor: move !important;
}

.permisos-overlay--minimizado {
  background: transparent;
  backdrop-filter: none;
  pointer-events: none;
  align-items: flex-end;
  justify-content: flex-start;
  padding: 1rem;
}

.permisos-modal--minimizado {
  pointer-events: auto;
  width: 280px;
  height: auto;
  min-height: auto;
  max-height: none;
  min-width: auto;
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  resize: none;
}

.permisos-modal--minimizado .permisos-content {
  display: none;
}

.permisos-modal--maximizado {
  max-width: 100%;
  max-height: 100%;
  border-radius: 0;
  resize: none;
}

.permisos-overlay--maximizado {
  padding: 0;
}

/* ============================================
   CONTENIDO PRINCIPAL - MASTER DETAIL
   ============================================ */

.permisos-content {
  flex: 1;
  display: flex;
  overflow: hidden;
  min-height: 0;
}

/* Panel izquierdo - Lista de usuarios (Master) */
.permisos-master {
  width: 280px;
  min-width: 220px;
  max-width: 350px;
  background: #0f172a;
  border-right: 1px solid #334155;
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
}

.permisos-master-toolbar {
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  border-bottom: 1px solid #334155;
  flex-shrink: 0;
}

.permisos-input-busqueda {
  width: 100%;
  padding: 0.5rem 0.75rem;
  background: #1e293b;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #e2e8f0;
  font-size: 0.8rem;
  outline: none;
  transition: border-color 0.15s;
}

.permisos-input-busqueda:focus {
  border-color: #0ea5e9;
}

.permisos-input-busqueda::placeholder {
  color: #64748b;
}

.permisos-select-filtro {
  width: 100%;
  padding: 0.4rem 0.6rem;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #e2e8f0;
  font-size: 0.75rem;
  cursor: pointer;
  outline: none;
}

.permisos-select-filtro:focus {
  border-color: #0ea5e9;
}

/* Lista de usuarios */
.permisos-usuarios-lista {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem;
}

.permisos-usuario-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.6rem 0.75rem;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.15s ease;
  margin-bottom: 0.25rem;
}

.permisos-usuario-item:hover {
  background: #1e293b;
}

.permisos-usuario-item--activo {
  background: rgba(14, 165, 233, 0.15);
  border-left: 3px solid #0ea5e9;
}

.permisos-usuario-item--activo:hover {
  background: rgba(14, 165, 233, 0.2);
}

.permisos-usuario-info {
  display: flex;
  flex-direction: column;
  gap: 0.1rem;
  min-width: 0;
  flex: 1;
}

.permisos-usuario-nombre {
  font-weight: 500;
  color: #e2e8f0;
  font-size: 0.85rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.permisos-usuario-email {
  font-size: 0.7rem;
  color: #64748b;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.permisos-badge-small {
  font-size: 0.6rem;
  padding: 0.15rem 0.35rem;
  border-radius: 3px;
  font-weight: 600;
  flex-shrink: 0;
  margin-left: 0.5rem;
}

.permisos-badge-small--admin {
  background: rgba(59, 130, 246, 0.2);
  color: #60a5fa;
}

.permisos-badge-small--operador {
  background: rgba(34, 197, 94, 0.2);
  color: #4ade80;
}

.permisos-badge-small--observador {
  background: rgba(156, 163, 175, 0.2);
  color: #9ca3af;
}

.permisos-master-footer {
  padding: 0.5rem 0.75rem;
  font-size: 0.7rem;
  color: #64748b;
  border-top: 1px solid #334155;
  text-align: center;
  flex-shrink: 0;
}

/* Panel derecho - Detalles (Detail) */
.permisos-detail {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  min-width: 0;
}

/* Estados vac√≠o/cargando/error del detalle */
.permisos-detalle-vacio,
.permisos-detalle-cargando,
.permisos-detalle-error {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 0.75rem;
  color: #64748b;
  font-size: 0.9rem;
}

.permisos-detalle-vacio-icono {
  font-size: 3rem;
  opacity: 0.5;
}

.permisos-detalle-error {
  color: #ef4444;
}

/* Panel de detalles del usuario */
.permisos-detalle {
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}

.permisos-detalle-header {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem 1.25rem;
  background: #0f172a;
  border-bottom: 1px solid #334155;
  flex-shrink: 0;
}

.permisos-detalle-usuario {
  flex: 1;
  min-width: 0;
}

.permisos-detalle-nombre {
  display: block;
  font-weight: 600;
  color: #e2e8f0;
  font-size: 1.1rem;
  margin-bottom: 0.15rem;
}

.permisos-detalle-email {
  display: block;
  font-size: 0.8rem;
  color: #64748b;
}

.permisos-detalle-badges {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex-shrink: 0;
}

.permisos-detalle-acceso {
  font-size: 0.8rem;
  color: #94a3b8;
}

.permisos-btn-editar {
  padding: 0.5rem 1rem;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #e2e8f0;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s ease;
  flex-shrink: 0;
}

.permisos-btn-editar:hover {
  background: #475569;
  border-color: #64748b;
}

/* Badges de rol */
.permisos-badge {
  display: inline-block;
  padding: 0.25rem 0.6rem;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.03em;
}

.permisos-badge--admin {
  background: rgba(59, 130, 246, 0.2);
  color: #60a5fa;
}

.permisos-badge--operador {
  background: rgba(34, 197, 94, 0.2);
  color: #4ade80;
}

.permisos-badge--observador {
  background: rgba(156, 163, 175, 0.2);
  color: #9ca3af;
}

/* Estad√≠sticas */
.permisos-detalle-stats {
  display: flex;
  gap: 1.5rem;
  padding: 1rem 1.25rem;
  background: #1e293b;
  border-bottom: 1px solid #334155;
  flex-shrink: 0;
}

.permisos-stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.2rem;
}

.permisos-stat-numero {
  font-size: 1.5rem;
  font-weight: 700;
  color: #0ea5e9;
}

.permisos-stat-label {
  font-size: 0.7rem;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* Contenido scrolleable */
.permisos-detalle-contenido {
  flex: 1;
  overflow-y: auto;
  padding: 1rem 1.25rem;
}

/* Secciones */
.permisos-seccion {
  margin-bottom: 1.5rem;
}

.permisos-seccion:last-child {
  margin-bottom: 0;
}

.permisos-seccion-titulo {
  font-size: 0.8rem;
  font-weight: 600;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin: 0 0 0.75rem 0;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #334155;
}

/* Grid de workspaces */
.permisos-workspaces-grid {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

/* Card de workspace */
.permisos-workspace-card {
  background: #0f172a;
  border-radius: 8px;
  padding: 0.875rem 1rem;
  border-left: 3px solid #0ea5e9;
}

.permisos-workspace-card--invitado {
  border-left-color: #8b5cf6;
}

.permisos-workspace-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.75rem;
}

.permisos-workspace-nombre {
  font-weight: 600;
  color: #e2e8f0;
  font-size: 0.95rem;
}

.permisos-workspace-puestos {
  font-size: 0.7rem;
  padding: 0.2rem 0.5rem;
  background: rgba(14, 165, 233, 0.15);
  color: #38bdf8;
  border-radius: 4px;
}

.permisos-workspace-row {
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
  font-size: 0.8rem;
}

.permisos-workspace-row:last-child {
  margin-bottom: 0;
}

.permisos-workspace-label {
  color: #64748b;
  min-width: 70px;
  flex-shrink: 0;
}

.permisos-workspace-vacio {
  color: #475569;
  font-style: italic;
}

.permisos-workspace-propietario {
  color: #e2e8f0;
}

.permisos-workspace-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 0.35rem;
}

.permisos-chip {
  padding: 0.15rem 0.45rem;
  background: #334155;
  color: #e2e8f0;
  border-radius: 4px;
  font-size: 0.75rem;
}

.permisos-chip--inactivo {
  opacity: 0.5;
  text-decoration: line-through;
}

/* Invitados agrupados por rol */
.permisos-invitados-grupos {
  display: flex;
  flex-direction: column;
  gap: 0.4rem;
  flex: 1;
}

.permisos-invitados-grupo {
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
}

.permisos-rol-badge {
  font-size: 0.65rem;
  padding: 0.15rem 0.4rem;
  border-radius: 3px;
  font-weight: 600;
  flex-shrink: 0;
}

.permisos-rol-badge--admin {
  background: rgba(59, 130, 246, 0.2);
  color: #60a5fa;
}

.permisos-rol-badge--operador {
  background: rgba(34, 197, 94, 0.2);
  color: #4ade80;
}

.permisos-rol-badge--observador {
  background: rgba(156, 163, 175, 0.2);
  color: #9ca3af;
}

.permisos-invitados-nombres {
  color: #94a3b8;
  font-size: 0.8rem;
  line-height: 1.4;
}

/* Sin datos */
.permisos-detalle-sin-datos {
  padding: 2rem;
  text-align: center;
  color: #64748b;
  font-size: 0.9rem;
  background: #0f172a;
  border-radius: 8px;
}

/* ============================================
   MODO EDICI√ìN
   ============================================ */

.permisos-detalle-edicion {
  padding: 1rem 1.25rem;
  background: #0f172a;
  border-bottom: 1px solid #334155;
}

.permisos-detalle-edicion h4 {
  margin: 0 0 1rem 0;
  font-size: 0.9rem;
  color: #e2e8f0;
  font-weight: 600;
}

.permisos-campo {
  margin-bottom: 1rem;
}

.permisos-campo:last-of-type {
  margin-bottom: 0;
}

.permisos-label {
  display: block;
  font-size: 0.7rem;
  font-weight: 600;
  color: #94a3b8;
  margin-bottom: 0.4rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.permisos-select {
  width: 100%;
  max-width: 300px;
  padding: 0.5rem 0.75rem;
  border: 1px solid #475569;
  border-radius: 4px;
  background-color: #1e293b;
  color: #e2e8f0;
  font-size: 0.85rem;
  cursor: pointer;
  outline: none;
}

.permisos-select:hover {
  border-color: #64748b;
}

.permisos-select:focus {
  border-color: #0ea5e9;
}

/* Checkboxes */
.permisos-checkbox {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.35rem 0;
  cursor: pointer;
  font-size: 0.8rem;
  color: #d1d5db;
}

.permisos-checkbox--destacado {
  padding: 0.5rem 0.75rem;
  margin-bottom: 0.5rem;
  background: rgba(14, 165, 233, 0.1);
  border-radius: 4px;
  border: 1px solid rgba(14, 165, 233, 0.2);
}

.permisos-checkbox input[type="checkbox"] {
  width: 14px;
  height: 14px;
  cursor: pointer;
  accent-color: #0ea5e9;
  flex-shrink: 0;
}

.permisos-agente-inactivo {
  font-size: 0.7rem;
  color: #64748b;
  font-style: italic;
  margin-left: 0.25rem;
}

.permisos-agentes-lista {
  display: flex;
  flex-direction: column;
  max-height: 150px;
  overflow-y: auto;
  padding: 0.5rem;
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 4px;
}

.permisos-agentes-vacio {
  padding: 0.75rem;
  text-align: center;
  color: #64748b;
  font-size: 0.8rem;
}

.permisos-edicion-acciones {
  display: flex;
  gap: 0.5rem;
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid #334155;
}

/* Botones */
.permisos-btn {
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;
}

.permisos-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.permisos-btn--cancelar {
  background: #334155;
  color: #d1d5db;
}

.permisos-btn--cancelar:hover:not(:disabled) {
  background: #475569;
}

.permisos-btn--guardar {
  background: #0ea5e9;
  color: #ffffff;
}

.permisos-btn--guardar:hover:not(:disabled) {
  background: #0284c7;
}

/* ============================================
   ESTADOS GENERALES
   ============================================ */

.permisos-estado {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 0.75rem;
  color: #94a3b8;
  font-size: 0.85rem;
  padding: 2rem;
}

.permisos-estado--error {
  color: #ef4444;
}

.permisos-estado button {
  padding: 0.4rem 0.8rem;
  background: #334155;
  border: none;
  color: #e2e8f0;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
}

.permisos-estado button:hover {
  background: #475569;
}

.permisos-spinner {
  width: 28px;
  height: 28px;
  border: 3px solid #334155;
  border-top-color: #0ea5e9;
  border-radius: 50%;
  animation: permisos-spin 0.8s linear infinite;
}

@keyframes permisos-spin {
  to {
    transform: rotate(360deg);
  }
}

/* ============================================
   RESPONSIVE
   ============================================ */

@media (max-width: 768px) {
  .permisos-overlay {
    padding: 0;
  }

  .permisos-modal {
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
    min-width: 100%;
    border-radius: 0;
  }

  .permisos-content {
    flex-direction: column;
  }

  .permisos-master {
    width: 100%;
    max-width: none;
    height: 40%;
    border-right: none;
    border-bottom: 1px solid #334155;
  }

  .permisos-detail {
    flex: 1;
  }

  .permisos-detalle-header {
    flex-wrap: wrap;
  }

  .permisos-btn-editar {
    width: 100%;
    margin-top: 0.5rem;
  }
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalPanelPermisos.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalPanelPermisos.jsx
// Modal para gestionar permisos de usuarios y acceso a agentes (solo superadmin)
// Dise√±o master-detail: Lista de usuarios + Panel de detalles

import React, { useState, useEffect, useMemo, useRef, useCallback } from "react";
import "./ModalPanelPermisos.css";
import {
  listarUsuariosAdmin,
  cambiarRolUsuarioAdmin,
  actualizarAgentesUsuarioAdmin,
  listarAgentesParaPermisos,
  obtenerDetallesUsuarioAdmin,
} from "../../../../servicios/apiService";

/**
 * Modal para gestionar los permisos de usuarios y su acceso a agentes.
 * Solo visible para superadmins.
 * Dise√±o: Master-detail (lista usuarios izquierda + detalles derecha)
 * Caracter√≠sticas: Arrastrable, redimensionable, no se cierra al hacer clic fuera
 */
const ModalPanelPermisos = ({ abierto, onCerrar }) => {
  // Estado principal
  const [usuarios, setUsuarios] = useState([]);
  const [agentesDisponibles, setAgentesDisponibles] = useState([]);
  const [cargando, setCargando] = useState(false);
  const [error, setError] = useState(null);

  // Estado de ventana (minimizado/maximizado)
  const [estadoVentana, setEstadoVentana] = useState("normal");

  // Estado para arrastrar
  const [posicion, setPosicion] = useState({ x: null, y: null });
  const [arrastrando, setArrastrando] = useState(false);
  const modalRef = useRef(null);
  const dragOffset = useRef({ x: 0, y: 0 });

  // B√∫squeda y filtrado
  const [busqueda, setBusqueda] = useState("");
  const [filtroRol, setFiltroRol] = useState("todos");

  // Usuario seleccionado para ver detalles
  const [usuarioSeleccionado, setUsuarioSeleccionado] = useState(null);
  const [detallesUsuario, setDetallesUsuario] = useState(null);
  const [cargandoDetalles, setCargandoDetalles] = useState(false);
  const [errorDetalles, setErrorDetalles] = useState(null);

  // Estado de edici√≥n
  const [modoEdicion, setModoEdicion] = useState(false);
  const [cambiosPendientes, setCambiosPendientes] = useState({});
  const [guardando, setGuardando] = useState(false);

  // Roles disponibles para asignar (no incluye superadmin)
  const rolesDisponibles = [
    { codigo: "admin", nombre: "Administrador" },
    { codigo: "operador", nombre: "Operador" },
    { codigo: "observador", nombre: "Observador" },
  ];

  // Usuarios filtrados
  const usuariosFiltrados = useMemo(() => {
    return usuarios.filter((u) => {
      const coincideBusqueda =
        busqueda === "" ||
        u.nombre?.toLowerCase().includes(busqueda.toLowerCase()) ||
        u.email?.toLowerCase().includes(busqueda.toLowerCase());
      const coincideRol = filtroRol === "todos" || u.rolGlobal === filtroRol;
      return coincideBusqueda && coincideRol;
    });
  }, [usuarios, busqueda, filtroRol]);

  // Cargar datos al abrir
  useEffect(() => {
    if (abierto) {
      cargarDatos();
    }
  }, [abierto]);

  // Limpiar estado al cerrar
  useEffect(() => {
    if (!abierto) {
      setUsuarioSeleccionado(null);
      setDetallesUsuario(null);
      setCambiosPendientes({});
      setModoEdicion(false);
      setError(null);
      setBusqueda("");
      setFiltroRol("todos");
      setEstadoVentana("normal");
      setErrorDetalles(null);
      setPosicion({ x: null, y: null });
    }
  }, [abierto]);

  // ============================================
  // L√ìGICA DE ARRASTRAR (DRAG)
  // ============================================
  const handleMouseDownDrag = useCallback((e) => {
    if (e.button !== 0 || estadoVentana === "maximizado") return;
    if (e.target.closest('.permisos-controles')) return;

    const modal = modalRef.current;
    if (!modal) return;

    const rect = modal.getBoundingClientRect();
    dragOffset.current = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    };

    if (posicion.x === null) {
      setPosicion({ x: rect.left, y: rect.top });
    }

    setArrastrando(true);
    e.preventDefault();
  }, [estadoVentana, posicion.x]);

  const handleMouseMoveDrag = useCallback((e) => {
    if (!arrastrando) return;

    const newX = e.clientX - dragOffset.current.x;
    const newY = e.clientY - dragOffset.current.y;

    const modal = modalRef.current;
    if (modal) {
      const maxX = window.innerWidth - modal.offsetWidth;
      const maxY = window.innerHeight - modal.offsetHeight;
      setPosicion({
        x: Math.max(0, Math.min(newX, maxX)),
        y: Math.max(0, Math.min(newY, maxY)),
      });
    }
  }, [arrastrando]);

  const handleMouseUpDrag = useCallback(() => {
    setArrastrando(false);
  }, []);

  useEffect(() => {
    if (arrastrando) {
      window.addEventListener('mousemove', handleMouseMoveDrag);
      window.addEventListener('mouseup', handleMouseUpDrag);
      return () => {
        window.removeEventListener('mousemove', handleMouseMoveDrag);
        window.removeEventListener('mouseup', handleMouseUpDrag);
      };
    }
  }, [arrastrando, handleMouseMoveDrag, handleMouseUpDrag]);

  const handleMinimizar = () => {
    setEstadoVentana(estadoVentana === "minimizado" ? "normal" : "minimizado");
  };

  const handleMaximizar = () => {
    if (estadoVentana === "maximizado") {
      setEstadoVentana("normal");
    } else {
      setEstadoVentana("maximizado");
      setPosicion({ x: null, y: null });
    }
  };

  const cargarDatos = async () => {
    try {
      setCargando(true);
      setError(null);

      const [usuariosData, agentesData] = await Promise.all([
        listarUsuariosAdmin(),
        listarAgentesParaPermisos(),
      ]);

      setUsuarios(usuariosData);
      setAgentesDisponibles(agentesData);
    } catch (err) {
      console.error("Error cargando datos:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Seleccionar usuario y cargar sus detalles
  const seleccionarUsuario = async (usuario) => {
    if (usuarioSeleccionado?.id === usuario.id) return;

    setUsuarioSeleccionado(usuario);
    setModoEdicion(false);
    setCambiosPendientes({});
    setCargandoDetalles(true);
    setErrorDetalles(null);
    setDetallesUsuario(null);

    try {
      const detalles = await obtenerDetallesUsuarioAdmin(usuario.id);
      setDetallesUsuario(detalles);
    } catch (err) {
      console.error("Error cargando detalles:", err);
      setErrorDetalles(err.message || "Error al cargar detalles");
    } finally {
      setCargandoDetalles(false);
    }
  };

  // Iniciar modo edici√≥n
  const iniciarEdicion = () => {
    if (!usuarioSeleccionado) return;
    setModoEdicion(true);
    setCambiosPendientes({
      rolGlobal: usuarioSeleccionado.rolGlobal,
      accesoTotal: usuarioSeleccionado.permisoAgentes?.accesoTotal || false,
      agentesIds: usuarioSeleccionado.permisoAgentes?.agentes?.map((a) => a.id) || [],
    });
  };

  const handleCambioRol = (nuevoRol) => {
    setCambiosPendientes((prev) => ({ ...prev, rolGlobal: nuevoRol }));
  };

  const handleToggleAccesoTotal = () => {
    setCambiosPendientes((prev) => ({
      ...prev,
      accesoTotal: !prev.accesoTotal,
      agentesIds: !prev.accesoTotal ? [] : prev.agentesIds,
    }));
  };

  const handleToggleAgente = (agenteId) => {
    setCambiosPendientes((prev) => {
      const yaIncluido = prev.agentesIds.includes(agenteId);
      return {
        ...prev,
        agentesIds: yaIncluido
          ? prev.agentesIds.filter((id) => id !== agenteId)
          : [...prev.agentesIds, agenteId],
      };
    });
  };

  const tieneModificaciones = () => {
    if (!usuarioSeleccionado || !cambiosPendientes.rolGlobal) return false;

    const rolCambio = usuarioSeleccionado.rolGlobal !== cambiosPendientes.rolGlobal;
    const accesoTotalCambio =
      (usuarioSeleccionado.permisoAgentes?.accesoTotal || false) !== cambiosPendientes.accesoTotal;
    const agentesOriginales =
      usuarioSeleccionado.permisoAgentes?.agentes?.map((a) => a.id).sort() || [];
    const agentesNuevos = [...cambiosPendientes.agentesIds].sort();
    const agentesCambio = JSON.stringify(agentesOriginales) !== JSON.stringify(agentesNuevos);

    return rolCambio || accesoTotalCambio || agentesCambio;
  };

  const handleGuardarUsuario = async () => {
    if (!usuarioSeleccionado) return;

    try {
      setGuardando(true);
      setError(null);

      if (usuarioSeleccionado.rolGlobal !== cambiosPendientes.rolGlobal) {
        await cambiarRolUsuarioAdmin(usuarioSeleccionado.id, cambiosPendientes.rolGlobal);
      }

      await actualizarAgentesUsuarioAdmin(
        usuarioSeleccionado.id,
        cambiosPendientes.accesoTotal,
        cambiosPendientes.agentesIds
      );

      await cargarDatos();
      // Recargar detalles del usuario
      const detalles = await obtenerDetallesUsuarioAdmin(usuarioSeleccionado.id);
      setDetallesUsuario(detalles);
      // Actualizar usuario seleccionado con nuevos datos
      const usuarioActualizado = (await listarUsuariosAdmin()).find(u => u.id === usuarioSeleccionado.id);
      if (usuarioActualizado) setUsuarioSeleccionado(usuarioActualizado);

      setModoEdicion(false);
      setCambiosPendientes({});
    } catch (err) {
      console.error("Error guardando usuario:", err);
      setError(err.message || err.detalles || "Error al guardar permisos");
    } finally {
      setGuardando(false);
    }
  };

  const handleCancelarEdicion = () => {
    setModoEdicion(false);
    setCambiosPendientes({});
  };

  const getAccesoTexto = (usuario) => {
    if (usuario.permisoAgentes?.accesoTotal) return "Todos";
    const count = usuario.permisoAgentes?.agentes?.length || 0;
    if (count === 0) return "Sin acceso a agentes";
    return `${count} agente${count > 1 ? "s" : ""}`;
  };

  // Agrupar invitados por rol
  const agruparInvitadosPorRol = (invitados) => {
    const grupos = {};
    invitados.forEach((inv) => {
      const rol = inv.rol || "observador";
      if (!grupos[rol]) grupos[rol] = [];
      grupos[rol].push(inv);
    });
    return grupos;
  };

  // Renderizar panel de detalles
  const renderPanelDetalles = () => {
    if (!usuarioSeleccionado) {
      return (
        <div className="permisos-detalle-vacio">
          <span className="permisos-detalle-vacio-icono">üë§</span>
          <span>Selecciona un usuario para ver sus detalles</span>
        </div>
      );
    }

    if (cargandoDetalles) {
      return (
        <div className="permisos-detalle-cargando">
          <div className="permisos-spinner"></div>
          <span>Cargando detalles...</span>
        </div>
      );
    }

    if (errorDetalles) {
      return (
        <div className="permisos-detalle-error">
          <span>Error: {errorDetalles}</span>
        </div>
      );
    }

    const { workspacesPropios = [], workspacesComoInvitado = [], resumen = {} } = detallesUsuario || {};

    return (
      <div className="permisos-detalle">
        {/* Header del usuario */}
        <div className="permisos-detalle-header">
          <div className="permisos-detalle-usuario">
            <span className="permisos-detalle-nombre">
              {usuarioSeleccionado.nombre || "Sin nombre"}
            </span>
            <span className="permisos-detalle-email">{usuarioSeleccionado.email}</span>
          </div>
          <div className="permisos-detalle-badges">
            <span className={`permisos-badge permisos-badge--${usuarioSeleccionado.rolGlobal}`}>
              {usuarioSeleccionado.rolNombre}
            </span>
            <span className="permisos-detalle-acceso">
              {getAccesoTexto(usuarioSeleccionado)}
            </span>
          </div>
          {!modoEdicion && (
            <button
              type="button"
              className="permisos-btn-editar"
              onClick={iniciarEdicion}
            >
              Editar permisos
            </button>
          )}
        </div>

        {/* Modo edici√≥n */}
        {modoEdicion && (
          <div className="permisos-detalle-edicion">
            <h4>Editar Permisos</h4>

            <div className="permisos-campo">
              <label className="permisos-label">Rol Global</label>
              <select
                className="permisos-select"
                value={cambiosPendientes.rolGlobal || ""}
                onChange={(e) => handleCambioRol(e.target.value)}
                disabled={guardando}
              >
                {rolesDisponibles.map((rol) => (
                  <option key={rol.codigo} value={rol.codigo}>
                    {rol.nombre}
                  </option>
                ))}
              </select>
            </div>

            <div className="permisos-campo">
              <label className="permisos-label">Acceso a Agentes</label>
              <label className="permisos-checkbox permisos-checkbox--destacado">
                <input
                  type="checkbox"
                  checked={cambiosPendientes.accesoTotal}
                  onChange={handleToggleAccesoTotal}
                  disabled={guardando}
                />
                <span>Acceso a todos los agentes</span>
              </label>

              {!cambiosPendientes.accesoTotal && (
                <div className="permisos-agentes-lista">
                  {agentesDisponibles.length === 0 ? (
                    <span className="permisos-agentes-vacio">No hay agentes disponibles</span>
                  ) : (
                    agentesDisponibles.map((agente) => (
                      <label key={agente.id} className="permisos-checkbox">
                        <input
                          type="checkbox"
                          checked={cambiosPendientes.agentesIds.includes(agente.id)}
                          onChange={() => handleToggleAgente(agente.id)}
                          disabled={guardando}
                        />
                        <span>{agente.nombre}</span>
                        {!agente.activo && <span className="permisos-agente-inactivo">(inactivo)</span>}
                      </label>
                    ))
                  )}
                </div>
              )}
            </div>

            <div className="permisos-edicion-acciones">
              <button
                type="button"
                className="permisos-btn permisos-btn--cancelar"
                onClick={handleCancelarEdicion}
                disabled={guardando}
              >
                Cancelar
              </button>
              <button
                type="button"
                className="permisos-btn permisos-btn--guardar"
                onClick={handleGuardarUsuario}
                disabled={guardando || !tieneModificaciones()}
              >
                {guardando ? "Guardando..." : "Guardar"}
              </button>
            </div>
          </div>
        )}

        {/* Resumen de estad√≠sticas */}
        {!modoEdicion && detallesUsuario && (
          <>
            <div className="permisos-detalle-stats">
              <div className="permisos-stat-item">
                <span className="permisos-stat-numero">{resumen.totalWorkspacesPropios ?? workspacesPropios.length}</span>
                <span className="permisos-stat-label">Workspaces propios</span>
              </div>
              <div className="permisos-stat-item">
                <span className="permisos-stat-numero">{resumen.totalPuestos ?? 0}</span>
                <span className="permisos-stat-label">Puestos totales</span>
              </div>
              <div className="permisos-stat-item">
                <span className="permisos-stat-numero">{resumen.totalWorkspacesInvitado ?? workspacesComoInvitado.length}</span>
                <span className="permisos-stat-label">Como invitado</span>
              </div>
            </div>

            {/* Contenido de workspaces */}
            <div className="permisos-detalle-contenido">
              {/* Workspaces propios */}
              {workspacesPropios.length > 0 && (
                <div className="permisos-seccion">
                  <h4 className="permisos-seccion-titulo">Workspaces Propios</h4>
                  <div className="permisos-workspaces-grid">
                    {workspacesPropios.map((ws) => {
                      const invitadosAgrupados = agruparInvitadosPorRol(ws.invitados || []);
                      return (
                        <div key={ws.id} className="permisos-workspace-card">
                          <div className="permisos-workspace-header">
                            <span className="permisos-workspace-nombre">{ws.nombre}</span>
                            <span className="permisos-workspace-puestos">
                              {ws.cantidadPuestos} puesto{ws.cantidadPuestos !== 1 ? "s" : ""}
                            </span>
                          </div>

                          {/* Agentes */}
                          <div className="permisos-workspace-row">
                            <span className="permisos-workspace-label">Agentes:</span>
                            {ws.agentes.length === 0 ? (
                              <span className="permisos-workspace-vacio">Sin agente</span>
                            ) : (
                              <div className="permisos-workspace-chips">
                                {ws.agentes.map((a) => (
                                  <span
                                    key={a.id}
                                    className={`permisos-chip ${!a.activo ? "permisos-chip--inactivo" : ""}`}
                                  >
                                    {a.nombre}
                                  </span>
                                ))}
                              </div>
                            )}
                          </div>

                          {/* Invitados agrupados por rol */}
                          <div className="permisos-workspace-row">
                            <span className="permisos-workspace-label">Invitados:</span>
                            {ws.invitados.length === 0 ? (
                              <span className="permisos-workspace-vacio">Sin invitados</span>
                            ) : (
                              <div className="permisos-invitados-grupos">
                                {Object.entries(invitadosAgrupados).map(([rol, invs]) => (
                                  <div key={rol} className="permisos-invitados-grupo">
                                    <span className={`permisos-rol-badge permisos-rol-badge--${rol}`}>
                                      {rol.toUpperCase()} ({invs.length})
                                    </span>
                                    <span className="permisos-invitados-nombres">
                                      {invs.map((inv) => inv.nombre || inv.email).join(", ")}
                                    </span>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}

              {/* Workspaces como invitado */}
              {workspacesComoInvitado.length > 0 && (
                <div className="permisos-seccion">
                  <h4 className="permisos-seccion-titulo">Acceso como Invitado</h4>
                  <div className="permisos-workspaces-grid">
                    {workspacesComoInvitado.map((ws) => (
                      <div key={ws.id} className="permisos-workspace-card permisos-workspace-card--invitado">
                        <div className="permisos-workspace-header">
                          <span className="permisos-workspace-nombre">{ws.nombre}</span>
                          <span className={`permisos-rol-badge permisos-rol-badge--${ws.rol}`}>
                            {ws.rol?.toUpperCase()}
                          </span>
                        </div>
                        <div className="permisos-workspace-row">
                          <span className="permisos-workspace-label">Propietario:</span>
                          <span className="permisos-workspace-propietario">
                            {ws.propietario?.nombre || ws.propietario?.email || "Desconocido"}
                          </span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Sin datos */}
              {workspacesPropios.length === 0 && workspacesComoInvitado.length === 0 && (
                <div className="permisos-detalle-sin-datos">
                  Este usuario no tiene workspaces propios ni acceso como invitado.
                </div>
              )}
            </div>
          </>
        )}
      </div>
    );
  };

  if (!abierto) return null;

  const getModalClase = () => {
    let clase = "permisos-modal";
    if (estadoVentana === "minimizado") clase += " permisos-modal--minimizado";
    if (estadoVentana === "maximizado") clase += " permisos-modal--maximizado";
    if (arrastrando) clase += " permisos-modal--arrastrando";
    return clase;
  };

  const getModalEstilo = () => {
    if (estadoVentana === "maximizado") {
      return { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, width: "100%", height: "100%" };
    }
    if (estadoVentana === "minimizado") {
      return { position: "fixed", bottom: "1rem", left: "1rem" };
    }
    if (posicion.x !== null && posicion.y !== null) {
      return { position: "fixed", top: posicion.y, left: posicion.x };
    }
    return {};
  };

  const getOverlayClase = () => {
    let clase = "permisos-overlay";
    if (estadoVentana === "minimizado") clase += " permisos-overlay--minimizado";
    if (estadoVentana === "maximizado") clase += " permisos-overlay--maximizado";
    return clase;
  };

  return (
    <div className={getOverlayClase()}>
      <div
        ref={modalRef}
        className={getModalClase()}
        style={getModalEstilo()}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div
          className="permisos-header"
          onMouseDown={handleMouseDownDrag}
          onDoubleClick={handleMaximizar}
          style={{ cursor: estadoVentana === "maximizado" ? "default" : "move" }}
        >
          <div className="permisos-titulo">
            <span className="permisos-icono">üîê</span>
            <span className="permisos-nombre">Panel de Permisos</span>
          </div>
          <div className="permisos-controles">
            <button
              type="button"
              className="permisos-btn-control"
              onClick={handleMinimizar}
              title={estadoVentana === "minimizado" ? "Restaurar" : "Minimizar"}
            >
              {estadoVentana === "minimizado" ? "üóó" : "‚Äî"}
            </button>
            <button
              type="button"
              className="permisos-btn-control"
              onClick={handleMaximizar}
              title={estadoVentana === "maximizado" ? "Restaurar" : "Maximizar"}
            >
              {estadoVentana === "maximizado" ? "üóó" : "‚òê"}
            </button>
            <button
              type="button"
              className="permisos-btn-cerrar"
              onClick={onCerrar}
              title="Cerrar"
            >
              ‚úï
            </button>
          </div>
        </div>

        {/* Contenido principal - Master Detail */}
        <div className="permisos-content">
          {/* Panel izquierdo - Lista de usuarios */}
          <div className="permisos-master">
            {/* B√∫squeda y filtros */}
            <div className="permisos-master-toolbar">
              <input
                type="text"
                placeholder="Buscar usuario..."
                value={busqueda}
                onChange={(e) => setBusqueda(e.target.value)}
                className="permisos-input-busqueda"
              />
              <select
                value={filtroRol}
                onChange={(e) => setFiltroRol(e.target.value)}
                className="permisos-select-filtro"
              >
                <option value="todos">Todos</option>
                <option value="admin">Admin</option>
                <option value="operador">Operador</option>
                <option value="observador">Observador</option>
              </select>
            </div>

            {/* Lista de usuarios */}
            <div className="permisos-usuarios-lista">
              {cargando ? (
                <div className="permisos-estado">
                  <div className="permisos-spinner"></div>
                  <span>Cargando...</span>
                </div>
              ) : error ? (
                <div className="permisos-estado permisos-estado--error">
                  <span>{error}</span>
                  <button onClick={cargarDatos}>Reintentar</button>
                </div>
              ) : usuariosFiltrados.length === 0 ? (
                <div className="permisos-estado">
                  <span>No hay usuarios</span>
                </div>
              ) : (
                usuariosFiltrados.map((usuario) => (
                  <div
                    key={usuario.id}
                    className={`permisos-usuario-item ${
                      usuarioSeleccionado?.id === usuario.id ? "permisos-usuario-item--activo" : ""
                    }`}
                    onClick={() => seleccionarUsuario(usuario)}
                  >
                    <div className="permisos-usuario-info">
                      <span className="permisos-usuario-nombre">
                        {usuario.nombre || "Sin nombre"}
                      </span>
                      <span className="permisos-usuario-email">{usuario.email}</span>
                    </div>
                    <span className={`permisos-badge-small permisos-badge-small--${usuario.rolGlobal}`}>
                      {usuario.rolGlobal?.substring(0, 3).toUpperCase()}
                    </span>
                  </div>
                ))
              )}
            </div>

            {/* Contador */}
            <div className="permisos-master-footer">
              {usuariosFiltrados.length} de {usuarios.length} usuarios
            </div>
          </div>

          {/* Panel derecho - Detalles */}
          <div className="permisos-detail">
            {renderPanelDetalles()}
          </div>
        </div>
      </div>
    </div>
  );
};

export default ModalPanelPermisos;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalPlantillasRele.css =====

/* Modal de Gesti√≥n de Plantillas de Rel√©s */

.modal-plantillas-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.modal-plantillas-contenido {
  background: #1a1f2e;
  border-radius: 8px;
  width: 90%;
  max-width: 700px;
  max-height: 85vh;
  display: flex;
  flex-direction: column;
  border: 1px solid #2a3447;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}

/* Header */
.modal-plantillas-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #2a3447;
}

.modal-plantillas-header h3 {
  margin: 0;
  font-size: 1.1rem;
  color: #e4e4e7;
}

.modal-plantillas-cerrar {
  background: none;
  border: none;
  color: #71717a;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 0;
  line-height: 1;
  transition: color 0.2s;
}

.modal-plantillas-cerrar:hover {
  color: #e4e4e7;
}

/* Body */
.modal-plantillas-body {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

/* Bot√≥n crear */
.modal-plantillas-btn-crear {
  width: 100%;
  padding: 12px;
  background: #2563eb;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 0.95rem;
  cursor: pointer;
  margin-bottom: 16px;
  transition: background 0.2s;
}

.modal-plantillas-btn-crear:hover {
  background: #1d4ed8;
}

/* Estado vac√≠o */
.modal-plantillas-vacio {
  text-align: center;
  padding: 40px 20px;
  color: #71717a;
}

.modal-plantillas-vacio-icono {
  font-size: 3rem;
  display: block;
  margin-bottom: 16px;
  opacity: 0.5;
}

.modal-plantillas-vacio p {
  margin: 8px 0;
}

.modal-plantillas-hint {
  font-size: 0.85rem;
  color: #52525b;
}

/* Lista de plantillas */
.modal-plantillas-lista {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.modal-plantillas-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #252b3b;
  border-radius: 6px;
  padding: 14px 16px;
  border: 1px solid #2a3447;
}

.modal-plantillas-item-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.modal-plantillas-item-nombre {
  font-weight: 500;
  color: #e4e4e7;
}

.modal-plantillas-item-desc {
  font-size: 0.85rem;
  color: #a1a1aa;
}

.modal-plantillas-item-func {
  font-size: 0.8rem;
  color: #9ca3af;
}

.modal-plantillas-item-acciones {
  display: flex;
  gap: 8px;
}

.modal-plantillas-btn-editar,
.modal-plantillas-btn-eliminar {
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 0.85rem;
  cursor: pointer;
  border: none;
  transition: all 0.2s;
}

.modal-plantillas-btn-editar {
  background: #374151;
  color: #e4e4e7;
}

.modal-plantillas-btn-editar:hover {
  background: #4b5563;
}

.modal-plantillas-btn-eliminar {
  background: #7f1d1d;
  color: #fca5a5;
}

.modal-plantillas-btn-eliminar:hover {
  background: #991b1b;
}

/* Formulario */
.modal-plantillas-formulario {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.modal-plantillas-error {
  background: rgba(220, 38, 38, 0.1);
  border: 1px solid #dc2626;
  color: #fca5a5;
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 0.9rem;
}

.modal-plantillas-campo {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.modal-plantillas-campo label {
  font-size: 0.85rem;
  color: #a1a1aa;
}

.modal-plantillas-campo input {
  padding: 10px 12px;
  background: #252b3b;
  border: 1px solid #2a3447;
  border-radius: 6px;
  color: #e4e4e7;
  font-size: 0.95rem;
}

.modal-plantillas-campo input:focus {
  outline: none;
  border-color: #2563eb;
}

.modal-plantillas-campo input::placeholder {
  color: #52525b;
}

/* Secci√≥n funcionalidades */
.modal-plantillas-seccion {
  margin-top: 8px;
}

.modal-plantillas-seccion h4 {
  margin: 0 0 4px 0;
  font-size: 0.95rem;
  color: #e4e4e7;
}

.modal-plantillas-seccion > .modal-plantillas-hint {
  margin-bottom: 16px;
}

/* Categor√≠as */
.modal-plantillas-categoria {
  margin-bottom: 16px;
}

.modal-plantillas-categoria h5 {
  margin: 0 0 10px 0;
  font-size: 0.85rem;
  color: #a1a1aa;
  padding-bottom: 6px;
  border-bottom: 1px solid #2a3447;
}

.modal-plantillas-func-lista {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.modal-plantillas-func-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 12px;
  background: #252b3b;
  border-radius: 6px;
  border: 1px solid transparent;
  transition: all 0.2s;
}

.modal-plantillas-func-item.activo {
  border-color: #2563eb;
  background: rgba(37, 99, 235, 0.1);
}

.modal-plantillas-func-check {
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  flex: 1;
}

.modal-plantillas-func-check input[type="checkbox"] {
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: #2563eb;
}

.modal-plantillas-func-nombre {
  color: #e4e4e7;
  font-size: 0.9rem;
}

.modal-plantillas-func-registro {
  display: flex;
  align-items: center;
  gap: 8px;
}

.modal-plantillas-func-registro label {
  font-size: 0.8rem;
  color: #71717a;
}

.modal-plantillas-func-registro input {
  width: 70px;
  padding: 6px 8px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 4px;
  color: #e4e4e7;
  font-size: 0.85rem;
  text-align: center;
}

.modal-plantillas-func-registro input:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.modal-plantillas-func-registro input:focus {
  outline: none;
  border-color: #2563eb;
}

/* Footer */
.modal-plantillas-footer {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 16px 20px;
  border-top: 1px solid #2a3447;
}

.modal-plantillas-btn-cerrar,
.modal-plantillas-btn-cancelar,
.modal-plantillas-btn-guardar {
  padding: 10px 20px;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
  border: none;
  transition: all 0.2s;
}

.modal-plantillas-btn-cerrar {
  background: #374151;
  color: #e4e4e7;
}

.modal-plantillas-btn-cerrar:hover {
  background: #4b5563;
}

.modal-plantillas-btn-cancelar {
  background: transparent;
  color: #a1a1aa;
  border: 1px solid #2a3447;
}

.modal-plantillas-btn-cancelar:hover {
  background: #252b3b;
}

.modal-plantillas-btn-guardar {
  background: #2563eb;
  color: white;
}

.modal-plantillas-btn-guardar:hover {
  background: #1d4ed8;
}

/* ========================================
   NUEVA UI: Agregar funcionalidad
   ======================================== */

.modal-plantillas-agregar-func {
  background: #252b3b;
  border-radius: 8px;
  padding: 16px;
  border: 1px dashed #3b4557;
}

.modal-plantillas-agregar-row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.modal-plantillas-agregar-campo {
  display: flex;
  flex-direction: column;
  gap: 6px;
  flex: 1;
}

.modal-plantillas-agregar-campo--peque√±o {
  flex: 0 0 70px;
}

.modal-plantillas-agregar-campo--categoria {
  flex: 0 0 140px;
}

.modal-plantillas-agregar-campo select {
  padding: 10px 12px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 6px;
  color: #e4e4e7;
  font-size: 0.9rem;
  cursor: pointer;
}

.modal-plantillas-agregar-campo select:focus {
  outline: none;
  border-color: #2563eb;
}

.modal-plantillas-agregar-campo label {
  font-size: 0.8rem;
  color: #a1a1aa;
}

.modal-plantillas-agregar-campo input {
  padding: 10px 12px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 6px;
  color: #e4e4e7;
  font-size: 0.9rem;
}

.modal-plantillas-agregar-campo input:focus {
  outline: none;
  border-color: #2563eb;
}

.modal-plantillas-agregar-campo input::placeholder {
  color: #52525b;
}

.modal-plantillas-btn-agregar {
  padding: 10px 16px;
  background: #059669;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
  white-space: nowrap;
  transition: background 0.2s;
}

.modal-plantillas-btn-agregar:hover {
  background: #047857;
}

/* ========================================
   Funcionalidad Card (nueva estructura)
   ======================================== */

.modal-plantillas-func-card {
  background: #252b3b;
  border-radius: 8px;
  padding: 14px;
  border: 1px solid #2a3447;
  transition: all 0.2s;
}

.modal-plantillas-func-card.activo {
  border-color: #2563eb;
  background: rgba(37, 99, 235, 0.08);
}

.modal-plantillas-func-card.inactivo {
  opacity: 0.6;
}

.modal-plantillas-func-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
}

/* ========================================
   DROPDOWN PERSONALIZADO TI/TV
   ======================================== */

.dropdown-transformador {
  position: relative;
  flex: 1;
  min-width: 0;
}

.dropdown-transformador.disabled {
  opacity: 0.5;
  pointer-events: none;
}

.dropdown-transformador-trigger {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 10px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 6px;
  color: #e4e4e7;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
  width: 100%;
  min-width: 0;
  overflow: hidden;
}

.dropdown-transformador-trigger:hover:not(:disabled) {
  border-color: #3b4557;
  background: #252b3b;
}

.dropdown-transformador-trigger:focus {
  outline: none;
  border-color: #2563eb;
}

.dropdown-transformador-texto {
  flex: 1;
  text-align: left;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 0.75rem;
}

.dropdown-transformador-chevron {
  font-size: 0.55rem;
  color: #71717a;
  transition: transform 0.2s;
  flex-shrink: 0;
}

/* Menu desplegable - aparece a la derecha, centrado verticalmente */
.dropdown-transformador-menu {
  position: absolute;
  left: calc(100% + 8px);
  top: 50%;
  transform: translateY(-50%);
  min-width: 200px;
  width: max-content;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  z-index: 3000;
  max-height: 300px;
  overflow-y: auto;
  padding: 8px 0;
}

/* Versi√≥n fixed del men√∫ - no es cortado por el modal */
.dropdown-transformador-menu--fixed {
  position: fixed;
  transform: none;
  max-height: 500px;
}

/* Fuente m√°s peque√±a en el men√∫ desplegable */
.dropdown-transformador-menu--fixed .dropdown-transformador-nombre {
  font-size: 0.8rem;
}

.dropdown-transformador-menu--fixed .dropdown-transformador-formula {
  font-size: 0.75rem;
  padding: 4px 8px;
}

.dropdown-transformador-menu--fixed .dropdown-transformador-opcion {
  padding: 8px 14px;
  gap: 12px;
}

/* L√≠nea divisoria con degradado */
.dropdown-transformador-divider {
  height: 1px;
  margin: 8px 16px;
  background: linear-gradient(
    to right,
    transparent 0%,
    #3b4557 20%,
    #4b5567 50%,
    #3b4557 80%,
    transparent 100%
  );
}

/* Opci√≥n individual */
.dropdown-transformador-opcion {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 10px 16px;
  cursor: pointer;
  transition: background 0.15s;
  white-space: nowrap;
}

.dropdown-transformador-opcion:hover {
  background: rgba(37, 99, 235, 0.15);
}

.dropdown-transformador-opcion.seleccionado {
  background: rgba(37, 99, 235, 0.25);
}

.dropdown-transformador-opcion.seleccionado .dropdown-transformador-nombre {
  color: #93c5fd;
  font-weight: 500;
}

.dropdown-transformador-nombre {
  color: #e4e4e7;
  font-size: 0.9rem;
  white-space: nowrap;
}

/* Estilos del trigger del dropdown - fuente m√°s peque√±a */
.dropdown-transformador-trigger .dropdown-transformador-nombre {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 0.75rem;
}

/* Mostrar f√≥rmula en el trigger - compacta, sin truncar */
.dropdown-transformador-trigger .dropdown-transformador-formula {
  flex-shrink: 0;
  font-size: 0.7rem;
  padding: 3px 6px;
}

/* Input readonly para la f√≥rmula */
.dropdown-transformador-formula {
  padding: 5px 10px;
  background: #252b3b;
  border: 1px solid #2a3447;
  border-radius: 4px;
  color: #e4e4e7;
  font-size: 0.85rem;
  font-family: "Consolas", "Monaco", monospace;
  text-align: center;
  pointer-events: none;
  white-space: nowrap;
  width: auto;
  field-sizing: content;
}

/* Estado vac√≠o */
.dropdown-transformador-vacio {
  padding: 16px;
  text-align: center;
  color: #71717a;
  font-size: 0.85rem;
  font-style: italic;
}

/* Contenedor de acciones (mover y eliminar) */
.modal-plantillas-func-acciones {
  display: flex;
  align-items: center;
  gap: 4px;
}

/* Botones de mover arriba/abajo */
.modal-plantillas-func-mover {
  background: transparent;
  border: 1px solid #3b4557;
  color: #71717a;
  font-size: 0.65rem;
  cursor: pointer;
  padding: 4px 6px;
  line-height: 1;
  border-radius: 4px;
  transition: all 0.2s;
}

.modal-plantillas-func-mover:hover {
  background: rgba(37, 99, 235, 0.2);
  border-color: #2563eb;
  color: #93c5fd;
}

.modal-plantillas-func-eliminar {
  background: transparent;
  border: none;
  color: #71717a;
  font-size: 1.3rem;
  cursor: pointer;
  padding: 0 4px;
  line-height: 1;
  transition: color 0.2s;
}

.modal-plantillas-func-eliminar:hover {
  color: #ef4444;
}

/* ========================================
   Registros individuales
   ======================================== */

.modal-plantillas-registros {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 26px; /* Alinear con el texto del checkbox */
}

.modal-plantillas-registro-item {
  display: flex;
  align-items: center;
  gap: 8px;
}

.modal-plantillas-registro-etiqueta {
  flex: 1;
  max-width: 150px;
  padding: 8px 10px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 4px;
  color: #e4e4e7;
  font-size: 0.85rem;
}

.modal-plantillas-registro-etiqueta:focus {
  outline: none;
  border-color: #2563eb;
}

.modal-plantillas-registro-etiqueta::placeholder {
  color: #52525b;
}

.modal-plantillas-registro-etiqueta:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.modal-plantillas-registro-separador {
  color: #52525b;
  font-size: 0.9rem;
}

.modal-plantillas-registro-valor {
  width: 80px;
  padding: 8px 10px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 4px;
  color: #e4e4e7;
  font-size: 0.85rem;
  text-align: center;
}

.modal-plantillas-registro-valor:focus {
  outline: none;
  border-color: #2563eb;
}

.modal-plantillas-registro-valor:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* ========================================
   Ocultar spinners en TODOS los inputs number del modal
   ======================================== */

.modal-plantillas-contenido input[type="number"]::-webkit-outer-spin-button,
.modal-plantillas-contenido input[type="number"]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.modal-plantillas-contenido input[type="number"] {
  -moz-appearance: textfield;
}

/* Estado vac√≠o para funcionalidades */
.modal-plantillas-vacio-func {
  text-align: center;
  padding: 30px 20px;
  background: #252b3b;
  border-radius: 8px;
  border: 1px dashed #3b4557;
  color: #71717a;
}

.modal-plantillas-vacio-func p {
  margin: 4px 0;
}

.modal-plantillas-vacio-func .modal-plantillas-hint {
  font-size: 0.85rem;
  color: #52525b;
}

/* ========================================
   SECCI√ìN DE ETIQUETAS DE BITS (LEDs)
   ======================================== */

.modal-plantillas-seccion-etiquetas {
  margin-top: 16px;
  border: 1px solid #2a3447;
  border-radius: 8px;
  overflow: hidden;
}

.modal-plantillas-seccion-header-colapsable {
  background: #1a1f2e;
  padding: 12px 16px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  gap: 4px;
  transition: background 0.2s;
}

.modal-plantillas-seccion-header-colapsable:hover {
  background: #252b3b;
}

.modal-plantillas-seccion-header-colapsable h4 {
  margin: 0;
  font-size: 0.95rem;
  font-weight: 600;
  color: #e4e4e7;
  display: flex;
  align-items: center;
  gap: 8px;
}

.modal-plantillas-chevron {
  font-size: 0.7rem;
  transition: transform 0.2s;
  color: #71717a;
}

.modal-plantillas-chevron.abierto {
  transform: rotate(90deg);
}

.modal-plantillas-badge {
  background: #2563eb;
  color: white;
  font-size: 0.7rem;
  padding: 2px 6px;
  border-radius: 10px;
  font-weight: 500;
}

.modal-plantillas-hint-inline {
  font-size: 0.8rem;
  color: #71717a;
  margin-left: 20px;
}

.modal-plantillas-etiquetas-contenido {
  padding: 16px;
  background: #1a1f2e;
  border-top: 1px solid #2a3447;
}

/* Acciones: selector de plantilla + limpiar */
.modal-plantillas-etiquetas-acciones {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid #2a3447;
}

.modal-plantillas-etiquetas-acciones label {
  font-size: 0.85rem;
  color: #a1a1aa;
}

.modal-plantillas-etiquetas-acciones select {
  flex: 1;
  max-width: 200px;
  padding: 8px 10px;
  background: #252b3b;
  border: 1px solid #2a3447;
  border-radius: 6px;
  color: #e4e4e7;
  font-size: 0.85rem;
  cursor: pointer;
}

.modal-plantillas-etiquetas-acciones select:focus {
  outline: none;
  border-color: #2563eb;
}

.modal-plantillas-btn-limpiar {
  padding: 6px 12px;
  background: transparent;
  border: 1px solid #52525b;
  border-radius: 4px;
  color: #a1a1aa;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
}

.modal-plantillas-btn-limpiar:hover {
  background: rgba(239, 68, 68, 0.1);
  border-color: #ef4444;
  color: #ef4444;
}

/* Lista de bits */
.modal-plantillas-bits-lista {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.modal-plantillas-bit-item {
  display: flex;
  align-items: center;
  gap: 10px;
}

.modal-plantillas-bit-numero {
  width: 50px;
  font-size: 0.8rem;
  color: #71717a;
  font-family: monospace;
}

.modal-plantillas-bit-etiqueta {
  flex: 1;
  padding: 8px 10px;
  background: #252b3b;
  border: 1px solid #2a3447;
  border-radius: 4px;
  color: #e4e4e7;
  font-size: 0.85rem;
}

.modal-plantillas-bit-etiqueta:focus {
  outline: none;
  border-color: #2563eb;
}

.modal-plantillas-bit-etiqueta::placeholder {
  color: #52525b;
}

.modal-plantillas-bit-severidad {
  width: 110px;
  padding: 8px 10px;
  background: #252b3b;
  border: 1px solid #2a3447;
  border-radius: 4px;
  color: #e4e4e7;
  font-size: 0.8rem;
  cursor: pointer;
}

.modal-plantillas-bit-severidad:focus {
  outline: none;
  border-color: #2563eb;
}

/* Colores de severidad para el select */
.modal-plantillas-bit-severidad.severidad-info {
  border-left: 3px solid #93c5fd;
}

.modal-plantillas-bit-severidad.severidad-estado {
  border-left: 3px solid #93c5fd;
}

.modal-plantillas-bit-severidad.severidad-warning {
  border-left: 3px solid #fde68a;
}

.modal-plantillas-bit-severidad.severidad-alarma {
  border-left: 3px solid #fca5a5;
}

.modal-plantillas-bit-severidad.severidad-error {
  border-left: 3px solid #ef4444;
}

/* ========================================
   NUEVA PLANTILLA DE ETIQUETAS
   ======================================== */

.modal-plantillas-nueva-plantilla-etiquetas {
  margin-bottom: 16px;
  padding: 12px;
  background: rgba(37, 99, 235, 0.1);
  border: 1px solid #2563eb;
  border-radius: 6px;
}

.modal-plantillas-nueva-plantilla-header {
  display: flex;
  gap: 12px;
  align-items: center;
}

.modal-plantillas-nueva-plantilla-nombre {
  flex: 1;
  padding: 10px 12px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 6px;
  color: #e4e4e7;
  font-size: 0.9rem;
}

.modal-plantillas-nueva-plantilla-nombre:focus {
  outline: none;
  border-color: #2563eb;
}

.modal-plantillas-nueva-plantilla-nombre::placeholder {
  color: #71717a;
}

.modal-plantillas-nueva-plantilla-botones {
  display: flex;
  gap: 8px;
}

.modal-plantillas-btn-guardar-etiquetas {
  padding: 8px 16px;
  background: #059669;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: background 0.2s;
}

.modal-plantillas-btn-guardar-etiquetas:hover {
  background: #047857;
}

.modal-plantillas-btn-cancelar-etiquetas {
  padding: 8px 16px;
  background: transparent;
  color: #a1a1aa;
  border: 1px solid #52525b;
  border-radius: 4px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s;
}

.modal-plantillas-btn-cancelar-etiquetas:hover {
  background: rgba(239, 68, 68, 0.1);
  border-color: #ef4444;
  color: #ef4444;
}

/* ========================================
   BOTONES AGREGAR/QUITAR BITS
   ======================================== */

.modal-plantillas-bits-acciones {
  display: flex;
  gap: 10px;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px dashed #2a3447;
}

.modal-plantillas-btn-agregar-bit,
.modal-plantillas-btn-quitar-bit {
  padding: 6px 14px;
  background: transparent;
  border: 1px solid #3b4557;
  border-radius: 4px;
  color: #a1a1aa;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
}

.modal-plantillas-btn-agregar-bit:hover {
  background: rgba(34, 197, 94, 0.1);
  border-color: #22c55e;
  color: #22c55e;
}

.modal-plantillas-btn-quitar-bit:hover {
  background: rgba(239, 68, 68, 0.1);
  border-color: #ef4444;
  color: #ef4444;
}

/* ========================================
   PLANTILLAS GUARDADAS
   ======================================== */

.modal-plantillas-etiquetas-guardadas {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid #2a3447;
}

.modal-plantillas-etiquetas-guardadas-label {
  display: block;
  font-size: 0.8rem;
  color: #71717a;
  margin-bottom: 8px;
}

.modal-plantillas-etiquetas-guardadas-lista {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.modal-plantillas-etiqueta-guardada {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px 4px 12px;
  background: #252b3b;
  border: 1px solid #2a3447;
  border-radius: 16px;
  font-size: 0.8rem;
  color: #a1a1aa;
}

.modal-plantillas-btn-eliminar-etiqueta {
  background: transparent;
  border: none;
  color: #71717a;
  font-size: 1rem;
  cursor: pointer;
  padding: 0 2px;
  line-height: 1;
  transition: color 0.2s;
}

.modal-plantillas-btn-eliminar-etiqueta:hover {
  color: #ef4444;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalPlantillasRele.jsx =====

import { useState, useEffect, useRef } from "react";
import {
  SEVERIDADES_DISPONIBLES,
  PLANTILLAS_ETIQUETAS_LEDS
} from "../../utilidades/interpreteRegistrosREF615";
import { useTransformadores } from "../../hooks/useTransformadores";
import "./ModalPlantillasRele.css";

/**
 * Dropdown personalizado para seleccionar TI/TV/Relaci√≥n
 * Con l√≠neas divisorias degradadas y f√≥rmula en input readonly
 * Usa posici√≥n fixed para evitar ser cortado por el modal
 */
const DropdownTransformador = ({
  value,
  onChange,
  disabled,
  tis,
  tvs,
  relaciones = []
}) => {
  const [abierto, setAbierto] = useState(false);
  const [menuPos, setMenuPos] = useState({ top: 0, left: 0 });
  const dropdownRef = useRef(null);
  const triggerRef = useRef(null);
  const menuRef = useRef(null);

  // Calcular posici√≥n del men√∫ cuando se abre
  useEffect(() => {
    if (abierto && triggerRef.current) {
      const rect = triggerRef.current.getBoundingClientRect();
      const menuHeight = 500; // altura m√°xima aproximada
      const viewportHeight = window.innerHeight;

      // Posici√≥n a la derecha del trigger
      let left = rect.right + 8;

      // Centrar verticalmente respecto al trigger
      let top = rect.top + (rect.height / 2) - (menuHeight / 2);

      // Ajustar si se sale por arriba
      if (top < 10) top = 10;

      // Ajustar si se sale por abajo
      if (top + menuHeight > viewportHeight - 10) {
        top = viewportHeight - menuHeight - 10;
      }

      // Si no cabe a la derecha, ponerlo a la izquierda
      if (left + 300 > window.innerWidth) {
        left = rect.left - 308;
      }

      setMenuPos({ top, left });
    }
  }, [abierto]);

  // Cerrar al hacer click fuera
  useEffect(() => {
    const handleClickFuera = (e) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(e.target) &&
        menuRef.current &&
        !menuRef.current.contains(e.target)
      ) {
        setAbierto(false);
      }
    };
    if (abierto) {
      document.addEventListener("mousedown", handleClickFuera);
    }
    return () => document.removeEventListener("mousedown", handleClickFuera);
  }, [abierto]);

  // Encontrar el transformador seleccionado
  const transformadorSeleccionado = value
    ? [...tis, ...tvs, ...relaciones].find(t => t.id === value)
    : null;

  const handleSeleccionar = (id) => {
    onChange(id);
    setAbierto(false);
  };

  return (
    <div
      className={`dropdown-transformador ${disabled ? "disabled" : ""}`}
      ref={dropdownRef}
    >
      <button
        type="button"
        className="dropdown-transformador-trigger"
        onClick={() => !disabled && setAbierto(!abierto)}
        disabled={disabled}
        ref={triggerRef}
      >
        {transformadorSeleccionado ? (
          <>
            <span className="dropdown-transformador-nombre">{transformadorSeleccionado.nombre}</span>
            <input
              type="text"
              className="dropdown-transformador-formula"
              value={transformadorSeleccionado.formula}
              readOnly
              tabIndex={-1}
            />
          </>
        ) : (
          <span className="dropdown-transformador-texto">Sin TI / TV</span>
        )}
        <span className="dropdown-transformador-chevron">{abierto ? "‚ñ≤" : "‚ñº"}</span>
      </button>

      {abierto && (
        <div
          className="dropdown-transformador-menu dropdown-transformador-menu--fixed"
          style={{ top: menuPos.top, left: menuPos.left }}
          ref={menuRef}
        >
          {/* Opci√≥n: Sin TI/TV */}
          <div
            className={`dropdown-transformador-opcion ${!value ? "seleccionado" : ""}`}
            onClick={() => handleSeleccionar("")}
          >
            <span className="dropdown-transformador-nombre">Sin TI / TV</span>
          </div>

          {/* L√≠nea divisoria despu√©s de Sin TI/TV si hay TIs */}
          {tis.length > 0 && <div className="dropdown-transformador-divider" />}

          {/* TIs */}
          {tis.map((t) => (
            <div
              key={t.id}
              className={`dropdown-transformador-opcion ${value === t.id ? "seleccionado" : ""}`}
              onClick={() => handleSeleccionar(t.id)}
            >
              <span className="dropdown-transformador-nombre">{t.nombre}</span>
              <input
                type="text"
                className="dropdown-transformador-formula"
                value={t.formula}
                readOnly
                tabIndex={-1}
              />
            </div>
          ))}

          {/* L√≠nea divisoria entre TIs y TVs */}
          {tis.length > 0 && tvs.length > 0 && <div className="dropdown-transformador-divider" />}

          {/* TVs */}
          {tvs.map((t) => (
            <div
              key={t.id}
              className={`dropdown-transformador-opcion ${value === t.id ? "seleccionado" : ""}`}
              onClick={() => handleSeleccionar(t.id)}
            >
              <span className="dropdown-transformador-nombre">{t.nombre}</span>
              <input
                type="text"
                className="dropdown-transformador-formula"
                value={t.formula}
                readOnly
                tabIndex={-1}
              />
            </div>
          ))}

          {/* L√≠nea divisoria entre TVs y Relaciones */}
          {(tis.length > 0 || tvs.length > 0) && relaciones.length > 0 && <div className="dropdown-transformador-divider" />}

          {/* Relaciones */}
          {relaciones.map((t) => (
            <div
              key={t.id}
              className={`dropdown-transformador-opcion ${value === t.id ? "seleccionado" : ""}`}
              onClick={() => handleSeleccionar(t.id)}
            >
              <span className="dropdown-transformador-nombre">{t.nombre}</span>
              <input
                type="text"
                className="dropdown-transformador-formula"
                value={t.formula}
                readOnly
                tabIndex={-1}
              />
            </div>
          ))}

          {/* Mensaje si no hay transformadores */}
          {tis.length === 0 && tvs.length === 0 && relaciones.length === 0 && (
            <div className="dropdown-transformador-vacio">
              No hay TI/TV/Relaciones configurados
            </div>
          )}
        </div>
      )}
    </div>
  );
};

// Categor√≠as disponibles para las funcionalidades
const CATEGORIAS = {
  mediciones: { id: "mediciones", nombre: "Mediciones", icono: "üìä" },
  estados: { id: "estados", nombre: "Estados y Alarmas", icono: "üö¶" },
  sistema: { id: "sistema", nombre: "Sistema", icono: "‚öôÔ∏è" },
};

// Clave para guardar plantillas de etiquetas personalizadas en localStorage
const STORAGE_KEY_PLANTILLAS_ETIQUETAS = "plantillasEtiquetasLeds";

/**
 * Modal para gestionar plantillas de rel√©s de protecci√≥n.
 * Permite crear funcionalidades personalizadas con registros individuales.
 */
const ModalPlantillasRele = ({
  abierto,
  onCerrar,
  plantillas,
  onCrear,
  onActualizar,
  onEliminar,
  plantillaEditando = null,
}) => {
  // Hook de transformadores
  const { obtenerTIs, obtenerTVs, obtenerRelaciones, recargar: recargarTransformadores } = useTransformadores();

  // Estado del formulario
  const [modo, setModo] = useState("lista"); // "lista" | "crear" | "editar"
  const [nombre, setNombre] = useState("");
  const [descripcion, setDescripcion] = useState("");
  const [funcionalidades, setFuncionalidades] = useState([]);
  const [plantillaSeleccionada, setPlantillaSeleccionada] = useState(null);
  const [error, setError] = useState("");

  // Estado para agregar nueva funcionalidad
  const [nuevaFunc, setNuevaFunc] = useState({
    nombre: "",
    cantidad: 1,
    categoria: "mediciones",
  });

  // Estado para etiquetas de bits (LEDs del panel frontal)
  // Formato: { [bit]: { texto: "Arranque I>", severidad: "warning" } }
  const [etiquetasBits, setEtiquetasBits] = useState({});
  const [seccionEtiquetasAbierta, setSeccionEtiquetasAbierta] = useState(false);

  // Estado para modo de creaci√≥n de plantilla de etiquetas personalizada
  const [modoNuevaPlantillaEtiquetas, setModoNuevaPlantillaEtiquetas] = useState(false);
  const [nombreNuevaPlantillaEtiquetas, setNombreNuevaPlantillaEtiquetas] = useState("");
  const [cantidadBits, setCantidadBits] = useState(1); // Cantidad de filas de bits
  const [plantillasEtiquetasPersonalizadas, setPlantillasEtiquetasPersonalizadas] = useState({});
  // Estado para rastrear la plantilla de etiquetas seleccionada en el combobox
  const [plantillaEtiquetasSeleccionada, setPlantillaEtiquetasSeleccionada] = useState("");

  // Cargar plantillas de etiquetas personalizadas desde localStorage al montar
  useEffect(() => {
    try {
      const guardadas = localStorage.getItem(STORAGE_KEY_PLANTILLAS_ETIQUETAS);
      if (guardadas) {
        setPlantillasEtiquetasPersonalizadas(JSON.parse(guardadas));
      }
    } catch (error) {
      console.error("Error al cargar plantillas de etiquetas:", error);
    }
  }, []);

  // Recargar transformadores cuando el modal se abre
  useEffect(() => {
    if (abierto) {
      recargarTransformadores();
    }
  }, [abierto, recargarTransformadores]);

  // Si se pasa una plantilla para editar, entrar en modo edici√≥n
  useEffect(() => {
    if (plantillaEditando && abierto) {
      setModo("editar");
      setPlantillaSeleccionada(plantillaEditando);
      setNombre(plantillaEditando.nombre);
      setDescripcion(plantillaEditando.descripcion || "");
      // Convertir funcionalidades del formato objeto al formato array
      const funcsArray = Object.entries(plantillaEditando.funcionalidades || {}).map(
        ([id, data]) => {
          // Migraci√≥n: si hay transformadorId a nivel de funcionalidad, aplicarlo a cada registro
          const transformadorIdGrupo = data.transformadorId || null;
          const registrosBase = data.registros || [{ etiqueta: "", valor: data.registro || 0 }];
          const registrosMigrados = registrosBase.map((reg) => ({
            ...reg,
            // Usar transformadorId del registro si existe, sino usar el del grupo (migraci√≥n)
            transformadorId: reg.transformadorId !== undefined ? reg.transformadorId : transformadorIdGrupo,
          }));
          return {
            id,
            nombre: data.nombre || id,
            habilitado: data.habilitado !== false,
            categoria: data.categoria || "mediciones",
            registros: registrosMigrados,
          };
        }
      );
      setFuncionalidades(funcsArray);
      // Cargar etiquetas de bits si existen
      setEtiquetasBits(plantillaEditando.etiquetasBits || {});
      // Restaurar la plantilla de etiquetas seleccionada
      setPlantillaEtiquetasSeleccionada(plantillaEditando.plantillaEtiquetasId || "");
      // Actualizar cantidad de bits basado en las etiquetas guardadas
      const etiquetasGuardadas = plantillaEditando.etiquetasBits || {};
      if (Object.keys(etiquetasGuardadas).length > 0) {
        const maxBit = Math.max(...Object.keys(etiquetasGuardadas).map(Number));
        setCantidadBits(maxBit + 1);
      }
      // Abrir secci√≥n si hay etiquetas configuradas
      if (plantillaEditando.etiquetasBits && Object.keys(plantillaEditando.etiquetasBits).length > 0) {
        setSeccionEtiquetasAbierta(true);
      }
    }
  }, [plantillaEditando, abierto]);

  // Reset al cerrar
  useEffect(() => {
    if (!abierto) {
      resetFormulario();
    }
  }, [abierto]);

  const resetFormulario = () => {
    setModo("lista");
    setNombre("");
    setDescripcion("");
    setFuncionalidades([]);
    setPlantillaSeleccionada(null);
    setError("");
    setNuevaFunc({ nombre: "", cantidad: 1, categoria: "mediciones" });
    setEtiquetasBits({});
    setSeccionEtiquetasAbierta(false);
    // Reset de creaci√≥n de plantilla de etiquetas
    setModoNuevaPlantillaEtiquetas(false);
    setNombreNuevaPlantillaEtiquetas("");
    setCantidadBits(1);
    setPlantillaEtiquetasSeleccionada("");
  };

  const iniciarCreacion = () => {
    resetFormulario();
    setModo("crear");
  };

  const iniciarEdicion = (plantilla) => {
    setPlantillaSeleccionada(plantilla);
    setNombre(plantilla.nombre);
    setDescripcion(plantilla.descripcion || "");

    // Convertir funcionalidades del formato objeto al formato array
    const funcsArray = Object.entries(plantilla.funcionalidades || {}).map(
      ([id, data]) => {
        // Migraci√≥n: si hay transformadorId a nivel de funcionalidad, aplicarlo a cada registro
        const transformadorIdGrupo = data.transformadorId || null;
        const registrosBase = data.registros || [{ etiqueta: "", valor: data.registro || 0 }];
        const registrosMigrados = registrosBase.map((reg) => ({
          ...reg,
          // Usar transformadorId del registro si existe, sino usar el del grupo (migraci√≥n)
          transformadorId: reg.transformadorId !== undefined ? reg.transformadorId : transformadorIdGrupo,
        }));
        return {
          id,
          nombre: data.nombre || id,
          habilitado: data.habilitado !== false,
          categoria: data.categoria || "mediciones",
          registros: registrosMigrados,
        };
      }
    );
    setFuncionalidades(funcsArray);
    // Cargar etiquetas de bits
    setEtiquetasBits(plantilla.etiquetasBits || {});
    // Restaurar la plantilla de etiquetas seleccionada
    setPlantillaEtiquetasSeleccionada(plantilla.plantillaEtiquetasId || "");
    // Actualizar cantidad de bits basado en las etiquetas guardadas
    const etiquetasGuardadas = plantilla.etiquetasBits || {};
    if (Object.keys(etiquetasGuardadas).length > 0) {
      const maxBit = Math.max(...Object.keys(etiquetasGuardadas).map(Number));
      setCantidadBits(maxBit + 1);
    }
    if (plantilla.etiquetasBits && Object.keys(plantilla.etiquetasBits).length > 0) {
      setSeccionEtiquetasAbierta(true);
    }
    setModo("editar");
  };

  // Generar ID √∫nico para funcionalidad
  const generarIdFunc = () => {
    return "func-" + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
  };

  // Agregar nueva funcionalidad
  const handleAgregarFuncionalidad = () => {
    if (!nuevaFunc.nombre.trim()) {
      setError("Ingresa un nombre para la funcionalidad");
      return;
    }

    const cantidad = parseInt(nuevaFunc.cantidad) || 1;

    // Crear array de registros vac√≠os seg√∫n la cantidad
    const registros = Array.from({ length: cantidad }, () => ({
      etiqueta: "",
      valor: 0,
    }));

    const nuevaFuncionalidad = {
      id: generarIdFunc(),
      nombre: nuevaFunc.nombre.trim(),
      categoria: nuevaFunc.categoria,
      habilitado: true,
      registros,
    };

    setFuncionalidades((prev) => [...prev, nuevaFuncionalidad]);
    setNuevaFunc({ nombre: "", cantidad: 1, categoria: nuevaFunc.categoria });
    setError("");
  };

  // Eliminar funcionalidad
  const handleEliminarFuncionalidad = (funcId) => {
    setFuncionalidades((prev) => prev.filter((f) => f.id !== funcId));
  };

  // Toggle habilitar/deshabilitar funcionalidad
  const handleToggleFuncionalidad = (funcId) => {
    setFuncionalidades((prev) =>
      prev.map((f) =>
        f.id === funcId ? { ...f, habilitado: !f.habilitado } : f
      )
    );
  };

  // Cambiar etiqueta de un registro
  const handleCambiarEtiqueta = (funcId, regIndex, valor) => {
    setFuncionalidades((prev) =>
      prev.map((f) => {
        if (f.id !== funcId) return f;
        const nuevosRegistros = [...f.registros];
        nuevosRegistros[regIndex] = { ...nuevosRegistros[regIndex], etiqueta: valor };
        return { ...f, registros: nuevosRegistros };
      })
    );
  };

  // Cambiar valor de un registro
  const handleCambiarValorRegistro = (funcId, regIndex, valor) => {
    setFuncionalidades((prev) =>
      prev.map((f) => {
        if (f.id !== funcId) return f;
        const nuevosRegistros = [...f.registros];
        nuevosRegistros[regIndex] = {
          ...nuevosRegistros[regIndex],
          valor: valor === "" ? "" : parseInt(valor) || 0,
        };
        return { ...f, registros: nuevosRegistros };
      })
    );
  };

  // Cambiar transformador asociado a una funcionalidad
  // Cambiar transformador de un registro espec√≠fico
  const handleCambiarTransformadorRegistro = (funcId, registroIndex, transformadorId) => {
    setFuncionalidades((prev) =>
      prev.map((f) => {
        if (f.id !== funcId) return f;
        const nuevosRegistros = f.registros.map((reg, idx) =>
          idx === registroIndex
            ? { ...reg, transformadorId: transformadorId || null }
            : reg
        );
        return { ...f, registros: nuevosRegistros };
      })
    );
  };

  // Aplicar un transformador a todos los registros de una funcionalidad
  const handleAplicarTransformadorATodos = (funcId, transformadorId) => {
    setFuncionalidades((prev) =>
      prev.map((f) => {
        if (f.id !== funcId) return f;
        const nuevosRegistros = f.registros.map((reg) => ({
          ...reg,
          transformadorId: transformadorId || null,
        }));
        return { ...f, registros: nuevosRegistros };
      })
    );
  };

  // Mover funcionalidad hacia arriba
  const handleMoverFuncionalidadArriba = (funcId) => {
    setFuncionalidades((prev) => {
      const index = prev.findIndex((f) => f.id === funcId);
      if (index <= 0) return prev;
      const newArr = [...prev];
      [newArr[index - 1], newArr[index]] = [newArr[index], newArr[index - 1]];
      return newArr;
    });
  };

  // Mover funcionalidad hacia abajo
  const handleMoverFuncionalidadAbajo = (funcId) => {
    setFuncionalidades((prev) => {
      const index = prev.findIndex((f) => f.id === funcId);
      if (index < 0 || index >= prev.length - 1) return prev;
      const newArr = [...prev];
      [newArr[index], newArr[index + 1]] = [newArr[index + 1], newArr[index]];
      return newArr;
    });
  };

  // ============================================
  // FUNCIONES PARA ETIQUETAS DE BITS
  // ============================================

  // Cambiar texto de una etiqueta de bit
  const handleCambiarEtiquetaBit = (bit, texto) => {
    setEtiquetasBits((prev) => ({
      ...prev,
      [bit]: {
        ...prev[bit],
        texto: texto,
        severidad: prev[bit]?.severidad || "info"
      }
    }));
  };

  // Cambiar severidad de una etiqueta de bit
  const handleCambiarSeveridadBit = (bit, severidad) => {
    setEtiquetasBits((prev) => ({
      ...prev,
      [bit]: {
        ...prev[bit],
        texto: prev[bit]?.texto || "",
        severidad: severidad
      }
    }));
  };

  // Aplicar una plantilla predefinida de etiquetas (incluye personalizadas)
  const handleAplicarPlantillaEtiquetas = (tipoPlantilla) => {
    // Primero buscar en plantillas predefinidas
    if (PLANTILLAS_ETIQUETAS_LEDS[tipoPlantilla]) {
      setEtiquetasBits(PLANTILLAS_ETIQUETAS_LEDS[tipoPlantilla].etiquetas);
      setCantidadBits(Object.keys(PLANTILLAS_ETIQUETAS_LEDS[tipoPlantilla].etiquetas).length);
      setModoNuevaPlantillaEtiquetas(false);
      setPlantillaEtiquetasSeleccionada(tipoPlantilla);
      return;
    }
    // Luego buscar en plantillas personalizadas
    if (plantillasEtiquetasPersonalizadas[tipoPlantilla]) {
      setEtiquetasBits(plantillasEtiquetasPersonalizadas[tipoPlantilla].etiquetas);
      setCantidadBits(Object.keys(plantillasEtiquetasPersonalizadas[tipoPlantilla].etiquetas).length);
      setModoNuevaPlantillaEtiquetas(false);
      setPlantillaEtiquetasSeleccionada(tipoPlantilla);
    }
  };

  // Iniciar modo de creaci√≥n de nueva plantilla de etiquetas
  const handleNuevaPlantillaEtiquetas = () => {
    setModoNuevaPlantillaEtiquetas(true);
    setNombreNuevaPlantillaEtiquetas("");
    setCantidadBits(1);
    setEtiquetasBits({ 0: { texto: "", severidad: "info" } });
  };

  // Cancelar creaci√≥n de nueva plantilla de etiquetas
  const handleCancelarNuevaPlantillaEtiquetas = () => {
    setModoNuevaPlantillaEtiquetas(false);
    setNombreNuevaPlantillaEtiquetas("");
    setCantidadBits(1);
    setEtiquetasBits({});
  };

  // Agregar una fila de bit
  const handleAgregarFilaBit = () => {
    const nuevoBit = cantidadBits;
    setCantidadBits(nuevoBit + 1);
    setEtiquetasBits((prev) => ({
      ...prev,
      [nuevoBit]: { texto: "", severidad: "info" }
    }));
  };

  // Quitar la √∫ltima fila de bit
  const handleQuitarFilaBit = () => {
    if (cantidadBits <= 1) return;
    const bitAQuitar = cantidadBits - 1;
    setCantidadBits(bitAQuitar);
    setEtiquetasBits((prev) => {
      const nuevas = { ...prev };
      delete nuevas[bitAQuitar];
      return nuevas;
    });
  };

  // Guardar plantilla de etiquetas personalizada
  const handleGuardarPlantillaEtiquetas = () => {
    if (!nombreNuevaPlantillaEtiquetas.trim()) {
      setError("Ingresa un nombre para la plantilla de etiquetas");
      return;
    }

    // Limpiar etiquetas vac√≠as
    const etiquetasLimpias = {};
    Object.entries(etiquetasBits).forEach(([bit, etiqueta]) => {
      if (etiqueta.texto && etiqueta.texto.trim() !== "") {
        etiquetasLimpias[bit] = {
          texto: etiqueta.texto.trim(),
          severidad: etiqueta.severidad || "info"
        };
      }
    });

    // Generar ID √∫nico
    const id = "custom-" + Date.now().toString(36);

    const nuevaPlantilla = {
      nombre: nombreNuevaPlantillaEtiquetas.trim(),
      etiquetas: etiquetasLimpias
    };

    const nuevasPlantillas = {
      ...plantillasEtiquetasPersonalizadas,
      [id]: nuevaPlantilla
    };

    // Guardar en localStorage
    try {
      localStorage.setItem(STORAGE_KEY_PLANTILLAS_ETIQUETAS, JSON.stringify(nuevasPlantillas));
      setPlantillasEtiquetasPersonalizadas(nuevasPlantillas);
      setModoNuevaPlantillaEtiquetas(false);
      setNombreNuevaPlantillaEtiquetas("");
      setError("");
    } catch (error) {
      console.error("Error al guardar plantilla de etiquetas:", error);
      setError("Error al guardar la plantilla");
    }
  };

  // Eliminar plantilla de etiquetas personalizada
  const handleEliminarPlantillaEtiquetas = (id) => {
    const nuevasPlantillas = { ...plantillasEtiquetasPersonalizadas };
    delete nuevasPlantillas[id];

    try {
      localStorage.setItem(STORAGE_KEY_PLANTILLAS_ETIQUETAS, JSON.stringify(nuevasPlantillas));
      setPlantillasEtiquetasPersonalizadas(nuevasPlantillas);
    } catch (error) {
      console.error("Error al eliminar plantilla de etiquetas:", error);
    }
  };

  // Limpiar todas las etiquetas
  const handleLimpiarEtiquetas = () => {
    setEtiquetasBits({});
    setModoNuevaPlantillaEtiquetas(false);
    setCantidadBits(1);
    setPlantillaEtiquetasSeleccionada("");
  };

  // Contar etiquetas configuradas
  const contarEtiquetasConfiguradas = () => {
    return Object.values(etiquetasBits).filter(e => e.texto && e.texto.trim() !== "").length;
  };

  const validarFormulario = () => {
    if (!nombre.trim()) {
      setError("El nombre de la plantilla es requerido");
      return false;
    }

    if (funcionalidades.length === 0) {
      setError("Debes agregar al menos una funcionalidad");
      return false;
    }

    const hayFuncionalidadActiva = funcionalidades.some((f) => f.habilitado);
    if (!hayFuncionalidadActiva) {
      setError("Debe habilitar al menos una funcionalidad");
      return false;
    }

    setError("");
    return true;
  };

  const handleGuardar = () => {
    if (!validarFormulario()) return;

    // Convertir array de funcionalidades a objeto para guardar
    const funcParaGuardar = {};
    funcionalidades.forEach((func) => {
      if (func.habilitado) {
        // Los registros ya incluyen transformadorId por registro
        funcParaGuardar[func.id] = {
          nombre: func.nombre,
          categoria: func.categoria || "mediciones",
          habilitado: true,
          registros: func.registros, // Cada registro tiene su propio transformadorId
          // Mantener compatibilidad: primer registro como "registro" principal
          registro: func.registros[0]?.valor || 0,
        };
      }
    });

    // Limpiar etiquetas vac√≠as antes de guardar
    const etiquetasLimpias = {};
    Object.entries(etiquetasBits).forEach(([bit, etiqueta]) => {
      if (etiqueta.texto && etiqueta.texto.trim() !== "") {
        etiquetasLimpias[bit] = {
          texto: etiqueta.texto.trim(),
          severidad: etiqueta.severidad || "info"
        };
      }
    });

    const datos = {
      nombre: nombre.trim(),
      descripcion: descripcion.trim(),
      funcionalidades: funcParaGuardar,
      etiquetasBits: etiquetasLimpias,
      plantillaEtiquetasId: plantillaEtiquetasSeleccionada || null,
    };

    if (modo === "crear") {
      const nueva = onCrear(datos);
      if (nueva) {
        resetFormulario();
      }
    } else if (modo === "editar" && plantillaSeleccionada) {
      const exito = onActualizar(plantillaSeleccionada.id, datos);
      if (exito) {
        resetFormulario();
      }
    }
  };

  const handleEliminar = (plantilla) => {
    if (
      window.confirm(
        `¬øEliminar la plantilla "${plantilla.nombre}"? Esta acci√≥n no se puede deshacer.`
      )
    ) {
      onEliminar(plantilla.id);
    }
  };

  // Contar funcionalidades en una plantilla
  const contarFuncionalidades = (plantilla) => {
    return Object.values(plantilla.funcionalidades || {}).filter(
      (f) => f.habilitado !== false
    ).length;
  };

  // Obtener nombre de la plantilla de etiquetas de LEDs
  const obtenerNombrePlantillaEtiquetas = (plantilla) => {
    const idPlantillaEtiquetas = plantilla.plantillaEtiquetasId;
    if (!idPlantillaEtiquetas) return null;

    // Buscar en plantillas predefinidas
    if (PLANTILLAS_ETIQUETAS_LEDS[idPlantillaEtiquetas]) {
      return PLANTILLAS_ETIQUETAS_LEDS[idPlantillaEtiquetas].nombre;
    }

    // Buscar en plantillas personalizadas
    if (plantillasEtiquetasPersonalizadas[idPlantillaEtiquetas]) {
      return plantillasEtiquetasPersonalizadas[idPlantillaEtiquetas].nombre;
    }

    return null;
  };

  if (!abierto) return null;

  return (
    <div className="modal-plantillas-overlay">
      <div className="modal-plantillas-contenido">
        {/* Header */}
        <div className="modal-plantillas-header">
          <h3>
            {modo === "lista" && "Gestionar Plantillas"}
            {modo === "crear" && "Nueva Plantilla"}
            {modo === "editar" && "Editar Plantilla"}
          </h3>
          <button className="modal-plantillas-cerrar" onClick={onCerrar}>
            √ó
          </button>
        </div>

        {/* Contenido */}
        <div className="modal-plantillas-body">
          {/* MODO LISTA */}
          {modo === "lista" && (
            <>
              <button
                className="modal-plantillas-btn-crear"
                onClick={iniciarCreacion}
              >
                + Nueva Plantilla
              </button>

              {plantillas.length === 0 ? (
                <div className="modal-plantillas-vacio">
                  <span className="modal-plantillas-vacio-icono">üìã</span>
                  <p>No hay plantillas creadas</p>
                  <p className="modal-plantillas-hint">
                    Crea una plantilla para empezar a configurar rel√©s
                  </p>
                </div>
              ) : (
                <div className="modal-plantillas-lista">
                  {plantillas.map((plantilla) => (
                    <div key={plantilla.id} className="modal-plantillas-item">
                      <div className="modal-plantillas-item-info">
                        <span className="modal-plantillas-item-nombre">
                          üìã {plantilla.nombre}
                        </span>
                        {plantilla.descripcion && (
                          <span className="modal-plantillas-item-desc">
                            {plantilla.descripcion}
                          </span>
                        )}
                        <span className="modal-plantillas-item-func">
                          {contarFuncionalidades(plantilla)} funcionalidades
                          {obtenerNombrePlantillaEtiquetas(plantilla) && (
                            <> ¬∑ Panel: {obtenerNombrePlantillaEtiquetas(plantilla)}</>
                          )}
                        </span>
                      </div>
                      <div className="modal-plantillas-item-acciones">
                        <button
                          className="modal-plantillas-btn-editar"
                          onClick={() => iniciarEdicion(plantilla)}
                          title="Editar"
                        >
                          Editar
                        </button>
                        <button
                          className="modal-plantillas-btn-eliminar"
                          onClick={() => handleEliminar(plantilla)}
                          title="Eliminar"
                        >
                          Eliminar
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </>
          )}

          {/* MODO CREAR/EDITAR */}
          {(modo === "crear" || modo === "editar") && (
            <div className="modal-plantillas-formulario">
              {error && (
                <div className="modal-plantillas-error">{error}</div>
              )}

              <div className="modal-plantillas-campo">
                <label>Nombre de la plantilla *</label>
                <input
                  type="text"
                  value={nombre}
                  onChange={(e) => setNombre(e.target.value)}
                  placeholder="Ej: FE03 - Feeder con Autorecierre"
                />
              </div>

              <div className="modal-plantillas-campo">
                <label>Descripci√≥n (opcional)</label>
                <input
                  type="text"
                  value={descripcion}
                  onChange={(e) => setDescripcion(e.target.value)}
                  placeholder="Ej: Alimentadores sin medici√≥n de tensi√≥n"
                />
              </div>

              {/* Secci√≥n para agregar funcionalidad */}
              <div className="modal-plantillas-seccion">
                <h4>Agregar Funcionalidad</h4>
                <div className="modal-plantillas-agregar-func">
                  <div className="modal-plantillas-agregar-row">
                    <div className="modal-plantillas-agregar-campo">
                      <label>Nombre</label>
                      <input
                        type="text"
                        value={nuevaFunc.nombre}
                        onChange={(e) =>
                          setNuevaFunc((prev) => ({ ...prev, nombre: e.target.value }))
                        }
                        placeholder="Ej: Corrientes de Fase"
                      />
                    </div>
                    <div className="modal-plantillas-agregar-campo modal-plantillas-agregar-campo--peque√±o">
                      <label>Cant. Reg.</label>
                      <input
                        type="number"
                        value={nuevaFunc.cantidad}
                        onChange={(e) =>
                          setNuevaFunc((prev) => ({
                            ...prev,
                            cantidad: e.target.value,
                          }))
                        }
                        min={1}
                        max={20}
                      />
                    </div>
                    <div className="modal-plantillas-agregar-campo modal-plantillas-agregar-campo--categoria">
                      <label>Categor√≠a</label>
                      <select
                        value={nuevaFunc.categoria}
                        onChange={(e) =>
                          setNuevaFunc((prev) => ({
                            ...prev,
                            categoria: e.target.value,
                          }))
                        }
                      >
                        {Object.values(CATEGORIAS).map((cat) => (
                          <option key={cat.id} value={cat.id}>
                            {cat.icono} {cat.nombre}
                          </option>
                        ))}
                      </select>
                    </div>
                    <button
                      type="button"
                      className="modal-plantillas-btn-agregar"
                      onClick={handleAgregarFuncionalidad}
                    >
                      + Agregar
                    </button>
                  </div>
                </div>
              </div>

              {/* Lista de funcionalidades agregadas - Agrupadas por categor√≠a */}
              {funcionalidades.length > 0 && (
                <div className="modal-plantillas-seccion">
                  <h4>Funcionalidades ({funcionalidades.length})</h4>

                  {Object.values(CATEGORIAS).map((categoria) => {
                    const funcsDeCategoria = funcionalidades.filter(
                      (f) => (f.categoria || "mediciones") === categoria.id
                    );

                    if (funcsDeCategoria.length === 0) return null;

                    return (
                      <div key={categoria.id} className="modal-plantillas-categoria">
                        <h5>
                          {categoria.icono} {categoria.nombre}
                        </h5>
                        <div className="modal-plantillas-func-lista">
                          {funcsDeCategoria.map((func) => (
                            <div
                              key={func.id}
                              className={`modal-plantillas-func-card ${
                                func.habilitado ? "activo" : "inactivo"
                              }`}
                            >
                              <div className="modal-plantillas-func-header">
                                <label className="modal-plantillas-func-check">
                                  <input
                                    type="checkbox"
                                    checked={func.habilitado}
                                    onChange={() => handleToggleFuncionalidad(func.id)}
                                  />
                                  <span className="modal-plantillas-func-nombre">
                                    {func.nombre}
                                  </span>
                                </label>
                                <div className="modal-plantillas-func-acciones">
                                  <button
                                    type="button"
                                    className="modal-plantillas-func-mover"
                                    onClick={() => handleMoverFuncionalidadArriba(func.id)}
                                    title="Mover arriba"
                                  >
                                    ‚ñ≤
                                  </button>
                                  <button
                                    type="button"
                                    className="modal-plantillas-func-mover"
                                    onClick={() => handleMoverFuncionalidadAbajo(func.id)}
                                    title="Mover abajo"
                                  >
                                    ‚ñº
                                  </button>
                                  <button
                                    type="button"
                                    className="modal-plantillas-func-eliminar"
                                    onClick={() => handleEliminarFuncionalidad(func.id)}
                                    title="Eliminar funcionalidad"
                                  >
                                    √ó
                                  </button>
                                </div>
                              </div>

                              {/* Registros individuales con selector de TI/TV por registro */}
                              <div className="modal-plantillas-registros">
                                {func.registros.map((reg, index) => (
                                  <div
                                    key={index}
                                    className="modal-plantillas-registro-item"
                                  >
                                    <input
                                      type="text"
                                      className="modal-plantillas-registro-etiqueta"
                                      value={reg.etiqueta}
                                      onChange={(e) =>
                                        handleCambiarEtiqueta(func.id, index, e.target.value)
                                      }
                                      placeholder={`Etiqueta ${index + 1}`}
                                      disabled={!func.habilitado}
                                    />
                                    <span className="modal-plantillas-registro-separador">‚Üí</span>
                                    <input
                                      type="number"
                                      className="modal-plantillas-registro-valor"
                                      value={reg.valor}
                                      onChange={(e) =>
                                        handleCambiarValorRegistro(func.id, index, e.target.value)
                                      }
                                      placeholder={`${137 + index}`}
                                      disabled={!func.habilitado}
                                      min={0}
                                    />
                                    {/* Selector de TI/TV/Relaci√≥n por registro - solo para mediciones */}
                                    {categoria.id === "mediciones" && (
                                      <DropdownTransformador
                                        value={reg.transformadorId || ""}
                                        onChange={(id) => handleCambiarTransformadorRegistro(func.id, index, id)}
                                        disabled={!func.habilitado}
                                        tis={obtenerTIs()}
                                        tvs={obtenerTVs()}
                                        relaciones={obtenerRelaciones()}
                                      />
                                    )}
                                  </div>
                                ))}
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}

              {funcionalidades.length === 0 && (
                <div className="modal-plantillas-vacio-func">
                  <p>No hay funcionalidades agregadas</p>
                  <p className="modal-plantillas-hint">
                    Usa el formulario de arriba para agregar funcionalidades
                  </p>
                </div>
              )}

              {/* Secci√≥n de Etiquetas de Bits (LEDs) */}
              <div className="modal-plantillas-seccion modal-plantillas-seccion-etiquetas">
                <div
                  className="modal-plantillas-seccion-header-colapsable"
                  onClick={() => setSeccionEtiquetasAbierta(!seccionEtiquetasAbierta)}
                >
                  <h4>
                    <span className={`modal-plantillas-chevron ${seccionEtiquetasAbierta ? "abierto" : ""}`}>
                      ‚ñ∂
                    </span>
                    Etiquetas de LEDs (Registro 172)
                    {contarEtiquetasConfiguradas() > 0 && (
                      <span className="modal-plantillas-badge">
                        {contarEtiquetasConfiguradas()}
                      </span>
                    )}
                  </h4>
                  <span className="modal-plantillas-hint-inline">
                    Define qu√© significa cada LED del panel frontal
                  </span>
                </div>

                {seccionEtiquetasAbierta && (
                  <div className="modal-plantillas-etiquetas-contenido">
                    {/* Selector de plantilla predefinida o crear nueva */}
                    <div className="modal-plantillas-etiquetas-acciones">
                      <label>Plantilla:</label>
                      <select
                        onChange={(e) => {
                          if (e.target.value === "__nueva__") {
                            handleNuevaPlantillaEtiquetas();
                          } else if (e.target.value) {
                            handleAplicarPlantillaEtiquetas(e.target.value);
                          } else {
                            // Si selecciona "Seleccionar...", limpiar la selecci√≥n
                            setPlantillaEtiquetasSeleccionada("");
                          }
                        }}
                        value={modoNuevaPlantillaEtiquetas ? "__nueva__" : plantillaEtiquetasSeleccionada}
                      >
                        <option value="">Seleccionar...</option>
                        <option value="__nueva__">+ Nueva plantilla...</option>
                        {/* Plantillas predefinidas */}
                        <optgroup label="Predefinidas">
                          {Object.entries(PLANTILLAS_ETIQUETAS_LEDS).map(([key, plantilla]) => (
                            <option key={key} value={key}>
                              {plantilla.nombre}
                            </option>
                          ))}
                        </optgroup>
                        {/* Plantillas personalizadas */}
                        {Object.keys(plantillasEtiquetasPersonalizadas).length > 0 && (
                          <optgroup label="Mis plantillas">
                            {Object.entries(plantillasEtiquetasPersonalizadas).map(([key, plantilla]) => (
                              <option key={key} value={key}>
                                {plantilla.nombre}
                              </option>
                            ))}
                          </optgroup>
                        )}
                      </select>
                      {contarEtiquetasConfiguradas() > 0 && !modoNuevaPlantillaEtiquetas && (
                        <button
                          type="button"
                          className="modal-plantillas-btn-limpiar"
                          onClick={handleLimpiarEtiquetas}
                        >
                          Limpiar
                        </button>
                      )}
                    </div>

                    {/* Formulario para crear nueva plantilla de etiquetas */}
                    {modoNuevaPlantillaEtiquetas && (
                      <div className="modal-plantillas-nueva-plantilla-etiquetas">
                        <div className="modal-plantillas-nueva-plantilla-header">
                          <input
                            type="text"
                            className="modal-plantillas-nueva-plantilla-nombre"
                            value={nombreNuevaPlantillaEtiquetas}
                            onChange={(e) => setNombreNuevaPlantillaEtiquetas(e.target.value)}
                            placeholder="Nombre de la plantilla..."
                          />
                          <div className="modal-plantillas-nueva-plantilla-botones">
                            <button
                              type="button"
                              className="modal-plantillas-btn-guardar-etiquetas"
                              onClick={handleGuardarPlantillaEtiquetas}
                              title="Guardar plantilla"
                            >
                              Guardar
                            </button>
                            <button
                              type="button"
                              className="modal-plantillas-btn-cancelar-etiquetas"
                              onClick={handleCancelarNuevaPlantillaEtiquetas}
                              title="Cancelar"
                            >
                              Cancelar
                            </button>
                          </div>
                        </div>
                      </div>
                    )}

                    {/* Lista de bits configurables */}
                    <div className="modal-plantillas-bits-lista">
                      {Array.from({ length: cantidadBits }, (_, bit) => (
                        <div key={bit} className="modal-plantillas-bit-item">
                          <span className="modal-plantillas-bit-numero">Bit {bit}:</span>
                          <input
                            type="text"
                            className="modal-plantillas-bit-etiqueta"
                            value={etiquetasBits[bit]?.texto || ""}
                            onChange={(e) => handleCambiarEtiquetaBit(bit, e.target.value)}
                            placeholder={`LED ${bit + 1} (sin etiqueta)`}
                          />
                          <select
                            className={`modal-plantillas-bit-severidad severidad-${etiquetasBits[bit]?.severidad || "info"}`}
                            value={etiquetasBits[bit]?.severidad || "info"}
                            onChange={(e) => handleCambiarSeveridadBit(bit, e.target.value)}
                          >
                            {SEVERIDADES_DISPONIBLES.map((sev) => (
                              <option key={sev.id} value={sev.id}>
                                {sev.nombre}
                              </option>
                            ))}
                          </select>
                        </div>
                      ))}
                    </div>

                    {/* Botones para agregar/quitar filas (solo en modo nueva plantilla o si hay etiquetas) */}
                    {(modoNuevaPlantillaEtiquetas || contarEtiquetasConfiguradas() > 0) && (
                      <div className="modal-plantillas-bits-acciones">
                        <button
                          type="button"
                          className="modal-plantillas-btn-agregar-bit"
                          onClick={handleAgregarFilaBit}
                          title="Agregar fila"
                        >
                          + Agregar bit
                        </button>
                        {cantidadBits > 1 && (
                          <button
                            type="button"
                            className="modal-plantillas-btn-quitar-bit"
                            onClick={handleQuitarFilaBit}
                            title="Quitar √∫ltima fila"
                          >
                            ‚àí Quitar bit
                          </button>
                        )}
                      </div>
                    )}

                    {/* Lista de plantillas personalizadas guardadas para eliminar */}
                    {Object.keys(plantillasEtiquetasPersonalizadas).length > 0 && !modoNuevaPlantillaEtiquetas && (
                      <div className="modal-plantillas-etiquetas-guardadas">
                        <span className="modal-plantillas-etiquetas-guardadas-label">
                          Mis plantillas guardadas:
                        </span>
                        <div className="modal-plantillas-etiquetas-guardadas-lista">
                          {Object.entries(plantillasEtiquetasPersonalizadas).map(([key, plantilla]) => (
                            <div key={key} className="modal-plantillas-etiqueta-guardada">
                              <span>{plantilla.nombre}</span>
                              <button
                                type="button"
                                className="modal-plantillas-btn-eliminar-etiqueta"
                                onClick={() => handleEliminarPlantillaEtiquetas(key)}
                                title="Eliminar plantilla"
                              >
                                √ó
                              </button>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="modal-plantillas-footer">
          {modo === "lista" ? (
            <button className="modal-plantillas-btn-cerrar" onClick={onCerrar}>
              Cerrar
            </button>
          ) : (
            <>
              <button
                className="modal-plantillas-btn-cancelar"
                onClick={resetFormulario}
              >
                Cancelar
              </button>
              <button
                className="modal-plantillas-btn-guardar"
                onClick={handleGuardar}
              >
                {modo === "crear" ? "Crear Plantilla" : "Guardar Cambios"}
              </button>
            </>
          )}
        </div>
      </div>
    </div>
  );
};

export default ModalPlantillasRele;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalTransformadores.css =====

/* ============================================================================
   ModalTransformadores.css
   Estilos para el modal de gesti√≥n de transformadores TI/TV
   ============================================================================ */

.modal-transformadores-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-transformadores {
  background: #1e2433;
  border-radius: 12px;
  width: 90%;
  max-width: 700px;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  border: 1px solid #2a3447;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
}

.modal-transformadores-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #2a3447;
}

.modal-transformadores-header h3 {
  margin: 0;
  font-size: 1.1rem;
  color: #e4e4e7;
}

.modal-transformadores-cerrar {
  background: none;
  border: none;
  color: #71717a;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 0;
  line-height: 1;
  transition: color 0.2s;
}

.modal-transformadores-cerrar:hover {
  color: #e4e4e7;
}

/* Tabs */
.modal-transformadores-tabs {
  display: flex;
  border-bottom: 1px solid #2a3447;
}

.modal-transformadores-tab {
  flex: 1;
  padding: 12px 12px;
  background: none;
  border: none;
  color: #71717a;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s;
  border-bottom: 2px solid transparent;
  white-space: nowrap;
}

.modal-transformadores-tab:hover {
  color: #a1a1aa;
  background: rgba(255, 255, 255, 0.02);
}

.modal-transformadores-tab.activo {
  color: #93c5fd;
  border-bottom-color: #2563eb;
  background: rgba(37, 99, 235, 0.08);
}

/* Contenido */
.modal-transformadores-contenido {
  padding: 16px 20px;
  overflow-y: auto;
  flex: 1;
}

/* Lista */
.modal-transformadores-lista {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 16px;
}

.modal-transformadores-vacio {
  text-align: center;
  color: #52525b;
  font-style: italic;
  padding: 24px;
}

/* Item */
.modal-transformadores-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 14px;
  background: #252b3b;
  border-radius: 8px;
  border: 1px solid #2a3447;
  transition: all 0.2s;
}

.modal-transformadores-item:hover {
  border-color: #3b4557;
}

.modal-transformadores-item.editando {
  border-color: #2563eb;
  background: rgba(37, 99, 235, 0.08);
}

.modal-transformadores-item-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
  flex: 1;
}

.modal-transformadores-item-nombre {
  color: #e4e4e7;
  font-weight: 500;
  font-size: 0.9rem;
}

.modal-transformadores-item-formula {
  color: #71717a;
  font-size: 0.8rem;
  font-family: "Consolas", "Monaco", monospace;
}

.modal-transformadores-item-acciones {
  display: flex;
  gap: 8px;
}

.modal-transformadores-btn-editar,
.modal-transformadores-btn-eliminar {
  background: none;
  border: none;
  padding: 6px 8px;
  cursor: pointer;
  border-radius: 4px;
  transition: background 0.2s;
  font-size: 0.85rem;
}

.modal-transformadores-btn-editar:hover {
  background: rgba(255, 255, 255, 0.1);
}

.modal-transformadores-btn-eliminar:hover {
  background: rgba(220, 38, 38, 0.2);
}

.modal-transformadores-btn-eliminar.confirmar {
  background: #dc2626;
  color: white;
  font-size: 0.75rem;
  padding: 6px 10px;
}

/* Formulario vertical (nombre arriba, f√≥rmula + botones abajo) */
.modal-transformadores-form-vertical {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
}

.modal-transformadores-form-fila {
  display: flex;
  gap: 10px;
  align-items: center;
}

.modal-transformadores-input {
  padding: 8px 12px;
  background: #1a1f2e;
  border: 1px solid #2a3447;
  border-radius: 6px;
  color: #e4e4e7;
  font-size: 0.85rem;
}

.modal-transformadores-input:focus {
  outline: none;
  border-color: #2563eb;
}

.modal-transformadores-input-nombre {
  width: 100%;
}

.modal-transformadores-input-formula {
  flex: 1;
  font-family: "Consolas", "Monaco", monospace;
}

.modal-transformadores-btn-guardar,
.modal-transformadores-btn-cancelar {
  padding: 8px 14px;
  border-radius: 6px;
  font-size: 0.8rem;
  cursor: pointer;
  border: none;
  transition: all 0.2s;
}

.modal-transformadores-btn-guardar {
  background: #2563eb;
  color: white;
}

.modal-transformadores-btn-guardar:hover:not(:disabled) {
  background: #1d4ed8;
}

.modal-transformadores-btn-guardar:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.modal-transformadores-btn-cancelar {
  background: #374151;
  color: #e4e4e7;
}

.modal-transformadores-btn-cancelar:hover {
  background: #4b5563;
}

/* Bot√≥n nuevo */
.modal-transformadores-btn-nuevo {
  width: 100%;
  padding: 12px;
  background: rgba(37, 99, 235, 0.1);
  border: 1px dashed #2563eb;
  border-radius: 8px;
  color: #93c5fd;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s;
}

.modal-transformadores-btn-nuevo:hover {
  background: rgba(37, 99, 235, 0.2);
}

/* Ayuda */
.modal-transformadores-ayuda {
  margin-top: 16px;
  padding: 12px;
  background: #1a1f2e;
  border-radius: 6px;
  color: #71717a;
  font-size: 0.8rem;
  line-height: 1.6;
}

.modal-transformadores-ayuda code {
  background: #252b3b;
  padding: 2px 6px;
  border-radius: 4px;
  color: #fde68a;
  font-family: "Consolas", "Monaco", monospace;
}

/* Responsive */
@media (max-width: 500px) {
  .modal-transformadores-form-inline {
    flex-direction: column;
  }

  .modal-transformadores-input,
  .modal-transformadores-input-formula {
    width: 100%;
    flex: none;
  }

  .modal-transformadores-item-acciones {
    width: 100%;
    justify-content: flex-end;
  }
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalTransformadores.jsx =====

import { useState, useEffect } from "react";
import "./ModalTransformadores.css";

/**
 * Modal para gestionar transformadores de intensidad (TI) y voltaje (TV)
 */
// Configuraci√≥n de los tipos de transformadores
const TIPOS_CONFIG = {
  TI: {
    nombre: "T.I. (Intensidad)",
    nombreCorto: "T.I.",
    placeholder: "TI 200/1",
    ayudaFormula: "x * 200 / 1000",
    descripcionVacio: "intensidad",
  },
  TV: {
    nombre: "T.V. (Voltaje)",
    nombreCorto: "T.V.",
    placeholder: "TV 33kV",
    ayudaFormula: "x * 33000 / 10000",
    descripcionVacio: "voltaje",
  },
  REL: {
    nombre: "Relaci√≥n [ x : y ]",
    nombreCorto: "Relaci√≥n",
    placeholder: "Rel 1:100",
    ayudaFormula: "x * 100",
    descripcionVacio: "relaci√≥n",
  },
};

const ModalTransformadores = ({
  abierto,
  onCerrar,
  transformadores,
  onCrear,
  onActualizar,
  onEliminar,
  tipoInicial = "TI", // "TI", "TV" o "REL"
}) => {
  const [tipoActivo, setTipoActivo] = useState(tipoInicial);
  const [modoEdicion, setModoEdicion] = useState(null); // null | "crear" | id del transformador
  const [formData, setFormData] = useState({ nombre: "", formula: "" });
  const [confirmandoEliminar, setConfirmandoEliminar] = useState(null);

  // Actualizar tipo activo cuando cambia tipoInicial
  useEffect(() => {
    if (abierto) {
      setTipoActivo(tipoInicial);
    }
  }, [abierto, tipoInicial]);

  // Resetear estado al cerrar
  useEffect(() => {
    if (!abierto) {
      setModoEdicion(null);
      setFormData({ nombre: "", formula: "" });
      setConfirmandoEliminar(null);
    }
  }, [abierto]);

  if (!abierto) return null;

  const transformadoresFiltrados = transformadores.filter(
    (t) => t.tipo === tipoActivo
  );

  const handleNuevo = () => {
    setModoEdicion("crear");
    setFormData({ nombre: "", formula: "" });
  };

  const handleEditar = (transformador) => {
    setModoEdicion(transformador.id);
    setFormData({
      nombre: transformador.nombre,
      formula: transformador.formula,
    });
  };

  const handleCancelar = () => {
    setModoEdicion(null);
    setFormData({ nombre: "", formula: "" });
  };

  const handleGuardar = () => {
    if (!formData.nombre.trim() || !formData.formula.trim()) return;

    if (modoEdicion === "crear") {
      onCrear({
        tipo: tipoActivo,
        nombre: formData.nombre,
        formula: formData.formula,
      });
    } else {
      onActualizar(modoEdicion, {
        nombre: formData.nombre,
        formula: formData.formula,
      });
    }

    setModoEdicion(null);
    setFormData({ nombre: "", formula: "" });
  };

  const handleEliminar = (id) => {
    if (confirmandoEliminar === id) {
      onEliminar(id);
      setConfirmandoEliminar(null);
    } else {
      setConfirmandoEliminar(id);
    }
  };

  return (
    <div className="modal-transformadores-overlay">
      <div
        className="modal-transformadores"
      >
        <div className="modal-transformadores-header">
          <h3>Transformadores de Medida</h3>
          <button className="modal-transformadores-cerrar" onClick={onCerrar}>
            √ó
          </button>
        </div>

        {/* Tabs TI / TV / REL */}
        <div className="modal-transformadores-tabs">
          {Object.entries(TIPOS_CONFIG).map(([tipo, config]) => (
            <button
              key={tipo}
              className={`modal-transformadores-tab ${tipoActivo === tipo ? "activo" : ""}`}
              onClick={() => setTipoActivo(tipo)}
            >
              {config.nombre}
            </button>
          ))}
        </div>

        <div className="modal-transformadores-contenido">
          {/* Lista de transformadores */}
          <div className="modal-transformadores-lista">
            {transformadoresFiltrados.length === 0 ? (
              <div className="modal-transformadores-vacio">
                No hay transformadores de {TIPOS_CONFIG[tipoActivo].descripcionVacio} configurados
              </div>
            ) : (
              transformadoresFiltrados.map((t) => (
                <div
                  key={t.id}
                  className={`modal-transformadores-item ${modoEdicion === t.id ? "editando" : ""}`}
                >
                  {modoEdicion === t.id ? (
                    // Modo edici√≥n inline
                    <div className="modal-transformadores-form-vertical">
                      <input
                        type="text"
                        value={formData.nombre}
                        onChange={(e) =>
                          setFormData({ ...formData, nombre: e.target.value })
                        }
                        placeholder="Nombre"
                        className="modal-transformadores-input modal-transformadores-input-nombre"
                        autoFocus
                      />
                      <div className="modal-transformadores-form-fila">
                        <input
                          type="text"
                          value={formData.formula}
                          onChange={(e) =>
                            setFormData({ ...formData, formula: e.target.value })
                          }
                          placeholder="F√≥rmula (ej: x * 200 / 1000)"
                          className="modal-transformadores-input modal-transformadores-input-formula"
                        />
                        <button
                          className="modal-transformadores-btn-guardar"
                          onClick={handleGuardar}
                          disabled={!formData.nombre.trim() || !formData.formula.trim()}
                        >
                          Guardar
                        </button>
                        <button
                          className="modal-transformadores-btn-cancelar"
                          onClick={handleCancelar}
                        >
                          Cancelar
                        </button>
                      </div>
                    </div>
                  ) : (
                    // Modo visualizaci√≥n
                    <>
                      <div className="modal-transformadores-item-info">
                        <span className="modal-transformadores-item-nombre">
                          {t.nombre}
                        </span>
                        <span className="modal-transformadores-item-formula">
                          {t.formula}
                        </span>
                      </div>
                      <div className="modal-transformadores-item-acciones">
                        <button
                          className="modal-transformadores-btn-editar"
                          onClick={() => handleEditar(t)}
                          title="Editar"
                        >
                          ‚úèÔ∏è
                        </button>
                        <button
                          className={`modal-transformadores-btn-eliminar ${confirmandoEliminar === t.id ? "confirmar" : ""}`}
                          onClick={() => handleEliminar(t.id)}
                          title={confirmandoEliminar === t.id ? "Confirmar eliminaci√≥n" : "Eliminar"}
                        >
                          {confirmandoEliminar === t.id ? "¬øSeguro?" : "üóëÔ∏è"}
                        </button>
                      </div>
                    </>
                  )}
                </div>
              ))
            )}

            {/* Formulario para nuevo transformador */}
            {modoEdicion === "crear" && (
              <div className="modal-transformadores-item editando">
                <div className="modal-transformadores-form-vertical">
                  <input
                    type="text"
                    value={formData.nombre}
                    onChange={(e) =>
                      setFormData({ ...formData, nombre: e.target.value })
                    }
                    placeholder={`Nombre (ej: ${TIPOS_CONFIG[tipoActivo].placeholder})`}
                    className="modal-transformadores-input modal-transformadores-input-nombre"
                    autoFocus
                  />
                  <div className="modal-transformadores-form-fila">
                    <input
                      type="text"
                      value={formData.formula}
                      onChange={(e) =>
                        setFormData({ ...formData, formula: e.target.value })
                      }
                      placeholder="F√≥rmula (ej: x * 200 / 1000)"
                      className="modal-transformadores-input modal-transformadores-input-formula"
                    />
                    <button
                      className="modal-transformadores-btn-guardar"
                      onClick={handleGuardar}
                      disabled={!formData.nombre.trim() || !formData.formula.trim()}
                    >
                      Crear
                    </button>
                    <button
                      className="modal-transformadores-btn-cancelar"
                      onClick={handleCancelar}
                    >
                      Cancelar
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Bot√≥n agregar */}
          {modoEdicion === null && (
            <button
              className="modal-transformadores-btn-nuevo"
              onClick={handleNuevo}
            >
              + Nuevo {TIPOS_CONFIG[tipoActivo].nombreCorto}
            </button>
          )}

          {/* Ayuda */}
          <div className="modal-transformadores-ayuda">
            <strong>F√≥rmula:</strong> Use <code>x</code> para representar el valor le√≠do del registro.
            <br />
            Ejemplo: <code>{TIPOS_CONFIG[tipoActivo].ayudaFormula}</code> multiplica el valor por {tipoActivo === "REL" ? "100" : "200"} {tipoActivo !== "REL" && "y divide entre 1000"}.
          </div>
        </div>
      </div>
    </div>
  );
};

export default ModalTransformadores;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/TabApariencia.css =====

/* src/paginas/PaginaAlimentadores/componentes/modales/TabApariencia.css */

.tab-apariencia {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

/* Layout de dos columnas */
.apariencia-layout {
  display: flex;
  gap: 1.5rem;
  align-items: flex-start;
}

/* Columna de controles */
.apariencia-controles-columna {
  flex: 1;
  min-width: 0;
}

/* Contenedor unificado de controles */
.apariencia-controles-unificado {
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 8px;
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
}

/* Cada grupo de controles */
.apariencia-grupo {
  display: flex;
  align-items: center;
  gap: 2rem;
  flex-wrap: wrap;
}

.apariencia-grupo-label {
  font-size: 0.75rem;
  font-weight: 600;
  color: #94a3b8;
  min-width: 70px;
  text-transform: uppercase;
  letter-spacing: 0.03em;
}

/* Separador horizontal */
.apariencia-separador {
  height: 1px;
  background: linear-gradient(to right, #334155, transparent);
  margin: 0.2rem 0;
}

/* Separador y botones solo visibles en m√≥vil - ocultos por defecto */
.apariencia-separador--mobile-only,
.apariencia-botones-config-mobile {
  display: none;
}

/* =========================================================
   SELECTOR DE FUENTES PERSONALIZADO
   ========================================================= */

.selector-fuente {
  position: relative;
  min-width: 140px;
}

.selector-fuente-btn {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding: 0.35rem 0.5rem;
  border-radius: 4px;
  border: 1px solid #475569;
  background: #1e293b;
  color: #e2e8f0;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s ease;
  gap: 8px;
}

.selector-fuente-btn:hover {
  border-color: #64748b;
}

.selector-fuente-btn:focus {
  outline: none;
  border-color: #0ea5e9;
}

.selector-fuente-texto {
  flex: 1;
  text-align: left;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.selector-fuente-flecha {
  font-size: 0.6rem;
  color: #64748b;
}

.selector-fuente-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  margin-top: 2px;
  background: #1e293b;
  border: 1px solid #475569;
  border-radius: 4px;
  max-height: 280px;
  overflow-y: auto;
  z-index: 100;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
}

.selector-fuente-opcion {
  padding: 0.5rem 0.6rem;
  font-size: 0.9rem;
  color: #e2e8f0;
  cursor: pointer;
  transition: background 0.1s ease;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.selector-fuente-opcion:hover {
  background: #334155;
}

.selector-fuente-opcion--activa {
  background: #0ea5e9;
  color: #ffffff;
}

.selector-fuente-opcion--activa:hover {
  background: #0284c7;
}

/* Opci√≥n resaltada (navegaci√≥n con teclado) */
.selector-fuente-opcion--resaltada {
  background: #334155;
  outline: 1px solid #0ea5e9;
  outline-offset: -1px;
}

.selector-fuente-opcion--activa.selector-fuente-opcion--resaltada {
  background: #0ea5e9;
  outline: 2px solid #ffffff;
}

/* Scrollbar del dropdown */
.selector-fuente-dropdown::-webkit-scrollbar {
  width: 6px;
}

.selector-fuente-dropdown::-webkit-scrollbar-track {
  background: #1e293b;
}

.selector-fuente-dropdown::-webkit-scrollbar-thumb {
  background: #475569;
  border-radius: 3px;
}

.selector-fuente-dropdown::-webkit-scrollbar-thumb:hover {
  background: #64748b;
}

/* Sliders */
.apariencia-controles-unificado input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 80px;
  height: 4px;
  background: linear-gradient(to right, #334155, #0ea5e9);
  border-radius: 2px;
  cursor: pointer;
}

.apariencia-controles-unificado input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px;
  height: 12px;
  background: #e2e8f0;
  border: 2px solid #0ea5e9;
  border-radius: 50%;
  cursor: grab;
}

.apariencia-controles-unificado input[type="range"]::-moz-range-thumb {
  width: 12px;
  height: 12px;
  background: #e2e8f0;
  border: 2px solid #0ea5e9;
  border-radius: 50%;
  cursor: grab;
}

/* Valor del slider */
.tab-apariencia .apariencia-valor {
  font-size: 0.7rem;
  color: #e2e8f0;
  min-width: 45px;
}

/* =========================================================
   SLIDER CON FLECHAS
   ========================================================= */

.slider-con-flechas {
  display: flex;
  align-items: center;
  gap: 4px;
}

.slider-flecha {
  width: 18px;
  height: 18px;
  padding: 0;
  border: none;
  border-radius: 3px;
  background: #334155;
  color: #94a3b8;
  font-size: 0.55rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
}

.slider-flecha:hover:not(:disabled) {
  background: #475569;
  color: #e2e8f0;
}

.slider-flecha:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.slider-flecha:active:not(:disabled) {
  transform: scale(0.9);
}

/* =========================================================
   COLORES Y DECIMALES EN UNA FILA
   ========================================================= */

.apariencia-colores-decimales {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 1.5rem;
  padding-left: 35px;
  flex-wrap: wrap;
}

.apariencia-colores-grupo,
.apariencia-decimales-grupo {
  display: flex;
  align-items: center;
  gap: 6px;
}

.tab-apariencia .apariencia-mini-label {
  font-size: 0.7rem;
  color: #e2e8f0;
  white-space: nowrap;
}

.apariencia-colores-inline {
  display: flex;
  gap: 4px;
  align-items: center;
}

/* Separador antes del color picker personalizado */
.apariencia-colorpicker-wrapper::before {
  content: "";
  display: block;
  width: 1px;
  height: 16px;
  background: #475569;
  margin: 0 8px 0 6px;
}

.apariencia-decimales-inline {
  display: flex;
  gap: 6px;
  align-items: center;
}

.apariencia-decimal-btn {
  width: 28px;
  height: 28px;
  padding: 0;
  border: 1px solid #475569;
  border-radius: 4px;
  background: #1e293b;
  color: #94a3b8;
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s ease;
}

.apariencia-decimal-btn:hover {
  border-color: #0ea5e9;
  color: #e2e8f0;
}

.apariencia-decimal-btn--activo {
  background: #0ea5e9;
  border-color: #0ea5e9;
  color: #ffffff;
}

/* Colores (legacy - mantener para compatibilidad) */
.apariencia-colores {
  display: flex;
  gap: 4px;
  align-items: center;
  padding-left: 70px;
  flex-wrap: wrap;
}

.apariencia-color-btn {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 2px solid transparent;
  cursor: pointer;
  transition: transform 0.1s ease, border-color 0.15s ease;
}

.apariencia-color-btn:hover {
  transform: scale(1.15);
}

.apariencia-color-btn--activo {
  border-color: #ffffff;
  box-shadow: 0 0 4px rgba(255, 255, 255, 0.5);
}

/* Color picker personalizado con react-colorful */
.apariencia-colorpicker-wrapper {
  position: relative;
  display: flex;
  align-items: center;
}

.apariencia-color-picker-btn {
  width: 24px;
  height: 24px;
  padding: 0;
  border: 2px solid transparent;
  border-radius: 4px;
  cursor: pointer;
  transition: transform 0.1s ease, border-color 0.15s ease;
}

.apariencia-color-picker-btn:hover {
  transform: scale(1.15);
}

.apariencia-colorpicker-popover {
  position: fixed;
  z-index: 9999;
  padding: 8px;
  background: #1e293b;
  border-radius: 6px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
  border: 1px solid #334155;
  width: 240px;
}

.apariencia-colorpicker-popover .react-colorful {
  width: 100%;
  height: 180px;
}

.apariencia-colorpicker-popover .react-colorful__saturation {
  border-radius: 4px 4px 0 0;
  height: 140px;
}

.apariencia-colorpicker-popover .react-colorful__hue {
  height: 16px;
  border-radius: 0 0 4px 4px;
  margin-top: 6px;
}

.apariencia-colorpicker-popover .react-colorful__pointer {
  width: 18px;
  height: 18px;
}

.apariencia-colorpicker-input-row {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-top: 8px;
}

.apariencia-colorpicker-hex-input {
  flex: 1;
  padding: 5px 6px;
  border: 1.5px solid #64748b;
  border-radius: 4px;
  background: #0f172a;
  color: #e2e8f0;
  font-size: 12px;
  font-family: monospace;
  text-align: center;
  transition: all 0.2s ease;
}

.apariencia-colorpicker-hex-input:hover {
  border-color: #94a3b8;
  background: #1e293b;
}

.apariencia-colorpicker-hex-input:focus {
  outline: none;
  border-color: #06b6d4;
  background: #1e293b;
}

.apariencia-colorpicker-copy-btn {
  background: #334155;
  border: none;
  border-radius: 4px;
  padding: 6px 8px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.apariencia-colorpicker-copy-btn:hover {
  background: #475569;
  transform: scale(1.05);
}

.apariencia-colorpicker-copy-btn:active {
  transform: scale(0.95);
}

/* Dimensiones - layout en grid de 2 columnas */
.apariencia-grupo--dimensiones {
  flex-direction: column;
  align-items: flex-start;
  gap: 0.3rem;
}

.apariencia-dimensiones-fila {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 0.3rem 1.5rem;
  width: 100%;
  padding-left: 20px;
}

.apariencia-dimension-item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

.tab-apariencia .apariencia-dimension-item label {
  font-size: 0.7rem;
  color: #e2e8f0;
  min-width: auto;
  white-space: nowrap;
}

/* Sliders en dimensiones */
.apariencia-dimensiones-fila input[type="range"] {
  width: 70px;
}

/* Valores del slider en dimensiones */
.apariencia-dimensiones-fila .apariencia-valor {
  min-width: 38px;
}

.apariencia-dimension-separador {
  display: none;
}

/* Tercer item (Alto) - alineado m√°s a la derecha */
.apariencia-dimension-item:nth-child(3) {
  margin-left: 12px;
}

/* =========================================================
   COLUMNA DE PREVIEW
   ========================================================= */

.apariencia-preview-columna {
  flex-shrink: 0;
  width: 320px;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.apariencia-preview-label {
  font-size: 0.75rem;
  color: #94a3b8;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  text-align: center;
}

/* =========================================================
   TARJETA DE PREVIEW
   ========================================================= */

.preview-tarjeta {
  background-color: #262726;
  border-radius: 6px;
  overflow: hidden;
  box-shadow: 0 10px 25px rgba(15, 23, 42, 0.6);
  color: #f9fafb;
  border: 1px solid #64748b;
  width: 304px;
  min-width: 304px;
  flex-shrink: 0;
  box-sizing: border-box;
}

.preview-header {
  padding: 0.2rem 0.3rem;
  display: flex;
  align-items: center;
  position: relative;
  background: linear-gradient(to right, #f59e0b, #f59e0b80);
}

.preview-header-icons {
  display: flex;
  align-items: center;
  gap: 4px;
}

.preview-icon {
  border: 0px solid #37415171;
  border-radius: 10px;
  background: transparent;
  padding: 4px 6px;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 0.8rem;
}

.preview-titulo {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  font-weight: 700;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: calc(100% - 80px);
  pointer-events: none;
  color: #ffffff;
}

.preview-body {
  position: relative;
  padding: 0 1rem 1.2rem;
  background-color: #262726;
  border-radius: 0 0 6px 6px;
}

.preview-seccion {
  margin-bottom: 0.75rem;
}

.preview-seccion:last-child {
  margin-bottom: 0;
}

.preview-zona-titulo {
  margin: 0 -1rem 0.4rem -1rem;
  font-size: 0.8rem;
  letter-spacing: 0.05em;
  background: linear-gradient(to right, #47556999, #47556900);
  padding: 0.25rem 1rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.preview-boxes {
  display: flex;
  justify-content: center;
  gap: 18px;
  position: relative;
  overflow: visible;
}

.preview-box {
  position: relative;
  flex: 0 0 80px;
  text-align: center;
}

.preview-box-titulo {
  display: block;
  font-size: 1rem;
  margin-bottom: 0.2rem;
}

.preview-box-valor {
  position: relative;
  display: block;
  font-family: "DS-Digital", "Courier New", monospace;
  font-size: 1.5rem;
  letter-spacing: 0.06em;
  padding: 0.25rem 0.3rem;
  border-radius: 6px;
  background-color: #020617;
  border-width: 1px;
  border-style: solid;
  border-color: #0ea5e9;
  color: #ffff00;
  box-shadow: inset 0 0 6px rgba(250, 204, 21, 0.4);
}

.preview-acciones {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  padding: 0.5rem 0.8rem;
  background: #1e293b;
  border-top: 1px solid #334155;
}

.preview-btn {
  width: 32px;
  height: 32px;
  border-radius: 6px;
  border: 1px solid #475569;
  background: #334155;
  color: #e2e8f0;
  font-size: 1rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
}

.preview-btn:hover {
  background: #475569;
  border-color: #64748b;
  transform: scale(1.05);
}

/* =========================================================
   FOOTER CON BOTONES
   ========================================================= */

.apariencia-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 0.75rem;
  border-top: 1px solid #334155;
  margin-top: 0.5rem;
}

.apariencia-footer-izquierda {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

.apariencia-footer-derecha {
  display: flex;
  gap: 0.5rem;
}

.apariencia-btn {
  padding: 0.5rem 1rem;
  border-radius: 6px;
  font-size: 0.85rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;
  border: 1px solid transparent;
}

.apariencia-btn--reset {
  background: rgba(245, 158, 11, 0.15);
  border-color: #f59e0b;
  color: #f59e0b;
}

.apariencia-btn--reset:hover {
  background: rgba(245, 158, 11, 0.25);
}

.apariencia-btn--importar {
  background: rgba(6, 182, 212, 0.15);
  border-color: #06b6d4;
  color: #06b6d4;
}

.apariencia-btn--importar:hover {
  background: rgba(6, 182, 212, 0.25);
}

.apariencia-btn--exportar {
  background: rgba(16, 185, 129, 0.15);
  border-color: #10b981;
  color: #10b981;
}

.apariencia-btn--exportar:hover {
  background: rgba(16, 185, 129, 0.25);
}

.apariencia-btn--cancelar {
  background: #334155;
  border-color: #475569;
  color: #e2e8f0;
}

.apariencia-btn--cancelar:hover {
  background: #475569;
}

.apariencia-btn--guardar {
  background: #0ea5e9;
  border-color: #0ea5e9;
  color: #ffffff;
}

.apariencia-btn--guardar:hover {
  background: #0284c7;
  border-color: #0284c7;
}

/* =========================================================
   RESPONSIVE
   ========================================================= */

@media (max-width: 700px) {
  .apariencia-layout {
    flex-direction: column-reverse;
    gap: 1rem;
  }

  .apariencia-preview-columna {
    width: 100%;
    align-items: center;
  }

  .preview-tarjeta {
    width: 304px;
    min-width: 304px;
  }

  .apariencia-controles-unificado {
    padding: 0.5rem;
  }

  .apariencia-grupo {
    flex-direction: column;
    align-items: flex-start;
  }

  .apariencia-colores {
    padding-left: 0;
  }

  .apariencia-dimensiones-fila {
    grid-template-columns: 1fr;
    padding-left: 0;
    gap: 0.5rem;
  }

  .apariencia-footer {
    flex-direction: column;
    gap: 0.75rem;
  }

  .apariencia-footer-izquierda {
    width: 100%;
    flex-wrap: wrap;
    justify-content: center;
  }

  .apariencia-footer-derecha {
    width: 100%;
    justify-content: flex-end;
  }
}

/* =========================================================
   RESPONSIVE M√ìVIL (< 520px)
   ========================================================= */

@media (max-width: 520px) {
  /* Tab apariencia: NO scrolleable, flex column */
  .tab-apariencia {
    max-height: calc(100vh - 10rem);
    max-height: calc(100dvh - 10rem);
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    overflow: hidden; /* El tab no hace scroll */
  }

  /* Layout en columna: preview arriba fijo, controles abajo con scroll */
  .apariencia-layout {
    flex-direction: column;
    gap: 0.5rem;
    flex: 1;
    min-height: 0;
    overflow: visible;
  }

  /* Preview: fijo arriba, sin scroll */
  .apariencia-preview-columna {
    width: 100%;
    align-items: center;
    order: -1;
    flex-shrink: 0; /* No se encoge, mantiene su tama√±o */
  }

  /* Ocultar label "Vista previa" en m√≥vil */
  .apariencia-preview-label {
    display: none;
  }

  /* Tarjeta con tama√±o real, igual que en el panel */
  .preview-tarjeta {
    width: 304px;
    min-width: 304px;
    transform: none;
    margin-bottom: 0.6rem; /* M√°s espacio entre preview y opciones */
  }

  /* Controles: esta columna S√ç hace scroll */
  .apariencia-controles-columna {
    width: 100%;
    flex: 1;
    min-height: 0;
    overflow: visible;
    -webkit-overflow-scrolling: touch;
    position: relative;
    z-index: 10;
  }

  .apariencia-controles-unificado {
    padding: 0.6rem;
    gap: 0.5rem;
  }

  /* Cada grupo en una fila con flex wrap */
  .apariencia-grupo {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .apariencia-grupo-label {
    min-width: 55px;
    font-size: 0.7rem;
  }

  /* Sliders compactos */
  .apariencia-controles-unificado input[type="range"] {
    width: 70px;
  }

  .tab-apariencia .apariencia-valor {
    min-width: 40px;
    font-size: 0.7rem;
  }

  /* Colores y decimales - m√°s espacio entre filas */
  .apariencia-colores-decimales {
    padding-left: 0;
    gap: 1rem; /* Aumentado gap entre Color y Decimales */
    flex-wrap: wrap;
    justify-content: flex-start;
    margin-top: 0.3rem;
  }

  /* Dimensiones en grid de 2 columnas */
  .apariencia-dimensiones-fila {
    grid-template-columns: 1fr 1fr;
    padding-left: 0;
    gap: 0.6rem 0.8rem; /* M√°s espacio entre filas */
  }

  .apariencia-dimensiones-fila input[type="range"] {
    width: 50px; /* M√°s corto para que no se salga */
  }

  /* Mostrar separador y botones dentro del contenedor en m√≥vil */
  .apariencia-separador--mobile-only {
    display: block;
    margin-top: 0.4rem;
  }

  .apariencia-botones-config-mobile {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.4rem;
    padding-top: 0.3rem;
  }

  /* Restaurar a la izquierda, Importar/Exportar a la derecha */
  .apariencia-botones-config-mobile .apariencia-btn--reset {
    margin-right: auto;
  }

  /* Footer fijo abajo - Restaurar a la izquierda, Cancelar/Guardar a la derecha */
  .apariencia-footer {
    flex-direction: row;
    gap: 0.5rem;
    padding-top: 0.6rem;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    border-top: 1px solid #334155;
  }

  /* Mostrar solo el bot√≥n Restaurar, ocultar Importar/Exportar */
  .apariencia-footer-izquierda {
    display: flex;
    margin-left: -1rem;
  }

  .apariencia-footer-izquierda .apariencia-btn--importar,
  .apariencia-footer-izquierda .apariencia-btn--exportar {
    display: none;
  }

  /* Cancelar y Guardar a la derecha */
  .apariencia-footer-derecha {
    display: flex;
    gap: 0.5rem;
    justify-content: flex-end;
  }

  /* Botones m√°s compactos */
  .apariencia-btn {
    padding: 0.4rem 0.6rem;
    font-size: 0.75rem;
  }

  .apariencia-btn--reset,
  .apariencia-btn--importar,
  .apariencia-btn--exportar {
    padding: 0.35rem 0.5rem;
    font-size: 0.7rem;
  }

  /* Selector de fuente */
  .selector-fuente {
    min-width: 100px;
  }

  .selector-fuente-btn {
    padding: 0.3rem 0.4rem;
    font-size: 0.8rem;
  }

  /* Color picker */
  .apariencia-colorpicker-popover {
    width: 200px;
  }

  .apariencia-colorpicker-popover .react-colorful {
    height: 150px;
  }

  .apariencia-colorpicker-popover .react-colorful__saturation {
    height: 110px;
  }

  /* Input row del color picker - input flexible, bot√≥n a la derecha */
  .apariencia-colorpicker-input-row {
    display: flex;
    gap: 6px;
    width: 100%;
  }

  .apariencia-colorpicker-hex-input {
    flex: 1;
    min-width: 0;
    padding: 5px 6px;
    font-size: 12px;
  }

  .apariencia-colorpicker-copy-btn {
    flex-shrink: 0;
  }

  /* Slider con flechas m√°s compacto */
  .slider-flecha {
    width: 16px;
    height: 16px;
  }
}

/* =========================================================
   CARRUSEL M√ìVIL - ESTILOS
   ========================================================= */

/* Por defecto: ocultar carrusel, mostrar versi√≥n desktop */
.apariencia-carrusel {
  display: none;
}

.apariencia-controles-desktop {
  display: flex;
}

/* =========================================================
   CARRUSEL - M√ìVIL PORTRAIT
   ========================================================= */

@media (max-width: 520px) and (orientation: portrait) {
  /* Ocultar versi√≥n desktop con scroll */
  .apariencia-controles-desktop {
    display: none !important;
  }

  /* Mostrar carrusel */
  .apariencia-carrusel {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
    background: #0f172a;
    border: 1px solid #334155;
    border-radius: 8px;
    padding: 0.5rem;
    overflow: visible;
    position: relative;
  }

  /* Navegaci√≥n del carrusel - flechas + t√≠tulo central */
  .carrusel-navegacion {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
    padding: 0.2rem 0;
    border-bottom: 1px solid #334155;
    margin-bottom: 0.2rem;
  }

  /* Flechas simples sin c√≠rculo */
  .carrusel-flecha {
    padding: 0.3rem 0.5rem;
    border: none;
    border-radius: 4px;
    background: transparent;
    color: #64748b;
    font-size: 0.7rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s ease;
    flex-shrink: 0;
  }

  .carrusel-flecha:hover {
    color: #0ea5e9;
  }

  .carrusel-flecha:active {
    transform: scale(0.9);
    color: #0ea5e9;
  }

  /* T√≠tulo central del carrusel */
  .carrusel-titulo-central {
    font-size: 0.8rem;
    font-weight: 600;
    color: #0ea5e9;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    flex: 1;
    text-align: center;
  }

  /* Ocultar dots - ya no se usan */
  .carrusel-indicadores,
  .carrusel-dot {
    display: none !important;
  }

  /* Contenedor de slides */
  .carrusel-contenedor {
    position: relative;
    min-height: 70px;
    overflow: visible;
    padding-top: 0.15rem;
  }

  .carrusel-slide {
    display: none;
    flex-direction: column;
    gap: 0.5rem;
    padding: 0.3rem 0;
    padding-top: 0.15rem;
    overflow: visible;
  }

  .carrusel-slide--activo {
    display: flex;
    overflow: visible;
  }

  /* Ocultar t√≠tulo dentro del slide - ya est√° en la navegaci√≥n */
  .carrusel-slide-titulo {
    display: none;
  }

  /* Filas dentro del slide */
  .carrusel-fila {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .carrusel-label {
    font-size: 0.72rem;
    color: #94a3b8;
    min-width: 52px;
    flex-shrink: 0;
  }

  /* Fila de colores - m√°s espacio antes de decimales, menos gap con label */
  .carrusel-fila--colores {
    flex-wrap: nowrap;
    margin-bottom: 0.3rem;
    gap: 0.1rem;
  }

  .carrusel-fila--colores .apariencia-colores-inline {
    flex-wrap: wrap;
    gap: 6px;
  }

  /* Label para colores - separado de los botones */
  .carrusel-fila--colores .carrusel-label {
    min-width: 34px;
    margin-right: 0.3rem;
  }


  /* Ajustes para los controles dentro del carrusel */
  .carrusel-slide .selector-fuente {
    min-width: 100px;
    flex: 1;
  }

  /* Dropdown de fuentes hacia arriba en carrusel */
  .carrusel-slide .selector-fuente-dropdown {
    top: auto;
    bottom: 100%;
    margin-top: 0;
    margin-bottom: 2px;
    z-index: 99999;
  }

  .carrusel-slide .slider-con-flechas {
    flex: 1;
  }

  /* Flechas del slider m√°s grandes en carrusel */
  .carrusel-slide .slider-flecha {
    width: 28px;
    height: 28px;
    font-size: 0.75rem;
  }

  .carrusel-slide input[type="range"] {
    width: 65px;
  }

  /* Ocultar botones legacy del contenedor con scroll */
  .apariencia-separador--mobile-only,
  .apariencia-botones-config-mobile {
    display: none !important;
  }
}

/* =========================================================
   CARRUSEL - M√ìVIL LANDSCAPE
   ========================================================= */

@media (max-width: 900px) and (orientation: landscape) {
  /* En landscape tambi√©n mostrar carrusel si la altura es muy limitada */
  @media (max-height: 500px) {
    /* Ocultar versi√≥n desktop con scroll */
    .apariencia-controles-desktop {
      display: none !important;
    }

    /* Mostrar carrusel compacto */
    .apariencia-carrusel {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      background: #0f172a;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 0.4rem;
    }

    .carrusel-navegacion {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.4rem;
      padding: 0.15rem 0;
      border-bottom: 1px solid #334155;
      margin-bottom: 0.15rem;
    }

    .carrusel-flecha {
      padding: 0.2rem 0.4rem;
      border: none;
      background: transparent;
      color: #64748b;
      font-size: 0.6rem;
    }

    .carrusel-titulo-central {
      font-size: 0.7rem;
    }

    /* Ocultar dots en landscape */
    .carrusel-indicadores,
    .carrusel-dot {
      display: none !important;
    }

    .carrusel-contenedor {
      min-height: 60px;
    }

    .carrusel-slide {
      display: none;
      flex-direction: column;
      gap: 0.35rem;
      padding: 0.2rem 0;
    }

    .carrusel-slide--activo {
      display: flex;
    }

    .carrusel-slide-titulo {
      display: none;
    }

    .carrusel-fila {
      gap: 0.4rem;
    }

    .carrusel-label {
      font-size: 0.65rem;
      min-width: 45px;
    }

    .carrusel-botones {
      gap: 0.25rem;
      padding-top: 0.25rem;
      margin-top: 0.15rem;
    }

    .carrusel-botones .apariencia-btn {
      padding: 0.2rem 0.35rem;
      font-size: 0.6rem;
    }

    .carrusel-slide .selector-fuente-btn {
      padding: 0.2rem 0.35rem;
      font-size: 0.7rem;
    }

    .carrusel-slide input[type="range"] {
      width: 55px;
    }

    .apariencia-separador--mobile-only,
    .apariencia-botones-config-mobile {
      display: none !important;
    }
  }
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/TabApariencia.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/TabApariencia.jsx
// Pesta√±a de configuraci√≥n de apariencia global de las tarjetas

import React, { useState, useCallback, useEffect, useRef } from "react";
import { createPortal } from "react-dom";
import {
  FUENTES_DISPONIBLES,
  FUENTES_DIGITALES,
  LIMITES_TAMA√ëO,
  COLORES_VALOR_PREDEFINIDOS,
  OPCIONES_DECIMALES,
  ESTILOS_GLOBALES_DEFAULT,
} from "../../constantes/estilosGlobalesTarjeta";
import { HexColorPicker } from "react-colorful";
import "./TabApariencia.css";

// Versi√≥n del formato de archivo para compatibilidad futura
const FORMATO_VERSION = 1;

/**
 * Genera un valor aleatorio con formato de medici√≥n
 * @param {number} decimales - Cantidad de decimales a mostrar (0, 1 o 2)
 */
const generarValorAleatorio = (decimales = 2) => {
  const valor = (Math.random() * 500).toFixed(decimales);
  return valor.replace(".", ",");
};

/**
 * Formatea un valor seg√∫n la cantidad de decimales configurada
 * @param {string} valor - Valor original (puede ser "--,--" o n√∫mero con coma)
 * @param {number} decimales - Cantidad de decimales a mostrar
 */
const formatearValorConDecimales = (valor, decimales) => {
  if (valor === "--,--" || valor === "--" || valor === "--,-") {
    if (decimales === 0) return "--";
    if (decimales === 1) return "--,-";
    return "--,--";
  }

  // Convertir coma a punto para parsear
  const numStr = valor.replace(",", ".");
  const num = parseFloat(numStr);
  if (isNaN(num)) return valor;

  return num.toFixed(decimales).replace(".", ",");
};

/**
 * Redondea un n√∫mero para evitar errores de punto flotante
 * @param {number} valor - Valor a redondear
 * @param {number} decimales - Cantidad de decimales
 */
const redondear = (valor, decimales = 2) => {
  const factor = Math.pow(10, decimales);
  return Math.round(valor * factor) / factor;
};

/**
 * Selector de fuentes personalizado que muestra cada opci√≥n con su propia tipograf√≠a
 * - Auto-scroll a la fuente seleccionada al abrir
 * - Navegaci√≥n con flechas arriba/abajo con preview en vivo
 * - Enter para confirmar, Escape para cancelar
 */
const SelectorFuente = ({ value, onChange, fuentes }) => {
  const [abierto, setAbierto] = useState(false);
  const [indiceResaltado, setIndiceResaltado] = useState(-1);
  const [valorOriginal, setValorOriginal] = useState(value);
  const contenedorRef = useRef(null);
  const dropdownRef = useRef(null);
  const opcionesRefs = useRef([]);

  // √çndice de la fuente actualmente seleccionada
  const indiceSeleccionado = fuentes.findIndex((f) => f.id === value);

  // Al abrir el dropdown: guardar valor original, scroll a la opci√≥n seleccionada
  useEffect(() => {
    if (abierto) {
      setValorOriginal(value);
      setIndiceResaltado(indiceSeleccionado);

      // Scroll a la opci√≥n seleccionada despu√©s de que el DOM se actualice
      requestAnimationFrame(() => {
        const opcionActiva = opcionesRefs.current[indiceSeleccionado];
        if (opcionActiva && dropdownRef.current) {
          opcionActiva.scrollIntoView({ block: "center", behavior: "instant" });
        }
      });
    }
  }, [abierto, indiceSeleccionado, value]);

  // Cerrar dropdown al hacer clic fuera
  useEffect(() => {
    const handleClickFuera = (e) => {
      if (contenedorRef.current && !contenedorRef.current.contains(e.target)) {
        // Restaurar valor original si se cierra sin confirmar
        onChange(valorOriginal);
        setAbierto(false);
      }
    };
    if (abierto) {
      document.addEventListener("mousedown", handleClickFuera);
    }
    return () => document.removeEventListener("mousedown", handleClickFuera);
  }, [abierto, valorOriginal, onChange]);

  // Manejo de teclado
  useEffect(() => {
    if (!abierto) return;

    const handleKeyDown = (e) => {
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          setIndiceResaltado((prev) => {
            const nuevoIndice = prev < fuentes.length - 1 ? prev + 1 : 0;
            // Aplicar preview de la fuente
            onChange(fuentes[nuevoIndice].id);
            // Scroll a la opci√≥n
            requestAnimationFrame(() => {
              opcionesRefs.current[nuevoIndice]?.scrollIntoView({ block: "nearest", behavior: "smooth" });
            });
            return nuevoIndice;
          });
          break;
        case "ArrowUp":
          e.preventDefault();
          setIndiceResaltado((prev) => {
            const nuevoIndice = prev > 0 ? prev - 1 : fuentes.length - 1;
            // Aplicar preview de la fuente
            onChange(fuentes[nuevoIndice].id);
            // Scroll a la opci√≥n
            requestAnimationFrame(() => {
              opcionesRefs.current[nuevoIndice]?.scrollIntoView({ block: "nearest", behavior: "smooth" });
            });
            return nuevoIndice;
          });
          break;
        case "Enter":
          e.preventDefault();
          // Confirmar selecci√≥n actual
          setAbierto(false);
          break;
        case "Escape":
          e.preventDefault();
          // Restaurar valor original y cerrar
          onChange(valorOriginal);
          setAbierto(false);
          break;
        default:
          break;
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [abierto, fuentes, onChange, valorOriginal]);

  // Encontrar la fuente seleccionada para mostrar en el bot√≥n
  const fuenteSeleccionada = fuentes.find((f) => f.id === value) || fuentes[0];

  return (
    <div className="selector-fuente" ref={contenedorRef}>
      <button
        type="button"
        className="selector-fuente-btn"
        onClick={() => setAbierto(!abierto)}
        style={{ fontFamily: fuenteSeleccionada.id !== "inherit" ? fuenteSeleccionada.id : undefined }}
      >
        <span className="selector-fuente-texto">{fuenteSeleccionada.label}</span>
        <span className="selector-fuente-flecha">{abierto ? "‚ñ≤" : "‚ñº"}</span>
      </button>
      {abierto && (
        <div className="selector-fuente-dropdown" ref={dropdownRef}>
          {fuentes.map((f, idx) => (
            <div
              key={f.id}
              ref={(el) => (opcionesRefs.current[idx] = el)}
              className={`selector-fuente-opcion ${f.id === value ? "selector-fuente-opcion--activa" : ""} ${idx === indiceResaltado ? "selector-fuente-opcion--resaltada" : ""}`}
              style={{ fontFamily: f.id !== "inherit" ? f.id : undefined }}
              onClick={() => {
                onChange(f.id);
                setAbierto(false);
              }}
              onMouseEnter={() => {
                // Solo resaltar visualmente, sin aplicar preview ni scroll
                setIndiceResaltado(idx);
              }}
            >
              {f.label}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

/**
 * Componente Slider con flechitas para incrementar/decrementar
 */
const SliderConFlechas = ({ value, onChange, min, max, step, valorDisplay }) => {
  // Calcular decimales del step para redondear correctamente
  const decimalesStep = step < 1 ? String(step).split('.')[1]?.length || 0 : 0;

  const incrementar = () => {
    const nuevoValor = redondear(Math.min(max, parseFloat(value) + step), decimalesStep);
    onChange(nuevoValor);
  };

  const decrementar = () => {
    const nuevoValor = redondear(Math.max(min, parseFloat(value) - step), decimalesStep);
    onChange(nuevoValor);
  };

  return (
    <div className="slider-con-flechas">
      <button
        type="button"
        className="slider-flecha slider-flecha--izq"
        onClick={decrementar}
        disabled={parseFloat(value) <= min}
      >
        ‚óÄ
      </button>
      <input
        type="range"
        min={min}
        max={max}
        step={step}
        value={value}
        onChange={(e) => onChange(parseFloat(e.target.value))}
      />
      <button
        type="button"
        className="slider-flecha slider-flecha--der"
        onClick={incrementar}
        disabled={parseFloat(value) >= max}
      >
        ‚ñ∂
      </button>
      <span className="apariencia-valor">{valorDisplay}</span>
    </div>
  );
};

/**
 * Bot√≥n de color con popover usando react-colorful
 */
const ColorPickerBoton = ({ color, onChange }) => {
  const [abierto, setAbierto] = useState(false);
  const [posicion, setPosicion] = useState({ top: 0, left: 0 });
  const [valorHex, setValorHex] = useState(color);
  const pickerRef = useRef(null);
  const buttonRef = useRef(null);

  // Sincronizar valor cuando cambia el color externo
  useEffect(() => {
    setValorHex(color);
  }, [color]);

  // Calcular posici√≥n del picker al abrirlo
  const togglePicker = (e) => {
    e.stopPropagation();
    if (abierto) {
      setAbierto(false);
      return;
    }

    if (buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect();
      const alturaPopover = 260;
      const anchoPopover = 240;

      // Calcular posici√≥n vertical (preferir abajo)
      let top = rect.bottom + 8;
      if (top + alturaPopover > window.innerHeight - 10) {
        top = rect.top - alturaPopover - 8;
      }

      // Calcular posici√≥n horizontal centrada
      let left = rect.left + rect.width / 2 - anchoPopover / 2;
      if (left < 10) left = 10;
      if (left + anchoPopover > window.innerWidth - 10) {
        left = window.innerWidth - anchoPopover - 10;
      }

      setPosicion({ top, left });
      setAbierto(true);
    }
  };

  // Cerrar al hacer clic fuera
  useEffect(() => {
    if (!abierto) return;
    const handleClickFuera = (e) => {
      if (
        pickerRef.current &&
        !pickerRef.current.contains(e.target) &&
        buttonRef.current &&
        !buttonRef.current.contains(e.target)
      ) {
        setAbierto(false);
      }
    };
    const timeoutId = setTimeout(() => {
      document.addEventListener("mousedown", handleClickFuera);
    }, 10);
    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener("mousedown", handleClickFuera);
    };
  }, [abierto]);

  const handleColorChange = (nuevoColor) => {
    setValorHex(nuevoColor);
    onChange(nuevoColor);
  };

  const handleInputChange = (e) => {
    const valor = e.target.value;
    setValorHex(valor);
    if (/^#[0-9A-Fa-f]{6}$/.test(valor)) {
      onChange(valor);
    }
  };

  return (
    <div className="apariencia-colorpicker-wrapper">
      <button
        ref={buttonRef}
        type="button"
        className="apariencia-color-picker-btn"
        style={{ backgroundColor: color }}
        onClick={togglePicker}
        title="Color personalizado"
      />
      {abierto &&
        createPortal(
          <div
            ref={pickerRef}
            className="apariencia-colorpicker-popover"
            style={{ top: `${posicion.top}px`, left: `${posicion.left}px` }}
            onClick={(e) => e.stopPropagation()}
            onMouseDown={(e) => e.stopPropagation()}
          >
            <HexColorPicker color={color} onChange={handleColorChange} />
            <div className="apariencia-colorpicker-input-row">
              <input
                type="text"
                value={valorHex}
                onChange={handleInputChange}
                className="apariencia-colorpicker-hex-input"
                placeholder="#000000"
                maxLength={7}
              />
              <button
                type="button"
                className="apariencia-colorpicker-copy-btn"
                onClick={() => navigator.clipboard.writeText(valorHex)}
                title="Copiar color"
              >
                üìã
              </button>
            </div>
          </div>,
          document.body
        )}
    </div>
  );
};

/**
 * Componente de preview que muestra c√≥mo quedan los estilos aplicados
 */
const PreviewTarjeta = ({ estilos, valores, onRandomizar, onResetearValores }) => {
  const decimales = estilos.valorBox.decimales ?? 2;

  return (
    <div className="preview-tarjeta">
      <div className="preview-header">
        <div className="preview-header-icons">
          <span className="preview-icon">‚ñ≤</span>
        </div>
        <span
          className="preview-titulo"
          style={{
            fontFamily: estilos.header.fontFamily,
            fontSize: estilos.header.fontSize,
            fontWeight: estilos.header.fontWeight,
          }}
        >
          TRAFO 1
        </span>
      </div>

      <div className="preview-body">
        {/* Secci√≥n superior */}
        <div className="preview-seccion">
          <div
            className="preview-zona-titulo"
            style={{
              fontFamily: estilos.tituloZona.fontFamily,
              fontSize: estilos.tituloZona.fontSize,
            }}
          >
            CORRIENTE DE L√çNEA (A) (EN 33 KV)
          </div>
          <div className="preview-boxes" style={{ gap: estilos.box.gap }}>
            {["R", "S", "T"].map((fase, idx) => (
              <div
                key={fase}
                className="preview-box"
                style={{ width: estilos.box.width, flex: `0 0 ${estilos.box.width}` }}
              >
                <span
                  className="preview-box-titulo"
                  style={{
                    fontFamily: estilos.tituloBox.fontFamily,
                    fontSize: estilos.tituloBox.fontSize,
                  }}
                >
                  {fase}
                </span>
                <span
                  className="preview-box-valor"
                  style={{
                    fontFamily: estilos.valorBox.fontFamily,
                    fontSize: estilos.valorBox.fontSize,
                    color: estilos.valorBox.color,
                    width: "100%",
                    height: estilos.box.height !== "auto" ? estilos.box.height : undefined,
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                  }}
                >
                  {formatearValorConDecimales(valores[idx], decimales)}
                </span>
              </div>
            ))}
          </div>
        </div>

        {/* Secci√≥n inferior */}
        <div className="preview-seccion">
          <div
            className="preview-zona-titulo"
            style={{
              fontFamily: estilos.tituloZona.fontFamily,
              fontSize: estilos.tituloZona.fontSize,
            }}
          >
            CORRIENTE DE L√çNEA (A) (EN 13,2 KV)
          </div>
          <div className="preview-boxes" style={{ gap: estilos.box.gap }}>
            {["R", "S", "T"].map((fase, idx) => (
              <div
                key={`inf-${fase}`}
                className="preview-box"
                style={{ width: estilos.box.width, flex: `0 0 ${estilos.box.width}` }}
              >
                <span
                  className="preview-box-titulo"
                  style={{
                    fontFamily: estilos.tituloBox.fontFamily,
                    fontSize: estilos.tituloBox.fontSize,
                  }}
                >
                  {fase}
                </span>
                <span
                  className="preview-box-valor"
                  style={{
                    fontFamily: estilos.valorBox.fontFamily,
                    fontSize: estilos.valorBox.fontSize,
                    color: estilos.valorBox.color,
                    width: "100%",
                    height: estilos.box.height !== "auto" ? estilos.box.height : undefined,
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                  }}
                >
                  {formatearValorConDecimales(valores[idx], decimales)}
                </span>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Botones para controlar los valores del preview */}
      <div className="preview-acciones">
        <button
          type="button"
          className="preview-btn"
          onClick={onRandomizar}
          title="Poner valores aleatorios"
        >
          üé≤
        </button>
        <button
          type="button"
          className="preview-btn"
          onClick={onResetearValores}
          title="Volver a --,--"
        >
          ‚ü≤
        </button>
      </div>
    </div>
  );
};

// Valores por defecto para el preview
const VALORES_DEFAULT = ["--,--", "--,--", "--,--"];

/**
 * Nombres de los slides del carrusel para m√≥vil
 */
const SLIDES_CARRUSEL = [
  { id: "header", label: "Header" },
  { id: "zona", label: "Zona" },
  { id: "fases", label: "Fases" },
  { id: "valores1", label: "Valores 1/2" },
  { id: "valores2", label: "Valores 2/2" },
  { id: "dimensiones", label: "Dimensiones" },
];

/**
 * Componente para configurar la apariencia global de las tarjetas
 */
const TabApariencia = ({
  estilosIniciales,
  onGuardar,
  onCancelar,
}) => {
  // Ref para guardar los estilos iniciales y solo sincronizar una vez
  const estilosInicialesRef = useRef(null);

  // Estado para el carrusel en m√≥vil
  const [slideActual, setSlideActual] = useState(0);

  // Estado local para los estilos (copia editable)
  const [estilos, setEstilos] = useState(() => ({
    header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...estilosIniciales?.header },
    tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...estilosIniciales?.tituloZona },
    tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...estilosIniciales?.tituloBox },
    valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...estilosIniciales?.valorBox },
    box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...estilosIniciales?.box },
  }));

  // Estado para los valores del preview
  const [valoresPreview, setValoresPreview] = useState(VALORES_DEFAULT);

  // Reiniciar estado local solo cuando cambian los estilos iniciales realmente (al abrir el modal)
  useEffect(() => {
    // Solo actualizar si es la primera vez o si los estilos iniciales cambiaron de verdad
    const estilosStr = JSON.stringify(estilosIniciales);
    if (estilosIniciales && estilosInicialesRef.current !== estilosStr) {
      estilosInicialesRef.current = estilosStr;
      setEstilos({
        header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...estilosIniciales.header },
        tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...estilosIniciales.tituloZona },
        tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...estilosIniciales.tituloBox },
        valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...estilosIniciales.valorBox },
        box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...estilosIniciales.box },
      });
    }
  }, [estilosIniciales]);

  // Funciones para actualizar cada secci√≥n
  const actualizarHeader = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      header: { ...prev.header, ...cambios },
    }));
  }, []);

  const actualizarTituloZona = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      tituloZona: { ...prev.tituloZona, ...cambios },
    }));
  }, []);

  const actualizarTituloBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      tituloBox: { ...prev.tituloBox, ...cambios },
    }));
  }, []);

  const actualizarValorBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      valorBox: { ...prev.valorBox, ...cambios },
    }));
  }, []);

  const actualizarBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      box: { ...prev.box, ...cambios },
    }));
  }, []);

  // Restaurar valores por defecto
  const restaurarDefecto = useCallback(() => {
    setEstilos(ESTILOS_GLOBALES_DEFAULT);
  }, []);

  // Funciones auxiliares
  const remANumero = (remStr) => {
    if (typeof remStr === "number") return remStr;
    return parseFloat(remStr) || 1;
  };

  const pxANumero = (pxStr) => {
    if (typeof pxStr === "number") return pxStr;
    return parseInt(pxStr) || 80;
  };

  const randomizarValores = useCallback(() => {
    const decimales = estilos.valorBox.decimales ?? 2;
    setValoresPreview([
      generarValorAleatorio(decimales),
      generarValorAleatorio(decimales),
      generarValorAleatorio(decimales),
    ]);
  }, [estilos.valorBox.decimales]);

  const resetearValoresPreview = useCallback(() => {
    setValoresPreview(VALORES_DEFAULT);
  }, []);

  // Navegaci√≥n del carrusel
  const irAlSlideAnterior = useCallback(() => {
    setSlideActual((prev) => (prev > 0 ? prev - 1 : SLIDES_CARRUSEL.length - 1));
  }, []);

  const irAlSlideSiguiente = useCallback(() => {
    setSlideActual((prev) => (prev < SLIDES_CARRUSEL.length - 1 ? prev + 1 : 0));
  }, []);

  // Guardar cambios
  const handleGuardar = () => {
    onGuardar(estilos);
  };

  // Referencia para el input de archivo oculto
  const inputArchivoRef = useRef(null);

  // Exportar configuraci√≥n a archivo JSON
  const exportarConfiguracion = useCallback(async () => {
    const configuracion = {
      version: FORMATO_VERSION,
      fechaExportacion: new Date().toISOString(),
      estilos: estilos,
    };

    const contenidoJSON = JSON.stringify(configuracion, null, 2);
    const nombreArchivo = `apariencia-tarjetas-${new Date().toISOString().slice(0, 10)}.json`;

    // Intentar usar File System Access API (Chrome, Edge)
    if ("showSaveFilePicker" in window) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: nombreArchivo,
          types: [
            {
              description: "Archivo JSON",
              accept: { "application/json": [".json"] },
            },
          ],
        });
        const writable = await handle.createWritable();
        await writable.write(contenidoJSON);
        await writable.close();
        return; // √âxito con File System Access API
      } catch (err) {
        // Si el usuario cancela, no hacer nada
        if (err.name === "AbortError") return;
        // Si hay otro error, usar el fallback
        console.warn("File System Access API fall√≥, usando fallback:", err);
      }
    }

    // Fallback para navegadores sin soporte (Firefox, Safari, etc.)
    const blob = new Blob([contenidoJSON], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = nombreArchivo;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [estilos]);

  // Importar configuraci√≥n desde archivo JSON
  const importarConfiguracion = (evento) => {
    const archivo = evento.target.files?.[0];
    if (!archivo) return;

    const lector = new FileReader();
    lector.onload = (e) => {
      try {
        const contenido = JSON.parse(e.target.result);

        // Validar que tenga la estructura esperada
        if (!contenido.estilos) {
          alert("El archivo no tiene el formato correcto de configuraci√≥n.");
          return;
        }

        // Aplicar los estilos importados
        setEstilos({
          header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...contenido.estilos.header },
          tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...contenido.estilos.tituloZona },
          tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...contenido.estilos.tituloBox },
          valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...contenido.estilos.valorBox },
          box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...contenido.estilos.box },
        });
      } catch {
        alert("Error al leer el archivo. Aseg√∫rate de que sea un archivo JSON v√°lido.");
      }
    };
    lector.readAsText(archivo);

    // Limpiar el input para permitir reimportar el mismo archivo
    evento.target.value = "";
  };

  return (
    <div className="tab-apariencia">
      <div className="apariencia-layout">
        {/* Columna de controles - todo en un contenedor con separadores */}
        <div className="apariencia-controles-columna">
          {/* Versi√≥n Desktop: contenedor con scroll */}
          <div className="apariencia-controles-unificado apariencia-controles-desktop">
            {/* Header */}
            <div className="apariencia-grupo">
              <span className="apariencia-grupo-label">Header</span>
              <SelectorFuente
                value={estilos.header.fontFamily}
                onChange={(fontFamily) => actualizarHeader({ fontFamily })}
                fuentes={FUENTES_DISPONIBLES}
              />
              <SliderConFlechas
                value={remANumero(estilos.header.fontSize)}
                onChange={(val) => actualizarHeader({ fontSize: `${val}rem` })}
                min={LIMITES_TAMA√ëO.header.min}
                max={LIMITES_TAMA√ëO.header.max}
                step={LIMITES_TAMA√ëO.header.step}
                valorDisplay={estilos.header.fontSize}
              />
            </div>

            <div className="apariencia-separador" />

            {/* T√≠tulos zona */}
            <div className="apariencia-grupo">
              <span className="apariencia-grupo-label">Zona</span>
              <SelectorFuente
                value={estilos.tituloZona.fontFamily}
                onChange={(fontFamily) => actualizarTituloZona({ fontFamily })}
                fuentes={FUENTES_DISPONIBLES}
              />
              <SliderConFlechas
                value={remANumero(estilos.tituloZona.fontSize)}
                onChange={(val) => actualizarTituloZona({ fontSize: `${val}rem` })}
                min={LIMITES_TAMA√ëO.tituloZona.min}
                max={LIMITES_TAMA√ëO.tituloZona.max}
                step={LIMITES_TAMA√ëO.tituloZona.step}
                valorDisplay={estilos.tituloZona.fontSize}
              />
            </div>

            <div className="apariencia-separador" />

            {/* Fases */}
            <div className="apariencia-grupo">
              <span className="apariencia-grupo-label">Fases</span>
              <SelectorFuente
                value={estilos.tituloBox.fontFamily}
                onChange={(fontFamily) => actualizarTituloBox({ fontFamily })}
                fuentes={FUENTES_DISPONIBLES}
              />
              <SliderConFlechas
                value={remANumero(estilos.tituloBox.fontSize)}
                onChange={(val) => actualizarTituloBox({ fontSize: `${val}rem` })}
                min={LIMITES_TAMA√ëO.tituloBox.min}
                max={LIMITES_TAMA√ëO.tituloBox.max}
                step={LIMITES_TAMA√ëO.tituloBox.step}
                valorDisplay={estilos.tituloBox.fontSize}
              />
            </div>

            <div className="apariencia-separador" />

            {/* Valores */}
            <div className="apariencia-grupo">
              <span className="apariencia-grupo-label">Valores</span>
              <SelectorFuente
                value={estilos.valorBox.fontFamily}
                onChange={(fontFamily) => actualizarValorBox({ fontFamily })}
                fuentes={FUENTES_DISPONIBLES}
              />
              <SliderConFlechas
                value={remANumero(estilos.valorBox.fontSize)}
                onChange={(val) => actualizarValorBox({ fontSize: `${val}rem` })}
                min={LIMITES_TAMA√ëO.valorBox.min}
                max={LIMITES_TAMA√ëO.valorBox.max}
                step={LIMITES_TAMA√ëO.valorBox.step}
                valorDisplay={estilos.valorBox.fontSize}
              />
            </div>

            {/* Colores y Decimales en una fila */}
            <div className="apariencia-colores-decimales">
              {/* Colores a la izquierda */}
              <div className="apariencia-colores-grupo">
                <span className="apariencia-mini-label">Color:</span>
                <div className="apariencia-colores-inline">
                  {COLORES_VALOR_PREDEFINIDOS.map((color) => (
                    <button
                      key={color}
                      type="button"
                      className={`apariencia-color-btn ${estilos.valorBox.color === color ? "apariencia-color-btn--activo" : ""}`}
                      style={{ backgroundColor: color }}
                      onClick={() => actualizarValorBox({ color })}
                      title={color}
                    />
                  ))}
                  <ColorPickerBoton
                    color={estilos.valorBox.color}
                    onChange={(color) => actualizarValorBox({ color })}
                  />
                </div>
              </div>

              {/* Decimales a la derecha */}
              <div className="apariencia-decimales-grupo">
                <span className="apariencia-mini-label">Decimales:</span>
                <div className="apariencia-decimales-inline">
                  {OPCIONES_DECIMALES.map((opcion) => (
                    <button
                      key={opcion.valor}
                      type="button"
                      className={`apariencia-decimal-btn ${(estilos.valorBox.decimales ?? 2) === opcion.valor ? "apariencia-decimal-btn--activo" : ""}`}
                      onClick={() => actualizarValorBox({ decimales: opcion.valor })}
                    >
                      {opcion.valor}
                    </button>
                  ))}
                </div>
              </div>
            </div>

            <div className="apariencia-separador" />

            {/* Dimensiones - grid 2x2 */}
            <div className="apariencia-grupo apariencia-grupo--dimensiones">
              <span className="apariencia-grupo-label">Dimensiones</span>
              <div className="apariencia-dimensiones-fila">
                <div className="apariencia-dimension-item">
                  <label>Ancho</label>
                  <SliderConFlechas
                    value={pxANumero(estilos.box.width)}
                    onChange={(val) => actualizarBox({ width: `${val}px` })}
                    min={LIMITES_TAMA√ëO.boxWidth.min}
                    max={LIMITES_TAMA√ëO.boxWidth.max}
                    step={LIMITES_TAMA√ëO.boxWidth.step}
                    valorDisplay={estilos.box.width}
                  />
                </div>
                <div className="apariencia-dimension-item">
                  <label>Espacio</label>
                  <SliderConFlechas
                    value={pxANumero(estilos.box.gap)}
                    onChange={(val) => actualizarBox({ gap: `${val}px` })}
                    min={LIMITES_TAMA√ëO.gap.min}
                    max={LIMITES_TAMA√ëO.gap.max}
                    step={LIMITES_TAMA√ëO.gap.step}
                    valorDisplay={estilos.box.gap}
                  />
                </div>
                <div className="apariencia-dimension-item">
                  <label>Alto</label>
                  <SliderConFlechas
                    value={estilos.box.height === "auto" ? LIMITES_TAMA√ëO.boxHeight.min : pxANumero(estilos.box.height)}
                    onChange={(val) => actualizarBox({ height: `${val}px` })}
                    min={LIMITES_TAMA√ëO.boxHeight.min}
                    max={LIMITES_TAMA√ëO.boxHeight.max}
                    step={LIMITES_TAMA√ëO.boxHeight.step}
                    valorDisplay={estilos.box.height}
                  />
                </div>
              </div>
            </div>
          </div>

          {/* Versi√≥n M√≥vil: Carrusel con flechas */}
          <div className="apariencia-carrusel">
            {/* Navegaci√≥n del carrusel con t√≠tulo en el centro */}
            <div className="carrusel-navegacion">
              <button
                type="button"
                className="carrusel-flecha carrusel-flecha--izq"
                onClick={irAlSlideAnterior}
                aria-label="Slide anterior"
              >
                ‚óÄ
              </button>

              <span className="carrusel-titulo-central">
                {SLIDES_CARRUSEL[slideActual].label}
              </span>

              <button
                type="button"
                className="carrusel-flecha carrusel-flecha--der"
                onClick={irAlSlideSiguiente}
                aria-label="Slide siguiente"
              >
                ‚ñ∂
              </button>
            </div>

            {/* Contenedor de slides */}
            <div className="carrusel-contenedor">
              {/* Slide 0: Header */}
              <div className={`carrusel-slide ${slideActual === 0 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Fuente:</span>
                  <SelectorFuente
                    value={estilos.header.fontFamily}
                    onChange={(fontFamily) => actualizarHeader({ fontFamily })}
                    fuentes={FUENTES_DISPONIBLES}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Tama√±o:</span>
                  <SliderConFlechas
                    value={remANumero(estilos.header.fontSize)}
                    onChange={(val) => actualizarHeader({ fontSize: `${val}rem` })}
                    min={LIMITES_TAMA√ëO.header.min}
                    max={LIMITES_TAMA√ëO.header.max}
                    step={LIMITES_TAMA√ëO.header.step}
                    valorDisplay={estilos.header.fontSize}
                  />
                </div>
              </div>

              {/* Slide 1: Zona */}
              <div className={`carrusel-slide ${slideActual === 1 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Fuente:</span>
                  <SelectorFuente
                    value={estilos.tituloZona.fontFamily}
                    onChange={(fontFamily) => actualizarTituloZona({ fontFamily })}
                    fuentes={FUENTES_DISPONIBLES}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Tama√±o:</span>
                  <SliderConFlechas
                    value={remANumero(estilos.tituloZona.fontSize)}
                    onChange={(val) => actualizarTituloZona({ fontSize: `${val}rem` })}
                    min={LIMITES_TAMA√ëO.tituloZona.min}
                    max={LIMITES_TAMA√ëO.tituloZona.max}
                    step={LIMITES_TAMA√ëO.tituloZona.step}
                    valorDisplay={estilos.tituloZona.fontSize}
                  />
                </div>
              </div>

              {/* Slide 2: Fases */}
              <div className={`carrusel-slide ${slideActual === 2 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Fuente:</span>
                  <SelectorFuente
                    value={estilos.tituloBox.fontFamily}
                    onChange={(fontFamily) => actualizarTituloBox({ fontFamily })}
                    fuentes={FUENTES_DISPONIBLES}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Tama√±o:</span>
                  <SliderConFlechas
                    value={remANumero(estilos.tituloBox.fontSize)}
                    onChange={(val) => actualizarTituloBox({ fontSize: `${val}rem` })}
                    min={LIMITES_TAMA√ëO.tituloBox.min}
                    max={LIMITES_TAMA√ëO.tituloBox.max}
                    step={LIMITES_TAMA√ëO.tituloBox.step}
                    valorDisplay={estilos.tituloBox.fontSize}
                  />
                </div>
              </div>

              {/* Slide 3: Valores 1/2 (Fuente y Tama√±o) */}
              <div className={`carrusel-slide ${slideActual === 3 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Fuente:</span>
                  <SelectorFuente
                    value={estilos.valorBox.fontFamily}
                    onChange={(fontFamily) => actualizarValorBox({ fontFamily })}
                    fuentes={FUENTES_DISPONIBLES}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Tama√±o:</span>
                  <SliderConFlechas
                    value={remANumero(estilos.valorBox.fontSize)}
                    onChange={(val) => actualizarValorBox({ fontSize: `${val}rem` })}
                    min={LIMITES_TAMA√ëO.valorBox.min}
                    max={LIMITES_TAMA√ëO.valorBox.max}
                    step={LIMITES_TAMA√ëO.valorBox.step}
                    valorDisplay={estilos.valorBox.fontSize}
                  />
                </div>
              </div>

              {/* Slide 4: Valores 2/2 (Color y Decimales) */}
              <div className={`carrusel-slide ${slideActual === 4 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila carrusel-fila--colores">
                  <span className="carrusel-label">Color:</span>
                  <div className="apariencia-colores-inline">
                    {COLORES_VALOR_PREDEFINIDOS.map((color) => (
                      <button
                        key={color}
                        type="button"
                        className={`apariencia-color-btn ${estilos.valorBox.color === color ? "apariencia-color-btn--activo" : ""}`}
                        style={{ backgroundColor: color }}
                        onClick={() => actualizarValorBox({ color })}
                        title={color}
                      />
                    ))}
                    <ColorPickerBoton
                      color={estilos.valorBox.color}
                      onChange={(color) => actualizarValorBox({ color })}
                    />
                  </div>
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Decimales:</span>
                  <div className="apariencia-decimales-inline">
                    {OPCIONES_DECIMALES.map((opcion) => (
                      <button
                        key={opcion.valor}
                        type="button"
                        className={`apariencia-decimal-btn ${(estilos.valorBox.decimales ?? 2) === opcion.valor ? "apariencia-decimal-btn--activo" : ""}`}
                        onClick={() => actualizarValorBox({ decimales: opcion.valor })}
                      >
                        {opcion.valor}
                      </button>
                    ))}
                  </div>
                </div>
              </div>

              {/* Slide 5: Dimensiones */}
              <div className={`carrusel-slide ${slideActual === 5 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Ancho:</span>
                  <SliderConFlechas
                    value={pxANumero(estilos.box.width)}
                    onChange={(val) => actualizarBox({ width: `${val}px` })}
                    min={LIMITES_TAMA√ëO.boxWidth.min}
                    max={LIMITES_TAMA√ëO.boxWidth.max}
                    step={LIMITES_TAMA√ëO.boxWidth.step}
                    valorDisplay={estilos.box.width}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Alto:</span>
                  <SliderConFlechas
                    value={estilos.box.height === "auto" ? LIMITES_TAMA√ëO.boxHeight.min : pxANumero(estilos.box.height)}
                    onChange={(val) => actualizarBox({ height: `${val}px` })}
                    min={LIMITES_TAMA√ëO.boxHeight.min}
                    max={LIMITES_TAMA√ëO.boxHeight.max}
                    step={LIMITES_TAMA√ëO.boxHeight.step}
                    valorDisplay={estilos.box.height}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Espacio:</span>
                  <SliderConFlechas
                    value={pxANumero(estilos.box.gap)}
                    onChange={(val) => actualizarBox({ gap: `${val}px` })}
                    min={LIMITES_TAMA√ëO.gap.min}
                    max={LIMITES_TAMA√ëO.gap.max}
                    step={LIMITES_TAMA√ëO.gap.step}
                    valorDisplay={estilos.box.gap}
                  />
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Columna de preview */}
        <div className="apariencia-preview-columna">
          <div className="apariencia-preview-label">Vista previa</div>
          <PreviewTarjeta
            estilos={estilos}
            valores={valoresPreview}
            onRandomizar={randomizarValores}
            onResetearValores={resetearValoresPreview}
          />
        </div>
      </div>

      {/* Footer con botones */}
      <div className="apariencia-footer">
        <div className="apariencia-footer-izquierda">
          <button
            type="button"
            className="apariencia-btn apariencia-btn--reset"
            onClick={restaurarDefecto}
          >
            Restaurar por defecto
          </button>
          <button
            type="button"
            className="apariencia-btn apariencia-btn--importar"
            onClick={() => inputArchivoRef.current?.click()}
            title="Importar configuraci√≥n desde archivo"
          >
            Importar
          </button>
          <button
            type="button"
            className="apariencia-btn apariencia-btn--exportar"
            onClick={exportarConfiguracion}
            title="Exportar configuraci√≥n a archivo"
          >
            Exportar
          </button>
          {/* Input oculto para importar archivo */}
          <input
            ref={inputArchivoRef}
            type="file"
            accept=".json"
            onChange={importarConfiguracion}
            style={{ display: "none" }}
          />
        </div>
        <div className="apariencia-footer-derecha">
          <button
            type="button"
            className="apariencia-btn apariencia-btn--cancelar"
            onClick={onCancelar}
          >
            Cancelar
          </button>
          <button
            type="button"
            className="apariencia-btn apariencia-btn--guardar"
            onClick={handleGuardar}
          >
            Guardar
          </button>
        </div>
      </div>
    </div>
  );
};

export default TabApariencia;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/VentanaHistorial.css =====

/**
 * Estilos para VentanaHistorial - Ventana flotante arrastrable
 */

/* Variables CSS para el tema */
:root {
  /* Colores principales */
  --vh-bg-primary: #1e293b;
  --vh-bg-secondary: #334155;
  --vh-bg-tertiary: #475569;
  --vh-bg-dark: #0f172a;

  /* Bordes */
  --vh-border-color: #475569;
  --vh-border-light: rgba(255, 255, 255, 0.05);
  --vh-border-accent: rgba(0, 255, 136, 0.3);

  /* Texto */
  --vh-text-primary: #e2e8f0;
  --vh-text-secondary: #94a3b8;
  --vh-text-muted: #64748b;

  /* Acentos */
  --vh-accent-blue: #0ea5e9;
  --vh-accent-green: #22c55e;
  --vh-accent-yellow: #fbbf24;
  --vh-accent-red: #ef4444;
  --vh-accent-cyan: #00ff88;

  /* Sombras */
  --vh-shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.4);
  --vh-shadow-md: 0 4px 16px rgba(0, 0, 0, 0.3);

  /* Transiciones */
  --vh-transition-fast: 0.15s ease;
  --vh-transition-normal: 0.2s ease;

  /* Dimensiones */
  --vh-border-radius: 8px;
  --vh-border-radius-sm: 4px;
}

/* Ventana principal */
.ventana-historial {
  background: var(--vh-bg-primary);
  border-radius: var(--vh-border-radius);
  box-shadow: var(--vh-shadow-lg), 0 0 0 1px var(--vh-border-light);
  display: flex;
  flex-direction: column;
  min-width: 600px;
  min-height: 400px;
  width: 1050px;
  height: 550px;
  overflow: hidden;
  resize: both;
}

.ventana-historial--maximizada {
  border-radius: 0;
  resize: none;
}

.ventana-historial--arrastrando {
  opacity: 0.9;
  cursor: grabbing;
}

/* Header */
.ventana-historial-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.5rem 0.75rem;
  background: linear-gradient(180deg, var(--vh-bg-secondary) 0%, var(--vh-bg-primary) 100%);
  border-bottom: 1px solid var(--vh-border-color);
  cursor: grab;
  user-select: none;
  flex-shrink: 0;
}

.ventana-historial--arrastrando .ventana-historial-header {
  cursor: grabbing;
}

.ventana-historial-titulo {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.ventana-historial-icono {
  font-size: 1rem;
}

.ventana-historial-nombre {
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--vh-text-primary);
  max-width: 200px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Selector de alimentador en la barra de controles */
/* Contenedor del selector de alimentador con separador */
.ventana-selector-alimentador-container {
  display: flex;
  align-items: center;
  padding: 0 0.5rem;
  margin-right: 0.5rem;
}

.ventana-selector-alimentador {
  font-size: 0.75rem;
  font-weight: 500;
  color: #e2e8f0;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  padding: 0.35rem 1.75rem 0.35rem 0.5rem;
  min-width: 120px;
  max-width: 180px;
  cursor: pointer;
  outline: none;
  transition: border-color 0.15s, background-color 0.15s;
  /* Flecha personalizada */
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 0.5rem center;
}

.ventana-selector-alimentador:hover {
  background: #3d4f66;
  border-color: #5b6b7f;
}

.ventana-selector-alimentador:focus {
  border-color: #0ea5e9;
  box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.25);
}

.ventana-selector-alimentador option {
  background: #1e293b;
  color: #e2e8f0;
  padding: 0.5rem;
}

/* Controles de ventana */
.ventana-historial-controles {
  display: flex;
  gap: 0.25rem;
}

.ventana-btn {
  width: 24px;
  height: 24px;
  border: none;
  border-radius: var(--vh-border-radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 1rem;
  line-height: 1;
  transition: all var(--vh-transition-fast);
}

.ventana-btn--minimizar {
  background: var(--vh-bg-tertiary);
  color: var(--vh-text-primary);
}

.ventana-btn--minimizar:hover {
  background: var(--vh-accent-yellow);
  color: var(--vh-bg-primary);
}

.ventana-btn--maximizar {
  background: var(--vh-bg-tertiary);
  color: var(--vh-text-primary);
}

.ventana-btn--maximizar:hover {
  background: var(--vh-accent-green);
  color: var(--vh-bg-primary);
}

.ventana-btn--cerrar {
  background: var(--vh-bg-tertiary);
  color: var(--vh-text-primary);
}

.ventana-btn--cerrar:hover {
  background: var(--vh-accent-red);
  color: #ffffff;
}

/* Contenido */
.ventana-historial-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 0.75rem;
  overflow: hidden;
  min-height: 0;
}

/* Barra de controles */
.ventana-controles {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 0.5rem 0.75rem;
  background: #0f172a;
  border-radius: 6px;
  margin-bottom: 0.75rem;
  flex-wrap: wrap;
  flex-shrink: 0;
}

/* Bot√≥n toggle para panel de datos */
.ventana-toggle-datos {
  width: 28px;
  height: 28px;
  padding: 0;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #94a3b8;
  cursor: pointer;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.ventana-toggle-datos:hover {
  background: #475569;
  border-color: #64748b;
  color: #e2e8f0;
}

.ventana-toggle-datos--activo {
  background: #0ea5e9;
  border-color: #0ea5e9;
  color: #ffffff;
}

.ventana-toggle-datos--activo:hover {
  background: #0284c7;
  border-color: #0284c7;
}

.ventana-toggle-icono {
  font-size: 0.65rem;
  line-height: 1;
  transition: transform 0.25s ease;
  display: inline-block;
}

.ventana-toggle-datos--activo .ventana-toggle-icono {
  transform: rotate(180deg);
}

/* Tabs de zona */
.ventana-tabs {
  display: flex;
  border: 1px solid #475569;
  border-radius: 4px;
  overflow: hidden;
}

.ventana-tab {
  padding: 0.35rem 1rem;
  background: transparent;
  border: none;
  border-right: 1px solid #475569;
  color: #94a3b8;
  font-size: 0.75rem;
  cursor: pointer;
  transition: all 0.15s ease;
  white-space: nowrap;
  max-width: 220px;
  overflow: hidden;
  text-overflow: ellipsis;
}

.ventana-tab:last-child {
  border-right: none;
}

.ventana-tab:hover:not(:disabled) {
  background: #334155;
}

.ventana-tab--activo {
  background: #0ea5e9;
  color: #ffffff;
}

.ventana-tab:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Selector de rango */
.ventana-rango {
  display: flex;
  gap: 0.25rem;
}

.ventana-rango-btn {
  padding: 0.3rem 0.5rem;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #94a3b8;
  font-size: 0.7rem;
  cursor: pointer;
  transition: all 0.15s ease;
}

.ventana-rango-btn:hover {
  background: #475569;
  color: #e2e8f0;
}

.ventana-rango-btn--activo {
  background: #0ea5e9;
  border-color: #0ea5e9;
  color: #ffffff;
}

/* Grupo contenedor para datepicker + botones de gr√°fico */
.ventana-grupo-graficos {
  display: flex;
  align-items: center;
  margin-left: 0.5rem;
  padding: 0 1rem;
  border-left: 1px solid #475569;
  border-right: 1px solid #475569;
}

/* Selector de d√≠a espec√≠fico */
.ventana-selector-dia {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding-right: 1rem;
}

.ventana-dia-seleccionado {
  font-size: 0.75rem;
  color: #0ea5e9;
  font-weight: 600;
}

/* Selector de tipo de gr√°fico */
.ventana-tipo-grafico {
  display: flex;
  gap: 0.4rem;
  padding-left: 1rem;
  border-left: 1px solid #475569;
}

.ventana-tipo-btn {
  width: 28px;
  height: 28px;
  padding: 0;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #94a3b8;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.ventana-tipo-btn:hover {
  background: #475569;
  border-color: #64748b;
}

.ventana-tipo-btn--activo {
  background: #0ea5e9;
  border-color: #0ea5e9;
  color: #ffffff;
}

.ventana-tipo-btn--activo:hover {
  background: #0284c7;
  border-color: #0284c7;
}

/* Cache + Fuente */
.ventana-cache {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-left: auto;
}

.ventana-cache-barra {
  width: 60px;
  height: 6px;
  background: #334155;
  border-radius: 3px;
  overflow: hidden;
}

.ventana-cache-progreso {
  height: 100%;
  background: linear-gradient(90deg, #0ea5e9, #38bdf8);
  border-radius: 3px;
  transition: width 0.3s ease;
}

.ventana-cache-progreso--completo {
  background: linear-gradient(90deg, #22c55e, #4ade80);
}

.ventana-cache-texto {
  font-size: 0.7rem;
  color: #94a3b8;
  min-width: 24px;
  text-align: center;
}

.ventana-fuente {
  padding: 0.15rem 0.4rem;
  border-radius: 3px;
  font-size: 0.65rem;
  font-weight: 600;
}

.ventana-fuente--local {
  background: rgba(34, 197, 94, 0.2);
  color: #22c55e;
}

.ventana-fuente--remoto {
  background: rgba(14, 165, 233, 0.2);
  color: #0ea5e9;
}

.ventana-fuente--mixto {
  background: rgba(251, 191, 36, 0.2);
  color: #fbbf24;
}

.ventana-btn-limpiar {
  width: 24px;
  height: 24px;
  padding: 0;
  background: transparent;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #94a3b8;
  font-size: 0.75rem;
  cursor: pointer;
  transition: all 0.15s ease;
}

.ventana-btn-limpiar:hover:not(:disabled) {
  background: #334155;
  border-color: #64748b;
}

.ventana-btn-limpiar:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Bot√≥n toggle gr√°fico - oculto por defecto (solo visible en m√≥vil portrait) */
.ventana-toggle-grafico {
  display: none;
}

/* Contenedor del gr√°fico y panel */
.ventana-grafico-container {
  flex: 1;
  display: flex;
  gap: 0.75rem;
  min-height: 200px;
  overflow: hidden;
}

/* Slider vertical para escala Y (pegado al gr√°fico) */
.ventana-escala-y {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  padding: 0.35rem 0.15rem;
  background: #0f172a;
  border-radius: 6px;
  width: 38px;
  flex-shrink: 0;
}

.ventana-escala-y-label {
  font-size: 0.65rem;
  color: #94a3b8;
  font-family: "Consolas", "Monaco", monospace;
  text-align: center;
  min-width: 32px;
}

.ventana-escala-y-label--editable {
  cursor: pointer;
  border-radius: 2px;
  padding: 1px 2px;
  transition: background-color 0.15s ease;
}

.ventana-escala-y-label--editable:hover {
  background: #334155;
  color: #e2e8f0;
}

.ventana-escala-y-input {
  width: 32px;
  padding: 1px 2px;
  font-size: 0.65rem;
  font-family: "Consolas", "Monaco", monospace;
  text-align: center;
  background: #1e293b;
  border: 1px solid #0ea5e9;
  border-radius: 2px;
  color: #e2e8f0;
  outline: none;
}

.ventana-escala-y-input::-webkit-inner-spin-button,
.ventana-escala-y-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.ventana-escala-y-input[type="number"] {
  -moz-appearance: textfield;
}

.ventana-escala-y-slider {
  flex: 1;
  writing-mode: vertical-lr;
  direction: rtl;
  -webkit-appearance: none;
  appearance: none;
  width: 6px;
  background: transparent;
  cursor: pointer;
  min-height: 100px;
}

/* Track del slider vertical */
.ventana-escala-y-slider::-webkit-slider-runnable-track {
  width: 6px;
  height: 100%;
  background: linear-gradient(to top, #22c55e 0%, #eab308 50%, #ef4444 100%);
  border-radius: 3px;
}

.ventana-escala-y-slider::-moz-range-track {
  width: 6px;
  height: 100%;
  background: linear-gradient(to top, #22c55e 0%, #eab308 50%, #ef4444 100%);
  border-radius: 3px;
}

/* Thumb del slider vertical */
.ventana-escala-y-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 14px;
  height: 14px;
  background: #e2e8f0;
  border: 2px solid #0ea5e9;
  border-radius: 50%;
  cursor: grab;
  margin-left: -4px;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
}

.ventana-escala-y-slider::-moz-range-thumb {
  width: 14px;
  height: 14px;
  background: #e2e8f0;
  border: 2px solid #0ea5e9;
  border-radius: 50%;
  cursor: grab;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
}

.ventana-escala-y-slider::-webkit-slider-thumb:hover {
  background: #ffffff;
  border-color: #38bdf8;
  transform: scale(1.1);
}

.ventana-escala-y-slider::-moz-range-thumb:hover {
  background: #ffffff;
  border-color: #38bdf8;
  transform: scale(1.1);
}

.ventana-escala-y-slider::-webkit-slider-thumb:active {
  cursor: grabbing;
}

.ventana-escala-y-slider::-moz-range-thumb:active {
  cursor: grabbing;
}

/* Bot√≥n reset escala */
.ventana-escala-y-reset {
  padding: 0.2rem 0.35rem;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 3px;
  color: #94a3b8;
  font-size: 0.6rem;
  cursor: pointer;
  transition: all 0.15s ease;
  white-space: nowrap;
}

.ventana-escala-y-reset:hover:not(:disabled) {
  background: #475569;
  color: #e2e8f0;
  border-color: #64748b;
}

.ventana-escala-y-reset:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Botones de flechas para escala Y - ocultos por defecto (solo visibles en landscape m√≥vil) */
.ventana-escala-y-btn {
  display: none;
}

/* Panel lateral de datos */
.ventana-panel-datos {
  width: 260px;
  flex-shrink: 0;
  background: #0f172a;
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  animation: panelSlideIn 0.25s ease;
}

@keyframes panelSlideIn {
  from {
    opacity: 0;
    transform: translateX(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.ventana-panel-header {
  padding: 0.5rem 0.75rem;
  background: #1e293b;
  border-bottom: 1px solid #334155;
  font-size: 0.85rem;
  font-weight: 600;
  color: #e2e8f0;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
}

.ventana-panel-intervalo {
  padding: 0.2rem 0.4rem;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #e2e8f0;
  font-size: 0.7rem;
  cursor: pointer;
  outline: none;
}

.ventana-panel-intervalo:hover {
  border-color: #64748b;
}

.ventana-panel-intervalo:focus {
  border-color: #0ea5e9;
}

.ventana-panel-tabla-container {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
}

.ventana-panel-tabla {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}

.ventana-panel-tabla thead {
  position: sticky;
  top: 0;
  background: #1e293b;
  z-index: 1;
}

.ventana-panel-tabla th {
  padding: 0.4rem 0.35rem;
  text-align: left;
  color: #64748b;
  font-weight: 600;
  border-bottom: 1px solid #334155;
  white-space: nowrap;
}

.ventana-panel-tabla td {
  padding: 0.35rem;
  color: #e2e8f0;
  border-bottom: 1px solid #1e293b;
  white-space: nowrap;
}

.ventana-panel-tabla tbody tr:hover {
  background: #1e293b;
}

.ventana-panel-tabla td:last-child {
  text-align: right;
  font-family: "Consolas", "Monaco", monospace;
  color: #22c55e;
}

/* Gr√°fico */
.ventana-grafico {
  flex: 1;
  background: #0f172a;
  border-radius: 6px;
  min-height: 200px;
  overflow: hidden;
}


/* Estados */
.ventana-estado {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 0.75rem;
  color: #94a3b8;
}

.ventana-estado--error {
  color: #ef4444;
}

.ventana-estado button {
  padding: 0.4rem 0.8rem;
  background: #334155;
  border: none;
  color: #e2e8f0;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
}

.ventana-estado button:hover {
  background: #475569;
}

.ventana-spinner {
  width: 32px;
  height: 32px;
  border: 3px solid #334155;
  border-top-color: #0ea5e9;
  border-radius: 50%;
  animation: ventana-spin 1s linear infinite;
}

@keyframes ventana-spin {
  to { transform: rotate(360deg); }
}

/* Estad√≠sticas */
.ventana-stats {
  display: flex;
  align-items: center;
  gap: 1.75rem;
  padding: 0.5rem 0.75rem;
  background: #0f172a;
  border-radius: 6px;
  margin-top: 0.75rem;
  flex-shrink: 0;
}

.ventana-stat {
  font-size: 0.8rem;
  color: #94a3b8;
}

.ventana-stat b {
  color: #94a3b8;
  font-weight: 500;
  margin-right: 0.25rem;
}

.ventana-stat strong {
  color: #e2e8f0;
  font-weight: 700;
}

.ventana-stat-input {
  width: auto;
  min-width: 2ch;
  padding: 0.15rem 0.4rem 0.25rem 0.4rem;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 4px;
  color: #22c55e;
  font-family: "Consolas", "Monaco", monospace;
  font-size: 1.05rem;
  font-weight: 700;
  text-align: center;
  margin-left: 0.1rem;
}

.ventana-stat-input:focus {
  outline: none;
}

.ventana-stat-fecha {
  color: #e2e8f0;
  font-size: 0.75rem;
  margin-left: 0.5rem;
  font-weight: 400;
}

.ventana-btn-exportar {
  margin-left: auto;
  padding: 0.3rem 0.6rem;
  background: #0ea5e9;
  border: none;
  border-radius: 4px;
  color: #ffffff;
  font-size: 0.7rem;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.15s ease;
}

.ventana-btn-exportar:hover:not(:disabled) {
  background: #0284c7;
}

.ventana-btn-exportar:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.ventana-btn-informe {
  margin-left: 0.5rem;
  background: #059669;
}

.ventana-btn-informe:hover:not(:disabled) {
  background: #047857;
}

/* Barra de tareas para ventanas minimizadas */
.ventanas-barra-tareas {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  background: rgba(15, 23, 42, 0.95);
  border-top: 1px solid #334155;
  z-index: 900;
}

.ventana-tarea {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.4rem 0.75rem;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 6px;
  color: #e2e8f0;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s ease;
  max-width: 200px;
}

.ventana-tarea:hover {
  background: #475569;
  border-color: #64748b;
}

.ventana-tarea-icono {
  font-size: 0.9rem;
}

.ventana-tarea-nombre {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.ventana-tarea-cerrar {
  width: 18px;
  height: 18px;
  padding: 0;
  background: transparent;
  border: none;
  color: #94a3b8;
  font-size: 1rem;
  line-height: 1;
  cursor: pointer;
  border-radius: 3px;
  transition: all 0.15s ease;
}

.ventana-tarea-cerrar:hover {
  background: #ef4444;
  color: #ffffff;
}

/* ===== MODO LANDSCAPE M√ìVIL - Solo gr√°fico a pantalla completa ===== */
@media (max-width: 900px) and (orientation: landscape) {
  /* Modal usa position absolute para respetar los insets del contenedor padre */
  .ventana-historial {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: auto !important;
    height: auto !important;
    min-width: 0 !important;
    max-width: none !important;
    min-height: 0 !important;
    max-height: none !important;
    border-radius: 0 !important;
    resize: none !important;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    /* Fondo oscuro */
    background-color: #0f172a;
  }

  /* Ocultar header, controles, panel de datos y stats */
  .ventana-historial-header,
  .ventana-controles,
  .ventana-panel-datos,
  .ventana-stats {
    display: none !important;
  }

  /* Contenido ocupa todo el espacio disponible */
  .ventana-historial-content {
    flex: 1;
    width: 100%;
    min-height: 0; /* Importante para que flex no desborde */
    /* Padding m√≠nimo para que el gr√°fico respire */
    padding: 4px 8px 8px 4px;
    display: flex;
    flex-direction: row;
    gap: 4px;
    overflow: hidden;
    box-sizing: border-box;
  }

  /* Contenedor gr√°fico en fila - ambos hijos con mismo alto */
  .ventana-grafico-container {
    flex: 1;
    display: flex;
    flex-direction: row;
    align-items: stretch; /* Ambos hijos mismo alto */
    gap: 4px;
    width: 100%;
    min-height: 0; /* Importante para flex */
    overflow: hidden;
    box-sizing: border-box;
  }

  /* Escala Y - contenedor con botones arriba y abajo */
  .ventana-escala-y {
    display: flex !important;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    padding: 4px 2px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 4px;
    /* Ancho fijo estrecho */
    width: 38px;
    min-width: 38px;
    max-width: 38px;
    flex-shrink: 0;
    box-sizing: border-box;
    gap: 2px;
  }

  /* Ocultar label, reset e input en landscape */
  .ventana-escala-y-label,
  .ventana-escala-y-reset,
  .ventana-escala-y-input {
    display: none !important;
  }

  /* Botones de flecha visibles en landscape m√≥vil */
  .ventana-escala-y-btn {
    display: flex !important;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    background: #334155;
    border: 1px solid #475569;
    border-radius: 4px;
    color: #e2e8f0;
    font-size: 0.85rem;
    cursor: pointer;
    flex-shrink: 0;
    z-index: 10;
    transition: all 0.15s ease;
  }

  .ventana-escala-y-btn:active {
    background: #0ea5e9;
    border-color: #0ea5e9;
    transform: scale(0.95);
  }

  .ventana-escala-y-btn--arriba {
    order: -1;
  }

  .ventana-escala-y-btn--abajo {
    order: 10;
  }

  /* Slider vertical nativo usando writing-mode */
  .ventana-escala-y-slider {
    /* writing-mode hace el slider vertical de forma nativa */
    writing-mode: vertical-lr;
    direction: rtl; /* Invierte: arriba = max, abajo = min */
    -webkit-appearance: slider-vertical;
    appearance: slider-vertical;
    /* El ancho del slider debe ser igual al thumb para que quede centrado */
    width: 16px;
    background: transparent;
    cursor: pointer;
    margin: 0;
    padding: 0;
    flex: 1;
    min-height: 0;
  }

  /* Track del slider - gradiente vertical (rojo arriba, verde abajo) */
  .ventana-escala-y-slider::-webkit-slider-runnable-track {
    /* Track m√°s angosto que el slider - se centra autom√°ticamente */
    width: clamp(5px, 1.2dvw, 8px);
    height: 100%;
    background: linear-gradient(to bottom, #ef4444 0%, #eab308 50%, #22c55e 100%);
    border-radius: clamp(2px, 0.6dvw, 4px);
  }

  .ventana-escala-y-slider::-moz-range-track {
    width: clamp(5px, 1.2dvw, 8px);
    height: 100%;
    background: linear-gradient(to bottom, #ef4444 0%, #eab308 50%, #22c55e 100%);
    border-radius: clamp(2px, 0.6dvw, 4px);
  }

  /* Thumb del slider */
  .ventana-escala-y-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: clamp(14px, 3.5dvw, 18px);
    height: clamp(14px, 3.5dvw, 18px);
    background: #e2e8f0;
    border: 2px solid #64748b;
    border-radius: 50%;
    cursor: grab;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }

  .ventana-escala-y-slider::-moz-range-thumb {
    width: clamp(14px, 3.5dvw, 18px);
    height: clamp(14px, 3.5dvw, 18px);
    background: #e2e8f0;
    border: 2px solid #64748b;
    border-radius: 50%;
    cursor: grab;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }

  /* Gr√°fico - ocupa el espacio restante */
  .ventana-grafico {
    flex: 1;
    margin: 0;
    min-height: 0; /* Cr√≠tico para que flex no desborde */
    min-width: 0;
    overflow: hidden;
    box-sizing: border-box;
  }

  /* Ajustar ApexCharts para que respete el contenedor */
  .ventana-grafico > div {
    width: 100% !important;
    height: 100% !important;
  }

  .ventana-grafico .apexcharts-canvas {
    max-width: 100% !important;
    max-height: 100% !important;
  }

  /* Ocultar barra de tareas */
  .ventanas-barra-tareas {
    display: none !important;
  }
}

/* ===== RESPONSIVE M√ìVIL (Portrait) ===== */
@media (max-width: 600px) and (orientation: portrait) {
  /* Modal a pantalla completa con safe-areas */
  .ventana-historial {
    min-width: 100% !important;
    width: 100% !important;
    height: 100dvh !important;
    max-height: 100dvh !important;
    border-radius: 0 !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    resize: none !important;
    /* Safe areas para portrait - top y bottom */
    padding-top: var(--safe-area-inset-top, 0px);
    padding-bottom: var(--safe-area-inset-bottom, 0px);
    padding-left: var(--safe-area-inset-left, 0px);
    padding-right: var(--safe-area-inset-right, 0px);
    box-sizing: border-box;
    /* Fondo oscuro para las √°reas de safe-area */
    background-color: #0f172a;
  }

  /* Ocultar botones de minimizar/maximizar y exportar en m√≥vil */
  .ventana-btn--desktop-only {
    display: none !important;
  }

  /* Ocultar bot√≥n toggle de datos - tabla siempre visible en m√≥vil */
  .ventana-toggle-datos {
    display: none !important;
  }

  /* Header m√°s compacto */
  .ventana-historial-header {
    padding: 0.5rem 0.75rem;
    cursor: default;
  }

  .ventana-historial-nombre {
    font-size: 0.9rem;
    max-width: none;
  }

  /* Bot√≥n cerrar m√°s grande para t√°ctil */
  .ventana-btn--cerrar {
    width: 32px;
    height: 32px;
    font-size: 1.25rem;
  }

  /* Contenido con padding m√≠nimo */
  .ventana-historial-content {
    padding: 0.35rem;
  }

  /* Barra de controles - dise√±o fluido con wrap */
  .ventana-controles {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    align-items: center;
    gap: clamp(0.6rem, 2.5vw, 0.9rem);
    padding: clamp(0.6rem, 2.5vw, 0.9rem);
    margin-bottom: 0.5rem;
  }

  /* Tabs de zona - primera fila (ancho completo) */
  .ventana-tabs {
    width: 100%;
    order: 1;
    gap: clamp(0.2rem, 1vw, 0.4rem);
  }

  .ventana-tab {
    flex: 1;
    padding: clamp(0.3rem, 1.2vw, 0.5rem) clamp(0.3rem, 1vw, 0.5rem);
    font-size: clamp(0.8rem, 3.2vw, 0.95rem);
    text-align: center;
    max-width: none;
  }

  /* Fila de rango + calendario - dise√±o fluido */
  .ventana-rango {
    order: 2;
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-items: center;
    gap: clamp(0.4rem, 1.5vw, 0.6rem);
    flex: 1 1 auto;
  }

  /* Botones de rango - tama√±o fluido que se adapta al espacio */
  .ventana-rango-btn {
    /* min 28px, ideal ~9% del ancho, max 40px */
    width: clamp(28px, 9vw, 40px);
    min-width: clamp(28px, 9vw, 40px);
    height: clamp(30px, 8vw, 38px);
    padding: 0;
    font-size: clamp(0.65rem, 2.2vw, 0.8rem);
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Grupo de gr√°ficos */
  .ventana-grupo-graficos {
    order: 2;
    display: contents;
  }

  /* Selector de fecha - pegado a la derecha */
  .ventana-selector-dia {
    order: 2;
    padding-right: 0;
    margin-left: auto;
  }

  /* Bot√≥n del calendario - mismo tama√±o fluido que botones de rango */
  .ventana-selector-dia .selector-fecha-btn {
    width: clamp(30px, 9vw, 40px);
    height: clamp(30px, 8vw, 38px);
    font-size: clamp(0.9rem, 3vw, 1.1rem);
  }

  .ventana-selector-dia .selector-fecha-icono {
    font-size: clamp(0.85rem, 2.8vw, 1rem);
  }

  /* Ocultar texto de fecha seleccionada en m√≥vil */
  .ventana-dia-seleccionado {
    display: none;
  }

  /* Tipo de gr√°fico - fila completa, botones distribuidos */
  .ventana-tipo-grafico {
    order: 3;
    width: 100%;
    flex: 1 1 100%;
    display: flex;
    justify-content: stretch;
    gap: clamp(0.3rem, 1.5vw, 0.5rem);
    padding: 0;
    border-left: none;
  }

  .ventana-tipo-btn {
    flex: 1;
    width: auto;
    height: clamp(32px, 9vw, 40px);
    font-size: clamp(0.9rem, 3vw, 1.2rem);
  }

  /* Selector de alimentador - cuarta fila (ancho completo) */
  .ventana-selector-alimentador-container {
    order: 4;
    width: 100%;
    flex: 1 1 100%;
    padding: 0;
    margin-right: 0;
  }

  .ventana-selector-alimentador {
    width: 100%;
    max-width: none;
    padding: clamp(0.3rem, 1.2vw, 0.45rem) 2rem clamp(0.3rem, 1.2vw, 0.45rem) 0.75rem;
    font-size: clamp(0.7rem, 2.3vw, 0.85rem);
    height: clamp(32px, 9vw, 40px);
  }

  /* Cache - quinta fila */
  .ventana-cache {
    order: 5;
    margin-left: 0;
    width: 100%;
    flex: 1 1 100%;
    justify-content: flex-start;
    gap: clamp(0.5rem, 2vw, 0.75rem);
  }

  /* Bot√≥n toggle gr√°fico - visible en m√≥vil portrait */
  .ventana-toggle-grafico {
    display: flex;
    align-items: center;
    justify-content: center;
    width: clamp(28px, 8vw, 36px);
    height: clamp(28px, 8vw, 36px);
    padding: 0;
    background: #334155;
    border: 1px solid #475569;
    border-radius: 6px;
    color: #94a3b8;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
  }

  .ventana-toggle-grafico:hover {
    background: #475569;
    border-color: #64748b;
    color: #e2e8f0;
  }

  .ventana-toggle-grafico:active {
    transform: scale(0.95);
  }

  .ventana-toggle-grafico-icono {
    font-size: clamp(0.7rem, 2.5vw, 0.9rem);
    line-height: 1;
    transition: transform 0.3s ease;
    display: inline-block;
    transform: rotate(180deg); /* Tri√°ngulo apunta hacia arriba por defecto */
  }

  /* Cuando el gr√°fico est√° cerrado, rotar el tri√°ngulo hacia abajo */
  .ventana-toggle-grafico--cerrado .ventana-toggle-grafico-icono {
    transform: rotate(0deg);
  }

  /* Barra de progreso - ocupa espacio disponible */
  .ventana-cache-barra {
    flex: 1;
    width: auto;
    min-width: 60px;
    max-width: none;
    height: clamp(5px, 1.5vw, 7px);
    margin-left: 0.5rem;
  }

  .ventana-cache-texto {
    font-size: clamp(0.6rem, 2vw, 0.75rem);
  }

  .ventana-fuente {
    font-size: clamp(0.7rem, 2.5vw, 0.85rem);
    padding: clamp(0.2rem, 0.8vw, 0.3rem) clamp(0.4rem, 1.2vw, 0.5rem);
    min-width: clamp(28px, 8vw, 36px);
    min-height: clamp(28px, 8vw, 36px);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .ventana-btn-limpiar {
    width: clamp(28px, 8vw, 36px);
    height: clamp(28px, 8vw, 36px);
    font-size: clamp(0.9rem, 3vw, 1.1rem);
  }

  /* Contenedor gr√°fico + panel */
  .ventana-grafico-container {
    flex-direction: column;
    gap: 0.35rem;
  }

  /* Panel de datos en m√≥vil - siempre visible */
  .ventana-panel-datos {
    width: 100%;
    max-height: 200px;
    order: 1;
    display: flex !important; /* Forzar visible */
    border-left: 1px solid #334155;
    border-right: 1px solid #334155;
    border-bottom: 1px solid #334155;
  }

  .ventana-panel-tabla {
    font-size: 0.75rem;
  }

  .ventana-panel-tabla th,
  .ventana-panel-tabla td {
    padding: 0.3rem 0.25rem;
  }

  /* Ocultar escala Y en m√≥vil - ocupa mucho espacio */
  .ventana-escala-y {
    display: none;
  }

  /* Gr√°fico ocupa el resto */
  .ventana-grafico {
    flex: 1;
    min-height: 180px;
    order: 0;
    transition: all 0.3s ease;
  }

  /* Reducir espacio izquierdo del gr√°fico - ajuste sutil */
  .ventana-grafico .apexcharts-canvas {
    margin-left: -10px;
  }

  /* Cuando el gr√°fico est√° oculto (toggle cerrado) */
  .ventana-grafico-container--oculto .ventana-grafico,
  .ventana-grafico-container--oculto .ventana-escala-y {
    display: none;
  }

  /* Panel de datos ocupa todo el espacio cuando el gr√°fico est√° oculto */
  .ventana-grafico-container--oculto .ventana-panel-datos {
    max-height: none;
    flex: 1;
  }

  /* Estad√≠sticas: 2 columnas principales separadas */
  .ventana-stats {
    display: grid;
    /* Col1: etiqueta + valor, separador, Col2: etiqueta + valor */
    grid-template-columns: auto auto 2.5rem auto auto;
    row-gap: 0.35rem;
    column-gap: 0.2rem;
    padding: 0.6rem 1rem;
    margin-top: 0.5rem;
    justify-content: center;
    align-items: center;
  }

  .ventana-stat {
    display: contents; /* Los hijos van directo al grid */
    font-size: 0.8rem;
  }

  .ventana-stat b {
    text-align: right;
    white-space: nowrap;
    color: #94a3b8;
  }

  .ventana-stat-input {
    font-size: 0.9rem;
    padding: 0.15rem 0.3rem;
    width: auto;
    min-width: 55px;
    text-align: left;
  }

  /* Fila 1: Puntos (col 1-2), M√≠n (col 4-5) */
  .ventana-stat:nth-child(1) b { grid-column: 1; grid-row: 1; }
  .ventana-stat:nth-child(1) .ventana-stat-input { grid-column: 2; grid-row: 1; }
  .ventana-stat:nth-child(2) b { grid-column: 4; grid-row: 1; }
  .ventana-stat:nth-child(2) .ventana-stat-input { grid-column: 5; grid-row: 1; }

  /* Fila 2: M√°x (col 1-2), Prom (col 4-5) */
  .ventana-stat:nth-child(3) b { grid-column: 1; grid-row: 2; }
  .ventana-stat:nth-child(3) .ventana-stat-input { grid-column: 2; grid-row: 2; }
  .ventana-stat:nth-child(4) b { grid-column: 4; grid-row: 2; }
  .ventana-stat:nth-child(4) .ventana-stat-input { grid-column: 5; grid-row: 2; }

  .ventana-stat-fecha {
    display: none;
  }

  /* Ocultar barra de tareas en m√≥vil */
  .ventanas-barra-tareas {
    display: none;
  }

  /* Selector de intervalo m√°s alto */
  .ventana-panel-intervalo {
    padding: 0.4rem 0.5rem;
    font-size: 0.8rem;
  }
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/VentanaHistorial.jsx =====

/**
 * Ventana flotante para visualizar el historial de lecturas con gr√°ficos
 * Soporta: arrastrar, minimizar, maximizar, m√∫ltiples instancias
 */

import { useState, useEffect, useMemo, useCallback, useRef } from "react";
import ApexChartWrapper from "../../../../componentes/comunes/ApexChartWrapper";
import { useHistorialLocal } from "../../hooks/useHistorialLocal";
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase";
import { aplicarFormula } from "../../utilidades/calculosFormulas";
import { exportarCSV } from "../../utilidades/exportarCSV";
import { generarInformePDF } from "../../utilidades/exportarInformePDF";
import { TITULOS_MEDICIONES } from "../../constantes/titulosMediciones";
import {
  RANGOS_TIEMPO,
  TIPOS_GRAFICO,
  COLORES_GRADIENTE,
} from "../../constantes/historialConfig";
import ModalConfigInforme from "./ModalConfigInforme";
import PanelDatosHistorial from "../historial/PanelDatosHistorial";
import BarraTituloVentana from "../historial/BarraTituloVentana";
import BarraControlesHistorial from "../historial/BarraControlesHistorial";
import "./VentanaHistorial.css";

/**
 * Interpola color de verde a rojo basado en porcentaje (0-1)
 * 0 = verde, 0.5 = amarillo, 1 = rojo
 */
const interpolarColorVerdeRojo = (porcentaje) => {
  const p = Math.max(0, Math.min(1, porcentaje));
  const { verde, amarillo, rojo } = COLORES_GRADIENTE;

  let r, g, b;

  if (p <= 0.5) {
    // Verde a Amarillo (0 a 0.5)
    const t = p * 2;
    r = Math.round(verde.r + (amarillo.r - verde.r) * t);
    g = Math.round(verde.g + (amarillo.g - verde.g) * t);
    b = Math.round(verde.b + (amarillo.b - verde.b) * t);
  } else {
    // Amarillo a Rojo (0.5 a 1)
    const t = (p - 0.5) * 2;
    r = Math.round(amarillo.r + (rojo.r - amarillo.r) * t);
    g = Math.round(amarillo.g + (rojo.g - amarillo.g) * t);
    b = Math.round(amarillo.b + (rojo.b - amarillo.b) * t);
  }

  return `rgb(${r}, ${g}, ${b})`;
};

const obtenerTituloZona = (cardDesign, zona) => {
  const config = cardDesign?.[zona];
  if (!config) return zona === "superior" ? "Superior" : "Inferior";
  if (config.tituloCustom?.trim()) return config.tituloCustom;
  if (config.tituloId && TITULOS_MEDICIONES[config.tituloId]) {
    return TITULOS_MEDICIONES[config.tituloId];
  }
  return zona === "superior" ? "Superior" : "Inferior";
};

const calcularPromedioZona = (lectura, zonaConfig) => {
  if (!lectura?.valores || !Array.isArray(lectura.valores)) return null;
  if (!zonaConfig?.boxes) return null;

  const indiceInicial = lectura.indiceInicial ?? lectura.indice_inicial ?? 0;
  const valoresCalculados = [];

  zonaConfig.boxes.forEach((box) => {
    if (!box.enabled) return;
    const registro = box.registro ?? box.indice;
    if (registro === null || registro === undefined) return;
    const indiceEnArray = registro - indiceInicial;
    if (indiceEnArray < 0 || indiceEnArray >= lectura.valores.length) return;
    const valorCrudo = lectura.valores[indiceEnArray];
    if (valorCrudo === null || valorCrudo === undefined) return;
    const valorCalculado = aplicarFormula(box.formula || "x", valorCrudo);
    if (valorCalculado !== null && !Number.isNaN(valorCalculado) && valorCalculado !== 0) {
      valoresCalculados.push(valorCalculado);
    }
  });

  if (valoresCalculados.length === 0) return null;
  const suma = valoresCalculados.reduce((a, b) => a + b, 0);
  return suma / valoresCalculados.length;
};

const VentanaHistorial = ({
  ventana,
  onCerrar,
  onMinimizar,
  onMaximizar,
  onEnfocar,
  onMover,
}) => {
  const { alimentador: alimentadorInicial, cardDesign: cardDesignInicial, minimizada, maximizada, posicion, zIndex } = ventana;

  // Obtener alimentadores del puesto desde el contexto
  const { puestoSeleccionado } = usarContextoAlimentadores();
  const alimentadoresPuesto = puestoSeleccionado?.alimentadores || [];

  // Estado local para permitir cambiar de alimentador sin cerrar el modal
  const [alimentadorActual, setAlimentadorActual] = useState(alimentadorInicial);
  const [cardDesignActual, setCardDesignActual] = useState(cardDesignInicial);

  // Alias para mantener compatibilidad con el resto del c√≥digo
  const alimentador = alimentadorActual;
  const cardDesign = cardDesignActual;

  const ventanaRef = useRef(null);
  const headerRef = useRef(null);
  const chartRef = useRef(null);
  const [arrastrando, setArrastrando] = useState(false);
  const [offsetArrastre, setOffsetArrastre] = useState({ x: 0, y: 0 });

  // Hook de historial
  const {
    obtenerDatosGrafico,
    cargando,
    error,
    precargarPuesto,
    resetearPrecarga,
    precargaProgreso,
    precargaCompleta,
    precargando,
    datosDeBD,
    limpiarCacheCompleto,
    estadisticas,
    dbLista,
  } = useHistorialLocal();

  // Estados del selector
  const [rangoSeleccionado, setRangoSeleccionado] = useState("24h");
  const [fechaRangoDesde, setFechaRangoDesde] = useState(null);
  const [fechaRangoHasta, setFechaRangoHasta] = useState(null);
  const [zonaSeleccionada, setZonaSeleccionada] = useState("superior");
  const [datosGrafico, setDatosGrafico] = useState([]);
  const [fuenteDatos, setFuenteDatos] = useState(null);
  const [panelDatosAbierto, setPanelDatosAbierto] = useState(true);
  const [intervaloFiltro, setIntervaloFiltro] = useState(60); // 0 = todos, 15, 30, 60 minutos
  const [tipoGrafico, setTipoGrafico] = useState("line"); // line, area, bar
  const [modalInformeVisible, setModalInformeVisible] = useState(false);
  const [escalaYMax, setEscalaYMax] = useState(null); // null = auto, valor = m√°ximo personalizado
  const [graficoVisible, setGraficoVisible] = useState(true); // Toggle para mostrar/ocultar gr√°fico en m√≥vil
  const [editandoEscalaY, setEditandoEscalaY] = useState(false); // Para edici√≥n manual del valor

  // T√≠tulos de zonas
  const tituloSuperior = useMemo(() => obtenerTituloZona(cardDesign, "superior"), [cardDesign]);
  const tituloInferior = useMemo(() => obtenerTituloZona(cardDesign, "inferior"), [cardDesign]);
  const tituloZonaActual = zonaSeleccionada === "superior" ? tituloSuperior : tituloInferior;

  const zonaDisponible = useCallback((zona) => {
    const config = cardDesign?.[zona];
    return config?.boxes?.some((b) => b.enabled);
  }, [cardDesign]);

  const obtenerRegistradorZona = useCallback((zona) => {
    const regIdZona = cardDesign?.[zona]?.registrador_id;
    if (regIdZona) return regIdZona;
    return alimentador?.registrador_id || null;
  }, [cardDesign, alimentador]);

  // Cargar datos
  const cargarDatos = useCallback(async () => {
    if (!alimentador?.id) return;
    const registradorId = obtenerRegistradorZona(zonaSeleccionada);
    if (!registradorId) {
      setDatosGrafico([]);
      setFuenteDatos(null);
      return;
    }

    const ahora = Date.now();
    const rango = RANGOS_TIEMPO.find((r) => r.id === rangoSeleccionado);
    let desde, hasta;

    // Si hay un rango de fechas seleccionado desde el calendario
    if (fechaRangoDesde && fechaRangoHasta) {
      const fDesde = new Date(fechaRangoDesde);
      const fHasta = new Date(fechaRangoHasta);
      desde = new Date(fDesde.getFullYear(), fDesde.getMonth(), fDesde.getDate(), 0, 0, 0, 0).getTime();
      hasta = new Date(fHasta.getFullYear(), fHasta.getMonth(), fHasta.getDate(), 23, 59, 59, 999).getTime();
    } else if (rango?.ms) {
      desde = ahora - rango.ms;
      hasta = ahora;
    } else {
      return;
    }

    // Solo forzar local si:
    // 1. La precarga est√° completa Y
    // 2. Estamos usando un rango predefinido (no fechas personalizadas del calendario)
    // Los rangos personalizados pueden estar fuera de las 48h precargadas
    const usandoRangoPredefinido = !fechaRangoDesde && !fechaRangoHasta;
    const forzarSoloLocal = precargaCompleta && usandoRangoPredefinido;
    const { datos, fuente } = await obtenerDatosGrafico(
      alimentador.id,
      registradorId,
      zonaSeleccionada,
      desde,
      hasta,
      forzarSoloLocal
    );

    const zonaConfig = cardDesign?.[zonaSeleccionada];
    const datosTransformados = datos
      .map((lectura) => {
        const promedio = calcularPromedioZona(lectura, zonaConfig);
        if (promedio === null) return null;
        return { x: new Date(lectura.timestamp), y: promedio };
      })
      .filter((d) => d !== null);

    setDatosGrafico(datosTransformados);
    setFuenteDatos(fuente);
  }, [alimentador, cardDesign, rangoSeleccionado, fechaRangoDesde, fechaRangoHasta, zonaSeleccionada, obtenerDatosGrafico, obtenerRegistradorZona, precargaCompleta]);

  // Iniciar precarga de todo el puesto al montar (esperar a que IndexedDB est√© lista)
  // Esto beneficia a todas las cards del puesto, no solo a la actual
  useEffect(() => {
    if (!alimentador?.id || !dbLista || alimentadoresPuesto.length === 0) return;
    precargarPuesto(alimentadoresPuesto);
    return () => resetearPrecarga();
  }, [alimentador?.id, dbLista, alimentadoresPuesto, precargarPuesto, resetearPrecarga]);

  // Cargar datos cuando cambia selecci√≥n
  // IMPORTANTE: Esperar a que la precarga termine (precargaCompleta=true) antes de cargar
  // para evitar consultas innecesarias a la BD cuando ya hay datos en cache
  useEffect(() => {
    // Solo cargar cuando:
    // 1. No est√° minimizada
    // 2. La precarga termin√≥ (precargaCompleta es true, lo que significa que verific√≥ cache o carg√≥ datos)
    if (!minimizada && precargaCompleta) {
      cargarDatos();
    }
  }, [cargarDatos, minimizada, precargaCompleta]);

  // --- Drag & Drop ---
  const handleMouseDown = (e) => {
    if (maximizada) return;
    if (e.target.closest("button")) return;
    onEnfocar();
    setArrastrando(true);
    const rect = ventanaRef.current.getBoundingClientRect();
    setOffsetArrastre({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    });
  };

  useEffect(() => {
    if (!arrastrando) return;

    const handleMouseMove = (e) => {
      const newX = Math.max(0, e.clientX - offsetArrastre.x);
      const newY = Math.max(0, e.clientY - offsetArrastre.y);
      onMover({ x: newX, y: newY });
    };

    const handleMouseUp = () => {
      setArrastrando(false);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [arrastrando, offsetArrastre, onMover]);

  // Datos filtrados por intervalo (se usa tanto para el gr√°fico como para la tabla)
  // Esto evita renderizar miles de puntos y mejora el rendimiento
  // Siempre incluye la √∫ltima lectura del rango para mejor visualizaci√≥n
  const datosFiltrados = useMemo(() => {
    if (intervaloFiltro === 0 || datosGrafico.length === 0) {
      return datosGrafico;
    }

    if (datosGrafico.length === 1) {
      return datosGrafico;
    }

    const intervaloMs = intervaloFiltro * 60 * 1000;
    const resultado = [];
    let ultimoTimestamp = 0;

    // Filtrar por intervalo
    for (const punto of datosGrafico) {
      const timestamp = new Date(punto.x).getTime();
      if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs) {
        resultado.push(punto);
        ultimoTimestamp = timestamp;
      }
    }

    // Siempre incluir la √∫ltima lectura si no est√° ya incluida
    const ultimaLectura = datosGrafico[datosGrafico.length - 1];
    const ultimaEnResultado = resultado[resultado.length - 1];
    if (ultimaLectura !== ultimaEnResultado) {
      resultado.push(ultimaLectura);
    }

    return resultado;
  }, [datosGrafico, intervaloFiltro]);

  // Calcular l√≠mites para el slider de escala Y
  // min = valor m√°ximo de los datos (para que no se corte la l√≠nea)
  // max = doble del valor m√°ximo de los datos
  const limitesEscalaY = useMemo(() => {
    if (datosFiltrados.length === 0) return { min: 10, max: 100, valorMaxDatos: 0 };
    const valores = datosFiltrados.map((d) => d.y);
    const valorMaxDatos = Math.max(...valores);
    // Redondear hacia arriba para valores m√°s limpios
    const minRedondeado = Math.ceil(valorMaxDatos);
    const maxRedondeado = Math.ceil(valorMaxDatos * 2);
    return {
      min: Math.max(minRedondeado, 1), // M√≠nimo de 1 para evitar 0
      max: Math.max(maxRedondeado, minRedondeado + 10), // Asegurar que max > min
      valorMaxDatos,
    };
  }, [datosFiltrados]);

  // Manejador para edici√≥n manual del valor de escala Y
  const handleEscalaYManual = (valorInput) => {
    const valor = parseFloat(valorInput);
    if (isNaN(valor)) {
      setEditandoEscalaY(false);
      return;
    }
    // Validar l√≠mites: si excede max, usar max; si es menor a min, usar min
    const valorValidado = Math.min(Math.max(valor, limitesEscalaY.min), limitesEscalaY.max);
    setEscalaYMax(valorValidado);
    setEditandoEscalaY(false);
  };

  // Colores para gr√°fico de barras (verde a rojo con normalizaci√≥n min-max)
  // Usa el rango completo de colores: el valor m√≠nimo es verde, el m√°ximo es rojo
  const coloresBarras = useMemo(() => {
    if (datosFiltrados.length === 0) return [];
    const valores = datosFiltrados.map((d) => d.y);
    const minVal = Math.min(...valores);
    const maxVal = Math.max(...valores);
    const rango = maxVal - minVal;
    // Normalizaci√≥n min-max para maximizar el contraste visual
    return valores.map((val) => {
      const porcentaje = rango > 0 ? (val - minVal) / rango : 0;
      return interpolarColorVerdeRojo(porcentaje);
    });
  }, [datosFiltrados]);

  // Configuraci√≥n ApexCharts (din√°mica seg√∫n tipo de gr√°fico y colores)
  const opcionesGrafico = useMemo(() => {
    const opcionesBase = {
      chart: {
        id: `historial-${alimentador?.id}-${tipoGrafico}`,
        type: tipoGrafico,
        height: "100%",
        zoom: { enabled: true, type: "x", autoScaleYaxis: true },
        toolbar: {
          show: true,
          tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true },
          autoSelected: "zoom",
        },
        background: "#0f172a",
        foreColor: "#e2e8f0",
        animations: { enabled: true, speed: 500 },
      },
      colors: ["#0ea5e9"],
      xaxis: {
        type: "datetime",
        labels: {
          style: { colors: "#94a3b8" },
          datetimeUTC: false,
          datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm" },
        },
        axisBorder: { color: "#334155" },
        axisTicks: { color: "#334155" },
      },
      yaxis: {
        min: 0,
        max: escalaYMax || undefined, // undefined = auto, valor = m√°ximo personalizado
        labels: {
          style: { colors: "#94a3b8" },
          formatter: (val) => (val != null ? val.toFixed(2) : "--"),
        },
      },
      grid: { borderColor: "#334155", strokeDashArray: 3 },
      tooltip: { theme: "dark", x: { format: "dd/MM/yyyy HH:mm:ss" }, y: { formatter: (val) => (val != null ? val.toFixed(4) : "--") } },
      dataLabels: { enabled: false },
      noData: { text: "No hay datos", style: { color: "#94a3b8", fontSize: "14px" } },
    };

    // Opciones espec√≠ficas por tipo de gr√°fico
    if (tipoGrafico === "line") {
      opcionesBase.stroke = {
        curve: "smooth",
        width: 2,
        lineCap: "round",
      };
      // Gradiente en la l√≠nea (verde abajo, rojo arriba)
      opcionesBase.fill = {
        type: "gradient",
        gradient: {
          type: "vertical",
          colorStops: [
            { offset: 0, color: "#ef4444", opacity: 1 },   // Rojo arriba
            { offset: 50, color: "#eab308", opacity: 1 },  // Amarillo medio
            { offset: 100, color: "#22c55e", opacity: 1 }, // Verde abajo
          ],
        },
      };
      opcionesBase.markers = { size: 0, hover: { size: 5 } };
    } else if (tipoGrafico === "area") {
      opcionesBase.stroke = { curve: "smooth", width: 2, colors: ["#ef4444"] };
      opcionesBase.fill = {
        type: "gradient",
        gradient: {
          shade: "light",
          type: "vertical",
          shadeIntensity: 0.1,
          opacityFrom: 0.9,
          opacityTo: 0.9,
          colorStops: [
            { offset: 0, color: "#ef4444", opacity: 0.9 },   // Rojo arriba
            { offset: 50, color: "#eab308", opacity: 0.9 },  // Amarillo medio
            { offset: 100, color: "#22c55e", opacity: 0.9 }, // Verde abajo
          ],
        },
      };
      opcionesBase.markers = { size: 0, hover: { size: 5 } };
    } else if (tipoGrafico === "bar") {
      opcionesBase.plotOptions = {
        bar: {
          columnWidth: "95%",
          borderRadius: 0,
          distributed: true, // Permite colores individuales por barra
        },
      };
      opcionesBase.legend = { show: false }; // Ocultar leyenda cuando distributed
      opcionesBase.fill = { type: "solid" }; // Color s√≥lido por barra
      opcionesBase.stroke = { show: false }; // Sin borde en las barras
      // Asignar colores seg√∫n valor relativo al m√°ximo
      if (coloresBarras.length > 0) {
        opcionesBase.colors = coloresBarras;
      }
    }

    return opcionesBase;
  }, [alimentador?.id, tipoGrafico, coloresBarras, escalaYMax]);

  // Series para el gr√°fico (usa datos filtrados)
  const seriesGrafico = useMemo(() => [{ name: `Promedio ${tituloZonaActual}`, data: datosFiltrados }], [datosFiltrados, tituloZonaActual]);

  // Fuente de datos efectiva: considera si los datos vinieron de la BD aunque est√©n en cache local
  // Si fuenteDatos es "local" pero datosDeBD es true, mostrar "remoto" (BD)
  const fuenteDatosEfectiva = useMemo(() => {
    if (fuenteDatos === "local" && datosDeBD) {
      return "remoto"; // Los datos fueron descargados de la BD
    }
    return fuenteDatos;
  }, [fuenteDatos, datosDeBD]);

  // T√≠tulo del panel: per√≠odo de fechas o fecha √∫nica si es el mismo d√≠a
  const tituloPanelDatos = useMemo(() => {
    if (datosGrafico.length === 0) return "Sin datos";
    const primeraFecha = new Date(datosGrafico[0].x);
    const ultimaFecha = new Date(datosGrafico[datosGrafico.length - 1].x);

    const formatoFecha = { day: "2-digit", month: "2-digit", year: "2-digit" };
    const primeraStr = primeraFecha.toLocaleDateString("es-AR", formatoFecha);
    const ultimaStr = ultimaFecha.toLocaleDateString("es-AR", formatoFecha);

    // Si es el mismo d√≠a, mostrar solo una fecha
    if (primeraStr === ultimaStr) {
      return primeraStr;
    }
    // Si son d√≠as diferentes, mostrar rango
    return `${primeraStr} - ${ultimaStr}`;
  }, [datosGrafico]);

  const estadisticasGrafico = useMemo(() => {
    if (datosGrafico.length === 0) return null;
    const valores = datosGrafico.map((d) => d.y);
    const minVal = Math.min(...valores);
    const maxVal = Math.max(...valores);
    const promedio = valores.reduce((a, b) => a + b, 0) / valores.length;

    // Encontrar los puntos con min y max para obtener sus timestamps
    const puntoMin = datosGrafico.find((d) => d.y === minVal);
    const puntoMax = datosGrafico.find((d) => d.y === maxVal);

    // Formatear fecha/hora compacta con a√±o
    const formatearFecha = (date) => {
      if (!date) return "";
      const d = new Date(date);
      const dia = d.getDate().toString().padStart(2, "0");
      const mes = (d.getMonth() + 1).toString().padStart(2, "0");
      const anio = d.getFullYear().toString().slice(-2);
      const hora = d.getHours().toString().padStart(2, "0");
      const min = d.getMinutes().toString().padStart(2, "0");
      return `${dia}/${mes}/${anio} - ${hora}:${min} hs.`;
    };

    return {
      puntos: datosGrafico.length,
      min: minVal.toFixed(2),
      minFecha: formatearFecha(puntoMin?.x),
      max: maxVal.toFixed(2),
      maxFecha: formatearFecha(puntoMax?.x),
      promedio: promedio.toFixed(2)
    };
  }, [datosGrafico]);

  const handleExportarCSV = () => {
    if (datosGrafico.length === 0) return;
    exportarCSV(datosGrafico, `historial_${alimentador?.nombre}_${zonaSeleccionada}_${Date.now()}`, {
      columnas: ["timestamp", "valor"],
      etiquetas: { timestamp: "Fecha/Hora", valor: `Promedio ${tituloZonaActual}` },
    });
  };

  const handleAbrirModalInforme = () => {
    if (datosGrafico.length === 0) return;
    setModalInformeVisible(true);
  };

  // Handler para cambio de rango predefinido
  const handleRangoChange = useCallback((rangoId) => {
    setRangoSeleccionado(rangoId);
    setFechaRangoDesde(null);
    setFechaRangoHasta(null);
  }, []);

  // Handler para cambio de rango de fechas personalizado
  const handleFechaRangoChange = useCallback((desde, hasta) => {
    setFechaRangoDesde(desde);
    setFechaRangoHasta(hasta);
  }, []);

  // Handler para limpiar cache
  const handleLimpiarCache = useCallback(async () => {
    if (window.confirm("¬øLimpiar cache local?")) {
      await limpiarCacheCompleto();
      precargarPuesto(alimentadoresPuesto);
    }
  }, [limpiarCacheCompleto, precargarPuesto, alimentadoresPuesto]);

  // Handler para cambio de tipo de gr√°fico
  // Si cambia a barras y el intervalo es "Todos", primero cambia a 15min
  // para evitar renderizar miles de barras que tildan el navegador
  const handleTipoGraficoChange = useCallback((nuevoTipo) => {
    if (nuevoTipo === "bar" && intervaloFiltro === 0) {
      // Cambiar intervalo ANTES de cambiar el tipo para evitar render con todos los datos
      setIntervaloFiltro(15);
    }
    setTipoGrafico(nuevoTipo);
  }, [intervaloFiltro]);

  // Handler para cambio de alimentador desde el selector
  const handleAlimentadorChange = useCallback((nuevoAlimentadorId) => {
    const nuevoAlimentador = alimentadoresPuesto.find(a => a.id === nuevoAlimentadorId);
    if (nuevoAlimentador) {
      setAlimentadorActual(nuevoAlimentador);
      setCardDesignActual(nuevoAlimentador.card_design || {});
      // Resetear zona a superior al cambiar de alimentador
      setZonaSeleccionada("superior");
      // Limpiar datos del gr√°fico para que se recarguen
      setDatosGrafico([]);
    }
  }, [alimentadoresPuesto]);

  const handleGenerarInforme = async (configInforme) => {
    // La imagen del gr√°fico ahora se genera en el modal con los datos filtrados,
    // as√≠ siempre corresponde a los datos de la tabla del informe
    const { solicitadoPor, datosFiltrados, fechaInicio, fechaFin, intervalo, imagenGrafico } = configInforme;

    await generarInformePDF({
      nombreAlimentador: alimentador?.nombre || "Alimentador",
      tituloMedicion: tituloZonaActual,
      datos: datosFiltrados,
      fechaInicio,
      fechaFin,
      solicitadoPor,
      imagenGrafico,
      intervalo,
    });
  };

  // No renderizar si est√° minimizada
  if (minimizada) return null;

  const estiloVentana = maximizada
    ? { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, width: "100%", height: "100%", zIndex }
    : { position: "fixed", top: posicion.y, left: posicion.x, zIndex };

  return (
    <div
      ref={ventanaRef}
      className={`ventana-historial ${maximizada ? "ventana-historial--maximizada" : ""} ${arrastrando ? "ventana-historial--arrastrando" : ""}`}
      style={estiloVentana}
      onMouseDown={() => onEnfocar()}
    >
      {/* Header arrastrable */}
      <BarraTituloVentana
        ref={headerRef}
        nombre={alimentador?.nombre}
        maximizada={maximizada}
        onMinimizar={onMinimizar}
        onMaximizar={onMaximizar}
        onCerrar={onCerrar}
        onMouseDown={handleMouseDown}
      />

      {/* Contenido */}
      <div className="ventana-historial-content">
        {/* Barra de controles compacta */}
        <BarraControlesHistorial
          panelDatosAbierto={panelDatosAbierto}
          onTogglePanel={() => setPanelDatosAbierto(!panelDatosAbierto)}
          zonaSeleccionada={zonaSeleccionada}
          onZonaChange={setZonaSeleccionada}
          zonaDisponible={zonaDisponible}
          tituloSuperior={tituloSuperior}
          tituloInferior={tituloInferior}
          rangoSeleccionado={rangoSeleccionado}
          onRangoChange={handleRangoChange}
          fechaRangoDesde={fechaRangoDesde}
          fechaRangoHasta={fechaRangoHasta}
          onFechaRangoChange={handleFechaRangoChange}
          tipoGrafico={tipoGrafico}
          onTipoGraficoChange={handleTipoGraficoChange}
          alimentadorId={alimentador?.id}
          alimentadores={alimentadoresPuesto}
          onAlimentadorChange={handleAlimentadorChange}
          precargaProgreso={precargaProgreso}
          precargaCompleta={precargaCompleta}
          precargando={precargando}
          fuenteDatos={fuenteDatosEfectiva}
          onLimpiarCache={handleLimpiarCache}
          graficoVisible={graficoVisible}
          onToggleGrafico={() => setGraficoVisible(!graficoVisible)}
        />

        {/* Contenedor del gr√°fico y panel de datos */}
        <div className={`ventana-grafico-container ${!graficoVisible ? "ventana-grafico-container--oculto" : ""}`}>
          {/* Panel lateral de datos */}
          <PanelDatosHistorial
            abierto={panelDatosAbierto}
            tituloPeriodo={tituloPanelDatos}
            intervaloFiltro={intervaloFiltro}
            onIntervaloChange={setIntervaloFiltro}
            datosFiltrados={datosFiltrados}
            tipoGrafico={tipoGrafico}
          />

          {/* Slider vertical para escala Y (elemento separado) */}
          {datosGrafico.length > 0 && !cargando && !error && (
            <div className="ventana-escala-y">
              {/* Bot√≥n subir escala (solo visible en landscape m√≥vil via CSS) */}
              <button
                type="button"
                className="ventana-escala-y-btn ventana-escala-y-btn--arriba"
                onClick={() => {
                  const valorActual = escalaYMax ?? limitesEscalaY.min;
                  const redondeado = Math.ceil(valorActual / 10) * 10;
                  const nuevoValor = redondeado === valorActual ? valorActual + 10 : redondeado;
                  setEscalaYMax(Math.min(nuevoValor, limitesEscalaY.max));
                }}
                title="Aumentar escala +10"
              >
                ‚ñ≤
              </button>
              {editandoEscalaY ? (
                <input
                  type="number"
                  className="ventana-escala-y-input"
                  defaultValue={escalaYMax ?? limitesEscalaY.min}
                  autoFocus
                  onBlur={(e) => handleEscalaYManual(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === "Enter") handleEscalaYManual(e.target.value);
                    if (e.key === "Escape") setEditandoEscalaY(false);
                  }}
                />
              ) : (
                <span
                  className="ventana-escala-y-label ventana-escala-y-label--editable"
                  onDoubleClick={() => setEditandoEscalaY(true)}
                  title="Doble click para editar"
                >
                  {escalaYMax ?? limitesEscalaY.min}
                </span>
              )}
              <input
                type="range"
                className="ventana-escala-y-slider"
                min={limitesEscalaY.min}
                max={limitesEscalaY.max}
                step={0.5}
                value={escalaYMax ?? limitesEscalaY.min}
                onChange={(e) => setEscalaYMax(Number(e.target.value))}
                title={`Escala Y: 0 - ${escalaYMax ?? limitesEscalaY.min}`}
              />
              <span className="ventana-escala-y-label">0</span>
              {/* Bot√≥n bajar escala (solo visible en landscape m√≥vil via CSS) */}
              <button
                type="button"
                className="ventana-escala-y-btn ventana-escala-y-btn--abajo"
                onClick={() => {
                  const valorActual = escalaYMax ?? limitesEscalaY.min;
                  const redondeado = Math.floor(valorActual / 10) * 10;
                  const nuevoValor = redondeado === valorActual ? valorActual - 10 : redondeado;
                  setEscalaYMax(Math.max(nuevoValor, limitesEscalaY.min));
                }}
                title="Disminuir escala -10"
              >
                ‚ñº
              </button>
              <button
                type="button"
                className="ventana-escala-y-reset"
                onClick={() => setEscalaYMax(null)}
                title="Restaurar escala autom√°tica"
                disabled={!escalaYMax}
              >
                Auto
              </button>
            </div>
          )}

          {/* Gr√°fico */}
          <div className="ventana-grafico">
              {cargando ? (
                <div className="ventana-estado">
                  <div className="ventana-spinner" />
                  <span>Cargando...</span>
                </div>
              ) : error ? (
                <div className="ventana-estado ventana-estado--error">
                  <span>Error: {error}</span>
                  <button onClick={cargarDatos}>Reintentar</button>
                </div>
              ) : precargando && datosGrafico.length === 0 ? (
                <div className="ventana-estado">
                  <div className="ventana-spinner" />
                  <span>Descargando datos de la base de datos...</span>
                </div>
              ) : datosGrafico.length === 0 ? (
                <div className="ventana-estado">
                  <span>No hay datos en el per√≠odo seleccionado</span>
                </div>
              ) : (
                <ApexChartWrapper key={`chart-${tipoGrafico}-${escalaYMax}`} ref={chartRef} options={opcionesGrafico} series={seriesGrafico} type={tipoGrafico} height="100%" />
              )}
          </div>
        </div>

        {/* Estad√≠sticas */}
        {estadisticasGrafico && (
          <div className="ventana-stats">
            <span className="ventana-stat">
              <b>Puntos:</b>
              <input type="text" className="ventana-stat-input" value={estadisticasGrafico.puntos} size={String(estadisticasGrafico.puntos).length || 1} readOnly />
            </span>
            <span className="ventana-stat">
              <b>M√≠n:</b>
              <input type="text" className="ventana-stat-input" value={estadisticasGrafico.min} size={estadisticasGrafico.min.length || 1} readOnly />
              {estadisticasGrafico.minFecha && (
                <span className="ventana-stat-fecha">({estadisticasGrafico.minFecha})</span>
              )}
            </span>
            <span className="ventana-stat">
              <b>M√°x:</b>
              <input type="text" className="ventana-stat-input" value={estadisticasGrafico.max} size={estadisticasGrafico.max.length || 1} readOnly />
              {estadisticasGrafico.maxFecha && (
                <span className="ventana-stat-fecha">({estadisticasGrafico.maxFecha})</span>
              )}
            </span>
            <span className="ventana-stat">
              <b>Prom:</b>
              <input type="text" className="ventana-stat-input" value={estadisticasGrafico.promedio} size={estadisticasGrafico.promedio.length || 1} readOnly />
            </span>
            <button type="button" className="ventana-btn-exportar ventana-btn--desktop-only" onClick={handleExportarCSV} disabled={datosGrafico.length === 0}>
              CSV
            </button>
            <button type="button" className="ventana-btn-exportar ventana-btn-informe ventana-btn--desktop-only" onClick={handleAbrirModalInforme} disabled={datosGrafico.length === 0}>
              Informe
            </button>
          </div>
        )}
      </div>

      {/* Modal de configuraci√≥n de informe */}
      <ModalConfigInforme
        visible={modalInformeVisible}
        onCerrar={() => setModalInformeVisible(false)}
        onGenerar={handleGenerarInforme}
        datos={datosGrafico}
        nombreAlimentador={alimentador?.nombre || "Alimentador"}
        tituloMedicion={tituloZonaActual}
        tipoGrafico={tipoGrafico}
      />
    </div>
  );
};

export default VentanaHistorial;

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/BarraNavegacion.css =====

/* src/paginas/PaginaAlimentadores/componentes/navegacion/BarraNavegacion.css */
/*
   NOTA SOBRE ESTE ARCHIVO (BarraNavegacion.css)
   - Define el layout visual de la barra superior en modo escritorio y compacto.

   - `.alim-navbar` arma el contenedor principal; los bloques
     `.alim-nav-bloque-puestos` y `.alim-nav-bloque-controles` distribuyen los
     botones de puestos y los controles (nuevo, editar, salir).

   - El media query a 900px activa el modo compacto: centra el t√≠tulo,
     muestra el bot√≥n de men√∫ (`.alim-navbar-menu-btn`) y oculta los botones
     de puestos y controles de la derecha (que pasan al men√∫ lateral).
*/

/* =========================================================
   NAVBAR (DESKTOP)
   ========================================================= */
.alim-navbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.6rem 1.25rem;
	background-color: #0f172a;
	color: #e5e7eb;
	box-shadow: 0 4px 10px rgba(15, 23, 42, 0.4);
	/* z-index bajo para no tapar modales */
	z-index: 50;
	width: 100%;
	/* Navbar sticky: fijo al hacer scroll pero sin tapar modales */
	position: sticky;
	top: 0;
	border: none;
	margin: 0;
	box-sizing: border-box;
}


.alim-navbar-left {
	display: flex;
	flex-direction: column;
}

.alim-title {
	margin: 0;
	font-size: 1.3rem;
}

/* Fila con nombre del puesto y bot√≥n maestro */
.alim-puesto-row {
	display: flex;
	align-items: center;
	gap: 0.5rem;
	margin-top: 0.15rem;
}

/* Bot√≥n del nombre del puesto - mejorado */
.alim-puesto-nombre-btn {
	background: rgba(30, 58, 95, 0.5);
	border: 1px solid #334155;
	padding: 0.3rem 0.6rem;
	border-radius: 6px;
	color: #e5e7eb;
	font-size: 0.85rem;
	font-weight: 500;
	cursor: pointer;
	transition: background-color 0.2s, border-color 0.2s, color 0.2s;
}

.alim-puesto-nombre-btn:hover {
	background: rgba(59, 130, 246, 0.2);
	border-color: #3b82f6;
	color: #60a5fa;
}

.alim-puesto-nombre-btn:active {
	background: rgba(59, 130, 246, 0.3);
}

/* Bot√≥n maestro de maestros */
.alim-maestro-btn {
	padding: 0.4rem 0.6rem;
	background: #1e3a5f;
	border: 1px solid #3b82f6;
	border-radius: 4px;
	color: #60a5fa;
	font-size: 1rem;
	cursor: pointer;
	transition: background 0.2s, transform 0.1s, border-color 0.2s;
	line-height: 1;
	display: flex;
	align-items: center;
	justify-content: center;
}

.alim-maestro-btn:hover {
	background: #2563eb;
	color: #fff;
}

.alim-maestro-btn:active {
	transform: scale(0.95);
}

.alim-maestro-btn--stop {
	background: #5f1e1e;
	border-color: #ef4444;
	color: #f87171;
}

.alim-maestro-btn--stop:hover {
	background: #dc2626;
	color: #fff;
}

.alim-maestro-btn--disabled {
	background: #374151;
	border-color: #4b5563;
	color: #6b7280;
	cursor: not-allowed;
	opacity: 0.7;
}

.alim-maestro-btn--disabled:hover {
	background: #374151;
	color: #6b7280;
}

/* Bot√≥n maestro con texto (INICIAR MEDICIONES / PARAR MEDICIONES) */
.alim-maestro-btn-texto {
	padding: 0.3rem 0.6rem;
	background: #1e3a5f;
	border: 1px solid #3b82f6;
	border-radius: 6px;
	color: #60a5fa;
	font-size: 0.85rem;
	font-weight: 500;
	cursor: pointer;
	transition: background 0.2s, transform 0.1s, border-color 0.2s;
	white-space: nowrap;
}

.alim-maestro-btn-texto:hover {
	background: #2563eb;
	color: #fff;
}

.alim-maestro-btn-texto:active {
	transform: scale(0.97);
}

.alim-maestro-btn-texto--stop {
	background: #5f1e1e;
	border-color: #ef4444;
	color: #f87171;
}

.alim-maestro-btn-texto--stop:hover {
	background: #dc2626;
	color: #fff;
}

.alim-maestro-btn-texto--disabled {
	background: #374151;
	border-color: #4b5563;
	color: #6b7280;
	cursor: not-allowed;
	opacity: 0.7;
}

.alim-maestro-btn-texto--disabled:hover {
	background: #374151;
	color: #6b7280;
}

/* Estilo para modo compacto */
.alim-current-puesto-btn {
	background: rgba(30, 58, 95, 0.5);
	border: 1px solid #334155;
	padding: 0.45rem 0.85rem;
	border-radius: 6px;
	color: #e5e7eb;
	font-size: 0.95rem;
	font-weight: 500;
	cursor: pointer;
	transition: background-color 0.2s, border-color 0.2s, color 0.2s;
	display: flex;
	align-items: center;
	justify-content: center;
	line-height: 1;
}

.alim-current-puesto-btn:hover {
	background: rgba(59, 130, 246, 0.2);
	border-color: #3b82f6;
	color: #60a5fa;
}

.alim-current-puesto-btn:active {
	background: rgba(59, 130, 246, 0.3);
}

/* Contenedor de botones de la nav */
.alim-nav-buttons {
	display: flex;
	align-items: center;
	gap: 2rem;
}

/* Bloque 2: botones de puestos */
.alim-nav-bloque-puestos {
	display: flex;
	align-items: center;
	gap: 2rem;
}

/* Bloque 1: +, editar, salir */
.alim-nav-bloque-controles {
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

/* Boton menu: oculto por defecto (solo se usa en modo compacto) */
.alim-navbar-menu-btn {
	display: none;
	border: none;
	background: transparent;
	color: #e5e7eb;
	font-size: 1.4rem;
	cursor: pointer;
}

/* =========================================================
   NAVBAR (MODO COMPACTO)
   ========================================================= */
@media (max-width: 900px) {

	/* El contenedor principal del nav pasa a modo centrado */
	.alim-navbar {
		justify-content: center;
	}

	.alim-navbar-compact {
		justify-content: space-between;
		align-items: center;
	}

	/* Ajuste vertical de botones en modo compacto */
	.alim-navbar-compact .alim-current-puesto-btn,
	.alim-navbar-compact .alim-maestro-btn {
		margin-top: 2px;
	}

	/* Texto centrado con el nombre del puesto (sin bot√≥n puesto) */
	.alim-navbar-compact-title {
		font-weight: 600;
		letter-spacing: 0.03em;
		text-align: center;
	}

	/* Mostramos el boton hamburguesa */
	.alim-navbar-menu-btn {
		display: block;
		background: none;
		border: none;
		color: #e5e7eb;
		font-size: 1.3rem;
		cursor: pointer;
	}

	/* Ocultamos titulo grande y zona de botones de la derecha */
	.alim-title {
		display: none;
	}

	.alim-nav-buttons {
		display: none;
	}
}

/* =========================================================
   DI√ÅLOGO DE CONFIRMACI√ìN (MEDICIONES)
   ========================================================= */
.alim-confirmacion-overlay {
	position: fixed;
	inset: 0;
	background: rgba(0, 0, 0, 0.75);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 1100;
	padding: 1rem;
}

.alim-confirmacion {
	background: #1e293b;
	border-radius: 12px;
	padding: 1.5rem;
	max-width: 400px;
	width: 90%;
	text-align: center;
	box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
	border: 1px solid #334155;
}

.alim-confirmacion__icono {
	font-size: 2.5rem;
	margin-bottom: 0.75rem;
}

.alim-confirmacion__titulo {
	margin: 0 0 0.5rem 0;
	font-size: 1.1rem;
	font-weight: 600;
	color: #f1f5f9;
}

.alim-confirmacion__mensaje {
	margin: 0 0 1.25rem 0;
	font-size: 0.9rem;
	color: #94a3b8;
	line-height: 1.5;
}

.alim-confirmacion__botones {
	display: flex;
	justify-content: center;
	gap: 0.75rem;
}

.alim-confirmacion__btn {
	padding: 0.6rem 1.25rem;
	border: none;
	border-radius: 6px;
	font-size: 0.9rem;
	font-weight: 500;
	cursor: pointer;
	transition: background 0.2s, transform 0.1s;
}

.alim-confirmacion__btn:active {
	transform: scale(0.98);
}

.alim-confirmacion__btn--cancelar {
	background: #475569;
	color: #f1f5f9;
}

.alim-confirmacion__btn--cancelar:hover {
	background: #64748b;
}

.alim-confirmacion__btn--iniciar {
	background: #2563eb;
	color: #fff;
}

.alim-confirmacion__btn--iniciar:hover {
	background: #1d4ed8;
}

.alim-confirmacion__btn--detener {
	background: #dc2626;
	color: #fff;
}

.alim-confirmacion__btn--detener:hover {
	background: #b91c1c;
}
// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/BarraNavegacion.jsx =====

// src/paginas/PaginaAlimentadores/componentes/navegacion/BarraNavegacion.jsx

import React, { useState } from "react";
import "./BarraNavegacion.css";            // estilos espec√≠ficos de la barra superior
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase";
import SelectorConfiguracion from "./SelectorConfiguracion.jsx";
import BotonGuardarCambios from "./BotonGuardarCambios.jsx";

/**
 * Barra de navegaci√≥n superior.
 * Muestra t√≠tulo, botones de selecci√≥n de puesto y controles globales.
 */
const BarraNavegacion = ({
	esCompacto,                             // true en pantallas angostas (modo compacto)
	puestos,                                // lista de puestos disponibles
	puestoSeleccionado,                     // puesto actualmente activo
	onSeleccionarPuesto,                    // callback al hacer clic en un bot√≥n de puesto
	onAbrirModalNuevoPuesto,                // callback para abrir modal "Nuevo puesto"
	onAbrirModalEditarPuestos,              // callback para abrir modal "Editar puestos"
	onAbrirModalConfigPuesto,               // callback para abrir modal de configuraci√≥n del puesto
	onAbrirModalConfigurarAgente,           // callback para abrir modal de configuraci√≥n del agente
	onAbrirModalGestionarAccesos,           // callback para abrir modal de gesti√≥n de accesos
	onAbrirModalPanelPermisos,              // callback para abrir modal de panel de permisos (solo superadmin)
	onSalir,                                // callback para cerrar sesi√≥n / volver al inicio
	onAbrirMenu,                            // callback para abrir el men√∫ lateral en modo compacto
	coloresSistema,                         // paleta de colores para botones de puesto
	estaPolling,                            // (alimId) => boolean - verifica si un alimentador est√° en polling
	onPlayStopClick,                        // (alimId) => void - alterna polling de un alimentador
}) => {
	const {
		hayCambiosPendientes,
		sincronizando,
		sincronizarCambios,
		descartarCambios,
		obtenerColorPuesto,
	} = usarContextoAlimentadores();

	// Estado para el di√°logo de confirmaci√≥n
	const [mostrarConfirmacion, setMostrarConfirmacion] = useState(false);

	// ===== L√ìGICA DEL BOT√ìN MAESTRO GLOBAL =====
	// Helper para verificar si un alimentador puede hacer polling (misma l√≥gica que ModalConfiguracionPuesto)
	const puedeHacerPolling = (alim) => {
		if (!alim.intervalo_consulta_ms || alim.intervalo_consulta_ms <= 0) return false;

		const cardDesign = alim.card_design || {};
		const superior = cardDesign.superior || {};
		const inferior = cardDesign.inferior || {};

		const tieneRegistrador = !!superior.registrador_id || !!inferior.registrador_id || !!alim.registrador_id;
		if (!tieneRegistrador) return false;

		// Verificar que al menos un box est√© habilitado con √≠ndice v√°lido
		const boxesSuperior = superior.boxes || [];
		const boxesInferior = inferior.boxes || [];
		const todosLosBoxes = [...boxesSuperior, ...boxesInferior];

		const tieneBoxHabilitado = todosLosBoxes.some(
			(box) => box.enabled && box.indice !== null && box.indice !== undefined && box.indice !== ""
		);

		return tieneBoxHabilitado;
	};

	const calcularEstadoGlobal = () => {
		if (!puestoSeleccionado) {
			return { alimentadoresConPolling: [], hayAlgunaCardDisponible: false, algunaCardMidiendo: false };
		}

		const alimentadores = puestoSeleccionado.alimentadores || [];

		// Filtrar solo los alimentadores que pueden hacer polling
		const alimentadoresConPolling = alimentadores.filter(puedeHacerPolling);

		const hayAlgunaCardDisponible = alimentadoresConPolling.length > 0;
		// Verificar si alg√∫n alimentador est√° actualmente en polling
		const algunaCardMidiendo = alimentadoresConPolling.some((alim) => estaPolling?.(alim.id));

		return { alimentadoresConPolling, hayAlgunaCardDisponible, algunaCardMidiendo };
	};

	const { alimentadoresConPolling, hayAlgunaCardDisponible, algunaCardMidiendo } = calcularEstadoGlobal();

	// Abre el di√°logo de confirmaci√≥n
	const handleClickMaestro = () => {
		if (!hayAlgunaCardDisponible) return;
		setMostrarConfirmacion(true);
	};

	// Ejecuta la acci√≥n despu√©s de confirmar - inicia o detiene el polling de todos los alimentadores
	const ejecutarMaestroGlobal = () => {
		setMostrarConfirmacion(false);

		if (algunaCardMidiendo) {
			// Detener todos los que est√°n en polling
			alimentadoresConPolling.forEach((alim) => {
				if (estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		} else {
			// Iniciar todos los disponibles
			alimentadoresConPolling.forEach((alim) => {
				if (!estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		}
	};

	return (
		<>
		<nav
			className={
				"alim-navbar" + (esCompacto ? " alim-navbar-compact" : "")
			}                                  // aplica clase extra cuando est√° en modo compacto
		>
			{esCompacto ? (
				<>
					{/* Bot√≥n men√∫ (solo en modo compacto / mobile) */}
					<button
						type="button"
						className="alim-navbar-menu-btn"
						onClick={onAbrirMenu}
						aria-label="Abrir men√∫"
					>
						‚ò∞
					</button>

					{/* Centro: nombre del puesto o texto gen√©rico */}
					{puestoSeleccionado ? (
						<button
							type="button"
							className="alim-current-puesto-btn"
							onClick={onAbrirModalConfigPuesto}
							title="Configurar puesto"
						>
							{puestoSeleccionado.nombre}
						</button>
					) : (
						<div className="alim-navbar-compact-title">
							Panel de Alimentadores
						</div>
					)}

					{/* Bot√≥n maestro a la derecha (solo si hay puesto seleccionado) */}
					{puestoSeleccionado && (
						<button
							type="button"
							className={`alim-maestro-btn ${algunaCardMidiendo ? "alim-maestro-btn--stop" : ""} ${!hayAlgunaCardDisponible ? "alim-maestro-btn--disabled" : ""}`}
							onClick={handleClickMaestro}
							disabled={!hayAlgunaCardDisponible}
							title={!hayAlgunaCardDisponible ? "Sin registradores con configuraci√≥n v√°lida" : algunaCardMidiendo ? "Detener todas las mediciones" : "Iniciar todas las mediciones"}
						>
							{!hayAlgunaCardDisponible ? "‚äò" : algunaCardMidiendo ? "‚èπ" : "‚ñ∂"}
						</button>
					)}
				</>
			) : (
				<>
					{/* Lado izquierdo: t√≠tulo grande y nombre del puesto actual */}
					<div className="alim-navbar-left">
						<h1 className="alim-title">Panel de Alimentadores</h1>

						{puestoSeleccionado && (
							<div className="alim-puesto-row">
								<button
									type="button"
									className="alim-puesto-nombre-btn"
									onClick={onAbrirModalConfigPuesto}
									title="Configurar puesto"
								>
									{puestoSeleccionado.nombre}
								</button>
								<button
									type="button"
									className={`alim-maestro-btn-texto ${algunaCardMidiendo ? "alim-maestro-btn-texto--stop" : ""} ${!hayAlgunaCardDisponible ? "alim-maestro-btn-texto--disabled" : ""}`}
									onClick={handleClickMaestro}
									disabled={!hayAlgunaCardDisponible}
									title={!hayAlgunaCardDisponible ? "Sin registradores con configuraci√≥n v√°lida" : algunaCardMidiendo ? "Detener todas las mediciones" : "Iniciar todas las mediciones"}
								>
									{!hayAlgunaCardDisponible ? "‚äò" : algunaCardMidiendo ? "PARAR MEDICIONES" : "INICIAR MEDICIONES"}
								</button>
							</div>
						)}
					</div>

					{/* Lado derecho: botones de puestos + controles */}
					<div className="alim-nav-buttons">
						{/* Bloque 2: botones de puestos (uno por cada puesto creado) */}
						<div className="alim-nav-bloque-puestos">
							{puestos.map((p) => (
								<button
									key={p.id}
									className={
										"alim-btn" +
										(puestoSeleccionado &&
										puestoSeleccionado.id === p.id
											? " alim-btn-active"
											: "")
									}
									onClick={() => onSeleccionarPuesto(p.id)}
									style={{
										backgroundColor:
											obtenerColorPuesto(p.id) || coloresSistema[0],
									}}                           // usa el color configurado (con soporte para preferencias de invitado)
								>
									{p.nombre}
								</button>
							))}
						</div>

						{/* Bloque 1: botones de control fijo (nuevo, editar, config, salir) */}
						<div className="alim-nav-bloque-controles">
							<BotonGuardarCambios
								hayCambios={hayCambiosPendientes}
								sincronizando={sincronizando}
								onGuardar={sincronizarCambios}
								onDescartar={descartarCambios}
							/>

							<SelectorConfiguracion
								onAbrirModalNuevoPuesto={onAbrirModalNuevoPuesto}
								onAbrirModalEditarPuestos={onAbrirModalEditarPuestos}
								onAbrirModalConfigurarAgente={onAbrirModalConfigurarAgente}
								onAbrirModalGestionarAccesos={onAbrirModalGestionarAccesos}
								onAbrirModalPanelPermisos={onAbrirModalPanelPermisos}
								puestosLength={puestos.length}
							/>

							<button
								type="button"
								className="alim-btn-exit"
								onClick={onSalir}
							>
								Salir
							</button>
						</div>
					</div>
				</>
			)}
		</nav>

		{/* Di√°logo de confirmaci√≥n para el bot√≥n maestro */}
		{mostrarConfirmacion && (
			<div className="alim-confirmacion-overlay">
				<div className="alim-confirmacion">
					<div className="alim-confirmacion__icono">
						{algunaCardMidiendo ? "‚èπÔ∏è" : "‚ñ∂Ô∏è"}
					</div>
					<h3 className="alim-confirmacion__titulo">
						{algunaCardMidiendo ? "¬øDetener todas las mediciones?" : "¬øIniciar todas las mediciones?"}
					</h3>
					<p className="alim-confirmacion__mensaje">
						{algunaCardMidiendo
							? "Se detendr√°n las mediciones de todos los registradores activos en este puesto."
							: "Se iniciar√°n las mediciones de todos los registradores con configuraci√≥n v√°lida en este puesto."}
					</p>
					<div className="alim-confirmacion__botones">
						<button
							type="button"
							className="alim-confirmacion__btn alim-confirmacion__btn--cancelar"
							onClick={() => setMostrarConfirmacion(false)}
						>
							Cancelar
						</button>
						<button
							type="button"
							className={`alim-confirmacion__btn ${algunaCardMidiendo ? "alim-confirmacion__btn--detener" : "alim-confirmacion__btn--iniciar"}`}
							onClick={ejecutarMaestroGlobal}
						>
							{algunaCardMidiendo ? "Detener" : "Iniciar"}
						</button>
					</div>
				</div>
			</div>
		)}
		</>
	);
};

export default BarraNavegacion;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (BarraNavegacion.jsx)

 - Este componente es la barra superior fija del panel de alimentadores.
   En modo escritorio muestra el t√≠tulo, el puesto actual y todos los botones
   de puestos; en modo compacto solo muestra el bot√≥n de men√∫ y el t√≠tulo.

 - La prop `esCompacto` viene de `VistaAlimentadores` y decide si se muestra la
   versi√≥n completa (desktop) o la versi√≥n reducida (mobile).

 - El array `puestos` se recorre para dibujar un bot√≥n por puesto; el que est√°
   seleccionado recibe la clase `alim-btn-active` y el color que tenga
   configurado (`p.color`).

 - Los callbacks `onSeleccionarPuesto`, `onAbrirModalNuevoPuesto`,
   `onAbrirModalEditarPuestos` y `onSalir` se conectan directamente con la
   l√≥gica del contexto y la navegaci√≥n, pero este componente se limita a
   dispararlos cuando corresponde (no sabe la l√≥gica interna).
---------------------------------------------------------------------------*/}

{/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (BarraNavegacion.jsx)

0) Visi√≥n general del componente

   `BarraNavegacion` es la barra superior fija del panel de alimentadores.

   - En modo escritorio:
       ‚Ä¢ muestra el t√≠tulo grande ‚ÄúPanel de Alimentadores‚Äù,
       ‚Ä¢ debajo, el nombre del puesto actualmente seleccionado,
       ‚Ä¢ a la derecha, todos los botones de puestos,
       ‚Ä¢ y los controles globales: nuevo puesto, editar puestos, salir.

   - En modo compacto (pantallas angostas):
       ‚Ä¢ muestra solo:
           - un bot√≥n de men√∫ (‚ò∞) para abrir el panel lateral,
           - un t√≠tulo centrado (nombre del puesto actual o texto gen√©rico).


1) Props del componente

   const BarraNavegacion = ({
     esCompacto,
     puestos,
     puestoSeleccionado,
     onSeleccionarPuesto,
     onAbrirModalNuevoPuesto,
     onAbrirModalEditarPuestos,
     onSalir,
     onAbrirMenu,
     coloresSistema,
   }) => { ... }

   - `esCompacto` (boolean):
       ‚Ä¢ true  ‚Üí se usa el layout reducido (mobile),
       ‚Ä¢ false ‚Üí se usa el layout completo (desktop).

   - `puestos` (array):
       ‚Ä¢ lista de todos los puestos creados,
       ‚Ä¢ cada puesto suele tener `{ id, nombre, color, ... }`.

   - `puestoSeleccionado` (objeto o null):
       ‚Ä¢ el puesto actualmente activo,
       ‚Ä¢ si existe, se muestra su nombre y se marca su bot√≥n.

   - `onSeleccionarPuesto(idPuesto)`:
       ‚Ä¢ callback que se llama al hacer clic en el bot√≥n de un puesto.

   - `onAbrirModalNuevoPuesto()`:
       ‚Ä¢ se ejecuta al hacer clic en el bot√≥n "+".

   - `onAbrirModalEditarPuestos()`:
       ‚Ä¢ se ejecuta al hacer clic en el bot√≥n de edici√≥n (‚úé).

   - `onSalir()`:
       ‚Ä¢ se ejecuta al hacer clic en el bot√≥n ‚ÄúSalir‚Äù (volver al login).

   - `onAbrirMenu()`:
       ‚Ä¢ se usa solo en modo compacto para abrir el men√∫ lateral.

   - `coloresSistema` (array de colores):
       ‚Ä¢ paleta de fallback para botones de puestos,
       ‚Ä¢ si un puesto no tiene `color`, se usa `coloresSistema[0]`.


2) Contenedor principal <nav>

   return (
     <nav
       className={
         "alim-navbar" + (esCompacto ? " alim-navbar-compact" : "")
       }
     >
       {esCompacto ? ( ... ) : ( ... )}
     </nav>
   );

   - El `<nav>` usa siempre la clase base `"alim-navbar"`.

   - Si `esCompacto` es true, agrega tambi√©n `"alim-navbar-compact"`,
     que aplica estilos espec√≠ficos para el modo reducido (CSS).

   - Dentro del nav se hace un condicional:
       ‚Ä¢ si `esCompacto` es true ‚Üí renderiza la versi√≥n compacta,
       ‚Ä¢ si es false ‚Üí renderiza la versi√≥n completa.


3) Modo compacto (mobile)

   {esCompacto ? (
     <>
       <button ... onClick={onAbrirMenu}>‚ò∞</button>
       <div className="alim-navbar-compact-title">
         {puestoSeleccionado ? puestoSeleccionado.nombre : "Panel de Alimentadores"}
       </div>
     </>
   ) : ( ... )}

   - Bot√≥n de men√∫:
       ‚Ä¢ solo aparece en modo compacto,
       ‚Ä¢ tiene texto ‚Äú‚ò∞‚Äù (√≠cono tipo hamburguesa),
       ‚Ä¢ `onClick={onAbrirMenu}`: dispara la apertura del men√∫ lateral,
       ‚Ä¢ `aria-label="Abrir men√∫"`: mejora la accesibilidad.

   - T√≠tulo centrado:
       ‚Ä¢ si hay `puestoSeleccionado`, muestra su nombre,
       ‚Ä¢ si no, muestra el texto gen√©rico `"Panel de Alimentadores"`.

   - En este modo NO se muestran los botones de puestos ni los controles
     de nuevo/editar/salir; esas funciones se acceden desde el men√∫ lateral.


4) Modo escritorio (layout completo)

   : (
     <>
       // Lado izquierdo: t√≠tulo y puesto actual 
       <div className="alim-navbar-left">
         <h1 className="alim-title">Panel de Alimentadores</h1>

         {puestoSeleccionado && (
           <div className="alim-current-puesto">
             {puestoSeleccionado.nombre}
           </div>
         )}
       </div>

       // Lado derecho: botones de puestos + controles 
       <div className="alim-nav-buttons">
         // Bloque de puestos 
         <div className="alim-nav-bloque-puestos">
           {puestos.map((p) => (
             <button
               key={p.id}
               className={
                 "alim-btn" +
                 (puestoSeleccionado && puestoSeleccionado.id === p.id
                   ? " alim-btn-active"
                   : "")
               }
               onClick={() => onSeleccionarPuesto(p.id)}
               style={{
                 backgroundColor: p.color || coloresSistema[0],
               }}
             >
               {p.nombre}
             </button>
           ))}
         </div>

         // Bloque de controles
         <div className="alim-nav-bloque-controles">
           <button ... onClick={onAbrirModalNuevoPuesto}>+</button>
           <button ... onClick={onAbrirModalEditarPuestos} disabled={puestos.length === 0}>‚úé</button>
           <button ... onClick={onSalir}>Salir</button>
         </div>
       </div>
     </>
   )

   4.1) Lado izquierdo

   - `<h1 className="alim-title">Panel de Alimentadores</h1>`:
       ‚Ä¢ t√≠tulo fijo de la pantalla.

   - `puestoSeleccionado && <div className="alim-current-puesto">...`:
       ‚Ä¢ si hay puesto seleccionado, se muestra su nombre debajo del t√≠tulo,
       ‚Ä¢ si no hay, directamente no se renderiza ese div.


   4.2) Botones de puestos (lado derecho, bloque de puestos)

   {puestos.map((p) => (
     <button
       key={p.id}
       className={
         "alim-btn" +
         (puestoSeleccionado && puestoSeleccionado.id === p.id
           ? " alim-btn-active"
           : "")
       }
       onClick={() => onSeleccionarPuesto(p.id)}
       style={{ backgroundColor: p.color || coloresSistema[0] }}
     >
       {p.nombre}
     </button>
   ))}

   - Se recorre el array `puestos` y se dibuja un bot√≥n por cada puesto.

   - `key={p.id}`:
       ‚Ä¢ clave √∫nica para que React identifique cada bot√≥n.

   - `className`:
       ‚Ä¢ siempre tiene la clase base `"alim-btn"`,
       ‚Ä¢ si este puesto es el seleccionado (`puestoSeleccionado.id === p.id`),
         se agrega `"alim-btn-active"`, lo que aplica estilos de ‚Äúbot√≥n activo‚Äù.

   - `onClick={() => onSeleccionarPuesto(p.id)}`:
       ‚Ä¢ al hacer clic, se llama al callback con el id del puesto,
       ‚Ä¢ la l√≥gica de cambio de puesto vive afuera, en la vista/contexto.

   - `style={{ backgroundColor: p.color || coloresSistema[0] }}`:
       ‚Ä¢ usa el color configurado en el puesto (`p.color`),
       ‚Ä¢ si el puesto no tiene color, cae al primer color del sistema.


   4.3) Botones de control (lado derecho, bloque de controles)

   <div className="alim-nav-bloque-controles">
     <button
       type="button"
       className="alim-btn alim-btn-add"
       onClick={onAbrirModalNuevoPuesto}
     >
       <span className="alim-btn-add-icon">+</span>
     </button>

     <button
       type="button"
       className="alim-btn alim-btn-edit"
       onClick={onAbrirModalEditarPuestos}
       disabled={puestos.length === 0}
     >
       ‚úé
     </button>

     <button
       type="button"
       className="alim-btn-exit"
       onClick={onSalir}
     >
       Salir
     </button>
   </div>

   - Bot√≥n de ‚Äúnuevo puesto‚Äù:
       ‚Ä¢ muestra un ‚Äú+‚Äù,
       ‚Ä¢ dispara `onAbrirModalNuevoPuesto` ‚Üí abre modal de alta de puesto.

   - Bot√≥n de ‚Äúeditar puestos‚Äù:
       ‚Ä¢ muestra un √≠cono ‚úé,
       ‚Ä¢ dispara `onAbrirModalEditarPuestos`,
       ‚Ä¢ est√° `disabled` mientras `puestos.length === 0` (no hay nada que editar).

   - Bot√≥n ‚ÄúSalir‚Äù:
       ‚Ä¢ dispara `onSalir`,
       ‚Ä¢ normalmente vuelve al login o pantalla inicial.


5) Export

   export default BarraNavegacion;

   - Exporta el componente para ser usado en `VistaAlimentadores`.
	
   - Esa vista le pasa:
       ‚Ä¢ los datos (puestos, puesto actual, colores),
       ‚Ä¢ y los callbacks (seleccionar, nuevo, editar, salir, abrir men√∫).

---------------------------------------------------------------------------*/}



// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/BotonGuardarCambios.css =====

/* src/paginas/PaginaAlimentadores/componentes/navegacion/BotonGuardarCambios.css */

.guardar-cambios-container {
  display: flex;
  align-items: center;
  gap: 4px;
}

.guardar-cambios-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  font-size: 0.85rem;
  font-weight: 500;
  color: #9ca3af;
  background: #1f2937;
  border: 1px solid #374151;
  border-radius: 6px;
  cursor: not-allowed;
  transition: all 0.2s ease;
  opacity: 0.6;
}

.guardar-cambios-btn--activo {
  color: #fff;
  background: #059669;
  border-color: #10b981;
  cursor: pointer;
  opacity: 1;
}

.guardar-cambios-btn--activo:hover {
  background: #047857;
  border-color: #059669;
}

.guardar-cambios-btn--sincronizando {
  color: #fff;
  background: #3b82f6;
  border-color: #60a5fa;
  cursor: wait;
  opacity: 1;
}

.guardar-cambios-btn:disabled {
  cursor: not-allowed;
}

.guardar-cambios-icono {
  font-size: 1rem;
}

.guardar-cambios-spinner {
  width: 14px;
  height: 14px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: #fff;
  border-radius: 50%;
  animation: guardar-spin 0.8s linear infinite;
}

@keyframes guardar-spin {
  to {
    transform: rotate(360deg);
  }
}

.guardar-cambios-btn-descartar {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  color: #9ca3af;
  background: #374151;
  border: 1px solid #4b5563;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.guardar-cambios-btn-descartar:hover {
  color: #fff;
  border-color: #6b7280;
  background: #4b5563;
}

.guardar-cambios-btn-descartar svg {
  width: 16px;
  height: 16px;
}

/* ===== Overlay de guardado ===== */
.guardar-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  animation: overlay-fade-in 0.2s ease;
}

@keyframes overlay-fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.guardar-overlay__contenido {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  padding: 32px 48px;
  background: #1f2937;
  border-radius: 12px;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
}

.guardar-overlay__spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255, 255, 255, 0.2);
  border-top-color: #10b981;
  border-radius: 50%;
  animation: guardar-spin 0.8s linear infinite;
}

.guardar-overlay__texto {
  color: #f3f4f6;
  font-size: 1rem;
  font-weight: 500;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/BotonGuardarCambios.jsx =====

// src/paginas/PaginaAlimentadores/componentes/navegacion/BotonGuardarCambios.jsx

import React from "react";
import ReactDOM from "react-dom";
import "./BotonGuardarCambios.css";

/**
 * Overlay de guardado que se muestra sobre toda la pantalla
 */
const OverlayGuardando = () => {
  return ReactDOM.createPortal(
    <div className="guardar-overlay">
      <div className="guardar-overlay__contenido">
        <div className="guardar-overlay__spinner" />
        <span className="guardar-overlay__texto">Guardando cambios...</span>
      </div>
    </div>,
    document.body
  );
};

/**
 * Bot√≥n para guardar cambios pendientes en la base de datos.
 * Se activa solo cuando hay diferencias entre el estado local y la BD.
 *
 * @param {boolean} hayCambios - Si hay cambios pendientes por sincronizar
 * @param {boolean} sincronizando - Si est√° en proceso de sincronizaci√≥n
 * @param {Function} onGuardar - Callback para iniciar la sincronizaci√≥n
 * @param {Function} onDescartar - Callback para descartar cambios (opcional)
 */
const BotonGuardarCambios = ({
  hayCambios,
  sincronizando,
  onGuardar,
  onDescartar,
}) => {
  return (
    <>
      {/* Overlay de guardado */}
      {sincronizando && <OverlayGuardando />}

      <div className="guardar-cambios-container">
        <button
          type="button"
          className={`guardar-cambios-btn ${hayCambios ? "guardar-cambios-btn--activo" : ""} ${sincronizando ? "guardar-cambios-btn--sincronizando" : ""}`}
          onClick={onGuardar}
          disabled={!hayCambios || sincronizando}
          title={
            sincronizando
              ? "Guardando..."
              : hayCambios
                ? "Guardar cambios en la base de datos"
                : "No hay cambios pendientes"
          }
        >
          {sincronizando ? (
            <>
              <span className="guardar-cambios-spinner" />
              <span>Guardando...</span>
            </>
          ) : (
            <>
              <span className="guardar-cambios-icono">üíæ</span>
              <span>Guardar</span>
            </>
          )}
        </button>

        {hayCambios && onDescartar && !sincronizando && (
          <button
            type="button"
            className="guardar-cambios-btn-descartar"
            onClick={onDescartar}
            title="Descartar cambios y recargar desde la base de datos"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
              <path d="M3 3v5h5" />
            </svg>
          </button>
        )}
      </div>
    </>
  );
};

export default BotonGuardarCambios;

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/MenuLateral.css =====

/* src/paginas/PaginaAlimentadores/componentes/navegacion/MenuLateral.css */
/*
   NOTA SOBRE ESTE ARCHIVO (MenuLateral.css)
   - Define el estilo del drawer lateral usado en modo compacto: overlay oscuro,
     panel deslizante, cabecera, lista de puestos y botones de acciones.

   - `.alim-drawer-overlay` controla la animaci√≥n de aparici√≥n/desaparici√≥n
     (opacity + pointer-events) y `.alim-drawer` maneja el slide desde la izquierda.
	  
   - Los botones dentro del drawer (`.alim-drawer .alim-btn`) se estiran a todo
     el ancho para que sean f√°ciles de tocar en pantallas t√°ctiles.
*/


/* =========================================================
   CONTENEDOR OSCURO (OVERLAY) + PANEL
   ========================================================= */

/* Capa oscura que cubre la pantalla cuando el drawer est√° abierto */
.alim-drawer-overlay {
   position: fixed;
   inset: 0;
   background-color: rgba(15, 23, 42, 0.45);
   display: flex;
   align-items: stretch;
   justify-content: flex-start;
   opacity: 0;
   pointer-events: none;
   transition: opacity 0.22s ease;
   /* z-index alto para estar sobre navbar (10000) y cobertura status bar (9999) */
   z-index: 10001;
}

/* Cuando el drawer est√° abierto: overlay visible y clickeable */
.alim-drawer-overlay.alim-drawer-open {
   opacity: 1;
   pointer-events: auto;
}

/* Panel lateral que se desliza desde la izquierda */
.alim-drawer {
   width: 260px;
   max-width: 80vw;
   height: 100%;
   max-height: 100vh;
   max-height: 100dvh; /* viewport din√°mico para m√≥viles */
   background-color: #020617;
   color: #e5e7eb;
   /* Padding con safe-areas para Android 15+ edge-to-edge */
   padding: calc(1.4rem + var(--safe-area-inset-top, 0px)) 1.1rem calc(2.5rem + var(--safe-area-inset-bottom, 0px)) calc(1.1rem + var(--safe-area-inset-left, 0px));
   box-shadow: 8px 0 25px rgba(15, 23, 42, 0.6);
   transform: translateX(-100%);
   transition: transform 0.22s ease-out;
   overflow-y: auto;
   overflow-x: hidden;
   -webkit-overflow-scrolling: touch; /* scroll suave en iOS */
}

/* Posici√≥n final del panel cuando el overlay est√° abierto */
.alim-drawer-overlay.alim-drawer-open .alim-drawer {
   transform: translateX(0);
}

/* =========================================================
   CABECERA DEL DRAWER
   ========================================================= */
.alim-drawer-header {
   margin-bottom: 1rem;
}

.alim-drawer-title {
   margin: 0;
   font-size: 1.1rem;
}

.alim-drawer-subtitle {
   margin: 0.25rem 0 0;
   font-size: 0.85rem;
   color: #9ca3af;
}

/* =========================================================
   SECCIONES DE LISTAS (PUESTOS / ACCIONES)
   ========================================================= */
.alim-drawer-section {
   margin-top: 1.1rem;
}

.alim-drawer-section-title {
   margin: 0 0 0.5rem;
   font-size: 0.8rem;
   text-transform: uppercase;
   letter-spacing: 0.08em;
   color: #9ca3af;
}

.alim-drawer-puestos,
.alim-drawer-actions {
   display: flex;
   flex-direction: column;
   gap: 0.45rem;
}

/* Botones dentro del drawer: ocupan todo el ancho */
.alim-drawer .alim-btn,
.alim-drawer .alim-btn-exit {
   width: 100%;
   justify-content: center;
}


/* =========================================================
   INFO DEL USUARIO
   ========================================================= */
.alim-drawer-usuario {
   display: flex;
   flex-direction: column;
   padding: 0.6rem 0.8rem;
   background-color: rgba(30, 41, 59, 0.5);
   border-radius: 8px;
   margin-bottom: 0.5rem;
}

.alim-drawer-usuario-nombre {
   font-weight: 600;
   font-size: 0.95rem;
   color: #f1f5f9;
}

.alim-drawer-usuario-rol {
   font-size: 0.75rem;
   color: #22d3ee;
   text-transform: capitalize;
}

/* =========================================================
   SELECTOR DE WORKSPACE
   ========================================================= */
.alim-drawer-workspace-trigger {
   width: 100%;
   display: flex;
   align-items: center;
   gap: 0.5rem;
   padding: 0.6rem 0.8rem;
   background-color: rgba(30, 41, 59, 0.6);
   border: 1px solid #334155;
   border-radius: 8px;
   color: #e5e7eb;
   font-size: 0.9rem;
   cursor: pointer;
   transition: background-color 0.15s ease;
}

.alim-drawer-workspace-trigger:hover {
   background-color: rgba(51, 65, 85, 0.8);
}

.alim-drawer-workspace-flecha {
   font-size: 0.7rem;
   transition: transform 0.2s ease;
}

.alim-drawer-workspace-flecha--abierto {
   transform: rotate(90deg);
}

.alim-drawer-workspace-lista {
   display: flex;
   flex-direction: column;
   gap: 0.25rem;
   margin-top: 0.4rem;
   padding-left: 0.5rem;
}

/* Row para contener estrella + item */
.alim-drawer-workspace-row {
   display: flex;
   align-items: center;
   gap: 0.25rem;
}

/* Bot√≥n de estrella para workspace default */
.alim-drawer-workspace-default-btn {
   display: flex;
   align-items: center;
   justify-content: center;
   width: 28px;
   height: 28px;
   padding: 0;
   background: transparent;
   border: none;
   font-size: 1rem;
   color: #64748b;
   cursor: pointer;
   border-radius: 4px;
   transition: all 0.15s ease;
   flex-shrink: 0;
}

.alim-drawer-workspace-default-btn:hover {
   background: rgba(51, 65, 85, 0.5);
   color: #fbbf24;
}

/* Cuando es el workspace default, la estrella es amarilla */
.alim-drawer-workspace-default-btn[title="Quitar como default"] {
   color: #fbbf24;
}

.alim-drawer-workspace-default-btn[title="Quitar como default"]:hover {
   color: #f59e0b;
}

.alim-drawer-workspace-item {
   width: 100%;
   padding: 0.5rem 0.7rem;
   background-color: transparent;
   border: none;
   border-radius: 6px;
   color: #9ca3af;
   font-size: 0.85rem;
   text-align: left;
   cursor: pointer;
   transition: background-color 0.15s ease, color 0.15s ease;
}

.alim-drawer-workspace-item:hover {
   background-color: rgba(51, 65, 85, 0.5);
   color: #e5e7eb;
}

.alim-drawer-workspace-item--activo {
   background-color: rgba(34, 211, 238, 0.15);
   color: #22d3ee;
}

.alim-drawer-workspace-invitado {
   margin-left: 0.4rem;
   font-size: 0.75rem;
   color: #6b7280;
}

/* =========================================================
   BOTONES DE ACCI√ìN ADICIONALES
   ========================================================= */
.alim-drawer-btn-action {
   width: 100%;
   display: flex;
   align-items: center;
   gap: 0.5rem;
   padding: 0.6rem 0.8rem;
   background-color: rgba(30, 41, 59, 0.4);
   border: 1px solid #334155;
   border-radius: 8px;
   color: #e5e7eb;
   font-size: 0.9rem;
   cursor: pointer;
   transition: background-color 0.15s ease, border-color 0.15s ease;
}

.alim-drawer-btn-action:hover {
   background-color: rgba(51, 65, 85, 0.6);
   border-color: #475569;
}

.alim-drawer-btn-action:disabled {
   opacity: 0.5;
   cursor: not-allowed;
}

.alim-drawer-btn-icon {
   font-size: 1rem;
}

.alim-drawer-btn-icon-svg {
   width: 18px;
   height: 18px;
}

/* Bot√≥n Gestionar Accesos */
.alim-drawer-btn-accesos {
   color: #60a5fa;
   border-color: rgba(96, 165, 250, 0.4);
}

.alim-drawer-btn-accesos:hover {
   border-color: #60a5fa;
}

/* Bot√≥n Configurar Agente */
.alim-drawer-btn-config {
   color: #a78bfa;
   border-color: rgba(167, 139, 250, 0.4);
}

.alim-drawer-btn-config:hover {
   border-color: #a78bfa;
}

/* Bot√≥n Nuevo Puesto */
.alim-drawer-btn-add {
   color: #34d399;
   border-color: rgba(52, 211, 153, 0.4);
}

.alim-drawer-btn-add:hover {
   border-color: #34d399;
}

/* Bot√≥n Editar Puestos */
.alim-drawer-btn-edit {
   color: #fbbf24;
   border-color: rgba(251, 191, 36, 0.4);
}

.alim-drawer-btn-edit:hover {
   border-color: #fbbf24;
}

/* Bot√≥n Nuevo Workspace */
.alim-drawer-btn-nuevo-workspace {
   color: #34d399;
   border: 1px dashed rgba(52, 211, 153, 0.6);
}

.alim-drawer-btn-nuevo-workspace:hover {
   border-color: #34d399;
}

/* Bot√≥n Salir */
.alim-drawer-btn-salir {
   color: #f87171;
   border-color: rgba(248, 113, 113, 0.4);
}

.alim-drawer-btn-salir:hover {
   border-color: #f87171;
}

/* =========================================================
   FORMULARIO NUEVO WORKSPACE
   ========================================================= */
.alim-drawer-form-workspace {
   display: flex;
   flex-direction: column;
   gap: 0.5rem;
   margin-top: 0.5rem;
}

.alim-drawer-input {
   width: 100%;
   padding: 0.5rem 0.7rem;
   background-color: #1e293b;
   border: 1px solid #334155;
   border-radius: 6px;
   color: #e5e7eb;
   font-size: 0.85rem;
}

.alim-drawer-input:focus {
   outline: none;
   border-color: #22d3ee;
}

.alim-drawer-form-btns {
   display: flex;
   gap: 0.5rem;
}

.alim-drawer-btn-cancelar,
.alim-drawer-btn-crear {
   flex: 1;
   padding: 0.4rem 0.6rem;
   border-radius: 6px;
   font-size: 0.8rem;
   cursor: pointer;
   transition: background-color 0.15s ease;
}

.alim-drawer-btn-cancelar {
   background-color: transparent;
   border: 1px solid #475569;
   color: #9ca3af;
}

.alim-drawer-btn-cancelar:hover {
   background-color: rgba(71, 85, 105, 0.3);
}

.alim-drawer-btn-crear {
   background-color: #22d3ee;
   border: none;
   color: #0f172a;
   font-weight: 600;
}

.alim-drawer-btn-crear:hover {
   background-color: #06b6d4;
}

.alim-drawer-btn-crear:disabled {
   opacity: 0.5;
   cursor: not-allowed;
}

/* =========================================================
   SECCI√ìN ESCALA GLOBAL
   ========================================================= */
.alim-drawer-escala {
   display: flex;
   flex-direction: column;
   gap: 0.6rem;
   padding: 0.6rem 0.8rem;
   background-color: rgba(30, 41, 59, 0.5);
   border-radius: 8px;
}

.alim-drawer-escala-slider {
   width: 100%;
   height: 6px;
   border-radius: 3px;
   background: #334155;
   outline: none;
   cursor: pointer;
   -webkit-appearance: none;
}

.alim-drawer-escala-slider::-webkit-slider-thumb {
   -webkit-appearance: none;
   width: 16px;
   height: 16px;
   border-radius: 50%;
   background: #22d3ee;
   cursor: pointer;
   border: none;
   box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.alim-drawer-escala-slider::-moz-range-thumb {
   width: 16px;
   height: 16px;
   border-radius: 50%;
   background: #22d3ee;
   cursor: pointer;
   border: none;
   box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.alim-drawer-escala-valor {
   display: flex;
   align-items: center;
   gap: 0.3rem;
}

.alim-drawer-escala-input {
   width: 60px;
   padding: 0.4rem 0.5rem;
   background-color: #1e293b;
   border: 1px solid #475569;
   border-radius: 6px;
   color: #e5e7eb;
   font-size: 0.9rem;
   text-align: center;
   font-family: "DS-Digital", "Courier New", monospace;
}

.alim-drawer-escala-input:focus {
   outline: none;
   border-color: #22d3ee;
}

.alim-drawer-escala-x {
   color: #9ca3af;
   font-size: 0.85rem;
}

.alim-drawer-escala-reset {
   padding: 0.4rem 0.8rem;
   background-color: transparent;
   border: 1px solid #475569;
   border-radius: 6px;
   color: #9ca3af;
   font-size: 0.8rem;
   cursor: pointer;
   transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease;
}

.alim-drawer-escala-reset:hover:not(:disabled) {
   background-color: rgba(71, 85, 105, 0.3);
   color: #e5e7eb;
   border-color: #64748b;
}

.alim-drawer-escala-reset:disabled {
   opacity: 0.5;
   cursor: not-allowed;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/MenuLateral.jsx =====

// src/paginas/PaginaAlimentadores/componentes/navegacion/MenuLateral.jsx

import React, { useState } from "react";
import "./MenuLateral.css";             // estilos del drawer lateral
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase";

/**
 * Men√∫ lateral (drawer) para modo compacto.
 * Muestra puestos, workspaces y acciones en un panel deslizante.
 */
const MenuLateral = ({
	abierto,                            // boolean: controla si el drawer est√° visible
	onCerrar,                           // callback para cerrar el drawer
	puestos,                            // lista de puestos
	puestoSeleccionado,                 // puesto actualmente activo
	onSeleccionarPuesto,                // callback al elegir un puesto
	onAbrirModalNuevoPuesto,            // callback para abrir modal "Nuevo puesto"
	onAbrirModalEditarPuestos,          // callback para abrir modal "Editar puestos"
	onAbrirModalConfigurarAgente,       // callback para abrir modal "Configurar Agente"
	onAbrirModalGestionarAccesos,       // callback para abrir modal "Gestionar Accesos"
	onAbrirModalPanelPermisos,          // callback para abrir modal "Panel de Permisos" (solo superadmin)
	onSalir,                            // callback para salir al login
	coloresSistema,                     // paleta de colores para botones de puesto
	// Props de escala global
	escalaGlobal,                       // n√∫mero actual de escala global
	onEscalaGlobalChange,               // (escala) => void
	ESCALA_MIN = 0.5,
	ESCALA_MAX = 2.0,
}) => {
	const {
		configuraciones,
		configuracionSeleccionada,
		seleccionarConfiguracion,
		agregarConfiguracion,
		puedeCrearWorkspaces,
		rolGlobal,
		perfil,
		workspaceDefaultId,
		toggleWorkspaceDefault,
	} = usarContextoConfiguracion();

	const { obtenerColorPuesto } = usarContextoAlimentadores();

	const [submenuWorkspaceAbierto, setSubmenuWorkspaceAbierto] = useState(false);
	const [mostrarFormNuevoWorkspace, setMostrarFormNuevoWorkspace] = useState(false);
	const [nombreNuevoWorkspace, setNombreNuevoWorkspace] = useState("");
	const [creandoWorkspace, setCreandoWorkspace] = useState(false);

	const handleSeleccionarPuesto = (id) => {
		onSeleccionarPuesto(id);        // selecciona el puesto
		onCerrar();                     // cierra el men√∫ despu√©s de elegir
	};

	const handleAccion = (accion) => {
		if (!accion) return;
		onCerrar();                     // primero cierra el men√∫
		accion();                       // luego ejecuta la acci√≥n (nuevo, editar, salir)
	};

	const handleSeleccionarWorkspace = (id) => {
		seleccionarConfiguracion(id);
		setSubmenuWorkspaceAbierto(false);
	};

	const handleCrearWorkspace = async (e) => {
		e.preventDefault();
		if (!nombreNuevoWorkspace.trim()) return;

		try {
			setCreandoWorkspace(true);
			await agregarConfiguracion(nombreNuevoWorkspace.trim());
			setNombreNuevoWorkspace("");
			setMostrarFormNuevoWorkspace(false);
		} catch (err) {
			console.error("Error creando workspace:", err);
		} finally {
			setCreandoWorkspace(false);
		}
	};

	const handleToggleDefault = async (e, id) => {
		e.stopPropagation();
		try {
			await toggleWorkspaceDefault(id);
		} catch (err) {
			console.error("Error cambiando workspace default:", err);
		}
	};

	return (
		<div
			className={
				"alim-drawer-overlay" + (abierto ? " alim-drawer-open" : "")
			}                             // overlay oscuro + animaci√≥n de apertura
			onClick={onCerrar}            // clic fuera del panel cierra el drawer
		>
			<aside
				className="alim-drawer"
				onClick={(e) => e.stopPropagation()} // evita que el clic dentro cierre el drawer
			>
				<header className="alim-drawer-header">
					<h2 className="alim-drawer-title">Panel de Alimentadores</h2>
					{puestoSeleccionado && (
						<p className="alim-drawer-subtitle">
							Puesto actual:{" "}
							<strong>{puestoSeleccionado.nombre}</strong>
						</p>
					)}
				</header>

				{/* Info del usuario */}
				{perfil && (
					<div className="alim-drawer-usuario">
						<span className="alim-drawer-usuario-nombre">{perfil.nombre || perfil.email}</span>
						<span className="alim-drawer-usuario-rol">{perfil.roles?.nombre || rolGlobal}</span>
					</div>
				)}

				{/* Secci√≥n Workspace */}
				<section className="alim-drawer-section">
					<h3 className="alim-drawer-section-title">Workspace</h3>

					{/* Bot√≥n para expandir/colapsar lista de workspaces */}
					<button
						type="button"
						className="alim-drawer-workspace-trigger"
						onClick={() => setSubmenuWorkspaceAbierto(!submenuWorkspaceAbierto)}
					>
						<span className={`alim-drawer-workspace-flecha ${submenuWorkspaceAbierto ? 'alim-drawer-workspace-flecha--abierto' : ''}`}>‚ñ∂</span>
						<span>{configuracionSeleccionada?.nombre || "Sin workspace"}</span>
					</button>

					{/* Lista de workspaces (submen√∫) */}
					{submenuWorkspaceAbierto && (
						<div className="alim-drawer-workspace-lista">
							{configuraciones.map((config) => (
								<div key={config.id} className="alim-drawer-workspace-row">
									<button
										type="button"
										className="alim-drawer-workspace-default-btn"
										onClick={(e) => handleToggleDefault(e, config.id)}
										title={config.id === workspaceDefaultId ? "Quitar como default" : "Establecer como default"}
									>
										{config.id === workspaceDefaultId ? "‚òÖ" : "‚òÜ"}
									</button>
									<button
										type="button"
										className={`alim-drawer-workspace-item ${config.id === configuracionSeleccionada?.id ? 'alim-drawer-workspace-item--activo' : ''}`}
										onClick={() => handleSeleccionarWorkspace(config.id)}
									>
										{config.nombre}
										{!config.esCreador && <em className="alim-drawer-workspace-invitado">(invitado)</em>}
									</button>
								</div>
							))}
						</div>
					)}
				</section>

				<section className="alim-drawer-section">
					<h3 className="alim-drawer-section-title">Puestos</h3>
					<div className="alim-drawer-puestos">
						{puestos.map((p) => (
							<button
								key={p.id}
								className={
									"alim-btn alim-drawer-btn-puesto" +
									(puestoSeleccionado &&
									puestoSeleccionado.id === p.id
										? " alim-btn-active"
										: "")
								}
								style={{
									backgroundColor:
										obtenerColorPuesto(p.id) || coloresSistema[0],
								}}           // usa el color (con soporte para preferencias de invitado)
								onClick={() => handleSeleccionarPuesto(p.id)}
							>
								{p.nombre}
							</button>
						))}
					</div>
				</section>

				{/* Secci√≥n Escala Global */}
				{onEscalaGlobalChange && (
					<section className="alim-drawer-section">
						<h3 className="alim-drawer-section-title">Escala Global</h3>
						<div className="alim-drawer-escala">
							<input
								type="range"
								min={ESCALA_MIN}
								max={ESCALA_MAX}
								step="0.1"
								value={escalaGlobal ?? 1.0}
								onChange={(e) => onEscalaGlobalChange(parseFloat(e.target.value))}
								className="alim-drawer-escala-slider"
							/>
							<div className="alim-drawer-escala-valor">
								<input
									type="number"
									step="0.1"
									min={ESCALA_MIN}
									max={ESCALA_MAX}
									value={escalaGlobal ?? 1.0}
									onChange={(e) => {
										const valor = parseFloat(e.target.value);
										if (!isNaN(valor) && valor >= ESCALA_MIN && valor <= ESCALA_MAX) {
											onEscalaGlobalChange(valor);
										}
									}}
									className="alim-drawer-escala-input"
								/>
								<span className="alim-drawer-escala-x">x</span>
							</div>
							<button
								type="button"
								className="alim-drawer-escala-reset"
								onClick={() => onEscalaGlobalChange(1.0)}
								disabled={escalaGlobal === 1.0}
							>
								Reset
							</button>
						</div>
					</section>
				)}

				<section className="alim-drawer-section">
					<h3 className="alim-drawer-section-title">Acciones</h3>
					<div className="alim-drawer-actions">
						{/* Gestionar Accesos (SOLO el creador del workspace) */}
						{configuracionSeleccionada?.esCreador && (
							<button
								type="button"
								className="alim-drawer-btn-action alim-drawer-btn-accesos"
								onClick={() => handleAccion(onAbrirModalGestionarAccesos)}
							>
								<svg className="alim-drawer-btn-icon-svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
									<path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
								</svg>
								Gestionar Accesos
							</button>
						)}

						{/* Nuevo puesto (creador del workspace O invitado con rol admin en el workspace) */}
						{(configuracionSeleccionada?.esCreador || configuracionSeleccionada?.rol === 'admin') && (
							<button
								type="button"
								className="alim-drawer-btn-action alim-drawer-btn-add"
								onClick={() => handleAccion(onAbrirModalNuevoPuesto)}
							>
								<span className="alim-drawer-btn-icon">+</span>
								<span>Nuevo puesto</span>
							</button>
						)}

						<button
							type="button"
							className="alim-drawer-btn-action alim-drawer-btn-edit"
							onClick={() =>
								handleAccion(onAbrirModalEditarPuestos)
							}
							disabled={puestos.length === 0} // deshabilitado si no hay puestos
						>
							<span className="alim-drawer-btn-icon">‚úé</span>
							<span>Editar puestos</span>
						</button>

						{/* Configurar Agente (creador del workspace O invitado con rol admin en el workspace) */}
						{(configuracionSeleccionada?.esCreador || configuracionSeleccionada?.rol === 'admin') && (
							<button
								type="button"
								className="alim-drawer-btn-action alim-drawer-btn-config"
								onClick={() => handleAccion(onAbrirModalConfigurarAgente)}
							>
								<span className="alim-drawer-btn-icon">‚öô</span>
								Configurar Agente
							</button>
						)}

						{/* Panel de Permisos (solo superadmin) */}
						{rolGlobal === 'superadmin' && (
							<button
								type="button"
								className="alim-drawer-btn-action alim-drawer-btn-permisos"
								onClick={() => handleAccion(onAbrirModalPanelPermisos)}
							>
								<span className="alim-drawer-btn-icon">üîê</span>
								Panel de Permisos
							</button>
						)}

						{/* Crear nuevo workspace (solo si tiene permisos) */}
						{puedeCrearWorkspaces && (
							<>
								{mostrarFormNuevoWorkspace ? (
									<form className="alim-drawer-form-workspace" onSubmit={handleCrearWorkspace}>
										<input
											type="text"
											className="alim-drawer-input"
											placeholder="Nombre del workspace"
											value={nombreNuevoWorkspace}
											onChange={(e) => setNombreNuevoWorkspace(e.target.value)}
											autoFocus
											disabled={creandoWorkspace}
										/>
										<div className="alim-drawer-form-btns">
											<button
												type="button"
												className="alim-drawer-btn-cancelar"
												onClick={() => {
													setMostrarFormNuevoWorkspace(false);
													setNombreNuevoWorkspace("");
												}}
												disabled={creandoWorkspace}
											>
												Cancelar
											</button>
											<button
												type="submit"
												className="alim-drawer-btn-crear"
												disabled={!nombreNuevoWorkspace.trim() || creandoWorkspace}
											>
												{creandoWorkspace ? "..." : "Crear"}
											</button>
										</div>
									</form>
								) : (
									<button
										type="button"
										className="alim-drawer-btn-action alim-drawer-btn-nuevo-workspace"
										onClick={() => setMostrarFormNuevoWorkspace(true)}
									>
										<span className="alim-drawer-btn-icon">+</span>
										Nuevo workspace
									</button>
								)}
							</>
						)}

						<button
							type="button"
							className="alim-drawer-btn-action alim-drawer-btn-salir"
							onClick={() => handleAccion(onSalir)}
						>
							<span className="alim-drawer-btn-icon">‚Ü©</span>
							<span>Salir</span>
						</button>
					</div>
				</section>
			</aside>
		</div>
	);
};

export default MenuLateral;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (MenuLateral.jsx)

 - Este componente es el "men√∫ hamburguesa" del modo compacto: un panel que
   se desliza desde la izquierda y permite cambiar de puesto o ejecutar
   acciones (nuevo puesto, editar puestos, salir).

 - La prop `abierto` decide si se aplican las clases de apertura en el overlay
   y el drawer; `onCerrar` se dispara al hacer clic fuera del panel o en alguna
   acci√≥n interna.

 - `handleSeleccionarPuesto` combina selecci√≥n de puesto + cierre del men√∫ para
   que la navegaci√≥n se sienta m√°s natural en mobile.

 - `handleAccion` es un peque√±o helper que cierra el men√∫ y luego ejecuta la
   acci√≥n que se le pase (abrir modal, salir, etc.), evitando repetir l√≥gica.
---------------------------------------------------------------------------*/}

{/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICI√ìN DE CADA PARTE (MenuLateral.jsx)

0) Visi√≥n general del componente

   `MenuLateral` es el men√∫ tipo ‚Äúhamburguesa‚Äù para el modo compacto (mobile):

   - Se muestra como un overlay oscuro que cubre la pantalla.
   - Desde la izquierda se desliza un panel (`aside`) con:
       ‚Ä¢ lista de puestos (para cambiar de puesto),
       ‚Ä¢ acciones r√°pidas: nuevo puesto, editar puestos, salir.

   La idea es que en pantallas chicas no haya una barra superior recargada, sino
   un panel lateral m√°s c√≥modo para el dedo.


1) Props del componente

   const MenuLateral = ({
     abierto,
     onCerrar,
     puestos,
     puestoSeleccionado,
     onSeleccionarPuesto,
     onAbrirModalNuevoPuesto,
     onAbrirModalEditarPuestos,
     onSalir,
     coloresSistema,
   }) => { ... }

   - `abierto` (boolean):
       ‚Ä¢ true  ‚Üí el drawer se muestra (overlay activo + panel deslizado),
       ‚Ä¢ false ‚Üí el drawer se oculta.

   - `onCerrar()`:
       ‚Ä¢ callback que se llama para cerrar el men√∫,
       ‚Ä¢ se usa tanto al hacer clic fuera del panel como dentro de algunas acciones.

   - `puestos` (array):
       ‚Ä¢ lista de todos los puestos,
       ‚Ä¢ se usa para dibujar un bot√≥n por cada uno.

   - `puestoSeleccionado` (objeto o null):
       ‚Ä¢ el puesto actualmente activo,
       ‚Ä¢ se muestra en el header y se marca su bot√≥n.

   - `onSeleccionarPuesto(idPuesto)`:
       ‚Ä¢ callback que cambia el puesto activo.

   - `onAbrirModalNuevoPuesto()`:
       ‚Ä¢ abre el modal de alta de puesto.

   - `onAbrirModalEditarPuestos()`:
       ‚Ä¢ abre el modal de edici√≥n masiva de puestos.

   - `onSalir()`:
       ‚Ä¢ vuelve al login / pantalla inicial.

   - `coloresSistema` (array):
       ‚Ä¢ paleta para colorear los botones de puestos (fallback si un puesto no tiene `color`).


2) Helpers internos: handleSeleccionarPuesto y handleAccion

   const handleSeleccionarPuesto = (id) => {
     onSeleccionarPuesto(id);
     onCerrar();
   };

   - Combina dos acciones t√≠picas en mobile:
       ‚Ä¢ cambiar el puesto seleccionado,
       ‚Ä¢ cerrar el men√∫ inmediatamente despu√©s.
   - Mejora la experiencia: el usuario toca un puesto ‚Üí se aplica el cambio y
     el panel se pliega solo.

   const handleAccion = (accion) => {
     onCerrar();
     accion();
   };

   - Recibe una funci√≥n `accion` (por ejemplo, `onAbrirModalNuevoPuesto`).
   - Siempre hace dos pasos, en este orden:
       1) cierra el men√∫ (`onCerrar()`),
       2) ejecuta la acci√≥n recibida.
   - Evita repetir la l√≥gica "cerrar + hacer algo" en cada bot√≥n.


3) Overlay principal (fondo oscuro + click fuera)

   return (
     <div
       className={
         "alim-drawer-overlay" + (abierto ? " alim-drawer-open" : "")
       }
       onClick={onCerrar}
     >
       ...
     </div>
   );

   - `className`:
       ‚Ä¢ `"alim-drawer-overlay"`      ‚Üí base del overlay (cubre toda la pantalla),
       ‚Ä¢ si `abierto` es true         ‚Üí agrega `" alim-drawer-open"`, que normalmente
                                        activa opacidad/animaci√≥n para mostrar el panel.

   - `onClick={onCerrar}`:
       ‚Ä¢ cualquier clic sobre el overlay (fuera del panel) cierra el men√∫,
       ‚Ä¢ es el comportamiento t√≠pico de un drawer en mobile.


4) Panel lateral <aside> y cabecera

   <aside
     className="alim-drawer"
     onClick={(e) => e.stopPropagation()}
   >
     <header className="alim-drawer-header">
       <h2 className="alim-drawer-title">Panel de Alimentadores</h2>
       {puestoSeleccionado && (
         <p className="alim-drawer-subtitle">
           Puesto actual: <strong>{puestoSeleccionado.nombre}</strong>
         </p>
       )}
     </header>
     ...
   </aside>

   - `<aside className="alim-drawer">`:
       ‚Ä¢ es el panel blanco que se desliza desde la izquierda.

   - `onClick={(e) => e.stopPropagation()}`:
       ‚Ä¢ evita que el clic dentro del panel ‚Äúsuba‚Äù al overlay,
       ‚Ä¢ si no estuviera, cualquier clic adentro tambi√©n disparar√≠a `onCerrar`.

   - Header:
       ‚Ä¢ t√≠tulo fijo: ‚ÄúPanel de Alimentadores‚Äù,
       ‚Ä¢ si hay `puestoSeleccionado`, muestra ‚ÄúPuesto actual: <nombre>‚Äù
         para que el usuario sepa d√≥nde est√° parado.


5) Secci√≥n de puestos

   <section className="alim-drawer-section">
     <h3 className="alim-drawer-section-title">Puestos</h3>
     <div className="alim-drawer-puestos">
       {puestos.map((p) => (
         <button
           key={p.id}
           className={
             "alim-btn alim-drawer-btn-puesto" +
             (puestoSeleccionado && puestoSeleccionado.id === p.id
               ? " alim-btn-active"
               : "")
           }
           style={{
             backgroundColor: p.color || coloresSistema[0],
           }}
           onClick={() => handleSeleccionarPuesto(p.id)}
         >
           {p.nombre}
         </button>
       ))}
     </div>
   </section>

   - Se recorre el array `puestos` y se crea un bot√≥n por cada puesto.

   - `className`:
       ‚Ä¢ `"alim-btn alim-drawer-btn-puesto"` ‚Üí estilo base del bot√≥n dentro del drawer,
       ‚Ä¢ si el puesto es el actual (`puestoSeleccionado.id === p.id`), se agrega
         `" alim-btn-active"` para resaltarlo visualmente.

   - `style={{ backgroundColor: p.color || coloresSistema[0] }}`:
       ‚Ä¢ usa el color espec√≠fico del puesto (`p.color`),
       ‚Ä¢ si no tiene, usa el primer color de la paleta.

   - `onClick={() => handleSeleccionarPuesto(p.id)}`:
       ‚Ä¢ selecciona el puesto y cierra el men√∫ (por c√≥mo se implement√≥ el helper).


6) Secci√≥n de acciones

   <section className="alim-drawer-section">
     <h3 className="alim-drawer-section-title">Acciones</h3>
     <div className="alim-drawer-actions">
       <button
         type="button"
         className="alim-btn alim-drawer-btn-action alim-drawer-btn-add"
         onClick={() => handleAccion(onAbrirModalNuevoPuesto)}
       >
         <span className="alim-drawer-btn-add-icon">+</span>
         <span>Nuevo puesto</span>
       </button>

       <button
         type="button"
         className="alim-btn alim-drawer-btn-action alim-btn-edit"
         onClick={() => handleAccion(onAbrirModalEditarPuestos)}
         disabled={puestos.length === 0}
       >
         ‚úé Editar puestos
       </button>

       <button
         type="button"
         className="alim-btn-exit alim-drawer-btn-action"
         onClick={() => handleAccion(onSalir)}
       >
         Salir
       </button>
     </div>
   </section>

   - ‚ÄúNuevo puesto‚Äù:
       ‚Ä¢ bot√≥n con √≠cono ‚Äú+‚Äù y texto ‚ÄúNuevo puesto‚Äù,
       ‚Ä¢ `onClick={() => handleAccion(onAbrirModalNuevoPuesto)}`:
           - cierra el men√∫,
           - abre el modal de creaci√≥n de puesto.

   - ‚ÄúEditar puestos‚Äù:
       ‚Ä¢ muestra √≠cono ‚úé + texto ‚ÄúEditar puestos‚Äù,
       ‚Ä¢ `onClick={() => handleAccion(onAbrirModalEditarPuestos)}`,
       ‚Ä¢ `disabled={puestos.length === 0}`:
           - si no hay ning√∫n puesto, no tiene sentido editar ‚Üí se deshabilita.

   - ‚ÄúSalir‚Äù:
       ‚Ä¢ bot√≥n con estilo de salida (`alim-btn-exit`),
       ‚Ä¢ `onClick={() => handleAccion(onSalir)}`:
           - cierra el men√∫,
           - y luego ejecuta la l√≥gica de salida (normalmente `navigate("/")`). 


7) Export

   export default MenuLateral;

   - Exporta el componente para que `VistaAlimentadores` pueda usarlo.

   - Esa vista controla:
       ‚Ä¢ cu√°ndo abrirlo (`abierto`),
       ‚Ä¢ y qu√© callbacks pasarle (seleccionar puesto, nuevo, editar, salir).

---------------------------------------------------------------------------*/}

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/SelectorConfiguracion.css =====

/* src/paginas/PaginaAlimentadores/componentes/navegacion/SelectorConfiguracion.css */

.selector-config {
  position: relative;
  display: inline-flex;
  align-items: center;
}

.selector-config--cargando,
.selector-config--error {
  padding: 8px 12px;
  font-size: 0.875rem;
  color: #64748b;
}

.selector-config--error {
  color: #ef4444;
}

.selector-config__spinner {
  display: inline-block;
  width: 14px;
  height: 14px;
  margin-right: 6px;
  border: 2px solid #e2e8f0;
  border-top-color: #3b82f6;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Bot√≥n trigger - tema oscuro para navbar */
.selector-config__trigger {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 0.5rem 1rem;
  background: #1e293b;
  border: 1px solid #475569;
  border-radius: 8px;
  font-size: 0.875rem;
  color: #f1f5f9;
  cursor: pointer;
  transition: all 0.2s ease;
}

.selector-config__trigger:hover {
  background: #334155;
  border-color: #64748b;
}

.selector-config__icono {
  font-size: 1rem;
  color: #94a3b8;
}

.selector-config__nombre {
  font-weight: 600;
  max-width: 160px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: #f1f5f9;
}

.selector-config__flecha {
  font-size: 0.6rem;
  color: #94a3b8;
  margin-left: 4px;
}

/* Overlay */
.selector-config__overlay {
  position: fixed;
  inset: 0;
  z-index: 99;
}

/* Men√∫ dropdown - tema oscuro */
.selector-config__menu {
  position: absolute;
  top: calc(100% + 4px);
  right: 0;
  min-width: 240px;
  max-width: 320px;
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  z-index: 100;
  overflow: visible;
}

/* Header del usuario */
.selector-config__usuario-header {
  padding: 12px 16px;
  background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
  border-bottom: 1px solid #334155;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.selector-config__usuario-nombre {
  font-size: 0.9rem;
  font-weight: 600;
  color: #f1f5f9;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.selector-config__usuario-rol {
  font-size: 0.75rem;
  color: #10b981;
  font-weight: 500;
  text-transform: capitalize;
}

.selector-config__usuario-linea {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 4px 8px;
}

.selector-config__rol-global {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 0.8rem;
  color: #10b981;
  font-weight: 600;
}

.selector-config__rol-icono {
  width: 13px;
  height: 13px;
  flex-shrink: 0;
}

.selector-config__rol-workspace {
  font-size: 0.78rem;
  color: #a78bfa;
  font-weight: 600;
  margin-top: 4px;
}

/* Lista de configuraciones */
.selector-config__lista {
  list-style: none;
  margin: 0;
  padding: 4px 0;
  max-height: 240px;
  overflow-y: auto;
}

.selector-config__item {
  display: flex;
  align-items: center;
  padding: 0 4px;
}

/* Bot√≥n de estrella para workspace default */
.selector-config__default-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  padding: 0;
  margin-left: 4px;
  background: transparent;
  border: none;
  font-size: 1rem;
  color: #64748b;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.15s ease;
  flex-shrink: 0;
}

.selector-config__default-btn:hover {
  background: #334155;
  color: #fbbf24;
}

/* Estrella activa (workspace default) */
.selector-config__item .selector-config__default-btn:first-child {
  color: #64748b;
}

.selector-config__item .selector-config__default-btn:first-child:hover {
  color: #fbbf24;
}

/* Cuando es el workspace default, la estrella es amarilla */
.selector-config__item .selector-config__default-btn[title="Quitar como default"] {
  color: #fbbf24;
}

.selector-config__item .selector-config__default-btn[title="Quitar como default"]:hover {
  color: #f59e0b;
}

.selector-config__item-btn {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 2px;
  padding: 10px 12px;
  background: transparent;
  border: none;
  text-align: left;
  font-size: 0.875rem;
  color: #f1f5f9;
  cursor: pointer;
  border-radius: 4px;
  transition: background 0.15s ease;
}

.selector-config__item-btn:hover {
  background: #334155;
}

.selector-config__item--activo .selector-config__item-btn {
  background: #1e3a5f;
  color: #60a5fa;
  font-weight: 500;
}

/* Nombre del workspace con badge de invitado */
.selector-config__item-nombre {
  display: flex;
  align-items: center;
  gap: 6px;
}

.selector-config__item-invitado {
  font-style: italic;
  font-size: 0.75rem;
  color: #fbbf24;
  font-weight: 400;
}

.selector-config__item--activo .selector-config__item-invitado {
  color: #fbbf24;
}

/* Rol del workspace (solo para invitados) */
.selector-config__item-rol {
  font-size: 0.7rem;
  color: #f1f5f9;
}

.selector-config__item-rol em {
  font-style: italic;
}

.selector-config__item--activo .selector-config__item-rol {
  color: #f1f5f9;
}

.selector-config__eliminar {
  padding: 6px 8px;
  background: transparent;
  border: none;
  color: #64748b;
  cursor: pointer;
  border-radius: 4px;
  font-size: 0.75rem;
  transition: all 0.15s ease;
}

.selector-config__eliminar:hover {
  background: #5f1e1e;
  color: #f87171;
}

/* Estado vac√≠o */
.selector-config__vacio {
  padding: 16px;
  text-align: center;
  color: #94a3b8;
  font-size: 0.875rem;
}

/* Separador */
.selector-config__separador {
  height: 1px;
  background: #334155;
  margin: 4px 0;
}

/* Bot√≥n nueva configuraci√≥n */
.selector-config__nueva {
  display: block;
  width: 100%;
  padding: 10px 12px;
  background: transparent;
  border: none;
  text-align: left;
  font-size: 0.875rem;
  color: #60a5fa;
  cursor: pointer;
  transition: background 0.15s ease;
}

.selector-config__nueva:hover {
  background: #334155;
}

/* Opci√≥n secundaria (editar puestos, etc.) */
.selector-config__opcion-secundaria {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  padding: 10px 12px;
  background: #283548;
  border: none;
  text-align: left;
  font-size: 0.875rem;
  color: #f1f5f9;
  cursor: pointer;
  transition: background 0.15s ease, color 0.15s ease;
}

.selector-config__opcion-secundaria:hover:not(:disabled) {
  background: #334155;
}

.selector-config__opcion-secundaria:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.selector-config__opcion-icono {
  font-size: 1rem;
  width: 20px;
  text-align: center;
  flex-shrink: 0;
}

.selector-config__opcion-icono-svg {
  width: 16px;
  height: 16px;
  flex-shrink: 0;
  color: #f1f5f9;
  vertical-align: middle;
  margin-right: 2px;
}

/* Bot√≥n eliminar workspace activo */
.selector-config__eliminar-activo {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  padding: 10px 12px;
  background: #283548;
  border: none;
  text-align: left;
  font-size: 0.875rem;
  color: #f1f5f9;
  cursor: pointer;
  transition: background 0.15s ease, color 0.15s ease;
}

.selector-config__eliminar-activo:hover {
  background: #7f1d1d;
  color: #f1f5f9;
}

.selector-config__eliminar-icono {
  font-size: 1.1rem;
  width: 20px;
  text-align: center;
  flex-shrink: 0;
}

/* Form para crear nueva */
.selector-config__form {
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  background: #0f172a;
  border-top: 1px solid #334155;
}

.selector-config__input {
  padding: 8px 12px;
  background: #1e293b;
  border: 1px solid #475569;
  border-radius: 6px;
  font-size: 0.875rem;
  color: #f1f5f9;
  outline: none;
  transition: border-color 0.15s ease, box-shadow 0.15s ease;
}

.selector-config__input::placeholder {
  color: #64748b;
}

.selector-config__input:focus {
  border-color: #3b82f6;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}

.selector-config__form-btns {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}

.selector-config__btn-cancelar,
.selector-config__btn-crear {
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 0.813rem;
  cursor: pointer;
  transition: all 0.15s ease;
}

.selector-config__btn-cancelar {
  background: #475569;
  border: 1px solid #475569;
  color: #f1f5f9;
}

.selector-config__btn-cancelar:hover {
  background: #64748b;
}

.selector-config__btn-crear {
  background: #1e3a5f;
  border: 1px solid #3b82f6;
  color: #60a5fa;
}

.selector-config__btn-crear:hover:not(:disabled) {
  background: #2563eb;
  color: #fff;
}

.selector-config__btn-crear:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* ===== SUBMEN√ö ===== */
.selector-config__submenu-container {
  position: relative;
}

.selector-config__submenu-trigger {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  padding: 10px 12px;
  background: transparent;
  border: none;
  text-align: center;
  font-size: 0.875rem;
  color: #f1f5f9;
  cursor: pointer;
  border-radius: 4px;
  transition: background 0.15s ease;
}

.selector-config__submenu-trigger:hover,
.selector-config__submenu-trigger--activo {
  background: #334155;
}

.selector-config__submenu-flecha {
  position: absolute;
  left: 12px;
  font-size: 0.6rem;
  color: #94a3b8;
  transform: rotate(90deg);
  transition: transform 0.2s ease, color 0.15s ease;
}

.selector-config__submenu-flecha--abierto {
  transform: rotate(-90deg);
}

.selector-config__submenu-trigger:hover .selector-config__submenu-flecha,
.selector-config__submenu-trigger--activo .selector-config__submenu-flecha {
  color: #f1f5f9;
}

/* Submen√∫ desplegable a la izquierda */
.selector-config__submenu {
  position: absolute;
  top: 0;
  right: calc(100% + 4px);
  min-width: 180px;
  max-width: 280px;
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  z-index: 101;
  overflow: hidden;
}

.selector-config__submenu .selector-config__lista {
  padding: 4px 0;
}

.selector-config__submenu .selector-config__item {
  padding: 0 4px;
}

.selector-config__submenu .selector-config__vacio {
  padding: 12px;
}

/* ===== ESTADO SIN WORKSPACES ===== */

/* Bot√≥n trigger verde para crear workspace */
.selector-config__trigger--crear {
  background: linear-gradient(135deg, #059669 0%, #047857 100%);
  border-color: #10b981;
  color: #ecfdf5;
}

.selector-config__trigger--crear:hover {
  background: linear-gradient(135deg, #047857 0%, #065f46 100%);
  border-color: #34d399;
}

.selector-config__trigger--crear .selector-config__nombre {
  color: #ecfdf5;
  font-weight: 600;
}

/* Mensaje de estado vac√≠o */
.selector-config__vacio-mensaje {
  padding: 16px;
  text-align: center;
  color: #94a3b8;
  font-size: 0.875rem;
  line-height: 1.5;
  border-bottom: 1px solid #334155;
}

/* Bot√≥n destacado para crear primer workspace */
.selector-config__nueva--destacado {
  background: linear-gradient(135deg, #059669 0%, #047857 100%);
  color: #ecfdf5;
  font-weight: 600;
  text-align: center;
  padding: 12px 16px;
  border-radius: 0 0 8px 8px;
}

.selector-config__nueva--destacado:hover {
  background: linear-gradient(135deg, #047857 0%, #065f46 100%);
}

/* Bot√≥n trigger deshabilitado (usuario sin permisos) */
.selector-config__trigger--deshabilitado {
  background: #374151;
  border-color: #4b5563;
  color: #9ca3af;
  cursor: pointer;
}

.selector-config__trigger--deshabilitado:hover {
  background: #4b5563;
  border-color: #6b7280;
}

.selector-config__trigger--deshabilitado .selector-config__nombre {
  color: #9ca3af;
}

/* Mensaje informativo para usuarios sin permisos */
.selector-config__vacio-mensaje--info {
  border-bottom: none;
  padding: 20px 16px;
}

.selector-config__vacio-mensaje--info small {
  display: block;
  margin-top: 8px;
  color: #64748b;
  font-size: 0.75rem;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/SelectorConfiguracion.jsx =====

// src/paginas/PaginaAlimentadores/componentes/navegacion/SelectorConfiguracion.jsx
// Componente para seleccionar y gestionar workspaces

import React, { useState, useRef, useEffect } from "react";
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import ModalConfirmacion from "../modales/ModalConfirmacion";
import "./SelectorConfiguracion.css";

/**
 * Selector dropdown de workspaces.
 * Permite cambiar entre workspaces y crear nuevos.
 */
const SelectorConfiguracion = ({ onAbrirModalEditarPuestos, onAbrirModalNuevoPuesto, onAbrirModalConfigurarAgente, onAbrirModalGestionarAccesos, onAbrirModalPanelPermisos, puestosLength = 0 }) => {
  const {
    configuraciones,
    configuracionSeleccionada,
    cargando,
    error,
    seleccionarConfiguracion,
    agregarConfiguracion,
    eliminarConfiguracion,
    puedeCrearWorkspaces,
    rolGlobal,
    perfil,
    workspaceDefaultId,
    toggleWorkspaceDefault,
  } = usarContextoConfiguracion();

  const [menuAbierto, setMenuAbierto] = useState(false);
  const [mostrarFormNueva, setMostrarFormNueva] = useState(false);
  const [nombreNueva, setNombreNueva] = useState("");
  const [creando, setCreando] = useState(false);
  const [submenuAbierto, setSubmenuAbierto] = useState(false);
  const [modalEliminarAbierto, setModalEliminarAbierto] = useState(false);

  const hoverTimeoutRef = useRef(null);
  const submenuRef = useRef(null);

  // Limpiar timeout al desmontar
  useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);

  // Cerrar submen√∫ cuando se cierra el men√∫ principal
  useEffect(() => {
    if (!menuAbierto) {
      setSubmenuAbierto(false);
    }
  }, [menuAbierto]);

  const handleSubmenuMouseEnter = () => {
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }
    hoverTimeoutRef.current = setTimeout(() => {
      setSubmenuAbierto(true);
    }, 300); // 300ms de delay para abrir
  };

  const handleSubmenuMouseLeave = () => {
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }
    hoverTimeoutRef.current = setTimeout(() => {
      setSubmenuAbierto(false);
    }, 200); // 200ms de delay para cerrar
  };

  const handleSubmenuClick = () => {
    setSubmenuAbierto(!submenuAbierto);
  };

  const handleSeleccionar = (id) => {
    seleccionarConfiguracion(id);
    setSubmenuAbierto(false);
    setMenuAbierto(false);
  };

  const handleToggleDefault = async (e, id) => {
    e.stopPropagation(); // Evitar que se seleccione el workspace
    try {
      await toggleWorkspaceDefault(id);
    } catch (err) {
      console.error("Error cambiando workspace default:", err);
    }
  };

  const handleCrearNueva = async (e) => {
    e.preventDefault();
    if (!nombreNueva.trim()) return;

    try {
      setCreando(true);
      await agregarConfiguracion(nombreNueva.trim());
      setNombreNueva("");
      setMostrarFormNueva(false);
      setMenuAbierto(false);
    } catch (err) {
      console.error("Error creando workspace:", err);
    } finally {
      setCreando(false);
    }
  };

  const handleEliminarActivo = () => {
    if (!configuracionSeleccionada) return;
    if (configuraciones.length <= 1) {
      alert("No se puede eliminar el √∫nico workspace existente.");
      return;
    }
    // Abrir modal de confirmaci√≥n
    setModalEliminarAbierto(true);
  };

  const confirmarEliminarWorkspace = async () => {
    try {
      // Encontrar el √≠ndice del workspace activo
      const indiceActual = configuraciones.findIndex(c => c.id === configuracionSeleccionada.id);

      // Determinar a qu√© workspace cambiar: anterior si existe, sino siguiente
      let nuevoWorkspace;
      if (indiceActual > 0) {
        nuevoWorkspace = configuraciones[indiceActual - 1];
      } else {
        nuevoWorkspace = configuraciones[indiceActual + 1];
      }

      // Cambiar al nuevo workspace antes de eliminar
      seleccionarConfiguracion(nuevoWorkspace.id);

      // Eliminar el workspace
      await eliminarConfiguracion(configuracionSeleccionada.id);

      setModalEliminarAbierto(false);
      setMenuAbierto(false);
    } catch (err) {
      console.error("Error eliminando workspace:", err);
    }
  };

  if (cargando) {
    return (
      <div className="selector-config selector-config--cargando">
        <span className="selector-config__spinner"></span>
        Cargando...
      </div>
    );
  }

  if (error) {
    return (
      <div className="selector-config selector-config--error">
        Error: {error}
      </div>
    );
  }

  // Si no hay workspaces, mostrar estado seg√∫n permisos del rol
  if (configuraciones.length === 0) {
    // Usuarios sin permiso para crear (operador, observador)
    if (!puedeCrearWorkspaces) {
      return (
        <div className="selector-config">
          <button
            type="button"
            className="selector-config__trigger selector-config__trigger--deshabilitado"
            onClick={() => setMenuAbierto(!menuAbierto)}
            aria-expanded={menuAbierto}
          >
            <span className="selector-config__nombre">Sin workspace</span>
            <span className="selector-config__flecha">{menuAbierto ? "‚ñ≤" : "‚ñº"}</span>
          </button>

          {menuAbierto && (
            <>
              <div
                className="selector-config__overlay"
                onClick={() => setMenuAbierto(false)}
              />
              <div className="selector-config__menu">
                {/* Header con usuario y rol */}
                {perfil && (
                  <div className="selector-config__usuario-header">
                    <span className="selector-config__usuario-nombre">{perfil.nombre || perfil.email}</span>
                    <span className="selector-config__usuario-rol">{perfil.roles?.nombre || rolGlobal}</span>
                  </div>
                )}
                <div className="selector-config__vacio-mensaje selector-config__vacio-mensaje--info">
                  No tienes workspaces asignados.
                  <br />
                  <small>Contacta a un administrador para ser invitado a un workspace.</small>
                </div>
              </div>
            </>
          )}
        </div>
      );
    }

    // Usuarios con permiso para crear (superadmin, admin)
    return (
      <div className="selector-config">
        <button
          type="button"
          className="selector-config__trigger selector-config__trigger--crear"
          onClick={() => setMenuAbierto(!menuAbierto)}
          aria-expanded={menuAbierto}
        >
          <span className="selector-config__nombre">+ Crear Workspace</span>
        </button>

        {menuAbierto && (
          <>
            <div
              className="selector-config__overlay"
              onClick={() => {
                setMenuAbierto(false);
                setMostrarFormNueva(false);
              }}
            />
            <div className="selector-config__menu">
              {/* Header con usuario y rol */}
              {perfil && (
                <div className="selector-config__usuario-header">
                  <span className="selector-config__usuario-nombre">{perfil.nombre || perfil.email}</span>
                  <span className="selector-config__usuario-rol">{perfil.roles?.nombre || rolGlobal}</span>
                </div>
              )}
              <div className="selector-config__vacio-mensaje">
                No tienes workspaces asignados.
                <br />
                Crea uno para empezar.
              </div>
              {mostrarFormNueva ? (
                <form className="selector-config__form" onSubmit={handleCrearNueva}>
                  <input
                    type="text"
                    className="selector-config__input"
                    placeholder="Nombre del workspace"
                    value={nombreNueva}
                    onChange={(e) => setNombreNueva(e.target.value)}
                    autoFocus
                    disabled={creando}
                  />
                  <div className="selector-config__form-btns">
                    <button
                      type="button"
                      className="selector-config__btn-cancelar"
                      onClick={() => {
                        setMostrarFormNueva(false);
                        setNombreNueva("");
                      }}
                      disabled={creando}
                    >
                      Cancelar
                    </button>
                    <button
                      type="submit"
                      className="selector-config__btn-crear"
                      disabled={!nombreNueva.trim() || creando}
                    >
                      {creando ? "Creando..." : "Crear"}
                    </button>
                  </div>
                </form>
              ) : (
                <button
                  type="button"
                  className="selector-config__nueva selector-config__nueva--destacado"
                  onClick={() => setMostrarFormNueva(true)}
                >
                  + Crear mi primer workspace
                </button>
              )}
            </div>
          </>
        )}
      </div>
    );
  }

  return (
    <div className="selector-config">
      <button
        type="button"
        className="selector-config__trigger"
        onClick={() => setMenuAbierto(!menuAbierto)}
        aria-expanded={menuAbierto}
        aria-haspopup="listbox"
      >
        <span className="selector-config__nombre">
          {configuracionSeleccionada?.nombre || "Sin workspace"}
        </span>
        <span className="selector-config__flecha">{menuAbierto ? "‚ñ≤" : "‚ñº"}</span>
      </button>

      {menuAbierto && (
        <>
          {/* Overlay para cerrar al hacer clic fuera */}
          <div
            className="selector-config__overlay"
            onClick={() => {
              setMenuAbierto(false);
              setMostrarFormNueva(false);
            }}
          />

          <div className="selector-config__menu" role="listbox">
            {/* Header con usuario y roles (global + workspace) */}
            {perfil && (
              <div className="selector-config__usuario-header">
                {/* Nombre + Rol global en la misma l√≠nea */}
                <div className="selector-config__usuario-linea">
                  <span className="selector-config__usuario-nombre">{perfil.nombre || perfil.email}</span>
                  <span className="selector-config__rol-global">
                    [ <svg className="selector-config__rol-icono" viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                    </svg>
                    {(() => {
                      const nombresRol = {
                        'superadmin': 'SuperAdmin',
                        'admin': 'Admin',
                        'operador': 'Operador',
                        'observador': 'Observador',
                      };
                      return nombresRol[rolGlobal] || 'Observador';
                    })()} ]
                  </span>
                </div>
                {/* Rol en workspace (solo si es invitado) */}
                {(() => {
                  const rolEnWs = configuracionSeleccionada?.rol;
                  const esCreador = configuracionSeleccionada?.esCreador;

                  if (esCreador === false && rolEnWs) {
                    const nombresRol = {
                      'admin': 'Admin',
                      'operador': 'Operador',
                      'observador': 'Observador',
                    };
                    return (
                      <span className="selector-config__rol-workspace">
                        Rol en Workspace: {nombresRol[rolEnWs] || 'Observador'}
                      </span>
                    );
                  }
                  return null;
                })()}
              </div>
            )}

            {/* Opci√≥n Workspaces con submen√∫ */}
            <div
              className="selector-config__submenu-container"
              ref={submenuRef}
              onMouseEnter={handleSubmenuMouseEnter}
              onMouseLeave={handleSubmenuMouseLeave}
            >
              <button
                type="button"
                className={`selector-config__submenu-trigger ${submenuAbierto ? 'selector-config__submenu-trigger--activo' : ''}`}
                onClick={handleSubmenuClick}
              >
                <span className={`selector-config__submenu-flecha ${submenuAbierto ? 'selector-config__submenu-flecha--abierto' : ''}`}>‚ñº</span>
                <span>Workspace</span>
              </button>

              {/* Submen√∫ de workspaces */}
              {submenuAbierto && (
                <div
                  className="selector-config__submenu"
                  onMouseEnter={handleSubmenuMouseEnter}
                  onMouseLeave={handleSubmenuMouseLeave}
                >
                  {configuraciones.length > 0 ? (
                    <ul className="selector-config__lista">
                      {configuraciones.map((config) => (
                        <li
                          key={config.id}
                          className={`selector-config__item ${
                            config.id === configuracionSeleccionada?.id
                              ? "selector-config__item--activo"
                              : ""
                          }`}
                        >
                          <button
                            type="button"
                            className="selector-config__default-btn"
                            onClick={(e) => handleToggleDefault(e, config.id)}
                            title={config.id === workspaceDefaultId ? "Quitar como default" : "Establecer como default"}
                          >
                            {config.id === workspaceDefaultId ? "‚òÖ" : "‚òÜ"}
                          </button>
                          <button
                            type="button"
                            className="selector-config__item-btn"
                            onClick={() => handleSeleccionar(config.id)}
                            role="option"
                            aria-selected={config.id === configuracionSeleccionada?.id}
                          >
                            <span className="selector-config__item-nombre">
                              {config.nombre}
                              {!config.esCreador && <em className="selector-config__item-invitado">(invitado)</em>}
                            </span>
                            {!config.esCreador && (
                              <span className="selector-config__item-rol">
                                <em>rol: {config.rol || 'observador'}</em>
                              </span>
                            )}
                          </button>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <div className="selector-config__vacio">
                      No hay workspaces
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Separador */}
            <div className="selector-config__separador" />

            {/* Bot√≥n/Form para crear nuevo */}
            {mostrarFormNueva ? (
              <form className="selector-config__form" onSubmit={handleCrearNueva}>
                <input
                  type="text"
                  className="selector-config__input"
                  placeholder="Nombre del workspace"
                  value={nombreNueva}
                  onChange={(e) => setNombreNueva(e.target.value)}
                  autoFocus
                  disabled={creando}
                />
                <div className="selector-config__form-btns">
                  <button
                    type="button"
                    className="selector-config__btn-cancelar"
                    onClick={() => {
                      setMostrarFormNueva(false);
                      setNombreNueva("");
                    }}
                    disabled={creando}
                  >
                    Cancelar
                  </button>
                  <button
                    type="submit"
                    className="selector-config__btn-crear"
                    disabled={!nombreNueva.trim() || creando}
                  >
                    {creando ? "Creando..." : "Crear"}
                  </button>
                </div>
              </form>
            ) : (
              <>
                {/*
                  Permisos en el men√∫:
                  - rolGlobal: rol global del usuario en el sistema (superadmin, admin, operador, observador)
                  - configuracionSeleccionada?.rol: rol del usuario EN ESTE WORKSPACE espec√≠fico
                  - configuracionSeleccionada?.esCreador: true si el usuario es el creador del workspace
                  - Gestionar Accesos: SOLO el creador del workspace
                  - Nuevo puesto / Configurar Agente: creador O invitado con rol admin en el workspace
                  - Editar puestos: creador, admin o operador en el workspace
                  - Panel de Permisos: SOLO superadmin global
                */}
                {(() => {
                  const rolEnWorkspace = configuracionSeleccionada?.rol;
                  const esCreador = configuracionSeleccionada?.esCreador;
                  // Para Nuevo puesto: creador O invitado con rol admin en el workspace (NO incluye superadmin global)
                  const puedeCrearPuesto = esCreador || rolEnWorkspace === 'admin';
                  // Para Editar puestos: creador, admin en workspace, o operador en workspace
                  const esOperadorEnWorkspace = puedeCrearPuesto || rolEnWorkspace === 'operador';

                  return (
                    <>
                      {/* Opci√≥n gestionar accesos (SOLO el creador del workspace) */}
                      {esCreador && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalGestionarAccesos?.();
                          }}
                        >
                          <svg className="selector-config__opcion-icono-svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                            <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                          </svg>
                          Gestionar Accesos
                        </button>
                      )}

                      {/* Opci√≥n nuevo puesto (creador O invitado con rol admin en el workspace) */}
                      {puedeCrearPuesto && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalNuevoPuesto?.();
                          }}
                        >
                          <span className="selector-config__opcion-icono">+</span>
                          Nuevo puesto
                        </button>
                      )}

                      {/* Opci√≥n editar puestos (admin u operador en workspace) */}
                      {esOperadorEnWorkspace && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalEditarPuestos?.();
                          }}
                          disabled={puestosLength === 0}
                        >
                          <span className="selector-config__opcion-icono">‚úé</span>
                          Editar puestos
                        </button>
                      )}

                      {/* Opci√≥n configurar agente (creador O invitado con rol admin en el workspace) */}
                      {puedeCrearPuesto && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalConfigurarAgente?.();
                          }}
                        >
                          <span className="selector-config__opcion-icono">‚öô</span>
                          Configurar Agente
                        </button>
                      )}
                    </>
                  );
                })()}

                {/* Opci√≥n panel de permisos (solo superadmin GLOBAL) */}
                {rolGlobal === 'superadmin' && (
                  <button
                    type="button"
                    className="selector-config__opcion-secundaria"
                    onClick={() => {
                      setMenuAbierto(false);
                      onAbrirModalPanelPermisos?.();
                    }}
                  >
                    <span className="selector-config__opcion-icono">üîê</span>
                    Panel de Permisos
                  </button>
                )}

                {/* Opci√≥n eliminar workspace activo (solo si hay m√°s de uno y es creador/admin) */}
                {configuraciones.length > 1 && configuracionSeleccionada?.esCreador && (
                  <button
                    type="button"
                    className="selector-config__eliminar-activo"
                    onClick={handleEliminarActivo}
                  >
                    <span className="selector-config__eliminar-icono">üóë</span>
                    Eliminar workspace
                  </button>
                )}

                {/* Solo mostrar bot√≥n de crear si tiene permisos */}
                {puedeCrearWorkspaces && (
                  <button
                    type="button"
                    className="selector-config__nueva"
                    onClick={() => setMostrarFormNueva(true)}
                  >
                    + Nuevo workspace
                  </button>
                )}
              </>
            )}
          </div>
        </>
      )}

      {/* Modal de confirmaci√≥n para eliminar workspace */}
      <ModalConfirmacion
        abierto={modalEliminarAbierto}
        titulo="Eliminar workspace"
        mensaje={`¬øEst√°s seguro de que deseas eliminar el workspace "${configuracionSeleccionada?.nombre}"? Esta acci√≥n no se puede deshacer.`}
        textoConfirmar="Eliminar"
        textoCancelar="Cancelar"
        peligroso={true}
        onConfirmar={confirmarEliminarWorkspace}
        onCancelar={() => setModalEliminarAbierto(false)}
      />
    </div>
  );
};

export default SelectorConfiguracion;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/CajaMedicion.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/CajaMedicion.jsx

import React from "react";

/**
 * Formatea un valor seg√∫n la cantidad de decimales configurada.
 * Solo afecta a valores num√©ricos, no modifica el valor interno.
 * @param {string} valor - Valor original (puede ser "--,--" o n√∫mero con coma)
 * @param {number} decimales - Cantidad de decimales a mostrar (0, 1 o 2)
 */
const formatearValorConDecimales = (valor, decimales) => {
	// Si no se especifica decimales, usar 2 por defecto
	if (decimales === undefined || decimales === null) return valor;

	// Si es placeholder, ajustar seg√∫n decimales
	if (valor === "--,--" || valor === "--" || valor === "--,-") {
		if (decimales === 0) return "--";
		if (decimales === 1) return "--,-";
		return "--,--";
	}

	// Convertir coma a punto para parsear
	const numStr = String(valor).replace(",", ".");
	const num = parseFloat(numStr);
	if (isNaN(num)) return valor;

	return num.toFixed(decimales).replace(".", ",");
};

/**
 * Caja individual de medici√≥n con su animaci√≥n de borde y valor.
 */
const CajaMedicion = ({
	box,                              // { etiqueta, valor, enabled, origen }
	indice,                           // posici√≥n dentro del grupo (0..3)
	zona,                             // "sup" o "inf" para identificar el lado
	mideRele,                         // indica si la medici√≥n de rel√© est√° activa
	mideAnalizador,                   // indica si la medici√≥n de analizador est√° activa
	mostrarProgresoRele,              // activa animaci√≥n de borde para rel√©
	mostrarProgresoAnalizador,        // activa animaci√≥n de borde para analizador
	periodoRele,                      // periodo configurado (segundos) para rel√©
	periodoAnalizador,                // periodo configurado (segundos) para analizador
	contadorRele,                     // cu√°ntas lecturas se hicieron para rel√©
	contadorAnalizador,               // cu√°ntas lecturas se hicieron para analizador
	// Polling de lecturas desde BD
	estaPolling = false,              // indica si hay polling activo
	mostrarProgresoPolling = false,   // activa animaci√≥n de borde para polling
	periodoPolling = 60,              // periodo de polling en segundos
	contadorPolling = 0,              // cu√°ntas lecturas se hicieron durante polling
	// Error de polling
	tieneError = false,               // indica si hay error de lectura
	// Estilos globales del box
	estilosBox = null,                // { tituloBox, valorBox, box }
}) => {
	const esDelRele = box.origen === "rele" || !box.origen;       // si no se especifica origen, asumimos rel√©
	const esDelAnalizador = box.origen === "analizador";

	// ===== MODO POLLING (tiene prioridad cuando est√° activo) =====
	// En modo polling, todas las cajas habilitadas muestran animaci√≥n
	const pollingActivo = estaPolling && box.enabled;
	const progresoPollingHabilitado = pollingActivo && mostrarProgresoPolling;

	// ===== MODO MEDICI√ìN TRADICIONAL (rele/analizador) =====
	const medicionActiva =
		!estaPolling &&                                            // solo si NO hay polling activo
		box.enabled &&                                             // la caja debe estar habilitada
		((esDelRele && mideRele) || (esDelAnalizador && mideAnalizador)); // y el equipo correspondiente debe estar midiendo

	const progresoTradicionalHabilitado =
		(esDelRele && mostrarProgresoRele) ||
		(esDelAnalizador && mostrarProgresoAnalizador);            // control global de cu√°ndo mostrar borde animado

	// ===== DECIDIR QU√â ANIMACI√ìN USAR =====
	// Prioridad: polling > medici√≥n tradicional
	let duracionAnimacion;
	let contadorLecturas;
	let propiedadDuracion;
	let usarAnimacion = false;

	if (pollingActivo && progresoPollingHabilitado) {
		// Usar animaci√≥n de polling (reutiliza el CSS de rel√©)
		duracionAnimacion = periodoPolling;
		contadorLecturas = contadorPolling;
		propiedadDuracion = "--rw-progress-duration-rele";          // reutiliza la animaci√≥n del rel√©
		usarAnimacion = true;
	} else if (medicionActiva && progresoTradicionalHabilitado) {
		// Usar animaci√≥n tradicional
		duracionAnimacion = esDelAnalizador ? periodoAnalizador : periodoRele;
		contadorLecturas = esDelAnalizador ? contadorAnalizador : contadorRele;
		propiedadDuracion = esDelRele
			? "--rw-progress-duration-rele"
			: "--rw-progress-duration-analizador";
		usarAnimacion = true;
	} else {
		// Sin animaci√≥n
		duracionAnimacion = 60;
		contadorLecturas = 0;
		propiedadDuracion = "--rw-progress-duration-rele";
	}

	const equipo = pollingActivo ? "polling" : (esDelAnalizador ? "analizador" : "rele");

	let clasesValor = "alim-card-meter-value";                    // clase base del valor

	// TEMPORALMENTE DESACTIVADO: animaci√≥n de borde en el box
	// Se usa la barra de progreso horizontal en su lugar
	// if (usarAnimacion && !tieneError) {
	// 	if (pollingActivo || esDelRele) {
	// 		clasesValor += " alim-meter-progress-rele";
	// 	} else if (esDelAnalizador) {
	// 		clasesValor += " alim-meter-progress-analizador";
	// 	}
	// }

	// si hay error, agregar clase de error
	if (tieneError && box.enabled) {
		clasesValor += " alim-card-meter-value--error";
	}

	// Key que incluye el contador de lecturas para reiniciar animaci√≥n
	const claveValor = `${zona}-${indice}-${equipo}-c${contadorLecturas}`;

	// Determinar qu√© valor mostrar (aplicando formato de decimales)
	const decimalesConfig = estilosBox?.valorBox?.decimales;
	let valorMostrar = box.valor ?? "--,--";
	if (tieneError && box.enabled) {
		valorMostrar = "ERROR";
	} else {
		valorMostrar = formatearValorConDecimales(valorMostrar, decimalesConfig);
	}

	// Construir estilos del t√≠tulo del box (etiqueta como R, S, T)
	const estiloTituloBox = estilosBox?.tituloBox ? {
		fontFamily: estilosBox.tituloBox.fontFamily,
		fontSize: estilosBox.tituloBox.fontSize,
	} : {};

	// Construir estilos del valor del box (n√∫mero) - ahora con tama√±o fijo y overflow
	const boxHeight = estilosBox?.box?.height;
	const estiloValorBase = {
		...(estilosBox?.valorBox ? {
			fontFamily: estilosBox.valorBox.fontFamily,
			fontSize: estilosBox.valorBox.fontSize,
			color: estilosBox.valorBox.color,
		} : {}),
		// El box ahora tiene tama√±o fijo, el texto se recorta si no cabe
		width: "100%",
		...(boxHeight && boxHeight !== "auto" ? { height: boxHeight } : {}),
		overflow: "hidden",
		textOverflow: "ellipsis",
		display: "flex",
		alignItems: "center",
		justifyContent: "center",
	};

	// Combinar con estilos de animaci√≥n si corresponde
	const estiloValor = usarAnimacion && !tieneError
		? {
			...estiloValorBase,
			[propiedadDuracion]: `${duracionAnimacion}s`,
		}
		: estiloValorBase;

	// Estilos del contenedor del box (ancho fijo)
	const estiloMeter = estilosBox?.box?.width ? {
		width: estilosBox.box.width,
		flex: `0 0 ${estilosBox.box.width}`,
	} : {};

	return (
		<div
			key={`${zona}-${indice}`}
			className="alim-card-meter"
			style={Object.keys(estiloMeter).length > 0 ? estiloMeter : undefined}
		>
			<span
				className="alim-card-meter-phase"
				style={estiloTituloBox}
			>
				{box.etiqueta}
			</span>
			<span
				key={claveValor}
				className={clasesValor}
				style={Object.keys(estiloValor).length > 0 ? estiloValor : undefined}
			>
				{valorMostrar}
			</span>
		</div>
	);
};

export default CajaMedicion;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (CajaMedicion.jsx)

 - Representa un √∫nico ‚Äúdisplay‚Äù de la tarjeta (por ejemplo, fase R de corriente),
   encargado de mostrar etiqueta, valor y, opcionalmente, el borde de progreso.

 - `box.origen` decide si la caja pertenece al rel√© o al analizador; si no se
   indica, se asume rel√© por defecto.

 - El par `medicionActiva` + `progresoHabilitado` controla cu√°ndo se aplica la
   clase de borde animado: solo si la caja est√° habilitada y el equipo est√°
   midiendo (y la vista decidi√≥ mostrar progreso).

 - La key `claveValor` incluye el contador de lecturas para que React vuelva a
   montar el span del valor cuando llegue una nueva lectura, reiniciando as√≠ la
   animaci√≥n de borde.

 - `propiedadDuracion` permite ajustar la duraci√≥n de la animaci√≥n v√≠a variable
   CSS diferente para rel√© y analizador.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (CajaMedicion.jsx)

0) Visi√≥n general del componente

   `CajaMedicion` es el ‚Äúdisplay‚Äù individual dentro de la tarjeta:

   - Muestra:
       ‚Ä¢ una etiqueta (ej: "R", "S", "T" o un nombre personalizado),
       ‚Ä¢ un valor num√©rico o placeholder (`"--,--"`).

   - Opcionalmente dibuja una animaci√≥n de borde alrededor del valor para indicar
     el progreso del per√≠odo de medici√≥n (tipo ‚Äúbarra de progreso circular‚Äù):

       ‚Ä¢ puede representar el per√≠odo del rel√©,
       ‚Ä¢ o el del analizador, seg√∫n el origen definido en la caja.


1) Props y rol de cada una

   const CajaMedicion = ({
     box,
     indice,
     zona,
     mideRele,
     mideAnalizador,
     mostrarProgresoRele,
     mostrarProgresoAnalizador,
     periodoRele,
     periodoAnalizador,
     contadorRele,
     contadorAnalizador,
   }) => { ... }

   - `box`:
       ‚Ä¢ objeto con la configuraci√≥n de esta caja:
           - `box.etiqueta`  ‚Üí texto a mostrar encima del valor,
           - `box.valor`     ‚Üí lectura procesada (como string),
           - `box.enabled`   ‚Üí si la caja est√° habilitada para mostrar medici√≥n,
           - `box.origen`    ‚Üí `"rele"`, `"analizador"` o `undefined`:
               ¬∑ si es `"rele"`, la caja depende del rel√©,
               ¬∑ si es `"analizador"`, depende del analizador,
               ¬∑ si no se indica, se asume rel√© por defecto.

   - `indice`:
       ‚Ä¢ posici√≥n dentro del grupo de cajas (0, 1, 2 o 3),
       ‚Ä¢ se usa para construir keys √∫nicas.

   - `zona`:
       ‚Ä¢ indica si esta caja est√° en la parte:
           - `"sup"` ‚Üí bloque superior de la tarjeta,
           - `"inf"` ‚Üí bloque inferior.
       ‚Ä¢ tambi√©n participa en la generaci√≥n de keys.

   - `mideRele` / `mideAnalizador`:
       ‚Ä¢ booleans que indican si hay mediciones activas para cada equipo.
       ‚Ä¢ vienen del contexto y reflejan el estado real de los timers.

   - `mostrarProgresoRele` / `mostrarProgresoAnalizador`:
       ‚Ä¢ booleans que controlan si se debe animar el borde para cada equipo.
       ‚Ä¢ los gestiona `TarjetaAlimentador` seg√∫n si ya hubo lecturas, etc.

   - `periodoRele` / `periodoAnalizador`:
       ‚Ä¢ duraci√≥n del ciclo de actualizaci√≥n en segundos,
       ‚Ä¢ se usan para ajustar la velocidad de la animaci√≥n del borde.

   - `contadorRele` / `contadorAnalizador`:
       ‚Ä¢ se incrementan en cada lectura,
       ‚Ä¢ sirven para forzar el reinicio de la animaci√≥n cuando llega un nuevo set
         de datos (usando la key).


2) Banderas de origen: esDelRele / esDelAnalizador

   const esDelRele = box.origen === "rele" || !box.origen;
   const esDelAnalizador = box.origen === "analizador";

   - `esDelRele`:
       ‚Ä¢ es true si `box.origen` es `"rele"`,
       ‚Ä¢ o si `box.origen` no est√° definido (`!box.origen`),
       ‚Ä¢ en otras palabras: si no se aclara, asumimos rel√© como origen por defecto.

   - `esDelAnalizador`:
       ‚Ä¢ true solo si `box.origen === "analizador"`.

   - Esto permite que la misma caja se integre a la l√≥gica de:
       ‚Ä¢ mediciones y animaciones del rel√©,
       ‚Ä¢ o del analizador,
       ‚Ä¢ sin mezclar ambas cosas a la vez.


3) Determinar si la medici√≥n est√° activa en esta caja

   const medicionActiva =
     box.enabled &&
     ((esDelRele && mideRele) || (esDelAnalizador && mideAnalizador));

   - La caja solo debe considerarse ‚Äúactiva‚Äù si se cumplen dos condiciones:

       1) `box.enabled` es true:
           ‚Ä¢ el mapeo habilit√≥ esta caja (se decidi√≥ usarla).

       2) El equipo correspondiente est√° midiendo:
           ‚Ä¢ si la caja es del rel√© ‚Üí se requiere `mideRele === true`,
           ‚Ä¢ si es del analizador ‚Üí se requiere `mideAnalizador === true`.

   - Si cualquiera de estas condiciones falla:
       ‚Ä¢ `medicionActiva` ser√° false,
       ‚Ä¢ no se mostrar√° animaci√≥n de progreso.


4) Control de progreso: progresoHabilitado

   const progresoHabilitado =
     (esDelRele && mostrarProgresoRele) ||
     (esDelAnalizador && mostrarProgresoAnalizador);

   - Esta bandera no mira solo el estado de medici√≥n, sino la decisi√≥n de la vista
     sobre si debe mostrarse la animaci√≥n en este momento.

   - Resumen:

       ‚Ä¢ Para cajas de rel√©:
             `esDelRele && mostrarProgresoRele`

       ‚Ä¢ Para cajas de analizador:
             `esDelAnalizador && mostrarProgresoAnalizador`

   - `mostrarProgresoRele` / `mostrarProgresoAnalizador` los maneja
     `TarjetaAlimentador` usando contadores de lecturas:
       ‚Ä¢ se activan cuando llega al menos una lectura,
       ‚Ä¢ se apagan si se detiene la medici√≥n o se cambia de puesto.


5) Equipo, duraci√≥n y contador de lecturas

   const equipo = esDelAnalizador ? "analizador" : "rele";

   - Texto de conveniencia para identificar a cu√°l equipo est√° asociada la caja.

   const duracionAnimacion = esDelAnalizador
     ? periodoAnalizador
     : periodoRele;

   - ‚ÄúCu√°nto dura‚Äù el ciclo de animaci√≥n del borde:
       ‚Ä¢ si la caja es del analizador ‚Üí usa `periodoAnalizador`,
       ‚Ä¢ si no ‚Üí usa `periodoRele`.

   const contadorLecturas = esDelAnalizador
     ? contadorAnalizador
     : contadorRele;

   - Se elige el contador que corresponde al equipo de esta caja:

       ‚Ä¢ analizador ‚Üí `contadorAnalizador`,
       ‚Ä¢ rel√©       ‚Üí `contadorRele`.

   - Este valor se usar√° despu√©s para generar una key √∫nica y provocar que
     React remonte el elemento cuando cambie (reiniciando la animaci√≥n).


6) Construcci√≥n de clases CSS para el valor

   let clasesValor = "alim-card-meter-value";

   if (medicionActiva && progresoHabilitado) {
     if (esDelRele) {
       clasesValor += " alim-meter-progress-rele";
     } else if (esDelAnalizador) {
       clasesValor += " alim-meter-progress-analizador";
     }
   }

   - Siempre partimos de la clase base `"alim-card-meter-value"`.

   - Si la medici√≥n est√° activa y el progreso est√° habilitado:

       ‚Ä¢ para cajas del rel√©:
           - se agrega `"alim-meter-progress-rele"`.

       ‚Ä¢ para cajas del analizador:
           - se agrega `"alim-meter-progress-analizador"`.

   - Estas clases extra son las que el CSS usa para dibujar el borde animado,
     usando las variables `--rw-progress-duration-rele` o
     `--rw-progress-duration-analizador`.


7) Key para reiniciar animaci√≥n y variable CSS de duraci√≥n

   const claveValor = `${zona}-${indice}-${equipo}-c${contadorLecturas}`;

   - Esta key se aplica al `<span>` que muestra el valor:

       ‚Ä¢ incluye:
           - `zona` (sup/inf),
           - `indice` dentro del grupo,
           - `equipo` ("rele"/"analizador"),
           - `contadorLecturas`.

   - Cuando `contadorLecturas` cambia (ej: llega una nueva lectura):

       ‚Ä¢ la key cambia,
       ‚Ä¢ React desmonta y vuelve a montar el `<span>`,
       ‚Ä¢ y la animaci√≥n CSS se reinicia desde cero.

   const propiedadDuracion = esDelRele
     ? "--rw-progress-duration-rele"
     : "--rw-progress-duration-analizador";

   - Esta string representa el nombre de la variable CSS que controla 
     la duraci√≥n de la animaci√≥n:

       ‚Ä¢ para cajas del rel√© ‚Üí `"--rw-progress-duration-rele"`,
       ‚Ä¢ para cajas del analizador ‚Üí `"--rw-progress-duration-analizador"`.


8) JSX final

   return (
     <div key={`${zona}-${indice}`} className="alim-card-meter">
       <span className="alim-card-meter-phase">{box.etiqueta}</span>
       <span
         key={claveValor}
         className={clasesValor}
         style={
           medicionActiva && progresoHabilitado
             ? { [propiedadDuracion]: `${duracionAnimacion}s` }
             : undefined
         }
       >
         {box.valor ?? "--,--"}
       </span>
     </div>
   );

   - Contenedor de la caja:
       ‚Ä¢ `<div className="alim-card-meter">` agrupa etiqueta y valor.
       ‚Ä¢ usa `key={`${zona}-${indice`}` para identificar la caja dentro del
         grupo de `GrupoMedidores`.

   - Etiqueta:
       ‚Ä¢ `<span className="alim-card-meter-phase">{box.etiqueta}</span>`
       ‚Ä¢ muestra el texto configurado (ej: R, S, T, ‚ÄúPromedio‚Äù, etc.).

   - Valor:
       ‚Ä¢ `<span key={claveValor} className={clasesValor} ...>`
       ‚Ä¢ `key={claveValor}`:
           - se apoya en el contador de lecturas para reiniciar animaci√≥n.
       ‚Ä¢ `className={clasesValor}`:
           - incluye o no las clases de animaci√≥n seg√∫n corresponda.
       ‚Ä¢ `style={ ... }`:
           - si la medici√≥n est√° activa y el progreso habilitado, se pasa
             un objeto con la variable CSS `[propiedadDuracion]` ajustada
             a `${duracionAnimacion}s`.
           - si no, `style` queda `undefined` y no se aplica ning√∫n override.

       ‚Ä¢ `{box.valor ?? "--,--"}`:
           - muestra `box.valor` si est√° definido,
           - si viene `null` o `undefined`, muestra `"--,--"` como placeholder.


9) Export

   export default CajaMedicion;

   - Permite usar esta caja desde `TarjetaAlimentador`, que es la que decide
     cu√°ntas cajas hay, c√≥mo se agrupan y con qu√© par√°metros se renderiza cada una.

---------------------------------------------------------------------------*/
// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GapResizer.css =====

/* src/paginas/PaginaAlimentadores/componentes/tarjetas/GapResizer.css */

.gap-resizer {
	position: relative;
	display: flex;
	align-items: center;
	justify-content: center;
	min-height: 230px; /* misma altura que las tarjetas */
	flex-shrink: 0;
	pointer-events: none; /* No bloquear eventos en el √°rea del gap */
	overflow: clip; /* M√°s estricto que hidden, recorta todo el contenido */
	/* El ancho se controla via style inline basado en el gap */
}

/* Hitbox invisible que siempre captura eventos del mouse */
/* Posicionado en el centro exacto del gap-resizer */
.gap-resizer__hitbox {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	width: 30px;
	height: 120px;
	cursor: ew-resize;
	z-index: 2;
	pointer-events: auto; /* Capturar eventos del mouse */
	/* background: rgba(255,0,0,0.2); */ /* descomentar para debug */
}

.gap-resizer__handle {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	gap: 4px;
	padding: 12px 8px;
	cursor: ew-resize;
	opacity: 0;
	transition: opacity 0.2s ease;
	border-radius: 8px;
	pointer-events: none; /* El hitbox maneja los eventos */
}

/* Solo mostrar el handle cuando est√° activo via React (no CSS :hover) */
.gap-resizer--active .gap-resizer__handle {
	opacity: 1;
}

.gap-resizer__handle--dragging {
	background: rgba(59, 130, 246, 0.2);
}

.gap-resizer__line {
	width: 2px;
	height: 30px;
	background: linear-gradient(180deg, transparent, #3b82f6, transparent);
	border-radius: 1px;
}

.gap-resizer__circle {
	width: 14px;
	height: 14px;
	border-radius: 50%;
	background: #1e3a5f;
	border: 2px solid #3b82f6;
	transition: transform 0.15s ease, background-color 0.15s ease;
}

.gap-resizer__handle:hover .gap-resizer__circle {
	transform: scale(1.2);
	background: #3b82f6;
}

.gap-resizer__handle--dragging .gap-resizer__circle {
	transform: scale(1.3);
	background: #3b82f6;
	box-shadow: 0 0 12px rgba(59, 130, 246, 0.5);
}

.gap-resizer__input-container {
	position: absolute;
	top: calc(50% + 50px);
	left: 50%;
	transform: translateX(-50%);
	display: flex;
	justify-content: center;
	opacity: 0;
	transition: opacity 0.2s ease;
	pointer-events: auto; /* Permitir interacci√≥n con el input */
}

/* Solo mostrar el input cuando est√° activo via React */
.gap-resizer--active .gap-resizer__input-container {
	opacity: 1;
}

.gap-resizer__value {
	font-size: 0.75rem;
	color: #9ca3af;
	background: rgba(17, 24, 39, 0.9);
	padding: 4px 8px;
	border-radius: 4px;
	border: 1px solid #374151;
	white-space: nowrap;
	cursor: pointer;
	transition: border-color 0.2s, color 0.2s;
}

.gap-resizer__value:hover {
	border-color: #3b82f6;
	color: #e5e7eb;
}

.gap-resizer__input {
	width: 60px;
	padding: 4px 8px;
	font-size: 0.75rem;
	color: #e5e7eb;
	background: #1f2937;
	border: 1px solid #3b82f6;
	border-radius: 4px;
	text-align: center;
	outline: none;
}

.gap-resizer__input:focus {
	box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
}

/* Ocultar flechas del input number */
.gap-resizer__input::-webkit-outer-spin-button,
.gap-resizer__input::-webkit-inner-spin-button {
	-webkit-appearance: none;
	appearance: none;
	margin: 0;
}

.gap-resizer__input[type="number"] {
	-moz-appearance: textfield;
	appearance: textfield;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GapResizer.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/GapResizer.jsx

import React, { useState, useRef, useEffect, useCallback } from "react";
import "./GapResizer.css";

/**
 * Componente que permite ajustar el gap entre tarjetas.
 * Aparece como una l√≠nea con un c√≠rculo al hacer hover entre tarjetas.
 *
 * Comportamiento:
 * - Al hacer hover sobre el handle: aparece la barra de gap con el valor actual
 * - Al arrastrar con click izquierdo: ajusta el gap visualmente
 * - Al hacer doble click: se habilita la edici√≥n manual del input
 * - Enter o click fuera del input: confirma el valor y oculta la barra
 * - Escape: cancela y oculta la barra
 *
 * @param {number} gap - Gap actual en p√≠xeles
 * @param {function} onGapChange - Callback (nuevoGap)
 */
const GapResizer = ({ gap, onGapChange, minGap = 0, maxGap = 500 }) => {
	const [isHovered, setIsHovered] = useState(false);
	const [isDragging, setIsDragging] = useState(false);
	const [isEditing, setIsEditing] = useState(false); // true = input editable
	const [inputValue, setInputValue] = useState(gap);
	const inputRef = useRef(null);
	const containerRef = useRef(null);
	const hitboxRef = useRef(null);
	const startXRef = useRef(0);
	const startGapRef = useRef(gap);

	// Actualizar inputValue cuando cambia el gap desde afuera (pero no durante edici√≥n)
	useEffect(() => {
		if (!isEditing) {
			setInputValue(gap);
		}
	}, [gap, isEditing]);

	// Detectar clicks fuera del componente para cerrar
	// NOTA: No cerrar si est√° en modo edici√≥n (solo Enter/Escape cierran)
	useEffect(() => {
		const handleClickOutside = (e) => {
			if (containerRef.current && !containerRef.current.contains(e.target)) {
				// Solo ocultar si NO est√° editando
				if (!isEditing) {
					setIsHovered(false);
				}
			}
		};

		// Solo escuchar si est√° activo y no editando
		if (isHovered && !isEditing) {
			document.addEventListener('mousedown', handleClickOutside);
		}

		return () => {
			document.removeEventListener('mousedown', handleClickOutside);
		};
	}, [isHovered, isEditing]);

	// ===== DRAG HANDLERS =====
	const handleMouseDown = useCallback((e) => {
		// Solo drag con click izquierdo (button 0)
		if (e.button !== 0) return;
		e.preventDefault();
		e.stopPropagation();
		setIsDragging(true);
		startXRef.current = e.clientX;
		startGapRef.current = gap;
	}, [gap]);

	const handleMouseMove = useCallback((e) => {
		if (!isDragging) return;

		const deltaX = e.clientX - startXRef.current;
		// Cada 2px de movimiento = 1px de gap
		const newGap = Math.round(startGapRef.current + deltaX / 2);
		const clampedGap = Math.max(minGap, Math.min(maxGap, newGap));

		onGapChange(clampedGap);
		setInputValue(clampedGap);
	}, [isDragging, minGap, maxGap, onGapChange]);

	const handleMouseUp = useCallback((e) => {
		setIsDragging(false);

		// Verificar si el mouse est√° fuera del hitbox al soltar
		// Si est√° fuera, ocultar la barra
		if (hitboxRef.current) {
			const rect = hitboxRef.current.getBoundingClientRect();
			const mouseX = e.clientX;
			const mouseY = e.clientY;
			const isOutside =
				mouseX < rect.left ||
				mouseX > rect.right ||
				mouseY < rect.top ||
				mouseY > rect.bottom;

			if (isOutside && !isEditing) {
				setIsHovered(false);
			}
		}
	}, [isEditing]);

	// Doble click para activar modo edici√≥n
	const handleDoubleClick = useCallback((e) => {
		e.preventDefault();
		e.stopPropagation();
		setIsEditing(true);
		setInputValue(gap);
	}, [gap]);

	// Agregar/remover listeners globales para el drag
	useEffect(() => {
		if (isDragging) {
			window.addEventListener("mousemove", handleMouseMove);
			window.addEventListener("mouseup", handleMouseUp);
		}
		return () => {
			window.removeEventListener("mousemove", handleMouseMove);
			window.removeEventListener("mouseup", handleMouseUp);
		};
	}, [isDragging, handleMouseMove, handleMouseUp]);

	// ===== INPUT HANDLERS =====
	// Click en el valor para habilitar edici√≥n
	const handleValueClick = (e) => {
		e.stopPropagation();
		if (!isDragging) {
			setIsEditing(true);
			setInputValue(gap);
		}
	};

	// Enfocar el input cuando se activa la edici√≥n
	useEffect(() => {
		if (isEditing && inputRef.current) {
			inputRef.current.focus();
			inputRef.current.select();
		}
	}, [isEditing]);

	const handleInputChange = (e) => {
		setInputValue(e.target.value);
	};

	const confirmarValor = () => {
		const numValue = parseInt(inputValue, 10);
		if (!isNaN(numValue)) {
			const clampedGap = Math.max(minGap, Math.min(maxGap, numValue));
			onGapChange(clampedGap);
			setInputValue(clampedGap);
		} else {
			setInputValue(gap);
		}
		setIsEditing(false);
	};

	const handleInputBlur = () => {
		// Al perder foco (click fuera), confirmar valor y cerrar igual que Enter
		confirmarValor();
		setIsHovered(false);
	};

	const handleInputKeyDown = (e) => {
		if (e.key === "Enter") {
			e.preventDefault();
			confirmarValor();
			// Tambi√©n ocultar la barra de gap completamente
			setIsHovered(false);
		} else if (e.key === "Escape") {
			setInputValue(gap);
			setIsEditing(false);
			// Tambi√©n ocultar la barra de gap completamente
			setIsHovered(false);
		}
	};

	const isActive = isHovered || isDragging || isEditing;

	return (
		<div
			ref={containerRef}
			className={`gap-resizer ${isActive ? "gap-resizer--active" : ""}`}
			style={{ width: `${gap}px` }}
		>
			{/* Hitbox centrado directamente en el gap-resizer */}
			<div
				ref={hitboxRef}
				className="gap-resizer__hitbox"
				style={{ width: `${Math.min(30, gap)}px` }}
				onMouseEnter={() => setIsHovered(true)}
				onMouseLeave={() => !isDragging && !isEditing && setIsHovered(false)}
				onMouseDown={handleMouseDown}
				onDoubleClick={handleDoubleClick}
			/>

			{/* Handle visual (solo decorativo, los eventos van al hitbox) */}
			<div
				className={`gap-resizer__handle ${isDragging ? "gap-resizer__handle--dragging" : ""}`}
				title="Arrastra para ajustar el espaciado"
			>
				<div className="gap-resizer__line" />
				<div className="gap-resizer__circle" />
				<div className="gap-resizer__line" />
			</div>

			{isActive && (
				<div className="gap-resizer__input-container">
					{isEditing ? (
						<input
							ref={inputRef}
							type="number"
							className="gap-resizer__input"
							value={inputValue}
							onChange={handleInputChange}
							onBlur={handleInputBlur}
							onKeyDown={handleInputKeyDown}
							min={minGap}
							max={maxGap}
						/>
					) : (
						<span
							className="gap-resizer__value"
							onClick={handleValueClick}
							title="Click para editar"
						>
							{gap}px
						</span>
					)}
				</div>
			)}
		</div>
	);
};

export default GapResizer;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaTarjetas.css =====

/* src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaTarjetas.css */
/*
   NOTA SOBRE ESTE ARCHIVO (GrillaTarjetas.css)
   - Estilos para la grilla de tarjetas y la tarjeta especial "+" / zona de drop.

   - `.alim-cards-grid` define el layout tipo flex con m√∫ltiples columnas, mientras
     que `.alim-card-add` reutiliza el tama√±o/forma de una tarjeta para el bot√≥n
     de "Nuevo registrador" o el mensaje de "mover al final".
*/

/* Contenedor principal que incluye row gaps y la grilla */
.grilla-con-row-gaps {
   position: relative; /* para posicionar la grilla unifiliar */
   display: flex;
   flex-direction: column;
   width: 100%;
   min-height: 500px; /* altura m√≠nima para que la grilla unifiliar sea visible */
   flex: 1; /* ocupar todo el espacio disponible del padre */
}

/* Contenedor de la grilla de tarjetas */
.alim-cards-grid {
   position: relative; /* para posicionar los RowGapResizers absolutamente */
   display: flex;
   flex-wrap: wrap;
   /* row-gap se aplica inline via style */
   justify-content: left; /* filas alineadas a la izquierda */
   padding-left: 1.2rem;
   align-items: stretch; /* para que GapResizer tenga la misma altura */
}

/* En pantallas m√°s angostas, centramos la grilla y agregamos gap fijo */
@media (max-width: 982px) {
   .alim-cards-grid {
      justify-content: center;
      padding-left: 0;
      padding-right: 0;
      gap: 1.5rem; /* gap fijo entre tarjetas en modo m√≥vil (aumentado) */
   }

   /* Centrar las tarjetas sin margin extra */
   .alim-card-wrapper {
      margin-left: 0;
   }

   /* Ocultar la tarjeta "Nuevo Registrador" en m√≥vil - es inc√≥modo agregar desde el celular */
   .alim-card-add {
      display: none !important;
   }

   /* Ocultar los gap-spacers en modo m√≥vil para que el centrado funcione */
   .gap-spacer {
      display: none;
   }
}

/* Wrapper que contiene solo la tarjeta */
.alim-card-wrapper {
   flex-shrink: 0;
}

/* Spacer para simular el gap cuando est√° en modo drag o mobile */
.gap-spacer {
   flex-shrink: 0;
}

/* Tarjeta especial: bot√≥n "+" o zona de drop al final */
.alim-card-add {
   box-sizing: border-box;
   border: 1px dashed #374151;
   background-color: #111827;
   color: #9ca3af;
   display: flex;
   flex-direction: column;
   align-items: center;
   justify-content: center;
   gap: 0.25rem;
   cursor: pointer;
   border-radius: 16px;
   flex-shrink: 0;
   flex-grow: 0;
}

.alim-card-add-plus {
   font-size: 2rem;
   line-height: 1;
}

.alim-card-add-text {
   font-size: 0.85rem;
}

/* Estado deshabilitado para usuarios sin permisos */
.alim-card-add--disabled {
   cursor: not-allowed;
   opacity: 0.4;
   border-color: #1f2937;
}

.alim-card-add--disabled:hover {
   background-color: #111827; /* No cambiar color al hover */
}

/* T√≠tulo de cada bloque de medidores dentro de la tarjeta */
.alim-card-section-title {
   text-transform: uppercase;
}

/* RowGapResizer posicionado absolutamente sobre el espacio entre filas */
.row-gap-resizer-overlay {
   position: absolute;
   left: 0;
   right: 0;
   display: flex;
   justify-content: center;
   z-index: 10;
   pointer-events: none; /* El overlay no captura eventos, solo el RowGapResizer interno */
}

.row-gap-resizer-overlay > * {
   pointer-events: auto; /* El RowGapResizer interno s√≠ captura eventos */
}

/* Mensaje cuando no hay alimentadores */
.alim-empty-message {
   color: #020202;
   font-size: 0.95rem;
   margin: 0 0 1rem 1.2rem;
}

/* =========================================================
   BOT√ìN FLOTANTE PARA EDITAR DIAGRAMA UNIFILIAR
   ========================================================= */
.grilla-btn-editar-diagrama {
   position: fixed;
   bottom: 20px;
   right: 20px;
   width: 48px;
   height: 48px;
   border-radius: 50%;
   background-color: #0ea5e9;
   border: none;
   color: #ffffff;
   display: flex;
   align-items: center;
   justify-content: center;
   cursor: pointer;
   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
   z-index: 50;
   /* Invisible por defecto, transici√≥n lenta al desaparecer */
   opacity: 0;
   transition: opacity 0.5s ease, background-color 0.15s ease, transform 0.15s ease;
}

.grilla-btn-editar-diagrama:hover {
   background-color: #0284c7;
   color: #ffffff;
   transform: scale(1.1);
   /* Visible al pasar el rat√≥n, transici√≥n r√°pida al aparecer */
   opacity: 1;
   transition: opacity 0.15s ease, background-color 0.15s ease, transform 0.15s ease;
}

.grilla-btn-editar-diagrama:active {
   transform: scale(0.95);
}

/* En m√≥vil, ajustar posici√≥n del bot√≥n */
@media (max-width: 600px) {
   .grilla-btn-editar-diagrama {
      bottom: 16px;
      right: 16px;
      width: 44px;
      height: 44px;
   }
}

/* =========================================================
   BOTONES FLOTANTES PARA GUARDAR/CARGAR DIAGRAMA
   ========================================================= */
.grilla-btns-archivo {
   position: fixed;
   bottom: 20px;
   right: 20px;
   display: flex;
   flex-direction: column;
   gap: 10px;
   z-index: 102;
}

.grilla-btn-archivo {
   width: 48px;
   height: 48px;
   border-radius: 50%;
   border: none;
   display: flex;
   align-items: center;
   justify-content: center;
   cursor: pointer;
   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
   transition: background-color 0.15s ease, color 0.15s ease, transform 0.15s ease;
}

.grilla-btn-archivo:hover {
   transform: scale(1.1);
}

.grilla-btn-archivo:active {
   transform: scale(0.95);
}

/* Bot√≥n guardar - color celeste */
.grilla-btn-archivo--guardar {
   background-color: #0ea5e9;
   color: #ffffff;
}

.grilla-btn-archivo--guardar:hover {
   background-color: #0284c7;
}

/* Bot√≥n abrir - color celeste */
.grilla-btn-archivo--abrir {
   background-color: #0ea5e9;
   color: #ffffff;
}

.grilla-btn-archivo--abrir:hover {
   background-color: #0284c7;
}

/* En m√≥vil, ajustar posici√≥n y tama√±o */
@media (max-width: 600px) {
   .grilla-btns-archivo {
      bottom: 16px;
      right: 16px;
      gap: 8px;
   }

   .grilla-btn-archivo {
      width: 44px;
      height: 44px;
   }
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaTarjetas.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaTarjetas.jsx

import React, { useRef, useEffect, useState, useCallback } from "react";
import TarjetaAlimentador from "./TarjetaAlimentador.jsx";
import GapResizer from "./GapResizer.jsx";
import RowGapResizer from "./RowGapResizer.jsx";
import GrillaUnifilar from "./GrillaUnifilar.jsx";
import useGrillaUnifilar from "../../hooks/useGrillaUnifilar.js";
import useChispas from "../../hooks/useChispas.js";
import "./GrillaTarjetas.css";

// Breakpoint para desactivar los controles de gap en m√≥viles/tablets
const BREAKPOINT_MOBILE = 982;

// Gaps fijos para modo m√≥vil
const GAP_FIJO_MOBILE = 10;
const ROW_GAP_FIJO_MOBILE = 20;

/**
 * Verifica si un alimentador tiene la configuraci√≥n completa para hacer polling.
 * Requisitos:
 * - Al menos una zona (superior o inferior) con registrador_id definido
 * - intervalo_consulta_ms definido y > 0
 * - Al menos un box habilitado (enabled: true) con un √≠ndice v√°lido en una zona que tenga registrador
 */
const puedeHacerPolling = (alim) => {
	// 1. Verificar intervalo_consulta_ms
	if (!alim.intervalo_consulta_ms || alim.intervalo_consulta_ms <= 0) {
		return false;
	}

	// 2. Verificar card_design y zonas
	const cardDesign = alim.card_design || {};
	const superior = cardDesign.superior || {};
	const inferior = cardDesign.inferior || {};

	// 3. Verificar que haya al menos una zona con registrador_id
	const tieneRegistradorSuperior = !!superior.registrador_id;
	const tieneRegistradorInferior = !!inferior.registrador_id;

	// Compatibilidad con formato antiguo: registrador_id en ra√≠z
	const tieneRegistradorLegacy = !!alim.registrador_id;

	if (!tieneRegistradorSuperior && !tieneRegistradorInferior && !tieneRegistradorLegacy) {
		return false;
	}

	// 4. Verificar que haya al menos un box habilitado con √≠ndice v√°lido en una zona que tenga registrador
	const tieneBoxHabilitado = (boxes) => {
		return boxes.some((box) => {
			if (!box.enabled) return false;
			// El √≠ndice puede estar en 'indice' (formato modal) o 'registro' (formato normalizado)
			const indice = box.indice !== undefined ? box.indice : box.registro;
			// Considerar v√°lido si es un n√∫mero >= 0 o un string num√©rico no vac√≠o
			if (indice === null || indice === undefined || indice === "") {
				return false;
			}
			const numIndice = Number(indice);
			return Number.isFinite(numIndice) && numIndice >= 0;
		});
	};

	const boxesSuperior = superior.boxes || [];
	const boxesInferior = inferior.boxes || [];

	// Verificar si hay boxes habilitados en zonas que tienen registrador
	const superiorValido = tieneRegistradorSuperior && tieneBoxHabilitado(boxesSuperior);
	const inferiorValido = tieneRegistradorInferior && tieneBoxHabilitado(boxesInferior);
	// Compatibilidad legacy: si hay registrador en ra√≠z, cualquier box habilitado vale
	const legacyValido = tieneRegistradorLegacy && (tieneBoxHabilitado(boxesSuperior) || tieneBoxHabilitado(boxesInferior));

	return superiorValido || inferiorValido || legacyValido;
};

/**
 * Grilla de tarjetas de alimentadores.
 *
 * Estructura:
 * - El primer RowGapResizer controla la separaci√≥n del men√∫ (est√° fuera del grid)
 * - Las tarjetas se renderizan en un flex container con flex-wrap
 * - El row-gap del grid se controla via CSS
 * - Los RowGapResizers se posicionan con position: absolute sobre los espacios entre filas
 * - Cada tarjeta tiene un GapResizer a la derecha para controlar el espaciado horizontal
 * - Los GapResizers se ocultan durante drag & drop
 * - En pantallas peque√±as (< 982px) los controles de gap se desactivan y se usan valores fijos
 */
const GrillaTarjetas = ({
	alimentadores,
	lecturas,
	puestoId,
	workspaceId,             // ID del workspace para la grilla unifiliar
	elementoArrastrandoId,
	onAbrirConfiguracion,
	onAbrirHistorial,        // callback para abrir modal de historial
	onDragStart,
	onDragOver,
	onDrop,
	onDragEnd,
	onDropAlFinal,
	onAgregarNuevo,
	puedeAgregarNuevo = true, // si false, la card "Nuevo Registrador" est√° deshabilitada
	esObservador = false,    // si true, oculta el bot√≥n de estad√≠sticas
	estaMidiendo,
	obtenerTimestampInicio,
	obtenerContadorLecturas,
	// Gaps horizontales (entre tarjetas)
	obtenerGap,
	onGapChange,
	// Gaps verticales (entre filas)
	obtenerRowGap,
	onRowGapChange,
	// Skeleton card (opcional, se muestra mientras se guarda)
	skeletonCard = null,
	// Polling de lecturas
	estaPolling,              // (alimId) => boolean
	onPlayStopClick,          // (alimId) => void
	obtenerContadorPolling,   // (alimId) => number - contador de lecturas para animaci√≥n
	obtenerErrorPolling,      // (alimId) => { mensaje, timestamp } | null - error de lectura
	// Escala de tarjetas
	obtenerEscalaEfectiva,    // (alimId, puestoId) => number - escala efectiva considerando jerarqu√≠a
	onEscalaChange,           // (alimId, nuevaEscala) => void - callback para cambiar escala individual
	ESCALA_MIN = 0.5,
	ESCALA_MAX = 2.0,
}) => {
	const gridRef = useRef(null);
	// Posiciones Y de los espacios entre filas (para posicionar los RowGapResizers)
	const [posicionesEntreFilas, setPosicionesEntreFilas] = useState([]);
	// Mapa de filas por tarjeta para detectar cambios de fila
	const filasAnterioresRef = useRef({});
	// Snapshot de TODOS los gaps cuando se detecta un cambio de layout por resize
	// Se guarda una vez y se restaura cuando se vuelve a la configuraci√≥n original
	const snapshotGapsRef = useRef(null);
	// N√∫mero de filas en el snapshot (para saber cu√°ndo restaurar)
	const numFilasSnapshotRef = useRef(null);
	// Estado para detectar si estamos en modo m√≥vil (< 982px)
	const [esModoMobile, setEsModoMobile] = useState(() =>
		typeof window !== 'undefined' ? window.innerWidth < BREAKPOINT_MOBILE : false
	);

	// Mapa de fila por tarjeta (para aplicar margin-top individual)
	const [filasPorTarjeta, setFilasPorTarjeta] = useState({});
	// Primera tarjeta de cada fila (para saber d√≥nde poner el RowGapResizer)
	const [primerasTarjetasPorFila, setPrimerasTarjetasPorFila] = useState({});

	// Hook para la grilla unifiliar (dibujo de diagramas)
	const grillaUnifilar = useGrillaUnifilar(puestoId, workspaceId);

	// Hook para animaci√≥n de chispas
	const chispasHook = useChispas({
		bornes: grillaUnifilar.bornes,
		celdas: grillaUnifilar.celdas,
		chispasConfig: grillaUnifilar.chispasConfig,
		grosorLinea: grillaUnifilar.grosorLinea,
	});

	// Detectar las posiciones entre filas y manejar gaps de tarjetas que cambian de fila
	const detectarFilasYFinales = useCallback(() => {
		if (!gridRef.current) return;

		const nuevasPosiciones = [];
		const nuevasFilasPorTarjeta = {};
		const nuevasPrimerasPorFila = {}; // { filaIndex: alimId }
		let ultimoLeft = null;
		let ultimoBottom = null;
		let filaIndex = 0;

		// Incluir todos los wrappers de alimentadores y la tarjeta "Nuevo Registrador"
		const tarjetas = Array.from(gridRef.current.querySelectorAll('.alim-card-wrapper, .alim-card-add'));
		const gridRect = gridRef.current.getBoundingClientRect();

		tarjetas.forEach((wrapper, index) => {
			const alimId = wrapper.dataset.alimId || 'nuevo-registrador';
			const rect = wrapper.getBoundingClientRect();

			// Detectar cambio de fila: si esta tarjeta est√° m√°s a la izquierda que la anterior,
			// significa que salt√≥ a una nueva fila (flex-wrap)
			// Usamos left en lugar de top porque top se ve afectado por margin-top
			if (ultimoLeft !== null && rect.left < ultimoLeft) {
				// Guardar la posici√≥n Y entre filas (relativa al grid)
				const posY = ultimoBottom - gridRect.top;
				nuevasPosiciones.push({
					filaIndex: filaIndex + 1,
					top: posY
				});
				filaIndex++;
				// Esta tarjeta es la primera de la nueva fila
				nuevasPrimerasPorFila[filaIndex] = alimId;
			} else if (index === 0) {
				// La primera tarjeta es la primera de la fila 0
				nuevasPrimerasPorFila[0] = alimId;
			}

			// Guardar en qu√© fila est√° cada tarjeta
			nuevasFilasPorTarjeta[alimId] = filaIndex;

			ultimoLeft = rect.left;
			ultimoBottom = rect.bottom;
		});

		const numFilasActual = filaIndex + 1; // N√∫mero total de filas
		const filasAnteriores = filasAnterioresRef.current;
		const numFilasAnterior = Object.keys(filasAnteriores).length > 0
			? Math.max(...Object.values(filasAnteriores)) + 1
			: numFilasActual;

		// Detectar si aument√≥ el n√∫mero de filas (se achic√≥ la pantalla)
		if (numFilasActual > numFilasAnterior) {
			// Si no hay snapshot, guardar todos los gaps actuales
			if (snapshotGapsRef.current === null) {
				const snapshot = {};
				alimentadores.forEach((alim) => {
					snapshot[alim.id] = obtenerGap(alim.id);
				});
				snapshotGapsRef.current = snapshot;
				numFilasSnapshotRef.current = numFilasAnterior;
			}

			// Resetear gaps de tarjetas que bajaron de fila
			Object.keys(nuevasFilasPorTarjeta).forEach((alimId) => {
				if (alimId === 'nuevo-registrador') return;
				const filaAnterior = filasAnteriores[alimId];
				const filaNueva = nuevasFilasPorTarjeta[alimId];

				if (filaAnterior !== undefined && filaNueva > filaAnterior) {
					onGapChange(alimId, 10);
				}
			});
		}
		// Detectar si disminuy√≥ el n√∫mero de filas (se ensanch√≥ la pantalla)
		else if (numFilasActual < numFilasAnterior) {
			// Si volvimos al n√∫mero de filas del snapshot (o menos), restaurar todos los gaps
			if (snapshotGapsRef.current !== null && numFilasActual <= numFilasSnapshotRef.current) {
				Object.keys(snapshotGapsRef.current).forEach((alimId) => {
					onGapChange(alimId, snapshotGapsRef.current[alimId]);
				});
				// Limpiar el snapshot
				snapshotGapsRef.current = null;
				numFilasSnapshotRef.current = null;
			}
		}

		// Actualizar referencia de filas anteriores
		filasAnterioresRef.current = nuevasFilasPorTarjeta;

		// Solo actualizar posiciones si realmente cambi√≥
		const posicionesStr = JSON.stringify(nuevasPosiciones);
		setPosicionesEntreFilas(prev => {
			const prevStr = JSON.stringify(prev);
			if (prevStr !== posicionesStr) {
				return nuevasPosiciones;
			}
			return prev;
		});

		// Actualizar mapa de filas por tarjeta
		const filasStr = JSON.stringify(nuevasFilasPorTarjeta);
		setFilasPorTarjeta(prev => {
			if (JSON.stringify(prev) !== filasStr) {
				return nuevasFilasPorTarjeta;
			}
			return prev;
		});

		// Actualizar primeras tarjetas por fila
		const primerasStr = JSON.stringify(nuevasPrimerasPorFila);
		setPrimerasTarjetasPorFila(prev => {
			if (JSON.stringify(prev) !== primerasStr) {
				return nuevasPrimerasPorFila;
			}
			return prev;
		});
	}, [onGapChange, obtenerGap, alimentadores]);

	// Ejecutar detecci√≥n despu√©s del primer render y cuando cambian dependencias
	useEffect(() => {
		const raf = requestAnimationFrame(() => {
			detectarFilasYFinales();
		});
		return () => cancelAnimationFrame(raf);
	}, [alimentadores, detectarFilasYFinales]);

	// Re-detectar en resize
	useEffect(() => {
		const handleResize = () => {
			requestAnimationFrame(detectarFilasYFinales);
		};

		window.addEventListener('resize', handleResize);

		// ResizeObserver para el grid
		const resizeObserver = new ResizeObserver(() => {
			requestAnimationFrame(detectarFilasYFinales);
		});

		if (gridRef.current) {
			resizeObserver.observe(gridRef.current);
		}

		return () => {
			window.removeEventListener('resize', handleResize);
			resizeObserver.disconnect();
		};
	}, [detectarFilasYFinales]);

	// Re-detectar cuando cambian los row gaps o el puesto seleccionado
	useEffect(() => {
		const timer = setTimeout(() => {
			requestAnimationFrame(detectarFilasYFinales);
		}, 50);
		return () => clearTimeout(timer);
	}, [obtenerRowGap, puestoId, detectarFilasYFinales]);

	// Detectar modo m√≥vil al cambiar el tama√±o de ventana
	useEffect(() => {
		const handleResize = () => {
			const nuevoEsMobile = window.innerWidth < BREAKPOINT_MOBILE;
			setEsModoMobile(nuevoEsMobile);
		};

		window.addEventListener('resize', handleResize);
		return () => window.removeEventListener('resize', handleResize);
	}, []);

	// En modo m√≥vil, usar gaps fijos; en desktop, usar los configurados (con puestoId)
	const rowGapPrimero = esModoMobile ? ROW_GAP_FIJO_MOBILE : obtenerRowGap(puestoId, 0);

	// Funci√≥n para obtener el margin-top de una tarjeta seg√∫n su fila
	const obtenerMarginTop = (alimId) => {
		const fila = filasPorTarjeta[alimId];
		if (fila === undefined || fila === 0) return 0; // Primera fila no tiene margin
		// Buscar si esta tarjeta es la primera de su fila
		if (primerasTarjetasPorFila[fila] === alimId) {
			return esModoMobile ? ROW_GAP_FIJO_MOBILE : obtenerRowGap(puestoId, fila);
		}
		return esModoMobile ? ROW_GAP_FIJO_MOBILE : obtenerRowGap(puestoId, fila);
	};

	return (
		<div className="grilla-con-row-gaps">
			{/* Grilla unifiliar para dibujar diagramas - solo en desktop (no m√≥viles/tablets) */}
			{!esModoMobile && (
				<GrillaUnifilar
					celdas={grillaUnifilar.celdas}
					textos={grillaUnifilar.textos}
					modoEdicion={grillaUnifilar.modoEdicion}
					colorSeleccionado={grillaUnifilar.colorSeleccionado}
					herramienta={grillaUnifilar.herramienta}
					estaPintando={grillaUnifilar.estaPintando}
					coloresDisponibles={grillaUnifilar.coloresDisponibles}
					fuentesDisponibles={grillaUnifilar.fuentesDisponibles}
					tamanosDisponibles={grillaUnifilar.tamanosDisponibles}
					grosoresDisponibles={grillaUnifilar.grosoresDisponibles}
					grosorLinea={grillaUnifilar.grosorLinea}
					onCambiarGrosor={grillaUnifilar.cambiarGrosor}
					configTexto={grillaUnifilar.configTexto}
					onConfigTextoChange={grillaUnifilar.setConfigTexto}
					textoSeleccionadoId={grillaUnifilar.textoSeleccionadoId}
					onTextoSeleccionadoChange={grillaUnifilar.setTextoSeleccionadoId}
					onPintarCelda={grillaUnifilar.pintarCelda}
					onIniciarPintado={grillaUnifilar.iniciarPintado}
					onDetenerPintado={grillaUnifilar.detenerPintado}
					onCambiarColor={grillaUnifilar.setColorSeleccionado}
					onSeleccionarPincel={grillaUnifilar.seleccionarPincel}
					onSeleccionarBorrador={grillaUnifilar.seleccionarBorrador}
					onSeleccionarTexto={grillaUnifilar.seleccionarTexto}
					onSeleccionarBalde={grillaUnifilar.seleccionarBalde}
					onSeleccionarMover={grillaUnifilar.seleccionarMover}
					onRellenarConectadas={grillaUnifilar.rellenarConectadas}
					onBorrarArea={grillaUnifilar.borrarArea}
					onObtenerCeldasConectadas={grillaUnifilar.obtenerCeldasConectadas}
					onMoverCeldasConectadas={grillaUnifilar.moverCeldasConectadas}
					onAgregarTexto={grillaUnifilar.agregarTexto}
					onActualizarTexto={grillaUnifilar.actualizarTexto}
					onEliminarTexto={grillaUnifilar.eliminarTexto}
					onLimpiarTodo={grillaUnifilar.limpiarTodo}
					onCerrarEdicion={grillaUnifilar.desactivarEdicion}
					// === SISTEMA DE BORNES Y CHISPAS ===
					bornes={grillaUnifilar.bornes}
					chispasConfig={grillaUnifilar.chispasConfig}
					tiposBorne={grillaUnifilar.tiposBorne}
					onSeleccionarBorne={grillaUnifilar.seleccionarBorne}
					onAgregarBorne={grillaUnifilar.agregarBorne}
					onEliminarBorneEnPosicion={grillaUnifilar.eliminarBorneEnPosicion}
					onActualizarChispasConfig={grillaUnifilar.actualizarChispasConfig}
					// Estado y control de animaci√≥n de chispas
					animandoChispas={chispasHook.animando}
					onToggleAnimacionChispas={chispasHook.toggleAnimacion}
					chispasRef={chispasHook.chispasRef}
					onObtenerPosicionPixelChispa={chispasHook.obtenerPosicionPixel}
					onObtenerEstelaPixeles={chispasHook.obtenerEstelaPixeles}
				/>
			)}

			{/* Bot√≥n flotante para activar/desactivar modo edici√≥n de diagrama - solo en desktop */}
			{!esModoMobile && !grillaUnifilar.modoEdicion && (
				<button
					type="button"
					className="grilla-btn-editar-diagrama"
					onClick={grillaUnifilar.activarEdicion}
					title="Editar diagrama unifiliar"
				>
					<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
						<path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.996.996 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
					</svg>
				</button>
			)}

			{/* Botones flotantes para guardar/cargar diagrama - solo en modo edici√≥n y desktop */}
			{!esModoMobile && grillaUnifilar.modoEdicion && (
				<div className="grilla-btns-archivo">
					{/* Bot√≥n guardar (arriba) */}
					<button
						type="button"
						className="grilla-btn-archivo grilla-btn-archivo--guardar"
						onClick={grillaUnifilar.exportarAArchivo}
						title="Guardar diagrama a archivo"
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
							<path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
						</svg>
					</button>
					{/* Bot√≥n abrir (abajo) */}
					<label
						className="grilla-btn-archivo grilla-btn-archivo--abrir"
						title="Cargar diagrama desde archivo"
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
							<path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/>
						</svg>
						<input
							type="file"
							accept=".json"
							style={{ display: "none" }}
							onChange={async (e) => {
								const archivo = e.target.files?.[0];
								if (archivo) {
									const exito = await grillaUnifilar.importarDesdeArchivo(archivo);
									if (!exito) {
										alert("Error al cargar el archivo. Verifica que sea un archivo JSON v√°lido.");
									}
								}
								e.target.value = "";
							}}
						/>
					</label>
				</div>
			)}

			{/* RowGapResizer para la primera fila (separaci√≥n del men√∫) - solo en desktop */}
			{!elementoArrastrandoId && !esModoMobile && (
				<RowGapResizer
					gap={obtenerRowGap(puestoId, 0)}
					onGapChange={(nuevoGap) => onRowGapChange(puestoId, 0, nuevoGap)}
					rowIndex={0}
				/>
			)}
			{/* Spacer fijo durante drag o en modo m√≥vil */}
			{(elementoArrastrandoId || esModoMobile) && (
				<div style={{ height: rowGapPrimero }} />
			)}

			{/* Mensaje cuando no hay alimentadores */}
			{alimentadores.length === 0 && (
				<p className="alim-empty-message">
					Este puesto no tiene alimentadores. Haz clic en el bot√≥n de abajo para agregar.
				</p>
			)}

			<div
				ref={gridRef}
				className="alim-cards-grid"
			>
				{alimentadores.map((alim) => {
					const lecturasAlim = lecturas[alim.id] || {};
					const mideRele = estaMidiendo(alim.id, "rele");
					const mideAnalizador = estaMidiendo(alim.id, "analizador");
					const gapTarjeta = obtenerGap(alim.id);
					const marginTop = obtenerMarginTop(alim.id);

					return (
						<React.Fragment key={alim.id}>
							{/* Tarjeta del alimentador */}
							<div
								className="alim-card-wrapper"
								data-alim-id={alim.id}
								style={{ marginTop: marginTop > 0 ? `${marginTop}px` : undefined }}
							>
								<TarjetaAlimentador
									nombre={alim.nombre}
									color={alim.color}
									onConfigClick={() => onAbrirConfiguracion(puestoId, alim)}
									onHistorialClick={onAbrirHistorial ? () => onAbrirHistorial(puestoId, alim) : undefined}
									esObservador={esObservador}
									topSide={lecturasAlim.parteSuperior}
									bottomSide={lecturasAlim.parteInferior}
									draggable={true}
									isDragging={elementoArrastrandoId === alim.id}
									onDragStart={() => onDragStart(alim.id)}
									onDragOver={onDragOver}
									onDrop={(e) => {
										e.preventDefault();
										onDrop(alim.id);
									}}
									onDragEnd={onDragEnd}
									mideRele={mideRele}
									mideAnalizador={mideAnalizador}
									periodoRele={alim.periodoSegundos || 60}
									periodoAnalizador={alim.analizador?.periodoSegundos || 60}
									timestampInicioRele={obtenerTimestampInicio(alim.id, "rele")}
									timestampInicioAnalizador={obtenerTimestampInicio(alim.id, "analizador")}
									contadorRele={obtenerContadorLecturas(alim.id, "rele")}
									contadorAnalizador={obtenerContadorLecturas(alim.id, "analizador")}
									// Polling de lecturas
									estaPolling={estaPolling ? estaPolling(alim.id) : false}
									puedePolling={puedeHacerPolling(alim)}
									onPlayStopClick={() => onPlayStopClick && onPlayStopClick(alim.id)}
									contadorPolling={obtenerContadorPolling ? obtenerContadorPolling(alim.id) : 0}
									periodoPolling={(alim.intervalo_consulta_ms || 60000) / 1000}
									errorPolling={obtenerErrorPolling ? obtenerErrorPolling(alim.id) : null}
									// Escala de tarjetas
									// En modo m√≥vil, la escala es fija en 1 y no se puede cambiar (no se pasa onEscalaChange)
									escala={obtenerEscalaEfectiva ? obtenerEscalaEfectiva(alim.id, puestoId) : 1.0}
									onEscalaChange={!esModoMobile && onEscalaChange ? (nuevaEscala) => onEscalaChange(alim.id, nuevaEscala) : undefined}
									ESCALA_MIN={ESCALA_MIN}
									ESCALA_MAX={ESCALA_MAX}
								/>
							</div>
							{/* GapResizer a la derecha de cada tarjeta (elemento hermano independiente) */}
							{/* Usa el mismo marginTop que la tarjeta para alinearse verticalmente */}
							{!elementoArrastrandoId && !esModoMobile ? (
								<div style={{ marginTop: marginTop > 0 ? `${marginTop}px` : undefined }}>
									<GapResizer
										gap={gapTarjeta}
										onGapChange={(nuevoGap) => onGapChange(alim.id, nuevoGap)}
									/>
								</div>
							) : (
								<div className="gap-spacer" style={{ width: esModoMobile ? GAP_FIJO_MOBILE : gapTarjeta, marginTop: marginTop > 0 ? `${marginTop}px` : undefined }} />
							)}
						</React.Fragment>
					);
				})}

				{/* Skeleton card (se muestra mientras se guarda un nuevo alimentador) */}
				{skeletonCard && (() => {
					const marginTopSkeleton = obtenerMarginTop('nuevo-registrador');
					return (
						<React.Fragment>
							<div
								className="alim-card-wrapper"
								data-alim-id="skeleton"
								style={{ marginTop: marginTopSkeleton > 0 ? `${marginTopSkeleton}px` : undefined }}
							>
								{skeletonCard}
							</div>
							{/* Gap despu√©s del skeleton */}
							<div className="gap-spacer" style={{ width: esModoMobile ? GAP_FIJO_MOBILE : 10 }} />
						</React.Fragment>
					);
				})()}

				{/* Tarjeta "Nuevo Registrador" o zona de drop */}
				{/* Solo se muestra si: est√° arrastrando (zona de drop) O tiene permisos para agregar */}
				{(elementoArrastrandoId || puedeAgregarNuevo) && (() => {
					const marginTopNuevo = obtenerMarginTop('nuevo-registrador');
					const styleNuevo = {
						width: 304, minWidth: 304, maxWidth: 304, height: 279, minHeight: 279,
						...(marginTopNuevo > 0 && { marginTop: `${marginTopNuevo}px` })
					};

					return elementoArrastrandoId ? (
						<div
							className="alim-card-add"
							style={styleNuevo}
							onDragOver={onDragOver}
							onDrop={(e) => {
								e.preventDefault();
								onDropAlFinal();
							}}
						>
							<span style={{ textAlign: "center", padding: "1rem" }}>
								Soltar aqu√≠ para mover al final
							</span>
						</div>
					) : (
						<div
							className="alim-card-add"
							style={styleNuevo}
							onClick={onAgregarNuevo}
						>
							<span className="alim-card-add-plus">+</span>
							<span className="alim-card-add-text">Nuevo Registrador</span>
						</div>
					);
				})()}

				{/* RowGapResizers posicionados absolutamente sobre los espacios entre filas - solo en desktop */}
				{!elementoArrastrandoId && !esModoMobile && posicionesEntreFilas.map((pos) => (
					<div
						key={`row-gap-${pos.filaIndex}`}
						className="row-gap-resizer-overlay"
						style={{ top: `${pos.top}px` }}
					>
						<RowGapResizer
							gap={obtenerRowGap(puestoId, pos.filaIndex)}
							onGapChange={(nuevoGap) => onRowGapChange(puestoId, pos.filaIndex, nuevoGap)}
							rowIndex={pos.filaIndex}
						/>
					</div>
				))}
			</div>
		</div>
	);
};

export default GrillaTarjetas;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaUnifilar.css =====

/* src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaUnifilar.css */

/*
   NOTA SOBRE ESTE ARCHIVO (GrillaUnifilar.css)
   - Estilos para la grilla de dibujo unifiliar que permite crear diagramas
     sobre las tarjetas de alimentadores.

   - La grilla tiene dos modos:
     1. Modo edici√≥n (--editando): aparece al frente con z-index alto,
        muestra la cuadr√≠cula y permite dibujar.
     2. Modo fondo (--fondo): queda detr√°s de las tarjetas, solo muestra
        el dibujo como imagen de fondo transparente.
*/

/* Contenedor principal de la grilla */
.grilla-unifilar {
   position: absolute;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   pointer-events: none;
}

/* Modo fondo: detr√°s de las tarjetas */
.grilla-unifilar--fondo {
   z-index: 0;
}

/* Modo edici√≥n: al frente pero dentro del contenedor padre */
.grilla-unifilar--editando {
   z-index: 100;
   pointer-events: auto;
   background-color: rgba(15, 23, 42, 0.6);
}

/* Canvas de dibujo */
.grilla-unifilar__canvas {
   width: 100%;
   height: 100%;
   display: block;
}

.grilla-unifilar--editando .grilla-unifilar__canvas {
   pointer-events: auto;
}

/* Canvas overlay para chispas (superpuesto, sin interacci√≥n) */
.grilla-unifilar__canvas-chispas {
   position: absolute;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   pointer-events: none;
}

/* =========================================================
   BARRA DE HERRAMIENTAS
   ========================================================= */
.grilla-unifilar__toolbar {
   position: fixed;
   bottom: 20px;
   left: 50%;
   transform: translateX(-50%);
   display: flex;
   align-items: center;
   gap: 0;
   padding: 10px 16px;
   background-color: #1e293b;
   border: 1px solid #334155;
   border-radius: 12px;
   box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
   z-index: 101;
}

/* Contenedor de colores */
.grilla-unifilar__colores {
   display: flex;
   gap: 6px;
}

/* Bot√≥n de color individual */
.grilla-unifilar__color {
   width: 24px;
   height: 24px;
   border-radius: 50%;
   border: 2px solid transparent;
   cursor: pointer;
   transition: transform 0.15s ease, border-color 0.15s ease;
   outline: 1px solid rgba(255, 255, 255, 0.5);
   outline-offset: 0px;
}

.grilla-unifilar__color:hover {
   transform: scale(1.15);
}

.grilla-unifilar__color--activo {
   border-color: #fff;
   box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
}

/* Color activo - borde m√°s visible */
.grilla-unifilar__color--activo {
   outline: 1px solid #fff;
}

/* Estilos para ColorPickerSimple dentro de la grilla */
.grilla-unifilar__colores .color-picker-simple {
   margin-top: 0;
   flex-direction: row;
}

.grilla-unifilar__colores .color-picker-simple-label {
   display: none;
}

.grilla-unifilar__colores .color-picker-simple-button {
   width: 24px;
   height: 24px;
   border: 2px solid transparent;
   outline: 1px solid rgba(255, 255, 255, 0.5);
   outline-offset: 0px;
   box-shadow: none;
}

.grilla-unifilar__colores .color-picker-simple-button:hover {
   transform: scale(1.15);
   border-color: transparent;
   box-shadow: none;
}


/* Separador gen√©rico */
.grilla-unifilar__separador {
   width: 1px;
   height: 28px;
   background-color: #475569;
   align-self: center;
   margin: 0 8px;
}

/* Secci√≥n de grosor y gotero */
.grilla-unifilar__seccion-grosor {
   display: flex;
   align-items: center;
   gap: 6px;
   padding: 0 14px;
   border-left: 1px solid #475569;
   border-right: 1px solid #475569;
   margin: 0px 14px 0px 14px;
   height: 28px;
}

/* Contenedor de herramientas */
.grilla-unifilar__herramientas {
   display: flex;
   gap: 4px;
   align-items: center;
    margin: 0px 0px 0px 0px;
}

/* Bot√≥n de herramienta gen√©rico */
.grilla-unifilar__btn {
   display: flex;
   align-items: center;
   justify-content: center;
   gap: 6px;
   padding: 8px;
   background-color: transparent;
   border: 1px solid #475569;
   border-radius: 8px;
   color: #94a3b8;
   cursor: pointer;
   transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease;
}

.grilla-unifilar__btn:hover {
   background-color: rgba(51, 65, 85, 0.5);
   color: #e2e8f0;
}

.grilla-unifilar__btn--activo {
   background-color: #334155;
   color: #22d3ee;
   border-color: #22d3ee;
}

.grilla-unifilar__btn--peligro {
   color: #f87171;
   border-color: rgba(248, 113, 113, 0.4);
}

.grilla-unifilar__btn--peligro:hover {
   background-color: rgba(248, 113, 113, 0.15);
   border-color: #f87171;
}

/* Bot√≥n cerrar/listo */
.grilla-unifilar__btn--cerrar {
   padding: 8px 14px;
   background-color: #22d3ee;
   border-color: #22d3ee;
   color: #0f172a;
   font-weight: 600;
   font-size: 0.85rem;
}

.grilla-unifilar__btn--cerrar:hover {
   background-color: #06b6d4;
   border-color: #06b6d4;
   color: #0f172a;
}

/* Separador despu√©s del bot√≥n eliminar */
.grilla-unifilar__herramientas::after {
   content: "";
   width: 1px;
   height: 28px;
   background-color: #475569;
   margin: 0 8px;
   align-self: center;
}

/* Bot√≥n de formato (B, I) y botones peque√±os en opciones de texto */
.grilla-unifilar__btn--formato,
.grilla-unifilar__texto-opciones .grilla-unifilar__btn--peligro {
   min-width: 36px;
   height: 36px;
   padding: 0;
   font-size: 14px;
}

/* =========================================================
   TEXTAREA DE TEXTO FLOTANTE REDIMENSIONABLE
   ========================================================= */
.grilla-unifilar__input-texto {
   position: absolute;
   z-index: 102;
}

.grilla-unifilar__textarea-container {
   position: relative;
   min-width: 80px;
   min-height: 24px;
}

.grilla-unifilar__textarea-container textarea {
   width: 100%;
   height: 100%;
   background-color: rgba(30, 41, 59, 0.95);
   border: 2px solid #22d3ee;
   border-radius: 4px;
   padding: 2px 6px;
   outline: none;
   display: block;
   line-height: 1.2;
   white-space: pre-wrap;
   word-wrap: break-word;
   resize: none;
   overflow: auto;
   box-sizing: border-box;
   font-size: 0.85rem;
}

.grilla-unifilar__textarea-container textarea:focus {
   box-shadow: 0 0 0 2px rgba(34, 211, 238, 0.3);
}

.grilla-unifilar__textarea-container textarea::placeholder {
   color: #64748b;
}

/* =========================================================
   HANDLES DE REDIMENSIONAMIENTO (discretos)
   ========================================================= */
.grilla-unifilar__resize-handle {
   position: absolute;
   background-color: rgba(34, 211, 238, 0.6);
   z-index: 103;
   transition: background-color 0.15s ease;
}

/* Handles de esquinas (cuadrados peque√±os) */
.grilla-unifilar__resize-handle--nw,
.grilla-unifilar__resize-handle--ne,
.grilla-unifilar__resize-handle--sw,
.grilla-unifilar__resize-handle--se {
   width: 6px;
   height: 6px;
   border-radius: 1px;
}

.grilla-unifilar__resize-handle--nw {
   top: -3px;
   left: -3px;
   cursor: nw-resize;
}

.grilla-unifilar__resize-handle--ne {
   top: -3px;
   right: -3px;
   cursor: ne-resize;
}

.grilla-unifilar__resize-handle--sw {
   bottom: -3px;
   left: -3px;
   cursor: sw-resize;
}

.grilla-unifilar__resize-handle--se {
   bottom: -3px;
   right: -3px;
   cursor: se-resize;
}

/* Handles de lados (rectangulares finos) */
.grilla-unifilar__resize-handle--n,
.grilla-unifilar__resize-handle--s {
   width: 20px;
   height: 4px;
   left: 50%;
   transform: translateX(-50%);
   border-radius: 2px;
}

.grilla-unifilar__resize-handle--n {
   top: -2px;
   cursor: n-resize;
}

.grilla-unifilar__resize-handle--s {
   bottom: -2px;
   cursor: s-resize;
}

.grilla-unifilar__resize-handle--e,
.grilla-unifilar__resize-handle--w {
   width: 4px;
   height: 20px;
   top: 50%;
   transform: translateY(-50%);
   border-radius: 2px;
}

.grilla-unifilar__resize-handle--e {
   right: -2px;
   cursor: e-resize;
}

.grilla-unifilar__resize-handle--w {
   left: -2px;
   cursor: w-resize;
}

/* Hover en handles - m√°s visible al pasar el mouse */
.grilla-unifilar__resize-handle:hover {
   background-color: #22d3ee;
}

/* =========================================================
   WRAPPER Y BOTONES DE ACCI√ìN DEL INPUT
   ========================================================= */
.grilla-unifilar__input-wrapper {
   display: flex;
   align-items: flex-start;
   gap: 6px;
}

.grilla-unifilar__input-acciones {
   display: flex;
   flex-direction: column;
   gap: 4px;
}

.grilla-unifilar__input-btn {
   display: flex;
   align-items: center;
   justify-content: center;
   width: 24px;
   height: 24px;
   padding: 0;
   border: none;
   border-radius: 4px;
   cursor: pointer;
   transition: background-color 0.15s ease, opacity 0.15s ease;
}

/* Bot√≥n Aceptar - verde */
.grilla-unifilar__input-btn--aceptar {
   background-color: #16a34a;
   color: #ffffff;
}

.grilla-unifilar__input-btn--aceptar:hover {
   background-color: #15803d;
}

/* Bot√≥n Cerrar (X) - rojo oscuro para nuevo texto */
.grilla-unifilar__input-btn--cerrar {
   background-color: #7f1d1d;
   color: #fecaca;
}

.grilla-unifilar__input-btn--cerrar:hover {
   background-color: #991b1b;
   color: #ffffff;
}

/* Bot√≥n Volver (undo) - amarillo claro para edici√≥n */
.grilla-unifilar__input-btn--volver {
   background-color: #a16207;
   color: #fef9c3;
}

.grilla-unifilar__input-btn--volver:hover {
   background-color: #ca8a04;
   color: #fefce8;
}

/* Bot√≥n Eliminar (tacho) - rojo oscuro como el bot√≥n cerrar */
.grilla-unifilar__input-btn--eliminar {
   background-color: #7f1d1d;
   color: #fecaca;
}

.grilla-unifilar__input-btn--eliminar:hover {
   background-color: #991b1b;
   color: #ffffff;
}

/* =========================================================
   OPCIONES DE TEXTO
   ========================================================= */
.grilla-unifilar__texto-opciones {
   display: flex;
   align-items: center;
   gap: 6px;
   margin-left: 6px;
   margin-right: 10px;
}

.grilla-unifilar__select {
   background-color: #1e293b;
   border: 1px solid #475569;
   border-radius: 6px;
   color: #e2e8f0;
   padding: 4px 8px;
   font-size: 0.8rem;
   cursor: pointer;
   outline: none;
}

.grilla-unifilar__select:hover {
   border-color: #64748b;
}

.grilla-unifilar__select:focus {
   border-color: #22d3ee;
}

.grilla-unifilar__select--tamano {
   width: 70px;
}

.grilla-unifilar__select--grosor {
   width: 85px;
}

/* =========================================================
   INDICADOR DE SHIFT
   ========================================================= */
.grilla-unifilar__shift-indicator {
   background-color: rgba(34, 211, 238, 0.2);
   border: 1px solid #22d3ee;
   border-radius: 4px;
   padding: 4px 8px;
	margin-right: 14px;
	margin-left: 4px;
   font-size: 0.75rem;
   color: #22d3ee;
   font-weight: 500;
   white-space: nowrap;
}

/* =========================================================
   RESPONSIVE - M√ìVIL
   ========================================================= */
@media (max-width: 600px) {
   .grilla-unifilar__toolbar {
      bottom: 10px;
      padding: 8px 12px;
      gap: 8px;
      max-width: calc(100vw - 20px);
      flex-wrap: wrap;
      justify-content: center;
   }

   .grilla-unifilar__colores {
      gap: 4px;
   }

   .grilla-unifilar__color {
      width: 20px;
      height: 20px;
   }

   .grilla-unifilar__btn {
      padding: 6px;
   }

   .grilla-unifilar__btn--cerrar {
      padding: 6px 10px;
      font-size: 0.8rem;
   }

   .grilla-unifilar__btn--cerrar span {
      display: none;
   }

   .grilla-unifilar__texto-opciones {
      width: 100%;
      justify-content: center;
      border-left: none;
      border-top: 1px solid #475569;
      padding-left: 0;
      padding-top: 8px;
      margin-left: 0px;
      margin-top: 4px;
   }

   .grilla-unifilar__select {
      font-size: 0.75rem;
      padding: 3px 6px;
   }

   .grilla-unifilar__select--tamano {
      width: 60px;
   }

   .grilla-unifilar__shift-indicator {
      font-size: 0.7rem;
      padding: 3px 6px;
   }
}

/* =========================================================
   MEN√ö CONTEXTUAL (click derecho)
   ========================================================= */
.grilla-unifilar__menu-contextual {
   position: absolute;
   z-index: 200;
   background-color: #1e293b;
   border: 1px solid #475569;
   border-radius: 8px;
   box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
   padding: 4px;
   min-width: 160px;
}

.grilla-unifilar__menu-item {
   display: flex;
   align-items: center;
   gap: 8px;
   width: 100%;
   padding: 8px 12px;
   background-color: transparent;
   border: none;
   border-radius: 4px;
   color: #e2e8f0;
   font-size: 0.85rem;
   cursor: pointer;
   transition: background-color 0.15s ease;
   text-align: left;
}

.grilla-unifilar__menu-item:hover:not(:disabled) {
   background-color: rgba(51, 65, 85, 0.8);
}

.grilla-unifilar__menu-item:active:not(:disabled) {
   background-color: rgba(51, 65, 85, 1);
}

.grilla-unifilar__menu-item--disabled {
   opacity: 0.4;
   cursor: not-allowed;
}

.grilla-unifilar__menu-item svg {
   flex-shrink: 0;
   color: #94a3b8;
}

.grilla-unifilar__menu-item span:first-of-type {
   flex: 1;
}

.grilla-unifilar__menu-shortcut {
   font-size: 0.75rem;
   color: #64748b;
   margin-left: auto;
}

.grilla-unifilar__menu-separator {
   height: 1px;
   background-color: #475569;
   margin: 4px 8px;
}

.grilla-unifilar__menu-item--eliminar:hover:not(:disabled) {
   background-color: rgba(220, 38, 38, 0.2);
   color: #fca5a5;
}

.grilla-unifilar__menu-item--eliminar:hover:not(:disabled) svg {
   color: #f87171;
}

/* =========================================================
   PANEL DE CONFIGURACI√ìN DE CHISPAS
   ========================================================= */
.grilla-unifilar__panel-chispas {
   position: absolute;
   bottom: 60px;
   right: 100px;
   background-color: #1e293b;
   border: 1px solid #475569;
   border-radius: 12px;
   box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
   padding: 14px 16px;
   z-index: 102;
}

.grilla-unifilar__panel-header {
   display: flex;
   align-items: center;
   justify-content: space-between;
   gap: 16px;
   margin-bottom: 12px;
   padding-bottom: 10px;
   border-bottom: 1px solid #475569;
}

.grilla-unifilar__panel-titulo {
   font-size: 0.9rem;
   font-weight: 600;
   color: #e2e8f0;
}

.grilla-unifilar__panel-info-inline {
   font-size: 0.7rem;
   color: #64748b;
}

.grilla-unifilar__panel-columnas {
   display: flex;
   gap: 20px;
}

.grilla-unifilar__panel-columna {
   flex: 1;
   min-width: 180px;
   display: flex;
   flex-direction: column;
   gap: 8px;
}

.grilla-unifilar__panel-columna:first-child {
   padding-right: 16px;
   border-right: 1px solid #334155;
}

.grilla-unifilar__panel-fila {
   display: flex;
   gap: 12px;
   align-items: flex-end;
}

.grilla-unifilar__panel-campo {
   margin-bottom: 0;
}

.grilla-unifilar__panel-campo--flex {
   flex: 1;
}

.grilla-unifilar__panel-campo--color {
   flex-shrink: 0;
}

.grilla-unifilar__panel-campo label {
   display: block;
   font-size: 0.8rem;
   color: #94a3b8;
   margin-bottom: 4px;
}

.grilla-unifilar__panel-campo input[type="range"] {
   width: 100%;
   height: 6px;
   border-radius: 3px;
   background: #334155;
   outline: none;
   -webkit-appearance: none;
   appearance: none;
}

.grilla-unifilar__panel-campo input[type="range"]::-webkit-slider-thumb {
   -webkit-appearance: none;
   appearance: none;
   width: 14px;
   height: 14px;
   border-radius: 50%;
   background: #22d3ee;
   cursor: pointer;
   transition: background 0.15s ease;
}

.grilla-unifilar__panel-campo input[type="range"]::-webkit-slider-thumb:hover {
   background: #06b6d4;
}

.grilla-unifilar__panel-campo input[type="range"]::-moz-range-thumb {
   width: 14px;
   height: 14px;
   border-radius: 50%;
   background: #22d3ee;
   cursor: pointer;
   border: none;
}

.grilla-unifilar__panel-campo input[type="color"] {
   width: 40px;
   height: 28px;
   padding: 0;
   border: 2px solid #475569;
   border-radius: 6px;
   background: transparent;
   cursor: pointer;
}

.grilla-unifilar__panel-campo input[type="color"]::-webkit-color-swatch-wrapper {
   padding: 2px;
}

.grilla-unifilar__panel-campo input[type="color"]::-webkit-color-swatch {
   border-radius: 3px;
   border: none;
}

.grilla-unifilar__panel-campo--checkbox label {
   display: flex;
   align-items: center;
   gap: 8px;
   cursor: pointer;
}

.grilla-unifilar__panel-campo--checkbox input[type="checkbox"] {
   width: 16px;
   height: 16px;
   accent-color: #22d3ee;
   cursor: pointer;
}

.grilla-unifilar__panel-select {
   width: 100%;
   padding: 6px 10px;
   border: 1px solid #475569;
   border-radius: 6px;
   background-color: #334155;
   color: #e2e8f0;
   font-size: 0.85rem;
   cursor: pointer;
   outline: none;
   transition: border-color 0.15s ease;
}

.grilla-unifilar__panel-select:hover {
   border-color: #64748b;
}

.grilla-unifilar__panel-select:focus {
   border-color: #22d3ee;
}

.grilla-unifilar__panel-select option {
   background-color: #1e293b;
   color: #e2e8f0;
}


/* Slider + Input num√©rico en l√≠nea */
.grilla-unifilar__panel-slider-input {
   display: flex;
   align-items: center;
   gap: 8px;
}

.grilla-unifilar__panel-slider-input input[type="range"] {
   flex: 1;
   min-width: 0;
}

.grilla-unifilar__panel-number {
   width: 52px;
   padding: 4px 6px;
   border: 1px solid #475569;
   border-radius: 4px;
   background-color: #334155;
   color: #e2e8f0;
   font-size: 0.8rem;
   text-align: center;
   outline: none;
   transition: border-color 0.15s ease;
   -moz-appearance: textfield;
}

.grilla-unifilar__panel-number::-webkit-outer-spin-button,
.grilla-unifilar__panel-number::-webkit-inner-spin-button {
   -webkit-appearance: none;
   margin: 0;
}

.grilla-unifilar__panel-number:focus {
   border-color: #22d3ee;
}

.grilla-unifilar__panel-number:hover {
   border-color: #64748b;
}

.grilla-unifilar__panel-unidad {
   font-size: 0.7rem;
   color: #64748b;
   min-width: 32px;
}

/* Bot√≥n animando - efecto de brillo */
.grilla-unifilar__btn--animando {
   animation: pulso-chispa 1.5s ease-in-out infinite;
}

@keyframes pulso-chispa {
   0%, 100% {
      box-shadow: 0 0 4px rgba(34, 211, 238, 0.5);
   }
   50% {
      box-shadow: 0 0 12px rgba(34, 211, 238, 0.8);
   }
}

/* Bot√≥n de borne emisor - tinte cyan */
.grilla-unifilar__btn--emisor.grilla-unifilar__btn--activo {
   background-color: rgba(34, 211, 238, 0.15);
   border-color: #22d3ee;
   color: #22d3ee;
}

.grilla-unifilar__btn--emisor:hover {
   color: #22d3ee;
}

/* Bot√≥n de borne receptor - tinte naranja */
.grilla-unifilar__btn--receptor.grilla-unifilar__btn--activo {
   background-color: rgba(249, 115, 22, 0.15);
   border-color: #f97316;
   color: #f97316;
}

.grilla-unifilar__btn--receptor:hover {
   color: #f97316;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaUnifilar.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaUnifilar.jsx

import React, { useRef, useEffect, useCallback, useState } from "react";
import ColorPickerSimple from "../modales/ColorPickerSimple";
import "./GrillaUnifilar.css";

/**
 * Componente de grilla unifiliar para dibujar diagramas
 *
 * Funciona en dos modos:
 * - Modo edici√≥n: grilla visible al frente, permite dibujar
 * - Modo normal: solo muestra el dibujo como fondo transparente
 */
const GrillaUnifilar = ({
	// Estado de las celdas pintadas
	celdas,
	// Textos agregados
	textos = [],
	// ¬øEst√° en modo edici√≥n?
	modoEdicion,
	// Color seleccionado para pintar
	colorSeleccionado,
	// Herramienta activa: "pincel", "borrador", "texto", "balde", "mover" o "borne"
	herramienta,
	// ¬øEst√° pintando? (mouse presionado)
	estaPintando,
	// Colores disponibles
	coloresDisponibles,
	// Fuentes y tama√±os disponibles
	fuentesDisponibles = [],
	tamanosDisponibles = [],
	// Grosores de l√≠nea
	grosoresDisponibles = [],
	grosorLinea = 12,
	onCambiarGrosor,
	// Configuraci√≥n de texto actual
	configTexto = {},
	onConfigTextoChange,
	// Texto seleccionado
	textoSeleccionadoId,
	onTextoSeleccionadoChange,
	// Callbacks
	onPintarCelda,
	onIniciarPintado,
	onDetenerPintado,
	onCambiarColor,
	onSeleccionarPincel,
	onSeleccionarBorrador,
	onSeleccionarTexto,
	onSeleccionarBalde,
	onSeleccionarMover,
	onSeleccionarBorne,
	onRellenarConectadas,
	onBorrarArea,
	onObtenerCeldasConectadas,
	onMoverCeldasConectadas,
	onAgregarTexto,
	onActualizarTexto,
	onEliminarTexto,
	onLimpiarTodo,
	onCerrarEdicion,
	// === SISTEMA DE BORNES Y CHISPAS ===
	bornes = [],
	chispasConfig = {},
	tiposBorne = {},
	onAgregarBorne,
	onEliminarBorneEnPosicion,
	onActualizarChispasConfig,
	// Estado de animaci√≥n de chispas (controlado externamente)
	animandoChispas = false,
	onToggleAnimacionChispas,
	// Ref a chispas activas (mutable, no causa re-renders)
	chispasRef: chispasRefProp,
	onObtenerPosicionPixelChispa,
	onObtenerEstelaPixeles,
}) => {
	const canvasRef = useRef(null);
	const canvasChispasRef = useRef(null); // Canvas separado para chispas
	const contenedorRef = useRef(null);
	const [dimensiones, setDimensiones] = useState({ ancho: 0, alto: 0 });
	const chispasAnimationRef = useRef(null); // Ref para el loop de animaci√≥n de chispas
	// Refs para acceder a valores actuales en el loop de animaci√≥n sin re-renderizar
	const chispasPropsRef = useRef({ onObtenerPosicionPixelChispa, onObtenerEstelaPixeles });
	// Estado para el input de texto (nuevo o edici√≥n)
	// valorOriginal guarda el texto antes de editar para poder descartarlo
	const [inputTexto, setInputTexto] = useState({ visible: false, x: 0, y: 0, valor: "", editandoId: null, ancho: 220, alto: 55, valorOriginal: "" });
	// Estado para redimensionar el textarea
	const [redimensionando, setRedimensionando] = useState({ activo: false, handle: null, inicioX: 0, inicioY: 0, anchoInicial: 0, altoInicial: 0 });
	const textareaRef = useRef(null);
	// Estado para saber si Shift est√° presionado
	const [shiftPresionado, setShiftPresionado] = useState(false);
	// Estado para arrastrar texto
	const [arrastrando, setArrastrando] = useState({ activo: false, textoId: null, offsetX: 0, offsetY: 0 });
	// Estado para arrastrar l√≠neas conectadas
	const [arrastrandoLineas, setArrastrandoLineas] = useState({
		activo: false,
		celdasConectadas: [],    // Array de claves "x,y" de las celdas conectadas
		celdaInicialX: 0,        // Celda donde se hizo click inicial
		celdaInicialY: 0,
		ultimaCeldaX: 0,         // √öltima celda donde estaba el mouse (para calcular delta)
		ultimaCeldaY: 0,
	});
	// Estado para saber si el mouse est√° sobre un texto (para cambiar cursor)
	const [sobreTexto, setSobreTexto] = useState(false);
	// Estado para saber si el mouse est√° sobre una l√≠nea (para cambiar cursor)
	const [sobreLinea, setSobreLinea] = useState(false);
	// Estado para modo gotero (eyedropper)
	const [modoGotero, setModoGotero] = useState(false);
	// Estado para selecci√≥n de √°rea del borrador (como en Paint)
	const [areaBorrador, setAreaBorrador] = useState({
		activo: false,
		inicioX: 0,      // Coordenada de celda inicial X
		inicioY: 0,      // Coordenada de celda inicial Y
		actualX: 0,      // Coordenada de celda actual X
		actualY: 0,      // Coordenada de celda actual Y
	});
	// Estado para texto copiado (portapapeles interno)
	const [textoCopiado, setTextoCopiado] = useState(null);
	// === ESTADOS PARA BORNES Y CHISPAS ===
	// Tipo de borne a colocar cuando herramienta es "borne"
	const [tipoBorneActivo, setTipoBorneActivo] = useState("EMISOR");
	// Panel de configuraci√≥n de chispas visible
	const [panelChispasVisible, setPanelChispasVisible] = useState(false);
	// Estado para men√∫ contextual
	const [menuContextual, setMenuContextual] = useState({
		visible: false,
		x: 0,
		y: 0,
		pixelX: 0,  // Posici√≥n en p√≠xeles donde pegar
		pixelY: 0,
		hayTextoEnPosicion: false,  // Si hay un texto donde se hizo click
	});
	// Posici√≥n actual del mouse (para pegar en la posici√≥n correcta)
	const posicionMouseRef = useRef({ x: 0, y: 0 });

	/**
	 * Detectar teclas Shift, Delete, Ctrl+C y Ctrl+V
	 */
	useEffect(() => {
		const handleKeyDown = (e) => {
			if (e.key === "Shift") {
				setShiftPresionado(true);
			}
			// Delete o Backspace para eliminar texto seleccionado
			if ((e.key === "Delete" || e.key === "Backspace") && textoSeleccionadoId && herramienta === "texto" && !inputTexto.visible) {
				e.preventDefault();
				onEliminarTexto?.(textoSeleccionadoId);
			}
			// Ctrl+C para copiar texto seleccionado
			if (e.ctrlKey && e.key === "c" && textoSeleccionadoId && herramienta === "texto" && modoEdicion && !inputTexto.visible) {
				e.preventDefault();
				const textoACopiar = textos.find(t => t.id === textoSeleccionadoId);
				if (textoACopiar) {
					setTextoCopiado({ ...textoACopiar });
				}
			}
			// Ctrl+V para pegar texto
			if (e.ctrlKey && e.key === "v" && textoCopiado && herramienta === "texto" && modoEdicion && !inputTexto.visible) {
				e.preventDefault();
				// Pegar en la posici√≥n actual del mouse
				const nuevoTexto = {
					...textoCopiado,
					id: `texto-${Date.now()}`,
					x: posicionMouseRef.current.x,
					y: posicionMouseRef.current.y,
				};
				onAgregarTexto?.(nuevoTexto.x, nuevoTexto.y, nuevoTexto.texto);
				// Actualizar el texto reci√©n pegado con los estilos del copiado
				setTimeout(() => {
					// Buscar el √∫ltimo texto agregado y actualizarlo con los estilos
					const ultimoTexto = textos[textos.length - 1];
					if (ultimoTexto) {
						onActualizarTexto?.(ultimoTexto.id, {
							color: textoCopiado.color,
							fuente: textoCopiado.fuente,
							tamano: textoCopiado.tamano,
							negrita: textoCopiado.negrita,
							cursiva: textoCopiado.cursiva,
						});
					}
				}, 50);
			}
		};
		const handleKeyUp = (e) => {
			if (e.key === "Shift") {
				setShiftPresionado(false);
			}
		};

		window.addEventListener("keydown", handleKeyDown);
		window.addEventListener("keyup", handleKeyUp);

		return () => {
			window.removeEventListener("keydown", handleKeyDown);
			window.removeEventListener("keyup", handleKeyUp);
		};
	}, [textoSeleccionadoId, herramienta, inputTexto.visible, onEliminarTexto, textos, textoCopiado, modoEdicion, onAgregarTexto, onActualizarTexto]);

	/**
	 * Calcular dimensiones - siempre usa el contenedor padre (para que las coordenadas coincidan)
	 */
	useEffect(() => {
		let resizeObserver = null;
		let timer = null;

		const actualizarDimensiones = () => {
			if (!contenedorRef.current) return;

			// Obtener el contenedor padre (.grilla-con-row-gaps)
			const padre = contenedorRef.current.parentElement;
			if (!padre) return;

			const rect = padre.getBoundingClientRect();
			if (rect.width > 0 && rect.height > 0) {
				setDimensiones({
					ancho: rect.width,
					alto: rect.height
				});
			}
		};

		// Esperar un frame para que el CSS se aplique
		requestAnimationFrame(actualizarDimensiones);

		// Tambi√©n actualizar despu√©s de peque√±os delays para asegurar que las dimensiones sean correctas
		timer = setTimeout(actualizarDimensiones, 50);
		const timer2 = setTimeout(actualizarDimensiones, 150);

		// Observar cambios de tama√±o del contenedor
		resizeObserver = new ResizeObserver(actualizarDimensiones);
		if (contenedorRef.current?.parentElement) {
			resizeObserver.observe(contenedorRef.current.parentElement);
		}

		window.addEventListener("resize", actualizarDimensiones);

		return () => {
			clearTimeout(timer);
			clearTimeout(timer2);
			if (resizeObserver) resizeObserver.disconnect();
			window.removeEventListener("resize", actualizarDimensiones);
		};
	}, [modoEdicion]); // Re-calcular cuando cambia el modo

	/**
	 * Dibujar el canvas
	 */
	useEffect(() => {
		const canvas = canvasRef.current;
		if (!canvas || dimensiones.ancho === 0) return;

		const ctx = canvas.getContext("2d");
		const { ancho, alto } = dimensiones;

		// Ajustar tama√±o del canvas
		canvas.width = ancho;
		canvas.height = alto;

		// Limpiar canvas
		ctx.clearRect(0, 0, ancho, alto);

		// Dibujar grilla solo en modo edici√≥n
		if (modoEdicion) {
			ctx.strokeStyle = "rgba(148, 163, 184, 0.5)"; // Color m√°s visible
			ctx.lineWidth = 1;

			// L√≠neas verticales
			for (let x = 0; x <= ancho; x += grosorLinea) {
				ctx.beginPath();
				ctx.moveTo(x + 0.5, 0); // +0.5 para l√≠neas m√°s n√≠tidas
				ctx.lineTo(x + 0.5, alto);
				ctx.stroke();
			}

			// L√≠neas horizontales
			for (let y = 0; y <= alto; y += grosorLinea) {
				ctx.beginPath();
				ctx.moveTo(0, y + 0.5); // +0.5 para l√≠neas m√°s n√≠tidas
				ctx.lineTo(ancho, y + 0.5);
				ctx.stroke();
			}
		}

		// Dibujar celdas pintadas
		Object.entries(celdas).forEach(([clave, color]) => {
			const [x, y] = clave.split(",").map(Number);
			ctx.fillStyle = color;
			ctx.fillRect(
				x * grosorLinea,
				y * grosorLinea,
				grosorLinea,
				grosorLinea
			);
		});

		// Dibujar textos (con soporte multil√≠nea)
		textos.forEach((t) => {
			const fontStyle = `${t.cursiva ? "italic " : ""}${t.negrita ? "bold " : ""}${t.tamano}px ${t.fuente}`;
			ctx.font = fontStyle;
			ctx.fillStyle = t.color;
			ctx.textBaseline = "top";

			// Dividir texto en l√≠neas
			const lineas = t.texto.split("\n");
			const alturaLinea = t.tamano * 1.2; // 1.2 de line-height
			let anchoMaximo = 0;

			// Dibujar cada l√≠nea
			lineas.forEach((linea, index) => {
				ctx.fillText(linea, t.x, t.y + index * alturaLinea);
				const anchoLinea = ctx.measureText(linea).width;
				if (anchoLinea > anchoMaximo) anchoMaximo = anchoLinea;
			});

			// Si est√° seleccionado, dibujar borde
			if (modoEdicion && textoSeleccionadoId === t.id) {
				const alturaTotal = lineas.length * alturaLinea;
				ctx.strokeStyle = "#22d3ee";
				ctx.lineWidth = 2;
				ctx.setLineDash([4, 2]);
				ctx.strokeRect(t.x - 2, t.y - 2, anchoMaximo + 4, alturaTotal + 4);
				ctx.setLineDash([]);
			}
		});

		// Dibujar bornes
		bornes.forEach((borne) => {
			const centroX = borne.x * grosorLinea + grosorLinea / 2;
			const centroY = borne.y * grosorLinea + grosorLinea / 2;
			const radio = grosorLinea * 0.8;

			// C√≠rculo exterior con borde
			ctx.beginPath();
			ctx.arc(centroX, centroY, radio, 0, Math.PI * 2);
			ctx.fillStyle = borne.color;
			ctx.fill();
			ctx.strokeStyle = borne.tipo === "EMISOR" ? "#0ea5e9" : "#ea580c";
			ctx.lineWidth = 2;
			ctx.stroke();

			// Letra E o R en el centro
			ctx.font = `bold ${grosorLinea * 0.7}px sans-serif`;
			ctx.fillStyle = "#ffffff";
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.fillText(borne.tipo === "EMISOR" ? "E" : "R", centroX, centroY);
		});

		// NOTA: Las chispas ahora se dibujan en un canvas separado (canvasChispasRef)
		// para evitar redibujar todo el canvas 60 veces por segundo

		// Dibujar rect√°ngulo de selecci√≥n del borrador (si est√° activo)
		if (areaBorrador.activo) {
			const minX = Math.min(areaBorrador.inicioX, areaBorrador.actualX);
			const maxX = Math.max(areaBorrador.inicioX, areaBorrador.actualX);
			const minY = Math.min(areaBorrador.inicioY, areaBorrador.actualY);
			const maxY = Math.max(areaBorrador.inicioY, areaBorrador.actualY);

			const rectX = minX * grosorLinea;
			const rectY = minY * grosorLinea;
			const rectW = (maxX - minX + 1) * grosorLinea;
			const rectH = (maxY - minY + 1) * grosorLinea;

			// Fondo semitransparente rojo
			ctx.fillStyle = "rgba(239, 68, 68, 0.25)";
			ctx.fillRect(rectX, rectY, rectW, rectH);

			// Borde rojo punteado
			ctx.strokeStyle = "#ef4444";
			ctx.lineWidth = 2;
			ctx.setLineDash([6, 3]);
			ctx.strokeRect(rectX, rectY, rectW, rectH);
			ctx.setLineDash([]);
		}
	}, [celdas, textos, modoEdicion, dimensiones, textoSeleccionadoId, grosorLinea, areaBorrador, bornes]);

	// Mantener ref actualizado con los props de chispas
	useEffect(() => {
		chispasPropsRef.current = { onObtenerPosicionPixelChispa, onObtenerEstelaPixeles };
	}, [onObtenerPosicionPixelChispa, onObtenerEstelaPixeles]);

	/**
	 * Canvas separado para chispas - usa requestAnimationFrame independiente
	 * Esto evita redibujar todo el canvas principal 60 veces por segundo
	 */
	useEffect(() => {
		const canvasChispas = canvasChispasRef.current;
		if (!canvasChispas || dimensiones.ancho === 0) return;

		// Ajustar tama√±o del canvas de chispas
		canvasChispas.width = dimensiones.ancho;
		canvasChispas.height = dimensiones.alto;

		const ctx = canvasChispas.getContext("2d");

		// Configuraci√≥n de chispas
		const colorChispa = chispasConfig.color || "#fef08a";
		const tamanoChispa = chispasConfig.tamano || 4;
		const mostrarEstela = chispasConfig.estela !== false;
		const formaChispa = chispasConfig.forma || "circulo";

		// Convertir color hex a RGB
		const hexToRgb = (hex) => {
			const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
			return result ? {
				r: parseInt(result[1], 16),
				g: parseInt(result[2], 16),
				b: parseInt(result[3], 16)
			} : { r: 254, g: 240, b: 138 };
		};
		const rgb = hexToRgb(colorChispa);

		// Funci√≥n para calcular √°ngulo de direcci√≥n
		const calcularAngulo = (chispa) => {
			const { ruta, posicion } = chispa;
			if (!ruta || ruta.length < 2 || posicion >= ruta.length - 1) return 0;
			const [x1, y1] = ruta[posicion].split(",").map(Number);
			const [x2, y2] = ruta[posicion + 1].split(",").map(Number);
			return Math.atan2(y2 - y1, x2 - x1);
		};

		// Funci√≥n para dibujar formas
		const dibujarForma = (x, y, tamano, color, angulo = 0, opacidad = 1) => {
			ctx.save();
			ctx.translate(x, y);
			ctx.rotate(angulo);
			ctx.globalAlpha = opacidad;

			switch (formaChispa) {
				case "cuadrado":
					ctx.fillStyle = color;
					ctx.fillRect(-tamano, -tamano, tamano * 2, tamano * 2);
					break;

				case "estrella":
					ctx.fillStyle = color;
					ctx.beginPath();
					for (let i = 0; i < 8; i++) {
						const radio = i % 2 === 0 ? tamano * 1.2 : tamano * 0.4;
						const a = (i * Math.PI) / 4;
						if (i === 0) ctx.moveTo(Math.cos(a) * radio, Math.sin(a) * radio);
						else ctx.lineTo(Math.cos(a) * radio, Math.sin(a) * radio);
					}
					ctx.closePath();
					ctx.fill();
					break;

				case "rayo":
					ctx.fillStyle = color;
					ctx.beginPath();
					ctx.moveTo(-tamano * 1.2, -tamano * 0.3);
					ctx.lineTo(-tamano * 0.3, tamano * 0.5);
					ctx.lineTo(-tamano * 0.3, 0);
					ctx.lineTo(tamano * 1.2, tamano * 0.3);
					ctx.lineTo(tamano * 0.3, -tamano * 0.5);
					ctx.lineTo(tamano * 0.3, 0);
					ctx.closePath();
					ctx.fill();
					break;

				case "flecha":
					ctx.fillStyle = color;
					ctx.beginPath();
					ctx.moveTo(tamano * 1.2, 0);
					ctx.lineTo(-tamano * 0.8, -tamano * 0.8);
					ctx.lineTo(-tamano * 0.4, 0);
					ctx.lineTo(-tamano * 0.8, tamano * 0.8);
					ctx.closePath();
					ctx.fill();
					break;

				case "gota":
					ctx.fillStyle = color;
					ctx.beginPath();
					ctx.moveTo(tamano * 1.2, 0);
					ctx.quadraticCurveTo(0, -tamano * 0.8, -tamano * 0.8, 0);
					ctx.quadraticCurveTo(0, tamano * 0.8, tamano * 1.2, 0);
					ctx.fill();
					break;

				case "anillo":
					ctx.strokeStyle = color;
					ctx.lineWidth = tamano * 0.4;
					ctx.beginPath();
					ctx.arc(0, 0, tamano * 0.8, 0, Math.PI * 2);
					ctx.stroke();
					break;

				case "barra":
					if (color.startsWith("#")) {
						const gradientBarra = ctx.createLinearGradient(-tamano * 6, 0, tamano * 6, 0);
						gradientBarra.addColorStop(0, "transparent");
						gradientBarra.addColorStop(0.15, `${color}15`);
						gradientBarra.addColorStop(0.3, `${color}40`);
						gradientBarra.addColorStop(0.45, `${color}80`);
						gradientBarra.addColorStop(0.5, color);
						gradientBarra.addColorStop(0.55, `${color}80`);
						gradientBarra.addColorStop(0.7, `${color}40`);
						gradientBarra.addColorStop(0.85, `${color}15`);
						gradientBarra.addColorStop(1, "transparent");
						ctx.fillStyle = gradientBarra;
						ctx.fillRect(-tamano * 6, -tamano * 1.2, tamano * 12, tamano * 2.4);
					}
					ctx.fillStyle = color;
					ctx.fillRect(-tamano * 0.4, -tamano * 1.2, tamano * 0.8, tamano * 2.4);
					break;

				case "circulo":
				default:
					ctx.fillStyle = color;
					ctx.beginPath();
					ctx.arc(0, 0, tamano, 0, Math.PI * 2);
					ctx.fill();
					break;
			}

			ctx.restore();
		};

		// Loop de dibujo de chispas
		const dibujarChispas = () => {
			// Limpiar canvas de chispas
			ctx.clearRect(0, 0, dimensiones.ancho, dimensiones.alto);

			// Obtener chispas directamente del ref (mutable, sin pasar por React)
			const chispasActuales = chispasRefProp?.current || [];
			// Obtener funciones desde el ref de props
			const { onObtenerPosicionPixelChispa: getPosicion, onObtenerEstelaPixeles: getEstela } = chispasPropsRef.current;

			if (chispasActuales.length > 0 && getPosicion) {
				for (let i = 0; i < chispasActuales.length; i++) {
					const chispa = chispasActuales[i];
					const angulo = calcularAngulo(chispa);

					// Dibujar estela
					if (mostrarEstela && getEstela) {
						const estelaPixeles = getEstela(chispa);
						for (let j = 0; j < estelaPixeles.length; j++) {
							const punto = estelaPixeles[j];
							dibujarForma(
								punto.x,
								punto.y,
								tamanoChispa * 0.6,
								`rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${punto.opacidad * 0.6})`,
								angulo,
								punto.opacidad * 0.6
							);
						}
					}

					// Dibujar chispa principal
					const pos = getPosicion(chispa);

					// Efecto de brillo (glow)
					if (["circulo", "estrella", "anillo"].includes(formaChispa)) {
						const gradient = ctx.createRadialGradient(
							pos.x, pos.y, 0,
							pos.x, pos.y, tamanoChispa * 2
						);
						gradient.addColorStop(0, colorChispa);
						gradient.addColorStop(0.5, `${colorChispa}80`);
						gradient.addColorStop(1, "transparent");

						ctx.beginPath();
						ctx.arc(pos.x, pos.y, tamanoChispa * 2, 0, Math.PI * 2);
						ctx.fillStyle = gradient;
						ctx.fill();
					}

					dibujarForma(pos.x, pos.y, tamanoChispa, colorChispa, angulo);
				}
			}

			// Continuar el loop si hay animaci√≥n activa
			if (animandoChispas) {
				chispasAnimationRef.current = requestAnimationFrame(dibujarChispas);
			}
		};

		// Iniciar o detener el loop seg√∫n el estado
		if (animandoChispas) {
			chispasAnimationRef.current = requestAnimationFrame(dibujarChispas);
		} else {
			// Limpiar canvas cuando se detiene la animaci√≥n
			ctx.clearRect(0, 0, dimensiones.ancho, dimensiones.alto);
		}

		// Cleanup
		return () => {
			if (chispasAnimationRef.current) {
				cancelAnimationFrame(chispasAnimationRef.current);
			}
		};
	}, [dimensiones, animandoChispas, chispasConfig]);

	/**
	 * Obtener coordenadas de celda desde evento de mouse
	 */
	const obtenerCoordenadas = useCallback((e) => {
		const canvas = canvasRef.current;
		if (!canvas) return null;

		const rect = canvas.getBoundingClientRect();
		const x = Math.floor((e.clientX - rect.left) / grosorLinea);
		const y = Math.floor((e.clientY - rect.top) / grosorLinea);

		return { x, y };
	}, [grosorLinea]);

	/**
	 * Obtener coordenadas en p√≠xeles desde evento de mouse
	 */
	const obtenerCoordenadasPixel = useCallback((e) => {
		const canvas = canvasRef.current;
		if (!canvas) return null;

		const rect = canvas.getBoundingClientRect();
		return {
			x: e.clientX - rect.left,
			y: e.clientY - rect.top
		};
	}, []);

	/**
	 * Verificar si hay una celda pintada en las coordenadas de celda dadas
	 * @param {number} x - Coordenada X de celda
	 * @param {number} y - Coordenada Y de celda
	 * @returns {boolean} true si hay una celda pintada
	 */
	const hayCeldaEn = useCallback((x, y) => {
		const claveCelda = `${x},${y}`;
		return !!celdas[claveCelda];
	}, [celdas]);

	/**
	 * Verificar si un punto est√° sobre un texto y devolver el texto
	 * (con soporte para texto multil√≠nea)
	 */
	const textoEnPunto = useCallback((px, py) => {
		const canvas = canvasRef.current;
		if (!canvas) return null;

		const ctx = canvas.getContext("2d");

		// Buscar en orden inverso (los √∫ltimos est√°n encima)
		for (let i = textos.length - 1; i >= 0; i--) {
			const t = textos[i];
			const fontStyle = `${t.cursiva ? "italic " : ""}${t.negrita ? "bold " : ""}${t.tamano}px ${t.fuente}`;
			ctx.font = fontStyle;

			// Calcular dimensiones considerando m√∫ltiples l√≠neas
			const lineas = t.texto.split("\n");
			const alturaLinea = t.tamano * 1.2;
			let anchoMaximo = 0;
			lineas.forEach(linea => {
				const anchoLinea = ctx.measureText(linea).width;
				if (anchoLinea > anchoMaximo) anchoMaximo = anchoLinea;
			});
			const alturaTotal = lineas.length * alturaLinea;

			if (
				px >= t.x - 2 &&
				px <= t.x + anchoMaximo + 2 &&
				py >= t.y - 2 &&
				py <= t.y + alturaTotal + 2
			) {
				return t;
			}
		}
		return null;
	}, [textos]);

	/**
	 * Manejar click o movimiento con mouse presionado
	 */
	const manejarPintado = useCallback((e) => {
		if (!modoEdicion || herramienta === "texto") return;

		const coords = obtenerCoordenadas(e);
		if (coords) {
			onPintarCelda(coords.x, coords.y, shiftPresionado);
		}
	}, [modoEdicion, herramienta, obtenerCoordenadas, onPintarCelda, shiftPresionado]);

	/**
	 * Capturar color del canvas con el gotero
	 */
	const capturarColorGotero = useCallback((e) => {
		const canvas = canvasRef.current;
		if (!canvas) return;

		const ctx = canvas.getContext("2d");
		const rect = canvas.getBoundingClientRect();
		const x = e.clientX - rect.left;
		const y = e.clientY - rect.top;

		// Obtener el color del p√≠xel
		const pixel = ctx.getImageData(x, y, 1, 1).data;

		// Convertir a hex
		const r = pixel[0].toString(16).padStart(2, "0");
		const g = pixel[1].toString(16).padStart(2, "0");
		const b = pixel[2].toString(16).padStart(2, "0");
		const colorHex = `#${r}${g}${b}`;

		// Cambiar el color seleccionado
		onCambiarColor(colorHex);

		// Desactivar modo gotero
		setModoGotero(false);
	}, [onCambiarColor]);

	/**
	 * Mouse down - iniciar pintado, manejar texto, o iniciar arrastre
	 * Solo responde al bot√≥n izquierdo del mouse (button 0)
	 */
	const handleMouseDown = useCallback((e) => {
		if (!modoEdicion) return;
		// Ignorar clicks que no sean del bot√≥n izquierdo (0 = izquierdo, 2 = derecho)
		if (e.button !== 0) return;
		e.preventDefault();

		// Si el men√∫ contextual est√° abierto, solo cerrarlo y no hacer nada m√°s
		if (menuContextual.visible) {
			setMenuContextual(prev => ({ ...prev, visible: false }));
			return;
		}

		// Si el modo gotero est√° activo, capturar el color
		if (modoGotero) {
			capturarColorGotero(e);
			return;
		}

		if (herramienta === "texto") {
			const coords = obtenerCoordenadasPixel(e);
			if (!coords) return;

			// Verificar si hay un texto en esta posici√≥n
			const textoEncontrado = textoEnPunto(coords.x, coords.y);

			if (textoEncontrado) {
				// Seleccionar texto existente e iniciar arrastre
				onTextoSeleccionadoChange?.(textoEncontrado.id);
				setArrastrando({
					activo: true,
					textoId: textoEncontrado.id,
					offsetX: coords.x - textoEncontrado.x,
					offsetY: coords.y - textoEncontrado.y
				});
			} else {
				// Si hay un texto seleccionado, solo deseleccionarlo sin crear nuevo input
				if (textoSeleccionadoId) {
					onTextoSeleccionadoChange?.(null);
					return;
				}
				// Mostrar input para nuevo texto
				setInputTexto({
					visible: true,
					x: coords.x,
					y: coords.y,
					valor: "",
					editandoId: null,
					ancho: 220,
					alto: 55,
					valorOriginal: ""
				});
			}
		} else if (herramienta === "borne") {
			// Herramienta borne: colocar o eliminar borne
			const coords = obtenerCoordenadas(e);
			if (coords) {
				// Verificar si ya hay un borne en esta posici√≥n
				const borneExistente = bornes.find(b => b.x === coords.x && b.y === coords.y);
				if (borneExistente) {
					// Si hay un borne, eliminarlo
					onEliminarBorneEnPosicion?.(coords.x, coords.y);
				} else {
					// Si no hay borne, agregar uno del tipo activo
					onAgregarBorne?.(coords.x, coords.y, tipoBorneActivo);
				}
			}
		} else if (herramienta === "balde") {
			// Herramienta balde: rellenar celdas conectadas
			const coords = obtenerCoordenadas(e);
			if (coords) {
				onRellenarConectadas?.(coords.x, coords.y);
			}
		} else if (herramienta === "mover") {
			// Herramienta mover: iniciar arrastre de l√≠neas conectadas
			const coords = obtenerCoordenadas(e);
			if (coords && hayCeldaEn(coords.x, coords.y)) {
				// Obtener todas las celdas conectadas desde esta posici√≥n
				const celdasConectadas = onObtenerCeldasConectadas?.(coords.x, coords.y, celdas) || [];
				if (celdasConectadas.length > 0) {
					setArrastrandoLineas({
						activo: true,
						celdasConectadas,
						celdaInicialX: coords.x,
						celdaInicialY: coords.y,
						ultimaCeldaX: coords.x,
						ultimaCeldaY: coords.y,
					});
				}
			}
		} else if (herramienta === "borrador") {
			// Borrador: iniciar selecci√≥n de √°rea
			const coords = obtenerCoordenadas(e);
			if (coords) {
				setAreaBorrador({
					activo: true,
					inicioX: coords.x,
					inicioY: coords.y,
					actualX: coords.x,
					actualY: coords.y,
				});
			}
		} else {
			// Pincel
			const coords = obtenerCoordenadas(e);
			if (coords) {
				onIniciarPintado(coords.x, coords.y);
				onPintarCelda(coords.x, coords.y, shiftPresionado);
			}
		}
	}, [modoEdicion, modoGotero, capturarColorGotero, herramienta, obtenerCoordenadas, obtenerCoordenadasPixel, textoEnPunto, onIniciarPintado, onPintarCelda, onRellenarConectadas, onObtenerCeldasConectadas, onTextoSeleccionadoChange, shiftPresionado, hayCeldaEn, celdas, menuContextual.visible, textoSeleccionadoId]);

	/**
	 * Doble clic - editar texto existente
	 */
	const handleDoubleClick = useCallback((e) => {
		if (!modoEdicion || herramienta !== "texto") return;
		e.preventDefault();

		const coords = obtenerCoordenadasPixel(e);
		if (!coords) return;

		const textoEncontrado = textoEnPunto(coords.x, coords.y);
		if (textoEncontrado) {
			// Cargar el color y configuraci√≥n del texto en los controles
			onCambiarColor(textoEncontrado.color);
			onConfigTextoChange?.({
				fuente: textoEncontrado.fuente,
				tamano: textoEncontrado.tamano,
				negrita: textoEncontrado.negrita,
				cursiva: textoEncontrado.cursiva,
			});
			// Abrir input para editar el texto - calcular dimensiones seg√∫n el texto existente
			const canvas = canvasRef.current;
			const ctx = canvas?.getContext("2d");
			let anchoCalculado = 200;
			let altoCalculado = 40;
			if (ctx) {
				const fontStyle = `${textoEncontrado.cursiva ? "italic " : ""}${textoEncontrado.negrita ? "bold " : ""}${textoEncontrado.tamano}px ${textoEncontrado.fuente}`;
				ctx.font = fontStyle;
				const lineas = textoEncontrado.texto.split("\n");
				const alturaLinea = textoEncontrado.tamano * 1.2;
				let anchoMax = 0;
				lineas.forEach(linea => {
					const w = ctx.measureText(linea).width;
					if (w > anchoMax) anchoMax = w;
				});
				anchoCalculado = Math.max(200, anchoMax + 30);
				altoCalculado = Math.max(40, lineas.length * alturaLinea + 20);
			}
			setInputTexto({
				visible: true,
				x: textoEncontrado.x,
				y: textoEncontrado.y,
				valor: textoEncontrado.texto,
				editandoId: textoEncontrado.id,
				ancho: anchoCalculado,
				alto: altoCalculado,
				valorOriginal: textoEncontrado.texto
			});
			onTextoSeleccionadoChange?.(textoEncontrado.id);
		}
	}, [modoEdicion, herramienta, obtenerCoordenadasPixel, textoEnPunto, onTextoSeleccionadoChange, onCambiarColor, onConfigTextoChange]);

	/**
	 * Mouse move - continuar pintado o arrastre de texto/l√≠neas
	 */
	const handleMouseMove = useCallback((e) => {
		if (!modoEdicion) return;

		// Guardar posici√≥n del mouse para Ctrl+V
		const coordsPixel = obtenerCoordenadasPixel(e);
		if (coordsPixel) {
			posicionMouseRef.current = { x: coordsPixel.x, y: coordsPixel.y };
		}

		// Mover texto si est√° arrastrando
		if (arrastrando.activo && arrastrando.textoId) {
			const coords = obtenerCoordenadasPixel(e);
			if (coords) {
				onActualizarTexto?.(arrastrando.textoId, {
					x: coords.x - arrastrando.offsetX,
					y: coords.y - arrastrando.offsetY
				});
			}
			return;
		}

		// Mover l√≠neas conectadas si est√° arrastrando
		if (arrastrandoLineas.activo && arrastrandoLineas.celdasConectadas.length > 0) {
			const coords = obtenerCoordenadas(e);
			if (coords) {
				const deltaX = coords.x - arrastrandoLineas.ultimaCeldaX;
				const deltaY = coords.y - arrastrandoLineas.ultimaCeldaY;

				if (deltaX !== 0 || deltaY !== 0) {
					// Mover las celdas
					onMoverCeldasConectadas?.(arrastrandoLineas.celdasConectadas, deltaX, deltaY);

					// Actualizar las posiciones de las celdas conectadas (sumar el delta)
					const nuevasCeldasConectadas = arrastrandoLineas.celdasConectadas.map(clave => {
						const [x, y] = clave.split(",").map(Number);
						return `${x + deltaX},${y + deltaY}`;
					});

					// Actualizar el estado con la nueva posici√≥n
					setArrastrandoLineas(prev => ({
						...prev,
						celdasConectadas: nuevasCeldasConectadas,
						ultimaCeldaX: coords.x,
						ultimaCeldaY: coords.y,
					}));
				}
			}
			return;
		}

		// Actualizar √°rea del borrador si est√° seleccionando
		if (areaBorrador.activo) {
			const coords = obtenerCoordenadas(e);
			if (coords) {
				setAreaBorrador(prev => ({
					...prev,
					actualX: coords.x,
					actualY: coords.y,
				}));
			}
			return;
		}

		// Detectar si el mouse est√° sobre un texto (para cambiar cursor)
		if (herramienta === "texto") {
			const coords = obtenerCoordenadasPixel(e);
			if (coords) {
				const textoEncontrado = textoEnPunto(coords.x, coords.y);
				setSobreTexto(!!textoEncontrado);
			}
		}

		// Detectar si el mouse est√° sobre una l√≠nea (para cambiar cursor en herramienta mover)
		if (herramienta === "mover") {
			const coords = obtenerCoordenadas(e);
			if (coords) {
				setSobreLinea(hayCeldaEn(coords.x, coords.y));
			}
		}

		if (!estaPintando || herramienta === "texto" || herramienta === "mover" || herramienta === "borrador") return;
		manejarPintado(e);
	}, [modoEdicion, arrastrando, arrastrandoLineas, areaBorrador.activo, estaPintando, herramienta, obtenerCoordenadas, obtenerCoordenadasPixel, onActualizarTexto, onMoverCeldasConectadas, manejarPintado, textoEnPunto, hayCeldaEn]);

	/**
	 * Mouse up - detener pintado o arrastre
	 */
	const handleMouseUp = useCallback(() => {
		if (!modoEdicion) return;

		// Si estaba seleccionando √°rea para borrar, ejecutar el borrado
		if (areaBorrador.activo) {
			onBorrarArea?.(
				areaBorrador.inicioX,
				areaBorrador.inicioY,
				areaBorrador.actualX,
				areaBorrador.actualY
			);
			setAreaBorrador({
				activo: false,
				inicioX: 0,
				inicioY: 0,
				actualX: 0,
				actualY: 0,
			});
		}

		onDetenerPintado();
		setArrastrando({ activo: false, textoId: null, offsetX: 0, offsetY: 0 });
		setArrastrandoLineas({
			activo: false,
			celdasConectadas: [],
			celdaInicialX: 0,
			celdaInicialY: 0,
			ultimaCeldaX: 0,
			ultimaCeldaY: 0,
		});
	}, [modoEdicion, onDetenerPintado, areaBorrador, onBorrarArea]);

	/**
	 * Mouse leave - detener pintado si sale del canvas
	 */
	const handleMouseLeave = useCallback(() => {
		if (estaPintando) {
			onDetenerPintado();
		}
		if (arrastrando.activo) {
			setArrastrando({ activo: false, textoId: null, offsetX: 0, offsetY: 0 });
		}
		if (arrastrandoLineas.activo) {
			setArrastrandoLineas({
				activo: false,
				celdasConectadas: [],
				celdaInicialX: 0,
				celdaInicialY: 0,
				ultimaCeldaX: 0,
				ultimaCeldaY: 0,
			});
		}
		// Cancelar selecci√≥n de √°rea del borrador si sale del canvas
		if (areaBorrador.activo) {
			setAreaBorrador({
				activo: false,
				inicioX: 0,
				inicioY: 0,
				actualX: 0,
				actualY: 0,
			});
		}
		setSobreTexto(false);
		setSobreLinea(false);
	}, [estaPintando, arrastrando.activo, arrastrandoLineas.activo, areaBorrador.activo, onDetenerPintado]);

	/**
	 * Click derecho - mostrar men√∫ contextual para copiar/pegar
	 */
	const handleContextMenu = useCallback((e) => {
		// Siempre prevenir men√∫ del browser en modo edici√≥n
		if (!modoEdicion) return;

		// Si no es herramienta texto, solo prevenir el men√∫ del browser pero no mostrar nuestro men√∫
		if (herramienta !== "texto") {
			e.preventDefault();
			return;
		}

		e.preventDefault();
		e.stopPropagation();

		// Si el men√∫ contextual ya est√° abierto, solo cerrarlo
		if (menuContextual.visible) {
			setMenuContextual(prev => ({ ...prev, visible: false }));
			return;
		}

		const coords = obtenerCoordenadasPixel(e);
		if (!coords) return;

		// Verificar si hay un texto en esta posici√≥n para seleccionarlo
		const textoEncontrado = textoEnPunto(coords.x, coords.y);
		if (textoEncontrado) {
			onTextoSeleccionadoChange?.(textoEncontrado.id);
		} else {
			// Si hay un texto seleccionado y se hace click derecho fuera de √©l,
			// solo deseleccionar sin mostrar el men√∫ contextual
			if (textoSeleccionadoId) {
				onTextoSeleccionadoChange?.(null);
				return;
			}
		}

		// Obtener posici√≥n relativa al canvas para el men√∫
		const canvas = canvasRef.current;
		const rect = canvas.getBoundingClientRect();

		setMenuContextual({
			visible: true,
			x: e.clientX - rect.left,
			y: e.clientY - rect.top,
			pixelX: coords.x,
			pixelY: coords.y,
			// Guardar si hay texto seleccionado en el momento del click
			hayTextoEnPosicion: !!textoEncontrado,
		});
	}, [modoEdicion, herramienta, obtenerCoordenadasPixel, textoEnPunto, onTextoSeleccionadoChange, textoSeleccionadoId, menuContextual.visible]);

	/**
	 * Copiar texto seleccionado
	 */
	const copiarTexto = useCallback(() => {
		if (textoSeleccionadoId) {
			const textoACopiar = textos.find(t => t.id === textoSeleccionadoId);
			if (textoACopiar) {
				setTextoCopiado({ ...textoACopiar });
			}
			// Quitar la selecci√≥n despu√©s de copiar
			onTextoSeleccionadoChange?.(null);
		}
		setMenuContextual(prev => ({ ...prev, visible: false }));
	}, [textoSeleccionadoId, textos, onTextoSeleccionadoChange]);

	/**
	 * Pegar texto copiado
	 */
	const pegarTexto = useCallback(() => {
		if (textoCopiado) {
			onAgregarTexto?.(menuContextual.pixelX, menuContextual.pixelY, textoCopiado.texto);
			// Actualizar el texto reci√©n pegado con los estilos del copiado
			setTimeout(() => {
				const ultimoTexto = textos[textos.length - 1];
				if (ultimoTexto) {
					onActualizarTexto?.(ultimoTexto.id, {
						color: textoCopiado.color,
						fuente: textoCopiado.fuente,
						tamano: textoCopiado.tamano,
						negrita: textoCopiado.negrita,
						cursiva: textoCopiado.cursiva,
					});
				}
			}, 50);
		}
		setMenuContextual(prev => ({ ...prev, visible: false }));
	}, [textoCopiado, menuContextual.pixelX, menuContextual.pixelY, onAgregarTexto, onActualizarTexto, textos]);

	/**
	 * Eliminar texto seleccionado desde el men√∫ contextual
	 */
	const eliminarTextoMenu = useCallback(() => {
		if (textoSeleccionadoId) {
			onEliminarTexto?.(textoSeleccionadoId);
		}
		setMenuContextual(prev => ({ ...prev, visible: false }));
	}, [textoSeleccionadoId, onEliminarTexto]);

	/**
	 * Cerrar men√∫ contextual al hacer click fuera
	 */
	useEffect(() => {
		const handleClick = () => {
			if (menuContextual.visible) {
				setMenuContextual(prev => ({ ...prev, visible: false }));
			}
		};

		if (menuContextual.visible) {
			// Usar setTimeout para evitar que el click que abre el men√∫ lo cierre
			setTimeout(() => {
				window.addEventListener("click", handleClick);
			}, 0);
		}

		return () => {
			window.removeEventListener("click", handleClick);
		};
	}, [menuContextual.visible]);

	// Touch events para m√≥vil
	const handleTouchStart = useCallback((e) => {
		if (!modoEdicion || herramienta === "texto") return;
		e.preventDefault();
		const touch = e.touches[0];
		const coords = obtenerCoordenadas({ clientX: touch.clientX, clientY: touch.clientY });
		if (coords) {
			onIniciarPintado(coords.x, coords.y);
			onPintarCelda(coords.x, coords.y, false);
		}
	}, [modoEdicion, herramienta, obtenerCoordenadas, onIniciarPintado, onPintarCelda]);

	const handleTouchMove = useCallback((e) => {
		if (!modoEdicion || !estaPintando || herramienta === "texto") return;
		e.preventDefault();
		const touch = e.touches[0];
		const mouseEvent = { clientX: touch.clientX, clientY: touch.clientY };
		manejarPintado(mouseEvent);
	}, [modoEdicion, estaPintando, herramienta, manejarPintado]);

	const handleTouchEnd = useCallback(() => {
		if (!modoEdicion) return;
		onDetenerPintado();
	}, [modoEdicion, onDetenerPintado]);

	/**
	 * Confirmar texto ingresado (nuevo o editado)
	 */
	const confirmarTexto = useCallback(() => {
		if (inputTexto.valor.trim()) {
			if (inputTexto.editandoId) {
				// Actualizar texto existente - incluir color, fuente, tama√±o, negrita y cursiva
				onActualizarTexto?.(inputTexto.editandoId, {
					texto: inputTexto.valor,
					color: colorSeleccionado,
					fuente: configTexto.fuente,
					tamano: configTexto.tamano,
					negrita: configTexto.negrita,
					cursiva: configTexto.cursiva,
				});
			} else {
				// Agregar nuevo texto
				onAgregarTexto?.(inputTexto.x, inputTexto.y, inputTexto.valor);
			}
		} else if (inputTexto.editandoId) {
			// Si el texto queda vac√≠o al editar, eliminar
			onEliminarTexto?.(inputTexto.editandoId);
		}
		setInputTexto({ visible: false, x: 0, y: 0, valor: "", editandoId: null, ancho: 220, alto: 55, valorOriginal: "" });
	}, [inputTexto, colorSeleccionado, configTexto, onAgregarTexto, onActualizarTexto, onEliminarTexto]);

	/**
	 * Cancelar input de texto (para nuevo texto, simplemente cierra)
	 */
	const cancelarTexto = useCallback(() => {
		setInputTexto({ visible: false, x: 0, y: 0, valor: "", editandoId: null, ancho: 220, alto: 55, valorOriginal: "" });
	}, []);

	/**
	 * Descartar cambios y volver al valor original (solo para edici√≥n)
	 */
	const descartarCambios = useCallback(() => {
		setInputTexto({ visible: false, x: 0, y: 0, valor: "", editandoId: null, ancho: 220, alto: 55, valorOriginal: "" });
	}, []);

	/**
	 * Eliminar el texto que se est√° editando
	 */
	const eliminarTextoActual = useCallback(() => {
		if (inputTexto.editandoId) {
			onEliminarTexto?.(inputTexto.editandoId);
		}
		setInputTexto({ visible: false, x: 0, y: 0, valor: "", editandoId: null, ancho: 220, alto: 55, valorOriginal: "" });
	}, [inputTexto.editandoId, onEliminarTexto]);

	/**
	 * Manejar teclas en el textarea de texto
	 * - Enter: confirma el texto
	 * - Alt+Enter: agrega salto de l√≠nea
	 * - Escape: cancela
	 */
	const handleInputKeyDown = useCallback((e) => {
		if (e.key === "Enter") {
			if (e.altKey) {
				// Alt+Enter: insertar salto de l√≠nea
				e.preventDefault();
				const textarea = e.target;
				const start = textarea.selectionStart;
				const end = textarea.selectionEnd;
				const valor = inputTexto.valor;
				const nuevoValor = valor.substring(0, start) + "\n" + valor.substring(end);
				setInputTexto(prev => ({ ...prev, valor: nuevoValor }));
				// Reposicionar cursor despu√©s del salto de l√≠nea
				setTimeout(() => {
					textarea.selectionStart = textarea.selectionEnd = start + 1;
				}, 0);
			} else {
				// Enter solo: confirmar texto
				e.preventDefault();
				confirmarTexto();
			}
		} else if (e.key === "Escape") {
			cancelarTexto();
		}
	}, [confirmarTexto, cancelarTexto, inputTexto.valor]);

	/**
	 * Manejar cambio de texto en el textarea
	 */
	const handleTextareaInput = useCallback((e) => {
		setInputTexto(prev => ({ ...prev, valor: e.target.value }));
	}, []);

	/**
	 * Iniciar redimensionamiento del textarea
	 */
	const iniciarRedimension = useCallback((e, handle) => {
		e.preventDefault();
		e.stopPropagation();
		setRedimensionando({
			activo: true,
			handle,
			inicioX: e.clientX,
			inicioY: e.clientY,
			anchoInicial: inputTexto.ancho,
			altoInicial: inputTexto.alto,
		});
	}, [inputTexto.ancho, inputTexto.alto]);

	/**
	 * Manejar movimiento durante redimensionamiento
	 */
	useEffect(() => {
		if (!redimensionando.activo) return;

		const handleMouseMove = (e) => {
			const deltaX = e.clientX - redimensionando.inicioX;
			const deltaY = e.clientY - redimensionando.inicioY;
			const handle = redimensionando.handle;

			let nuevoAncho = redimensionando.anchoInicial;
			let nuevoAlto = redimensionando.altoInicial;

			// Calcular nuevo tama√±o seg√∫n el handle
			if (handle.includes("e")) nuevoAncho = Math.max(100, redimensionando.anchoInicial + deltaX);
			if (handle.includes("w")) nuevoAncho = Math.max(100, redimensionando.anchoInicial - deltaX);
			if (handle.includes("s")) nuevoAlto = Math.max(30, redimensionando.altoInicial + deltaY);
			if (handle.includes("n")) nuevoAlto = Math.max(30, redimensionando.altoInicial - deltaY);

			setInputTexto(prev => ({ ...prev, ancho: nuevoAncho, alto: nuevoAlto }));
		};

		const handleMouseUp = () => {
			setRedimensionando({ activo: false, handle: null, inicioX: 0, inicioY: 0, anchoInicial: 0, altoInicial: 0 });
		};

		window.addEventListener("mousemove", handleMouseMove);
		window.addEventListener("mouseup", handleMouseUp);

		return () => {
			window.removeEventListener("mousemove", handleMouseMove);
			window.removeEventListener("mouseup", handleMouseUp);
		};
	}, [redimensionando]);

	// Si no hay dibujo y no est√° en modo edici√≥n, no renderizar nada
	if (!modoEdicion && Object.keys(celdas).length === 0 && textos.length === 0) {
		return null;
	}

	// Cursor seg√∫n herramienta y estado
	const getCursor = () => {
		if (!modoEdicion) return "default";
		// Si el modo gotero est√° activo, mostrar cursor de cuentagotas
		if (modoGotero) return "crosshair";
		if (arrastrando.activo) return "grabbing";
		if (arrastrandoLineas.activo) return "grabbing";
		if (herramienta === "borrador") return "crosshair";
		if (herramienta === "balde") return "crosshair";
		if (herramienta === "borne") return "crosshair";
		if (herramienta === "mover") {
			// Mostrar manito si est√° sobre una l√≠nea
			if (sobreLinea) return "grab";
			return "move";
		}
		if (herramienta === "texto") {
			// Mostrar manito si est√° sobre un texto existente
			if (sobreTexto) return "grab";
			return "text";
		}
		// Pincel usa el mismo cursor que borrador (crosshair)
		return "crosshair";
	};

	return (
		<div
			ref={contenedorRef}
			className={`grilla-unifilar ${modoEdicion ? "grilla-unifilar--editando" : "grilla-unifilar--fondo"}`}
			onContextMenu={handleContextMenu}
		>
			<canvas
				ref={canvasRef}
				className="grilla-unifilar__canvas"
				onMouseDown={handleMouseDown}
				onMouseMove={handleMouseMove}
				onMouseUp={handleMouseUp}
				onMouseLeave={handleMouseLeave}
				onDoubleClick={handleDoubleClick}
				onContextMenu={handleContextMenu}
				onTouchStart={handleTouchStart}
				onTouchMove={handleTouchMove}
				onTouchEnd={handleTouchEnd}
				style={{ cursor: getCursor() }}
			/>
			{/* Canvas overlay para chispas - separado para mejor rendimiento */}
			<canvas
				ref={canvasChispasRef}
				className="grilla-unifilar__canvas-chispas"
				style={{ pointerEvents: "none" }}
			/>

			{/* Men√∫ contextual para copiar/pegar texto */}
			{menuContextual.visible && (
				<div
					className="grilla-unifilar__menu-contextual"
					style={{ left: menuContextual.x, top: menuContextual.y }}
					onClick={(e) => e.stopPropagation()}
					onContextMenu={(e) => e.preventDefault()}
				>
					<button
						type="button"
						className={`grilla-unifilar__menu-item ${!menuContextual.hayTextoEnPosicion ? "grilla-unifilar__menu-item--disabled" : ""}`}
						onClick={copiarTexto}
						disabled={!menuContextual.hayTextoEnPosicion}
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
							<path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
						</svg>
						<span>Copiar</span>
						<span className="grilla-unifilar__menu-shortcut">Ctrl+C</span>
					</button>
					<button
						type="button"
						className={`grilla-unifilar__menu-item ${!textoCopiado ? "grilla-unifilar__menu-item--disabled" : ""}`}
						onClick={pegarTexto}
						disabled={!textoCopiado}
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
							<path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"/>
						</svg>
						<span>Pegar</span>
						<span className="grilla-unifilar__menu-shortcut">Ctrl+V</span>
					</button>
					{/* Separador */}
					{menuContextual.hayTextoEnPosicion && (
						<div className="grilla-unifilar__menu-separator" />
					)}
					{/* Eliminar - solo si hay texto en la posici√≥n */}
					<button
						type="button"
						className={`grilla-unifilar__menu-item grilla-unifilar__menu-item--eliminar ${!menuContextual.hayTextoEnPosicion ? "grilla-unifilar__menu-item--disabled" : ""}`}
						onClick={eliminarTextoMenu}
						disabled={!menuContextual.hayTextoEnPosicion}
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
							<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
						</svg>
						<span>Eliminar</span>
						<span className="grilla-unifilar__menu-shortcut">Delete</span>
					</button>
				</div>
			)}

			{/* Textarea flotante redimensionable para texto */}
			{inputTexto.visible && (
				<div
					className="grilla-unifilar__input-texto"
					style={{ left: inputTexto.x, top: inputTexto.y }}
				>
					<div className="grilla-unifilar__input-wrapper">
						<div
							className="grilla-unifilar__textarea-container"
							style={{ width: inputTexto.ancho, height: inputTexto.alto }}
						>
							<textarea
								ref={textareaRef}
								autoFocus
								value={inputTexto.valor}
								onChange={handleTextareaInput}
								onKeyDown={handleInputKeyDown}
								placeholder="Escribir texto... (Alt+Enter para nueva l√≠nea)"
								style={{
									fontFamily: configTexto.fuente,
									fontSize: `${configTexto.tamano}px`,
									fontWeight: configTexto.negrita ? "bold" : "normal",
									fontStyle: configTexto.cursiva ? "italic" : "normal",
									color: colorSeleccionado,
								}}
							/>
							{/* Handles de redimensionamiento - Esquinas */}
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--nw" onMouseDown={(e) => iniciarRedimension(e, "nw")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--ne" onMouseDown={(e) => iniciarRedimension(e, "ne")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--sw" onMouseDown={(e) => iniciarRedimension(e, "sw")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--se" onMouseDown={(e) => iniciarRedimension(e, "se")} />
							{/* Handles de redimensionamiento - Lados */}
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--n" onMouseDown={(e) => iniciarRedimension(e, "n")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--s" onMouseDown={(e) => iniciarRedimension(e, "s")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--e" onMouseDown={(e) => iniciarRedimension(e, "e")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--w" onMouseDown={(e) => iniciarRedimension(e, "w")} />
						</div>
						{/* Botones de acci√≥n */}
						<div className="grilla-unifilar__input-acciones">
							{/* Aceptar */}
							<button
								type="button"
								className="grilla-unifilar__input-btn grilla-unifilar__input-btn--aceptar"
								onClick={confirmarTexto}
								title="Aceptar (Enter)"
							>
								<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
									<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
								</svg>
							</button>
							{/* Cerrar/Volver - cambia seg√∫n si es nuevo texto o edici√≥n */}
							<button
								type="button"
								className={`grilla-unifilar__input-btn ${inputTexto.editandoId ? "grilla-unifilar__input-btn--volver" : "grilla-unifilar__input-btn--cerrar"}`}
								onClick={cancelarTexto}
								title={inputTexto.editandoId ? "Volver (Esc)" : "Cerrar (Esc)"}
							>
								{inputTexto.editandoId ? (
									/* Icono de undo (deshacer) para edici√≥n */
									<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
										<path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
									</svg>
								) : (
									/* X para cerrar nuevo texto */
									<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
										<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
									</svg>
								)}
							</button>
						</div>
					</div>
				</div>
			)}

			{/* Barra de herramientas - solo en modo edici√≥n */}
			{modoEdicion && (
				<div className="grilla-unifilar__toolbar">
					{/* Selector de colores */}
					<div className="grilla-unifilar__colores">
						{coloresDisponibles.map((c) => (
							<button
								key={c.id}
								type="button"
								className={`grilla-unifilar__color ${colorSeleccionado === c.color ? "grilla-unifilar__color--activo" : ""} ${c.id === "negro" ? "grilla-unifilar__color--negro" : ""}`}
								style={{ backgroundColor: c.color }}
								onClick={() => {
									onCambiarColor(c.color);
									if (herramienta !== "texto") {
										onSeleccionarPincel();
									}
								}}
								title={c.nombre}
							/>
						))}
						{/* Separador entre negro y color picker */}
						<div className="grilla-unifilar__separador" />
						{/* Color picker personalizado */}
						<ColorPickerSimple
							color={colorSeleccionado}
							onChange={(color) => {
								onCambiarColor(color);
								if (herramienta !== "texto") {
									onSeleccionarPincel();
								}
							}}
							label=""
							posicionArriba={true}
						/>
					</div>

					{/* Secci√≥n de grosor y gotero */}
					<div className="grilla-unifilar__seccion-grosor">
						{/* Selector de grosor de l√≠nea */}
						<select
							className="grilla-unifilar__select grilla-unifilar__select--grosor"
							value={grosorLinea}
							onChange={(e) => onCambiarGrosor?.(Number(e.target.value))}
							title="Grosor de l√≠nea"
						>
							{grosoresDisponibles.map((g) => (
								<option key={g.id} value={g.valor}>
									{g.nombre}
								</option>
							))}
						</select>
						{/* Gotero - copiar color del canvas */}
						<button
							type="button"
							className={`grilla-unifilar__btn ${modoGotero ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={() => setModoGotero(!modoGotero)}
							title="Gotero - clic en el canvas para copiar color"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M20.71 5.63l-2.34-2.34a1 1 0 00-1.41 0l-3.12 3.12-1.41-1.41-1.42 1.42 1.41 1.41-7.83 7.83a2 2 0 00-.59 1.42V19h2.83c.53 0 1.04-.21 1.42-.59l7.83-7.83 1.41 1.41 1.42-1.42-1.41-1.41 3.12-3.12a1 1 0 00.09-1.41zM6.41 18H5v-1.41l7.83-7.83 1.41 1.41L6.41 18z"/>
							</svg>
						</button>
					</div>

					{/* Herramientas */}
					<div className="grilla-unifilar__herramientas">
						{/* Pincel */}
						<button
							type="button"
							className={`grilla-unifilar__btn ${herramienta === "pincel" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={onSeleccionarPincel}
							title="Pincel (mantener Shift para l√≠nea recta)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34a.996.996 0 00-1.41 0L9 12.25 11.75 15l8.96-8.96a.996.996 0 000-1.41z"/>
							</svg>
						</button>
						<button
							type="button"
							className={`grilla-unifilar__btn ${herramienta === "borrador" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={onSeleccionarBorrador}
							title="Borrador"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M15.14 3c-.51 0-1.02.2-1.41.59L2.59 14.73c-.78.78-.78 2.05 0 2.83l3.85 3.85c.39.39.9.59 1.41.59h8.48c.53 0 1.04-.21 1.41-.59l3.67-3.67c.78-.78.78-2.05 0-2.83L12.56 3.59C12.17 3.2 11.66 3 11.14 3h4zm-9.71 18H8.3l8.57-8.57-2.83-2.83L5.43 18.17l-.01 2.83z"/>
							</svg>
						</button>
						<button
							type="button"
							className={`grilla-unifilar__btn ${herramienta === "balde" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={onSeleccionarBalde}
							title="Balde de pintura (cambiar color de l√≠neas conectadas)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M19 11.5s-2 2.17-2 3.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-3.5-2-3.5zM5.21 10L10 5.21 14.79 10H5.21zM16.56 8.94L10 2.38 3.44 8.94c-.59.59-.59 1.54 0 2.12l6.56 6.56c.59.59 1.54.59 2.12 0l6.44-6.44c.59-.59.59-1.54 0-2.12l-.12-.12z"/>
							</svg>
						</button>
						<button
							type="button"
							className={`grilla-unifilar__btn ${herramienta === "texto" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={onSeleccionarTexto}
							title="Texto (doble clic para editar, arrastrar para mover)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M5 4v3h5.5v12h3V7H19V4H5z"/>
							</svg>
						</button>
						<button
							type="button"
							className={`grilla-unifilar__btn ${herramienta === "mover" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={onSeleccionarMover}
							title="Mover l√≠neas (arrastra l√≠neas conectadas)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"/>
							</svg>
						</button>
						<button
							type="button"
							className="grilla-unifilar__btn grilla-unifilar__btn--peligro"
							onClick={onLimpiarTodo}
							title="Limpiar todo"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
							</svg>
						</button>

						{/* Separador */}
						<div className="grilla-unifilar__separador" />

						{/* === HERRAMIENTAS DE BORNES Y CHISPAS === */}
						{/* Borne Emisor */}
						<button
							type="button"
							className={`grilla-unifilar__btn grilla-unifilar__btn--emisor ${herramienta === "borne" && tipoBorneActivo === "EMISOR" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={() => {
								setTipoBorneActivo("EMISOR");
								onSeleccionarBorne?.();
							}}
							title="Colocar borne emisor (origen de chispas)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M11 21h-1l1-7H7.5c-.58 0-.57-.32-.38-.66l.07-.12C8.48 10.94 10.42 7.54 13 3h1l-1 7h3.5c.49 0 .56.33.47.51l-.07.15C12.96 17.55 11 21 11 21z"/>
							</svg>
						</button>
						{/* Borne Receptor */}
						<button
							type="button"
							className={`grilla-unifilar__btn grilla-unifilar__btn--receptor ${herramienta === "borne" && tipoBorneActivo === "RECEPTOR" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={() => {
								setTipoBorneActivo("RECEPTOR");
								onSeleccionarBorne?.();
							}}
							title="Colocar borne receptor (destino de chispas)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" strokeWidth="2"/>
								<circle cx="12" cy="12" r="6" fill="none" stroke="currentColor" strokeWidth="2"/>
								<circle cx="12" cy="12" r="2"/>
							</svg>
						</button>
						{/* Play/Stop chispas */}
						<button
							type="button"
							className={`grilla-unifilar__btn ${animandoChispas ? "grilla-unifilar__btn--activo grilla-unifilar__btn--animando" : ""}`}
							onClick={onToggleAnimacionChispas}
							title={animandoChispas ? "Detener animaci√≥n de chispas" : "Iniciar animaci√≥n de chispas"}
							disabled={bornes.filter(b => b.tipo === "EMISOR").length === 0 || bornes.filter(b => b.tipo === "RECEPTOR").length === 0}
						>
							{animandoChispas ? (
								<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
									<rect x="6" y="4" width="4" height="16"/>
									<rect x="14" y="4" width="4" height="16"/>
								</svg>
							) : (
								<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
									<path d="M8 5v14l11-7z"/>
								</svg>
							)}
						</button>
						{/* Configuraci√≥n de chispas */}
						<button
							type="button"
							className={`grilla-unifilar__btn ${panelChispasVisible ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={() => setPanelChispasVisible(!panelChispasVisible)}
							title="Configuraci√≥n de chispas"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
							</svg>
						</button>
					</div>

					{/* Opciones de texto - solo si herramienta es texto */}
					{herramienta === "texto" && (
						<div className="grilla-unifilar__texto-opciones">
							{/* Selector de fuente */}
							<select
								className="grilla-unifilar__select"
								value={configTexto.fuente}
								onChange={(e) => {
									const nuevaFuente = e.target.value;
									// Siempre actualizar configTexto para el textarea visible
									onConfigTextoChange?.({ ...configTexto, fuente: nuevaFuente });
									// Si hay un texto seleccionado (sin textarea abierto), actualizarlo directamente
									if (!inputTexto.visible && textoSeleccionadoId) {
										onActualizarTexto?.(textoSeleccionadoId, { fuente: nuevaFuente });
									}
								}}
								title="Fuente"
							>
								{fuentesDisponibles.map((f) => (
									<option key={f.id} value={f.familia}>
										{f.nombre}
									</option>
								))}
							</select>

							{/* Selector de tama√±o */}
							<select
								className="grilla-unifilar__select grilla-unifilar__select--tamano"
								value={configTexto.tamano}
								onChange={(e) => {
									const nuevoTamano = Number(e.target.value);
									// Siempre actualizar configTexto para el textarea visible
									onConfigTextoChange?.({ ...configTexto, tamano: nuevoTamano });
									// Si hay un texto seleccionado (sin textarea abierto), actualizarlo directamente
									if (!inputTexto.visible && textoSeleccionadoId) {
										onActualizarTexto?.(textoSeleccionadoId, { tamano: nuevoTamano });
									}
								}}
								title="Tama√±o"
							>
								{tamanosDisponibles.map((t) => (
									<option key={t} value={t}>
										{t}px
									</option>
								))}
							</select>

							{/* Bot√≥n negrita */}
							<button
								type="button"
								className={`grilla-unifilar__btn grilla-unifilar__btn--formato ${
									configTexto.negrita ? "grilla-unifilar__btn--activo" : ""
								}`}
								onClick={() => {
									// Si hay textarea abierto (editando o creando), cambiar configTexto
									if (inputTexto.visible) {
										onConfigTextoChange?.({ ...configTexto, negrita: !configTexto.negrita });
									} else if (textoSeleccionadoId) {
										// Si hay un texto seleccionado sin textarea, actualizarlo directamente
										const textoActual = textos.find(t => t.id === textoSeleccionadoId);
										if (textoActual) {
											onActualizarTexto?.(textoSeleccionadoId, { negrita: !textoActual.negrita });
										}
									} else {
										// Cambiar config para el pr√≥ximo texto
										onConfigTextoChange?.({ ...configTexto, negrita: !configTexto.negrita });
									}
								}}
								title="Negrita"
							>
								<strong>B</strong>
							</button>

							{/* Bot√≥n cursiva */}
							<button
								type="button"
								className={`grilla-unifilar__btn grilla-unifilar__btn--formato ${
									configTexto.cursiva ? "grilla-unifilar__btn--activo" : ""
								}`}
								onClick={() => {
									// Si hay textarea abierto (editando o creando), cambiar configTexto
									if (inputTexto.visible) {
										onConfigTextoChange?.({ ...configTexto, cursiva: !configTexto.cursiva });
									} else if (textoSeleccionadoId) {
										// Si hay un texto seleccionado sin textarea, actualizarlo directamente
										const textoActual = textos.find(t => t.id === textoSeleccionadoId);
										if (textoActual) {
											onActualizarTexto?.(textoSeleccionadoId, { cursiva: !textoActual.cursiva });
										}
									} else {
										// Cambiar config para el pr√≥ximo texto
										onConfigTextoChange?.({ ...configTexto, cursiva: !configTexto.cursiva });
									}
								}}
								title="Cursiva"
							>
								<em>I</em>
							</button>

							{/* Eliminar texto seleccionado */}
							{textoSeleccionadoId && (
								<button
									type="button"
									className="grilla-unifilar__btn grilla-unifilar__btn--peligro"
									onClick={() => onEliminarTexto?.(textoSeleccionadoId)}
									title="Eliminar texto (Delete)"
								>
									<svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
										<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
									</svg>
								</button>
							)}
						</div>
					)}

					{/* Panel de configuraci√≥n de chispas */}
					{panelChispasVisible && (
						<div className="grilla-unifilar__panel-chispas">
							<div className="grilla-unifilar__panel-header">
								<div className="grilla-unifilar__panel-titulo">Configuraci√≥n de Chispas</div>
								<div className="grilla-unifilar__panel-info-inline">
									Emisores: {bornes.filter(b => b.tipo === "EMISOR").length} | Receptores: {bornes.filter(b => b.tipo === "RECEPTOR").length}
								</div>
							</div>

							<div className="grilla-unifilar__panel-columnas">
								{/* === COLUMNA IZQUIERDA === */}
								<div className="grilla-unifilar__panel-columna">
									{/* Forma y Color en fila */}
									<div className="grilla-unifilar__panel-fila">
										<div className="grilla-unifilar__panel-campo grilla-unifilar__panel-campo--flex">
											<label>Forma:</label>
											<select
												className="grilla-unifilar__panel-select"
												value={chispasConfig.forma || "circulo"}
												onChange={(e) => onActualizarChispasConfig?.({ forma: e.target.value })}
											>
												<option value="circulo">C√≠rculo</option>
												<option value="cuadrado">Cuadrado</option>
												<option value="estrella">Estrella</option>
												<option value="rayo">Rayo</option>
												<option value="flecha">Flecha</option>
												<option value="gota">Gota</option>
												<option value="anillo">Anillo</option>
												<option value="barra">Barra |</option>
											</select>
										</div>
										<div className="grilla-unifilar__panel-campo grilla-unifilar__panel-campo--color">
											<label>Color:</label>
											<input
												type="color"
												value={chispasConfig.color || "#fef08a"}
												onChange={(e) => onActualizarChispasConfig?.({ color: e.target.value })}
											/>
										</div>
									</div>

									{/* Tama√±o */}
									<div className="grilla-unifilar__panel-campo">
										<label>Tama√±o:</label>
										<div className="grilla-unifilar__panel-slider-input">
											<input
												type="range"
												min="2"
												max="10"
												value={chispasConfig.tamano || 4}
												onChange={(e) => onActualizarChispasConfig?.({ tamano: Number(e.target.value) })}
											/>
											<input
												type="number"
												className="grilla-unifilar__panel-number"
												min="2"
												max="10"
												value={chispasConfig.tamano || 4}
												onChange={(e) => {
													const val = Math.min(10, Math.max(2, Number(e.target.value) || 2));
													onActualizarChispasConfig?.({ tamano: val });
												}}
												onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
											/>
											<span className="grilla-unifilar__panel-unidad">px</span>
										</div>
									</div>

									{/* Velocidad */}
									<div className="grilla-unifilar__panel-campo">
										<label>Velocidad:</label>
										<div className="grilla-unifilar__panel-slider-input">
											<input
												type="range"
												min="1"
												max="20"
												value={chispasConfig.velocidad || 8}
												onChange={(e) => onActualizarChispasConfig?.({ velocidad: Number(e.target.value) })}
											/>
											<input
												type="number"
												className="grilla-unifilar__panel-number"
												min="1"
												max="20"
												value={chispasConfig.velocidad || 8}
												onChange={(e) => {
													const val = Math.min(20, Math.max(1, Number(e.target.value) || 1));
													onActualizarChispasConfig?.({ velocidad: val });
												}}
												onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
											/>
											<span className="grilla-unifilar__panel-unidad">cel/s</span>
										</div>
									</div>
								</div>

								{/* === COLUMNA DERECHA === */}
								<div className="grilla-unifilar__panel-columna">
									{/* Intervalo entre emisiones (en segundos) */}
									<div className="grilla-unifilar__panel-campo">
										<label>Intervalo:</label>
										<div className="grilla-unifilar__panel-slider-input">
											<input
												type="range"
												min="0.3"
												max="5"
												step="0.1"
												value={(chispasConfig.frecuenciaEmision || 2000) / 1000}
												onChange={(e) => onActualizarChispasConfig?.({ frecuenciaEmision: Math.round(Number(e.target.value) * 1000) })}
											/>
											<input
												type="number"
												className="grilla-unifilar__panel-number"
												min="0.3"
												max="5"
												step="0.1"
												value={((chispasConfig.frecuenciaEmision || 2000) / 1000).toFixed(1)}
												onChange={(e) => {
													const val = Math.min(5, Math.max(0.3, Number(e.target.value) || 0.3));
													onActualizarChispasConfig?.({ frecuenciaEmision: Math.round(val * 1000) });
												}}
												onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
											/>
											<span className="grilla-unifilar__panel-unidad">seg</span>
										</div>
									</div>

									{/* Estela checkbox + longitud */}
									<div className="grilla-unifilar__panel-campo grilla-unifilar__panel-campo--checkbox">
										<label>
											<input
												type="checkbox"
												checked={chispasConfig.estela !== false}
												onChange={(e) => onActualizarChispasConfig?.({ estela: e.target.checked })}
											/>
											Mostrar estela
										</label>
									</div>

									{/* Longitud estela */}
									{chispasConfig.estela !== false && (
										<div className="grilla-unifilar__panel-campo">
											<label>Longitud:</label>
											<div className="grilla-unifilar__panel-slider-input">
												<input
													type="range"
													min="1"
													max="10"
													value={chispasConfig.longitudEstela || 5}
													onChange={(e) => onActualizarChispasConfig?.({ longitudEstela: Number(e.target.value) })}
												/>
												<input
													type="number"
													className="grilla-unifilar__panel-number"
													min="1"
													max="10"
													value={chispasConfig.longitudEstela || 5}
													onChange={(e) => {
														const val = Math.min(10, Math.max(1, Number(e.target.value) || 1));
														onActualizarChispasConfig?.({ longitudEstela: val });
													}}
													onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
												/>
												<span className="grilla-unifilar__panel-unidad">celdas</span>
											</div>
										</div>
									)}
								</div>
							</div>
						</div>
					)}

					{/* Indicador de Shift */}
					{herramienta === "pincel" && shiftPresionado && (
						<div className="grilla-unifilar__shift-indicator">
							L√≠nea recta
						</div>
					)}

					{/* Bot√≥n cerrar */}
					<button
						type="button"
						className="grilla-unifilar__btn grilla-unifilar__btn--cerrar"
						onClick={onCerrarEdicion}
						title="Finalizar edici√≥n"
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
							<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
						</svg>
						<span>Listo</span>
					</button>
				</div>
			)}
		</div>
	);
};

export default GrillaUnifilar;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrupoMedidores.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/GrupoMedidores.jsx

import React from "react"; 

/**
 * Renderiza un grupo de cajas de medici√≥n (parte superior o inferior).
 */
const GrupoMedidores = ({ titulo, boxes, zona, renderizarCaja, estiloTitulo, gap }) => {     // zona: "sup" o "inf"
	// Estilo del contenedor de boxes (gap din√°mico)
	const estiloMeters = gap ? { gap } : {};

	return (
		<div className="alim-card-section">
			<h3
				className="alim-card-section-title"
				style={estiloTitulo || {}}
			>{titulo}</h3>            {/* t√≠tulo del bloque (ej: CONSUMO, TENSI√ìN) */}
			<div
				className="alim-card-meters"
				style={Object.keys(estiloMeters).length > 0 ? estiloMeters : undefined}
			>
				{boxes.map((box, idx) => renderizarCaja(box, idx, zona))}     {/* delega el render de cada CajaMedicion */}
			</div>
		</div>
	);
};

export default GrupoMedidores;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (GrupoMedidores.jsx)

 - Este componente es un contenedor: solo recibe `titulo`, `boxes` y una
   funci√≥n `renderizarCaja` y se encarga de ordenarlos dentro del layout de la
   tarjeta (`alim-card-section` / `alim-card-meters`).

 - La prop `zona` sirve para que el renderizador de cajas sepa si est√° dibujando
   la parte superior ("sup") o inferior ("inf") de la tarjeta.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (GrupoMedidores.jsx)

0) Visi√≥n general del componente

   `GrupoMedidores` es un componente muy simple que act√∫a como contenedor de un
   bloque de mediciones dentro de la tarjeta de alimentador.

   Pod√©s verlo como ‚Äúla fila‚Äù que contiene:
     - un t√≠tulo (por ejemplo: ‚ÄúCONSUMO (A)‚Äù o ‚ÄúTENSI√ìN (kV)‚Äù),
     - una serie de cajas de medici√≥n (`CajaMedicion`) ordenadas en una l√≠nea.

   No sabe de d√≥nde vienen los datos ni c√≥mo se dibuja cada caja; solo recibe
   todo por props y lo coloca en el layout correcto.


1) Props del componente

   const GrupoMedidores = ({ titulo, boxes, zona, renderizarCaja }) => { ... }

   - `titulo` (string):
       ‚Ä¢ texto que se muestra arriba del grupo,
       ‚Ä¢ ejemplos: ‚ÄúCONSUMO (A)‚Äù, ‚ÄúTENSI√ìN (kV)‚Äù, ‚ÄúPOTENCIAS‚Äù, etc.

   - `boxes` (array):
       ‚Ä¢ lista de objetos de caja ya normalizados,
       ‚Ä¢ t√≠picamente cada `box` tiene:
           - `etiqueta`  ‚Üí texto de cabecera de la caja,
           - `valor`     ‚Üí valor a mostrar,
           - `enabled`   ‚Üí si est√° activa o no,
           - `origen`    ‚Üí de d√≥nde viene la medici√≥n (rel√© / analizador).

       ‚Ä¢ Este componente NO modifica ni interpreta ese contenido,
         solo los recorre para dibujarlos.

   - `zona` (string):
       ‚Ä¢ indica si este grupo pertenece a:
           - "sup" ‚Üí parte superior de la tarjeta,
           - "inf" ‚Üí parte inferior de la tarjeta.
       ‚Ä¢ Se le pasa al renderizador de cajas para que pueda ajustar estilos/
         l√≥gica seg√∫n la zona si es necesario.

   - `renderizarCaja` (funci√≥n):
       ‚Ä¢ funci√≥n que sabe c√≥mo transformar `{ box, idx, zona }` en un elemento
         React (normalmente una `CajaMedicion`).
       ‚Ä¢ Firma t√≠pica: `(box, idx, zona) => <CajaMedicion ... />`
       ‚Ä¢ La idea es que `GrupoMedidores` no tenga que conocer los detalles de
         `CajaMedicion`; solo delega el trabajo.


2) JSX del componente

   return (
     <div className="alim-card-section">
       <h3 className="alim-card-section-title">{titulo}</h3>
       <div className="alim-card-meters">
         {boxes.map((box, idx) => renderizarCaja(box, idx, zona))}
       </div>
     </div>
   );

   2.1) Contenedor principal

   - `<div className="alim-card-section">`:
       ‚Ä¢ envuelve todo el bloque (t√≠tulo + cajas),
       ‚Ä¢ la clase se usa en CSS para dar m√°rgenes, separaci√≥n vertical, etc.

   2.2) T√≠tulo de la secci√≥n

   - `<h3 className="alim-card-section-title">{titulo}</h3>`:
       ‚Ä¢ muestra el t√≠tulo que se pas√≥ por props,
       ‚Ä¢ sirve como encabezado visual del grupo de medidores.

   2.3) Contenedor de cajas

   - `<div className="alim-card-meters">`:
       ‚Ä¢ contenedor donde se colocan las cajas de medici√≥n,
       ‚Ä¢ normalmente se renderizan en fila o grilla seg√∫n el CSS.

   - `{boxes.map((box, idx) => renderizarCaja(box, idx, zona))}`:
       ‚Ä¢ recorre el array `boxes`,
       ‚Ä¢ por cada elemento llama a `renderizarCaja(box, idx, zona)`,
       ‚Ä¢ `renderizarCaja` devuelve el JSX de la caja (por ejemplo, `CajaMedicion`),
       ‚Ä¢ de esta forma:
           - `GrupoMedidores` no est√° atado a un tipo de caja espec√≠fico,
           - solo se encarga de ‚Äúinvocar‚Äù al renderizador en el orden correcto.


3) Export

   export default GrupoMedidores;

   - Exporta el componente para ser usado dentro de `TarjetaAlimentador`.
   - La tarjeta crea los objetos `sup` e `inf` (con `titulo` y `boxes`) y
     luego se los pasa a `GrupoMedidores` para que los dibuje.

---------------------------------------------------------------------------*/
// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/RowGapResizer.css =====

/* src/paginas/PaginaAlimentadores/componentes/tarjetas/RowGapResizer.css */

.row-gap-resizer {
	position: relative;
	display: flex;
	align-items: center;
	justify-content: center;
	width: 100%;
	flex-shrink: 0;
	/* La altura se controla via style inline basado en el gap */
}

.row-gap-resizer__track {
	position: relative;
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: center;
	width: 100%;
	height: 100%;
}

/* Contenedor del handle + hitbox, siempre centrado */
.row-gap-resizer__handle-wrapper {
	position: relative;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Hitbox invisible que siempre captura eventos del mouse */
.row-gap-resizer__hitbox {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	width: 120px;
	height: 30px;
	cursor: ns-resize;
	z-index: 2;
	/* background: rgba(255,0,0,0.2); */ /* descomentar para debug */
}

.row-gap-resizer__handle {
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: center;
	gap: 4px;
	padding: 8px 12px;
	cursor: ns-resize;
	opacity: 0;
	transition: opacity 0.2s ease;
	border-radius: 8px;
	pointer-events: none;
}

/* Solo mostrar el handle cuando est√° activo via React */
.row-gap-resizer--active .row-gap-resizer__handle {
	opacity: 1;
}

.row-gap-resizer__handle--dragging {
	background: rgba(59, 130, 246, 0.2);
}

/* L√≠neas horizontales (rotadas 90¬∞ respecto al GapResizer vertical) */
.row-gap-resizer__line {
	width: 30px;
	height: 2px;
	background: linear-gradient(90deg, transparent, #3b82f6, transparent);
	border-radius: 1px;
}

.row-gap-resizer__circle {
	width: 14px;
	height: 14px;
	border-radius: 50%;
	background: #1e3a5f;
	border: 2px solid #3b82f6;
	transition: transform 0.15s ease, background-color 0.15s ease;
	flex-shrink: 0;
}

.row-gap-resizer__handle:hover .row-gap-resizer__circle {
	transform: scale(1.2);
	background: #3b82f6;
}

.row-gap-resizer__handle--dragging .row-gap-resizer__circle {
	transform: scale(1.3);
	background: #3b82f6;
	box-shadow: 0 0 12px rgba(59, 130, 246, 0.5);
}

.row-gap-resizer__input-container {
	position: absolute;
	left: calc(50% + 60px);
	display: flex;
	justify-content: center;
	opacity: 0;
	transition: opacity 0.2s ease;
}

/* Solo mostrar el input cuando est√° activo via React */
.row-gap-resizer--active .row-gap-resizer__input-container {
	opacity: 1;
}

.row-gap-resizer__value {
	font-size: 0.75rem;
	color: #9ca3af;
	background: rgba(17, 24, 39, 0.9);
	padding: 4px 8px;
	border-radius: 4px;
	border: 1px solid #374151;
	white-space: nowrap;
	cursor: pointer;
	transition: border-color 0.2s, color 0.2s;
}

.row-gap-resizer__value:hover {
	border-color: #3b82f6;
	color: #e5e7eb;
}

.row-gap-resizer__input {
	width: 60px;
	padding: 4px 8px;
	font-size: 0.75rem;
	color: #e5e7eb;
	background: #1f2937;
	border: 1px solid #3b82f6;
	border-radius: 4px;
	text-align: center;
	outline: none;
}

.row-gap-resizer__input:focus {
	box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
}

/* Ocultar flechas del input number */
.row-gap-resizer__input::-webkit-outer-spin-button,
.row-gap-resizer__input::-webkit-inner-spin-button {
	-webkit-appearance: none;
	margin: 0;
}

.row-gap-resizer__input[type="number"] {
	-moz-appearance: textfield;
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/RowGapResizer.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/RowGapResizer.jsx

import React, { useState, useRef, useEffect, useCallback } from "react";
import "./RowGapResizer.css";

/**
 * Componente que permite ajustar el gap vertical entre filas de tarjetas.
 * Aparece como una l√≠nea horizontal con un c√≠rculo al hacer hover entre filas.
 *
 * Comportamiento:
 * - Al hacer hover sobre el handle: aparece la barra de gap con el valor actual
 * - Al arrastrar con click izquierdo: ajusta el gap visualmente (movimiento vertical)
 * - Al hacer doble click: se habilita la edici√≥n manual del input
 * - Enter o click fuera del input: confirma el valor y oculta la barra
 * - Escape: cancela y oculta la barra
 *
 * @param {number} gap - Gap actual en p√≠xeles
 * @param {function} onGapChange - Callback (nuevoGap)
 * @param {number} rowIndex - √çndice de la fila (0 = primera fila, separaci√≥n del men√∫)
 */
const RowGapResizer = ({ gap, onGapChange, rowIndex, minGap = 0, maxGap = 400 }) => {
	const [isHovered, setIsHovered] = useState(false);
	const [isDragging, setIsDragging] = useState(false);
	const [isEditing, setIsEditing] = useState(false);
	const [inputValue, setInputValue] = useState(gap);
	const inputRef = useRef(null);
	const containerRef = useRef(null);
	const hitboxRef = useRef(null);
	const startYRef = useRef(0);
	const startGapRef = useRef(gap);

	// Actualizar inputValue cuando cambia el gap desde afuera
	useEffect(() => {
		if (!isEditing) {
			setInputValue(gap);
		}
	}, [gap, isEditing]);

	// Detectar clicks fuera del componente para cerrar
	useEffect(() => {
		const handleClickOutside = (e) => {
			if (containerRef.current && !containerRef.current.contains(e.target)) {
				if (!isEditing) {
					setIsHovered(false);
				}
			}
		};

		if (isHovered && !isEditing) {
			document.addEventListener('mousedown', handleClickOutside);
		}

		return () => {
			document.removeEventListener('mousedown', handleClickOutside);
		};
	}, [isHovered, isEditing]);

	// ===== DRAG HANDLERS =====
	const handleMouseDown = useCallback((e) => {
		if (e.button !== 0) return;
		e.preventDefault();
		e.stopPropagation();
		setIsDragging(true);
		startYRef.current = e.clientY;
		startGapRef.current = gap;
	}, [gap]);

	const handleMouseMove = useCallback((e) => {
		if (!isDragging) return;

		const deltaY = e.clientY - startYRef.current;
		// Cada 2px de movimiento = 1px de gap
		const newGap = Math.round(startGapRef.current + deltaY / 2);
		const clampedGap = Math.max(minGap, Math.min(maxGap, newGap));

		onGapChange(clampedGap);
		setInputValue(clampedGap);
	}, [isDragging, minGap, maxGap, onGapChange]);

	const handleMouseUp = useCallback((e) => {
		setIsDragging(false);

		// Verificar si el mouse est√° fuera del hitbox al soltar
		if (hitboxRef.current) {
			const rect = hitboxRef.current.getBoundingClientRect();
			const mouseX = e.clientX;
			const mouseY = e.clientY;
			const isOutside =
				mouseX < rect.left ||
				mouseX > rect.right ||
				mouseY < rect.top ||
				mouseY > rect.bottom;

			if (isOutside && !isEditing) {
				setIsHovered(false);
			}
		}
	}, [isEditing]);

	// Doble click para activar modo edici√≥n
	const handleDoubleClick = useCallback((e) => {
		e.preventDefault();
		e.stopPropagation();
		setIsEditing(true);
		setInputValue(gap);
	}, [gap]);

	// Agregar/remover listeners globales para el drag
	useEffect(() => {
		if (isDragging) {
			window.addEventListener("mousemove", handleMouseMove);
			window.addEventListener("mouseup", handleMouseUp);
		}
		return () => {
			window.removeEventListener("mousemove", handleMouseMove);
			window.removeEventListener("mouseup", handleMouseUp);
		};
	}, [isDragging, handleMouseMove, handleMouseUp]);

	// ===== INPUT HANDLERS =====
	const handleValueClick = (e) => {
		e.stopPropagation();
		if (!isDragging) {
			setIsEditing(true);
			setInputValue(gap);
		}
	};

	useEffect(() => {
		if (isEditing && inputRef.current) {
			inputRef.current.focus();
			inputRef.current.select();
		}
	}, [isEditing]);

	const handleInputChange = (e) => {
		setInputValue(e.target.value);
	};

	const confirmarValor = () => {
		const numValue = parseInt(inputValue, 10);
		if (!isNaN(numValue)) {
			const clampedGap = Math.max(minGap, Math.min(maxGap, numValue));
			onGapChange(clampedGap);
			setInputValue(clampedGap);
		} else {
			setInputValue(gap);
		}
		setIsEditing(false);
	};

	const handleInputBlur = () => {
		confirmarValor();
		setIsHovered(false);
	};

	const handleInputKeyDown = (e) => {
		if (e.key === "Enter") {
			e.preventDefault();
			confirmarValor();
			setIsHovered(false);
		} else if (e.key === "Escape") {
			setInputValue(gap);
			setIsEditing(false);
			setIsHovered(false);
		}
	};

	const isActive = isHovered || isDragging || isEditing;

	return (
		<div
			ref={containerRef}
			className={`row-gap-resizer ${isActive ? "row-gap-resizer--active" : ""}`}
			style={{ height: `${gap}px` }}
		>
			<div className="row-gap-resizer__track">
				<div className="row-gap-resizer__handle-wrapper">
					{/* Zona de hitbox invisible */}
					<div
						ref={hitboxRef}
						className="row-gap-resizer__hitbox"
						onMouseEnter={() => setIsHovered(true)}
						onMouseLeave={() => !isDragging && !isEditing && setIsHovered(false)}
						onMouseDown={handleMouseDown}
						onDoubleClick={handleDoubleClick}
					/>
					{/* Handle visual */}
					<div
						className={`row-gap-resizer__handle ${isDragging ? "row-gap-resizer__handle--dragging" : ""}`}
						title="Arrastra para ajustar el espaciado vertical"
					>
						<div className="row-gap-resizer__line" />
						<div className="row-gap-resizer__circle" />
						<div className="row-gap-resizer__line" />
					</div>
				</div>

				{isActive && (
					<div className="row-gap-resizer__input-container">
						{isEditing ? (
							<input
								ref={inputRef}
								type="number"
								className="row-gap-resizer__input"
								value={inputValue}
								onChange={handleInputChange}
								onBlur={handleInputBlur}
								onKeyDown={handleInputKeyDown}
								min={minGap}
								max={maxGap}
							/>
						) : (
							<span
								className="row-gap-resizer__value"
								onClick={handleValueClick}
								title="Click para editar"
							>
								{gap}px
							</span>
						)}
					</div>
				)}
			</div>
		</div>
	);
};

export default RowGapResizer;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/SkeletonCard.css =====

/* src/paginas/PaginaAlimentadores/componentes/tarjetas/SkeletonCard.css */
/* Estilos para el skeleton (esqueleto) de carga de tarjetas */

/* Animaci√≥n de pulso */
@keyframes skeleton-pulse {
	0% {
		opacity: 1;
	}
	50% {
		opacity: 0.4;
	}
	100% {
		opacity: 1;
	}
}

/* Contenedor principal del skeleton */
/* Debe coincidir con .alim-card-add (Nuevo Registrador) para que tenga el mismo tama√±o */
.skeleton-card {
	background-color: #111827; /* Mismo fondo que .alim-card */
	border-radius: 16px; /* Mismo border-radius que .alim-card */
	padding: 12px;
	width: 304px; /* Mismo ancho que .alim-card-add */
	min-width: 304px;
	max-width: 304px;
	height: 279px; /* Misma altura que .alim-card-add */
	min-height: 279px;
	box-shadow: 0 10px 25px rgba(15, 23, 42, 0.6); /* Mismo shadow que .alim-card */
	border: 1px solid #1f2937; /* Mismo borde que .alim-card */
	animation: skeleton-pulse 1.5s ease-in-out infinite;
	box-sizing: border-box;
	overflow: hidden;
}

/* Header */
.skeleton-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 8px;
}

.skeleton-title {
	background: linear-gradient(90deg, #334155 0%, #475569 50%, #334155 100%);
	background-size: 200% 100%;
	height: 24px;
	width: 140px;
	border-radius: 6px;
	animation: skeleton-shimmer 2s ease-in-out infinite;
}

.skeleton-buttons {
	display: flex;
	gap: 8px;
}

.skeleton-button-square {
	background: linear-gradient(90deg, #334155 0%, #475569 50%, #334155 100%);
	background-size: 200% 100%;
	width: 32px;
	height: 32px;
	border-radius: 6px; /* Bordes redondeados como los botones reales */
	animation: skeleton-shimmer 2s ease-in-out infinite;
}

/* Secciones (superior e inferior) */
.skeleton-section {
	margin-top: 1.1rem;
	margin-bottom: 1.6rem;
}

.skeleton-section:last-child {
	margin-bottom: 0;
}

.skeleton-section-title {
	background: linear-gradient(90deg, #334155 0%, #475569 50%, #334155 100%);
	background-size: 200% 100%;
	height: 14px;
	width: 180px;
	margin-bottom: 6px;
	border-radius: 4px;
	animation: skeleton-shimmer 2s ease-in-out infinite;
}

/* Contenedor de boxes */
.skeleton-boxes {
	display: flex;
	gap: 8px;
	justify-content: space-between;
}

/* Box individual */
.skeleton-box {
	flex: 1;
	background: linear-gradient(90deg, #1e293b 0%, #334155 50%, #1e293b 100%);
	background-size: 200% 100%;
	border: 1px solid #334155;
	border-radius: 8px;
	padding: 12px 6px;
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 6px;
	animation: skeleton-shimmer 2s ease-in-out infinite;
}

.skeleton-label {
	background: linear-gradient(90deg, #475569 0%, #64748b 50%, #475569 100%);
	background-size: 200% 100%;
	height: 12px;
	width: 16px;
	border-radius: 3px;
	animation: skeleton-shimmer 2s ease-in-out infinite;
}

.skeleton-value {
	background: linear-gradient(90deg, #475569 0%, #64748b 50%, #475569 100%);
	background-size: 200% 100%;
	height: 18px;
	width: 45px;
	border-radius: 4px;
	animation: skeleton-shimmer 2s ease-in-out infinite;
}

/* Animaci√≥n de shimmer (brillo deslizante) */
@keyframes skeleton-shimmer {
	0% {
		background-position: 200% 0;
	}
	100% {
		background-position: -200% 0;
	}
}

/* Responsive - en mobile el skeleton ocupa todo el ancho disponible */
@media (max-width: 982px) {
	.skeleton-card {
		flex: 1 1 100%;
		min-width: 280px;
	}
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/SkeletonCard.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/SkeletonCard.jsx
// Componente skeleton (esqueleto) que se muestra mientras se carga/guarda un alimentador

import React from "react";
import "./SkeletonCard.css";

const SkeletonCard = () => {
	return (
		<div className="skeleton-card">
			{/* Header de la tarjeta - botones a la izquierda, t√≠tulo a la derecha */}
			<div className="skeleton-header">
				<div className="skeleton-buttons">
					<div className="skeleton-button-square"></div>
					<div className="skeleton-button-square"></div>
				</div>
				<div className="skeleton-title"></div>
			</div>

			{/* Parte superior (ej: Corriente) */}
			<div className="skeleton-section">
				<div className="skeleton-section-title"></div>
				<div className="skeleton-boxes">
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
				</div>
			</div>

			{/* Parte inferior (ej: Tensi√≥n) */}
			<div className="skeleton-section">
				<div className="skeleton-section-title"></div>
				<div className="skeleton-boxes">
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
				</div>
			</div>
		</div>
	);
};

export default SkeletonCard;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/TarjetaAlimentador.css =====

/* src/paginas/PaginaAlimentadores/componentes/tarjetas/TarjetaAlimentador.css */
/*
   NOTA SOBRE ESTE ARCHIVO (TarjetaAlimentador.css)
   - Define el aspecto visual de cada tarjeta de alimentador: marco, header con
     botones, cuerpo con medidores y estados especiales (drag & drop, progreso).

   - `.alim-card` es el contenedor base; `.alim-card-wide` se usa cuando hay
     muchas cajas para ensanchar la tarjeta.

   - `.alim-card-meter-value` aplica la fuente digital y los colores del display,
     mientras que `.alim-meter-progress-*` dibuja el borde animado seg√∫n el
     periodo de medici√≥n configurado.
*/

/* Tarjeta base (card de alimentador) */
.alim-card {
	background-color: #262726; /* fondo gris oscuro */
	border-radius: 6px;
	overflow: hidden;
	box-shadow: 0 10px 25px rgba(15, 23, 42, 0.6);
	color: #f9fafb;
	border: 1px solid #64748b;
	/* sin min-height para que se ajuste al contenido cuando hay zonas ocultas */

	/* Ancho fijo de la tarjeta */
	width: 304px;
	min-width: 304px;
	flex-shrink: 0;
	box-sizing: border-box;
}

/* Cuando hay 4 boxes en alguna fila, la hacemos m√°s ancha */
.alim-card-wide {
	width: 380px;
	min-width: 380px;
}

/* Header de la tarjeta */
.alim-card-header {
	padding: 0.2rem 0.3rem;
	display: flex;
	align-items: center;
	position: relative;
}

/* contenedor de los iconos (tuerca + mapeo) */
.alim-card-icons {
	display: flex;
	align-items: center;
	gap: 4px;
}

/* Bot√≥n base para iconos (tuerca y mapeo) */
.alim-card-icon-btn,
.alim-card-config-btn {
	border: 0px solid #37415171;
	border-radius: 10px;
	background: transparent;
	cursor: pointer;
	padding: 4px 6px;
	display: inline-flex;
	align-items: center;
	gap: 4px;
}

.alim-card-icon-btn:hover,
.alim-card-config-btn:hover {
	background-color: rgba(221, 225, 233, 0.6);
}

/* Iconos (PNG) */
.alim-card-icon,
.alim-card-config-icon {
	width: 20px;
	height: 20px;
	display: block;
}

/* Bot√≥n de historial (emoji) */
.alim-card-historial-btn {
	font-size: 16px;
	line-height: 1;
}

.alim-card-historial-icon {
	display: block;
	font-size: 16px;
}

/* T√≠tulo centrado dentro del header (respecto al contenedor completo) */
.alim-card-title {
	position: absolute;
	left: 50%;
	transform: translateX(-50%);
	font-weight: 700;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	max-width: calc(100% - 80px); /* espacio para los botones */
	pointer-events: none; /* permitir clicks a trav√©s del t√≠tulo */
}

/* Bot√≥n Play/Stop para polling de lecturas */
.alim-card-play-btn {
	border: 1px solid #37415171;
	border-radius: 10px;
	background: transparent;
	cursor: pointer;
	padding: 4px 8px;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	font-size: 0.9rem;
	color: #f9fafb;
	margin-left: auto; /* empuja el bot√≥n a la derecha */
	transition: background-color 0.15s ease, opacity 0.15s ease;
}

.alim-card-play-btn:hover:not(:disabled) {
	background-color: rgba(221, 225, 233, 0.6);
}

.alim-card-play-btn:disabled {
	opacity: 0.4;
	cursor: not-allowed;
}

/* Estado activo (polling en curso) */
.alim-card-play-btn--active {
	background-color: rgba(239, 68, 68, 0.3);
	border-color: #ef4444;
}

.alim-card-play-btn--active:hover:not(:disabled) {
	background-color: rgba(239, 68, 68, 0.5);
}

.alim-card-map-label {
	font-size: 0.7rem;
	text-transform: uppercase;
	letter-spacing: 0.04em;
}

/* ===== BARRA DE PROGRESO DE POLLING ===== */
.alim-card-progress-track {
	height: 8px;
	background: transparent;
	position: relative;
	overflow: hidden;
}

.alim-card-progress-fill {
	height: 100%;
	width: 100%;
	background: linear-gradient(to right, #0a3d1a 0%, #22c55e 100%);
	transform: scaleX(0);
	transform-origin: left center;
	animation: alim-progress-fill var(--progress-duration, 60s) linear forwards;
	position: relative;
	overflow: hidden;
	will-change: transform;
}

/* Chispa que recorre solo el √°rea de progreso */
.alim-card-progress-spark {
	position: absolute;
	top: 0;
	left: -30px;
	width: 30px;
	height: 100%;
	background: linear-gradient(
		to right,
		transparent 0%,
		rgba(255, 255, 255, 0.7) 50%,
		transparent 100%
	);
	animation: alim-spark 2s ease-in-out infinite;
}

@keyframes alim-progress-fill {
	0% {
		transform: scaleX(0);
	}
	100% {
		transform: scaleX(1);
	}
}

@keyframes alim-spark {
	0% {
		left: -30px;
		opacity: 0;
	}
	10% {
		opacity: 1;
	}
	90% {
		opacity: 1;
	}
	100% {
		left: 100%;
		opacity: 0;
	}
}

/* Cuerpo de la tarjeta */
.alim-card-body {
	position: relative;
	padding: 0 1rem 1.2rem; /* sin padding superior, inferior para el tri√°ngulo de escala */
	background-color: #262726; /* mismo que la tarjeta base */
	border-radius: 0 0 6px 6px;
}

.alim-card-section {
	margin-bottom: 0.75rem;
}

.alim-card-section-title {
	margin: 0 -1rem 0.4rem -1rem;
	font-size: 0.8rem;
	letter-spacing: 0.05em;
	background: linear-gradient(to right, #47556999, #47556900);
	padding: 0.25rem 1rem;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

.alim-card-meters {
	display: flex;
	justify-content: center;       /* centra el grupo de boxes */
	gap: 18px;
	position: relative;            /* necesario para posicionar el borde animado */
	overflow: visible;             /* el borde puede sobresalir un poquito */
}

/* Cada box con ancho fijo */
.alim-card-meter {
	position: relative;
	flex: 0 0 80px;                /* ancho aproximado de cada box */
	text-align: center;
}

.alim-card-meter-phase {
	display: block;
	font-size: 1rem;
	margin-bottom: 0.2rem;
}

.alim-card-meter-value {
	position: relative;            /* necesario para dibujar el borde animado con ::before */
	display: block;
	font-family: "DS-Digital", "Courier New", monospace;
	font-size: 1.5rem;
	letter-spacing: 0.06em;
	padding: 0.25rem 0.3rem;
	border-radius: 6px;
	background-color: #020617;     /* fondo negro */
	border-width: 1px;
	border-style: solid;           /* necesario para que el borde sea visible */
	border-color: #0ea5e9;
	color: #ffff00;
	box-shadow: inset 0 0 6px rgba(250, 204, 21, 0.4);
}

/* Estado cuando la tarjeta est√° siendo arrastrada */
.alim-card-dragging {
	opacity: 0.35;
	transform: scale(0.98);
	transition: opacity 0.15s ease, transform 0.15s ease;
}

/* ===== BORDE PROGRESO PARA REGISTROS DEL REL√â ===== */
.alim-meter-progress-rele::before {
	content: "";
	position: absolute;
	inset: -2px;
	border-radius: 3px;
	pointer-events: none;

	background:
		linear-gradient(#ece4b3e7 0 0) 0% 0 / 0 4px no-repeat,      /* arriba */
		linear-gradient(#ece4b3e7 0 0) 100% 0 / 4px 0 no-repeat,    /* derecha */
		linear-gradient(#ece4b3e7 0 0) 100% 100% / 0 4px no-repeat, /* abajo */
		linear-gradient(#ece4b3e7 0 0) 0% 100% / 4px 0 no-repeat;   /* izquierda */

	animation: rw-border-progress-rele var(--rw-progress-duration-rele, 60s)
		linear infinite;
}

@keyframes rw-border-progress-rele {
	0% {
		background-size: 0 2px, 2px 0, 0 2px, 2px 0;
	}
	25% {
		background-size: 100% 2px, 2px 0, 0 2px, 2px 0;
	}
	50% {
		background-size: 100% 2px, 2px 100%, 0 2px, 2px 0;
	}
	75% {
		background-size: 100% 2px, 2px 100%, 100% 2px, 2px 0;
	}
	100% {
		background-size: 100% 2px, 2px 100%, 100% 2px, 2px 100%;
	}
}

/* ===== BORDE PROGRESO PARA REGISTROS DEL ANALIZADOR ===== */
.alim-meter-progress-analizador::before {
	content: "";
	position: absolute;
	inset: -2px;
	border-radius: 3px;
	pointer-events: none;

	/* Pod√©s usar el mismo color o cambiarlo si quer√©s distinguirlos */
	background:
		linear-gradient(#ece4b3e7 0 0) 0% 0 / 0 4px no-repeat,
		linear-gradient(#ece4b3e7 0 0) 100% 0 / 4px 0 no-repeat,
		linear-gradient(#ece4b3e7 0 0) 100% 100% / 0 4px no-repeat,
		linear-gradient(#ece4b3e7 0 0) 0% 100% / 4px 0 no-repeat;

	animation: rw-border-progress-analizador
		var(--rw-progress-duration-analizador, 60s) linear infinite;
}

@keyframes rw-border-progress-analizador {
	0% {
		background-size: 0 2px, 2px 0, 0 2px, 2px 0;
	}
	25% {
		background-size: 100% 2px, 2px 0, 0 2px, 2px 0;
	}
	50% {
		background-size: 100% 2px, 2px 100%, 0 2px, 2px 0;
	}
	75% {
		background-size: 100% 2px, 2px 100%, 100% 2px, 2px 0;
	}
	100% {
		background-size: 100% 2px, 2px 100%, 100% 2px, 2px 100%;
	}
}

/* ===== ESTADO DE ERROR EN LA TARJETA ===== */

/* Borde rojo sutil cuando hay error */
.alim-card-error {
	border-color: #dc2626;
}

/* Overlay semi-transparente sobre el cuerpo de la tarjeta */
.alim-card-error-overlay {
	position: absolute;
	inset: 0;
	background: rgba(0, 0, 0, 0.75);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 10;
	border-radius: 0 0 12px 12px;
}

.alim-card-error-content {
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 4px;
	text-align: center;
	padding: 1rem;
}

.alim-card-error-icon {
	font-size: 2rem;
	color: #fbbf24;
	line-height: 1;
}

.alim-card-error-title {
	font-size: 0.9rem;
	font-weight: 700;
	color: #fbbf24;
	letter-spacing: 0.1em;
}

.alim-card-error-message {
	font-size: 0.8rem;
	color: #f1f5f9;
	font-weight: 500;
}

.alim-card-error-detail {
	font-size: 0.7rem;
	color: #94a3b8;
	font-style: italic;
}

/* Valor en estado de error */
.alim-card-meter-value--error {
	background-color: #450a0a;
	border-color: #dc2626;
	color: #ef4444;
	box-shadow: inset 0 0 6px rgba(239, 68, 68, 0.4);
}

/* Animaci√≥n de parpadeo para el overlay de error */
.alim-card-error-overlay--parpadeo {
	animation: alim-error-parpadeo 3s ease-in-out infinite;
}

@keyframes alim-error-parpadeo {
	0%, 70% {
		opacity: 1;
	}
	85% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}

/* ===== TRI√ÅNGULO DE ESCALA (dentro del body) ===== */
.alim-card-scale-btn {
	position: absolute;
	bottom: 4px;
	left: 50%;
	transform: translateX(-50%);
	display: inline-flex;
	align-items: center;
	gap: 4px;
	background: transparent;
	border: none;
	color: #6b7280;
	cursor: pointer;
	padding: 2px 8px;
	border-radius: 4px;
	font-size: 0.7rem;
	transition: color 0.15s ease, background-color 0.15s ease;
	z-index: 5;
}

.alim-card-scale-btn:hover {
	color: #9ca3af;
	background-color: rgba(255, 255, 255, 0.1);
}

.alim-card-scale-btn--active {
	color: #60a5fa;
}

.alim-card-scale-btn--active:hover {
	color: #93c5fd;
}

.alim-card-scale-triangle {
	font-size: 0.6rem;
}

.alim-card-scale-value {
	font-family: "DS-Digital", "Courier New", monospace;
	font-size: 0.75rem;
}

/* ===== POPOVER DE ESCALA ===== */
.alim-card-scale-popover {
	position: fixed;
	z-index: 9999;
	background-color: #1e293b;
	border: 1px solid #374151;
	border-radius: 8px;
	padding: 12px;
	box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
	min-width: 120px;
}

.alim-card-scale-label {
	display: block;
	font-size: 0.85rem;
	color: #9ca3af;
	margin-bottom: 6px;
	text-align: center;
}

.alim-card-scale-controls {
	display: flex;
	align-items: stretch;
	gap: 6px;
	height: 32px;
}

.alim-card-scale-pm-btn {
	width: 32px;
	height: 32px;
	display: flex;
	align-items: center;
	justify-content: center;
	background-color: #374151;
	border: 1px solid #475569;
	border-radius: 4px;
	color: #f1f5f9;
	font-size: 1.2rem;
	font-weight: 600;
	cursor: pointer;
	transition: background-color 0.15s ease, border-color 0.15s ease;
	flex-shrink: 0;
	line-height: 1;
}

.alim-card-scale-pm-btn:hover:not(:disabled) {
	background-color: #4b5563;
	border-color: #60a5fa;
}

.alim-card-scale-pm-btn:disabled {
	opacity: 0.4;
	cursor: not-allowed;
}

.alim-card-scale-input {
	width: 60px;
	height: 32px;
	padding: 0 4px;
	background-color: #0f172a;
	border: 1px solid #475569;
	border-radius: 4px;
	color: #f1f5f9;
	font-size: 1rem;
	text-align: center;
	font-family: "DS-Digital", "Courier New", monospace;
	box-sizing: border-box;
}

.alim-card-scale-input:focus {
	outline: none;
	border-color: #60a5fa;
}

/* Ocultar flechas del input number */
.alim-card-scale-input::-webkit-outer-spin-button,
.alim-card-scale-input::-webkit-inner-spin-button {
	-webkit-appearance: none;
	margin: 0;
}
.alim-card-scale-input[type="number"] {
	-moz-appearance: textfield;
	appearance: textfield;
}

.alim-card-scale-actions {
	display: flex;
	justify-content: center;
	margin-top: 10px;
}

.alim-card-scale-reset {
	width: 100%;
	height: 28px;
	background: transparent;
	border: 1px solid #475569;
	border-radius: 4px;
	color: #9ca3af;
	font-size: 0.8rem;
	cursor: pointer;
	transition: background-color 0.15s ease, color 0.15s ease;
}

.alim-card-scale-reset:hover {
	background-color: rgba(255, 255, 255, 0.1);
	color: #f1f5f9;
}

/* ===== MEN√ö DESPLEGABLE FLOTANTE ===== */

/* Bot√≥n toggle con flecha animada */
.alim-card-menu-toggle {
	border: none;
	background: transparent;
	cursor: pointer;
	padding: 4px 6px;
	display: inline-flex;
	align-items: center;
	justify-content: center;
}

.alim-card-menu-arrow {
	display: block;
	font-size: 12px;
	color: #f1f5f9;
	transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
	line-height: 1;
	transform: rotate(180deg); /* Flecha apuntando hacia arriba por defecto */
}

/* Flecha rotada cuando est√° abierto (vuelve a apuntar abajo) */
.alim-card-menu-toggle--abierto .alim-card-menu-arrow {
	transform: rotate(0deg);
}

/* Men√∫ flotante (portal) - aparece arriba del header */
.alim-card-menu-flotante {
	position: fixed;
	z-index: 9999;
	background: linear-gradient(to top, #1e293b, #0f172a);
	border: 1px solid #374151;
	border-radius: 6px;
	box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.4);
	animation: alim-menu-aparecer 0.2s cubic-bezier(0.4, 0, 0.2, 1);
	overflow: hidden;
}

@keyframes alim-menu-aparecer {
	from {
		opacity: 0;
		transform: translateY(8px);
	}
	to {
		opacity: 1;
		transform: translateY(0);
	}
}

/* Contenido del men√∫ flotante */
.alim-card-menu-flotante-content {
	display: flex;
	align-items: center;
	justify-content: flex-start;
	gap: 12px;
	padding: 10px 12px;
}

/* Botones dentro del men√∫ flotante - transparentes sin bordes */
.alim-card-menu-flotante-btn {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	background: transparent;
	border: none;
	padding: 0;
	cursor: pointer;
	transition: opacity 0.15s ease, transform 0.1s ease;
}

.alim-card-menu-flotante-btn:hover {
	opacity: 0.7;
	transform: scale(1.1);
}

.alim-card-menu-flotante-btn:active {
	transform: scale(1);
}

/* Icono PNG dentro del bot√≥n */
.alim-card-menu-flotante-icon {
	width: 22px;
	height: 22px;
	display: block;
	filter: brightness(0) invert(1); /* Convertir a blanco */
}

/* Emoji dentro del bot√≥n */
.alim-card-menu-flotante-emoji {
	font-size: 20px;
	width: 22px;
	height: 22px;
	display: inline-block;
	text-align: center;
	line-height: 22px;
	vertical-align: middle;
	position: relative;
	top: 2px;
}


// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/TarjetaAlimentador.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/TarjetaAlimentador.jsx

import React, { useEffect, useRef, useState } from "react";   // React + hooks para estado y refs
import { createPortal } from "react-dom";
import "./TarjetaAlimentador.css";                            // estilos visuales de la tarjeta
import configIcon from "../../../../assets/imagenes/Config_Icon.png"; // icono de configuraci√≥n (tuerca)
import CajaMedicion from "./CajaMedicion.jsx";                // box individual de medici√≥n
import GrupoMedidores from "./GrupoMedidores.jsx";            // grupo de cajas (parte superior/inferior)
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion"; // para estilos globales

// Helper que prepara la estructura de un lado de la tarjeta (sup/inf)
const construirLado = (side, tituloDefault) => {                         // side: config del lado, tituloDefault: texto por defecto
  const cajasPorDefecto = ["R", "S", "T"].map((label) => ({              // arma 3 cajas por defecto (R, S, T)
    etiqueta: label,                                                     // etiqueta visible arriba del box
    valor: "--,--",                                                      // valor inicial cuando no hay lectura
    enabled: false,                                                      // por defecto la caja no est√° habilitada
    origen: null,                                                        // origen a√∫n no definido (rele/analizador)
  }));

  if (!side) {                                                           // si no hay configuraci√≥n para este lado...
    return {
      titulo: tituloDefault,                                             // usa el t√≠tulo por defecto
      boxes: cajasPorDefecto,                                           // y las cajas b√°sicas
      oculto: false,                                                     // por defecto no est√° oculto
    };
  }

  const titulo =
    (side.titulo && String(side.titulo).trim()) || tituloDefault;       // toma el t√≠tulo de la config o cae al default
  const oculto = !!side.oculto;                                          // si est√° marcado como oculto

  let boxes = Array.isArray(side.boxes) ? side.boxes : [];              // garantiza que boxes sea un array
  boxes = boxes.slice(0, 4);                                            // m√°ximo 4 cajas por lado

  if (boxes.length === 0) {                                             // si no hay ninguna caja configurada...
    boxes = cajasPorDefecto;                                            // usa las 3 por defecto
  } else {
    boxes = boxes.map((b, idx) => ({
      etiqueta:
        (b?.etiqueta && String(b.etiqueta).trim()) ||                   // etiqueta personalizada si existe
        `Box ${idx + 1}`,                                               // si no, "Box 1", "Box 2", etc.
      valor:
        b?.valor == null || b.valor === ""                              // si no hay valor num√©rico v√°lido...
          ? "--,--"                                                     // muestra placeholder
          : String(b.valor),                                            // convierte el valor a string
      enabled: !!b?.enabled,                                            // fuerza a booleano (true/false)
      origen: b?.origen || null,                                        // origen de datos o null si no est√° definido
    }));
  }

  return { titulo, boxes, oculto };                                     // devuelve t√≠tulo final, lista de cajas y si est√° oculto
};

const TarjetaAlimentador = ({
  nombre,
  color,
  onConfigClick,           // abre modal de configuraci√≥n del alimentador
  onHistorialClick,        // abre modal de historial de lecturas
  esObservador = false,    // si true, oculta el bot√≥n de estad√≠sticas (rol observador)
  topSide,                 // dise√±o + valores para la parte superior
  bottomSide,              // dise√±o + valores para la parte inferior
  draggable = false,       // si la tarjeta se puede arrastrar
  isDragging = false,      // estado visual mientras se arrastra
  onDragStart,
  onDragOver,
  onDrop,
  onDragEnd,

  // Info de mediciones y periodos
  mideRele = false,
  mideAnalizador = false,
  periodoRele = 60,
  periodoAnalizador = 60,
  timestampInicioRele = null,          // (reservado por si se usan futuras animaciones)
  timestampInicioAnalizador = null,    // idem
  contadorRele = 0,                    // n√∫mero de lecturas realizadas para rel√©
  contadorAnalizador = 0,              // n√∫mero de lecturas realizadas para analizador

  // Play/Stop para polling de lecturas
  estaPolling = false,                 // indica si est√° activo el polling de lecturas
  puedePolling = false,                // indica si la card tiene config completa para polling
  onPlayStopClick,                     // callback para iniciar/detener polling
  contadorPolling = 0,                 // n√∫mero de lecturas realizadas durante polling
  periodoPolling = 60,                 // periodo de polling en segundos (para animaci√≥n)
  errorPolling = null,                 // { mensaje, timestamp } si hay error de lectura

  // Escala de la tarjeta
  escala = 1.0,                        // escala efectiva a aplicar (ya calculada)
  onEscalaChange,                      // callback para cambiar escala individual
  ESCALA_MIN = 0.5,                    // l√≠mites de escala
  ESCALA_MAX = 2.0,
}) => {
  // Obtener estilos globales del contexto
  const { estilosGlobales } = usarContextoConfiguracion();

  // Control local de animaciones de borde: solo se activan tras recibir una lectura
  const [mostrarProgresoRele, setMostrarProgresoRele] = useState(false);
  const [mostrarProgresoAnalizador, setMostrarProgresoAnalizador] =
    useState(false);
  const [mostrarProgresoPolling, setMostrarProgresoPolling] = useState(false);
  const [cicloPolling, setCicloPolling] = useState(0); // contador local para reiniciar animaci√≥n de barra
  const ultimoContadorReleRef = useRef(contadorRele);
  const ultimoContadorAnalizadorRef = useRef(contadorAnalizador);
  const ultimoContadorPollingRef = useRef(contadorPolling);

  // Control del popover de escala
  const [mostrarPopoverEscala, setMostrarPopoverEscala] = useState(false);
  const [posicionPopover, setPosicionPopover] = useState({ top: 0, left: 0 });
  const [valorEscalaInput, setValorEscalaInput] = useState(escala.toString());
  const triangleRef = useRef(null);
  const popoverRef = useRef(null);

  // Control del men√∫ desplegable de opciones
  const [menuAbierto, setMenuAbierto] = useState(false);
  const menuRef = useRef(null);
  const cardRef = useRef(null);

  // Si se cambia de puesto o se detiene la medici√≥n de rel√©, resetea la animaci√≥n
  useEffect(() => {
    if (!mideRele) {
      setMostrarProgresoRele(false);
      ultimoContadorReleRef.current = contadorRele;
      return;
    }

    if (contadorRele !== ultimoContadorReleRef.current) {
      ultimoContadorReleRef.current = contadorRele;
      setMostrarProgresoRele(contadorRele > 0);
    }
  }, [contadorRele, mideRele]);

  // Idem para el analizador
  useEffect(() => {
    if (!mideAnalizador) {
      setMostrarProgresoAnalizador(false);
      ultimoContadorAnalizadorRef.current = contadorAnalizador;
      return;
    }

    if (contadorAnalizador !== ultimoContadorAnalizadorRef.current) {
      ultimoContadorAnalizadorRef.current = contadorAnalizador;
      setMostrarProgresoAnalizador(contadorAnalizador > 0);
    }
  }, [contadorAnalizador, mideAnalizador]);

  // Control de animaci√≥n para polling de lecturas desde BD
  // El contador se incrementa 1 vez por ciclo desde VistaAlimentadores
  useEffect(() => {
    if (!estaPolling) {
      setMostrarProgresoPolling(false);
      ultimoContadorPollingRef.current = contadorPolling;
      return;
    }

    if (contadorPolling !== ultimoContadorPollingRef.current) {
      ultimoContadorPollingRef.current = contadorPolling;
      setMostrarProgresoPolling(contadorPolling > 0);
      // Incrementar cicloPolling para reiniciar la animaci√≥n de la barra
      setCicloPolling(prev => prev + 1);
    }
  }, [contadorPolling, estaPolling]);

  // Sincronizar input con escala cuando cambia externamente
  useEffect(() => {
    setValorEscalaInput(escala.toString());
  }, [escala]);

  // Toggle del popover de escala
  const togglePopoverEscala = (e) => {
    e.stopPropagation();
    if (mostrarPopoverEscala) {
      setMostrarPopoverEscala(false);
      return;
    }
    if (triangleRef.current) {
      const rect = triangleRef.current.getBoundingClientRect();
      setPosicionPopover({
        top: rect.bottom + 8,
        left: rect.left + rect.width / 2 - 60, // centrar popover (120px / 2)
      });
      setMostrarPopoverEscala(true);
    }
  };

  // Cerrar popover al hacer click fuera
  useEffect(() => {
    if (!mostrarPopoverEscala) return;
    const handleClickOutside = (event) => {
      if (
        popoverRef.current &&
        !popoverRef.current.contains(event.target) &&
        triangleRef.current &&
        !triangleRef.current.contains(event.target)
      ) {
        setMostrarPopoverEscala(false);
      }
    };
    const timeoutId = setTimeout(() => {
      document.addEventListener("mousedown", handleClickOutside);
    }, 10);
    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [mostrarPopoverEscala]);

  // Cerrar men√∫ desplegable al hacer click fuera o al hacer scroll
  useEffect(() => {
    if (!menuAbierto) return;
    const handleClickOutside = (event) => {
      if (
        menuRef.current &&
        !menuRef.current.contains(event.target) &&
        cardRef.current &&
        !cardRef.current.querySelector(".alim-card-menu-toggle")?.contains(event.target)
      ) {
        setMenuAbierto(false);
      }
    };
    // Cerrar al hacer scroll con la rueda del rat√≥n
    const handleWheel = () => {
      setMenuAbierto(false);
    };
    const timeoutId = setTimeout(() => {
      document.addEventListener("mousedown", handleClickOutside);
      window.addEventListener("wheel", handleWheel, { passive: true });
    }, 10);
    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener("mousedown", handleClickOutside);
      window.removeEventListener("wheel", handleWheel);
    };
  }, [menuAbierto]);

  // Estado para posici√≥n del men√∫ flotante
  const [posicionMenu, setPosicionMenu] = useState({ top: 0, left: 0, width: 0 });

  // Toggle del men√∫ desplegable
  const toggleMenu = (e) => {
    e.stopPropagation();
    if (!menuAbierto && cardRef.current) {
      const rect = cardRef.current.getBoundingClientRect();
      const alturaMenu = 48; // altura aproximada del men√∫
      const separacion = 3; // separaci√≥n entre men√∫ y card
      setPosicionMenu({
        top: rect.top - alturaMenu - separacion, // arriba del header con separaci√≥n
        left: rect.left,
        width: rect.width,
      });
    }
    setMenuAbierto(!menuAbierto);
  };

  // Aplicar escala inmediatamente al cambiar el input
  const handleEscalaInputChange = (e) => {
    const valorStr = e.target.value;
    setValorEscalaInput(valorStr);

    // Aplicar inmediatamente si es un valor v√°lido
    const valor = parseFloat(valorStr);
    if (!isNaN(valor) && valor >= ESCALA_MIN && valor <= ESCALA_MAX) {
      onEscalaChange?.(valor);
    }
  };

  // Cerrar con Escape
  const handleEscalaKeyDown = (e) => {
    if (e.key === "Escape") {
      setMostrarPopoverEscala(false);
    }
  };

  // Incrementar escala
  const handleIncrementarEscala = () => {
    const valorActual = parseFloat(valorEscalaInput) || escala;
    const nuevoValor = Math.min(ESCALA_MAX, Math.round((valorActual + 0.01) * 100) / 100);
    setValorEscalaInput(nuevoValor.toString());
    onEscalaChange?.(nuevoValor);
  };

  // Decrementar escala
  const handleDecrementarEscala = () => {
    const valorActual = parseFloat(valorEscalaInput) || escala;
    const nuevoValor = Math.max(ESCALA_MIN, Math.round((valorActual - 0.01) * 100) / 100);
    setValorEscalaInput(nuevoValor.toString());
    onEscalaChange?.(nuevoValor);
  };

  // Resetear escala a 1.0
  const handleResetearEscala = () => {
    setValorEscalaInput("1");
    onEscalaChange?.(1.0);
  };

  // Armar lados de la tarjeta con valores por defecto si no hay dise√±o
  const sup = construirLado(topSide, "CONSUMO (A)");
  const inf = construirLado(bottomSide, "TENSI√ìN (kV)");

  // Detectar si alg√∫n lado tiene 4 boxes (para ensanchar la tarjeta)
  const maxBoxes = Math.max(sup.boxes.length, inf.boxes.length);
  const isWide = maxBoxes >= 4;

  // Determinar si hay error en cada zona
  // errorPolling tiene: { superior, inferior } para mostrar "ERROR" en boxes (desde 1er error)
  //                     { superiorCritico, inferiorCritico } para mostrar overlay (3+ errores)
  const errorSuperior = errorPolling?.superior || false;
  const errorInferior = errorPolling?.inferior || false;
  const tieneAlgunError = errorSuperior || errorInferior;

  // Para el overlay: solo mostrar cuando hay 3+ errores consecutivos
  const errorSuperiorCritico = errorPolling?.superiorCritico || false;
  const errorInferiorCritico = errorPolling?.inferiorCritico || false;
  const tieneErrorCritico = errorSuperiorCritico || errorInferiorCritico;

  // Armar clases de la card
  const clasesCard = ["alim-card"];
  if (isWide) clasesCard.push("alim-card-wide");
  if (isDragging) clasesCard.push("alim-card-dragging");
  if (tieneErrorCritico) clasesCard.push("alim-card-error"); // borde rojo solo cuando es cr√≠tico

  const renderizarCaja = (box, idx, zona) => {
    // Determinar si esta zona tiene error
    const zonaConError = zona === "sup" ? errorSuperior : errorInferior;
    return (
      <CajaMedicion
        key={`${zona}-${idx}`}                                           // key estable por lado e √≠ndice
        box={box}                                                        // datos de la caja (etiqueta, valor, enabled, origen)
        indice={idx}                                                     // posici√≥n dentro del grupo
        zona={zona}                                                      // identifica si la caja es superior o inferior
        mideRele={mideRele}                                              // indica si hay medici√≥n de rel√© activa
        mideAnalizador={mideAnalizador}                                  // indica si hay medici√≥n de analizador activa
        mostrarProgresoRele={mostrarProgresoRele}                        // controla animaci√≥n de borde del rel√©
        mostrarProgresoAnalizador={mostrarProgresoAnalizador}            // controla animaci√≥n de borde del analizador
        periodoRele={periodoRele}                                        // periodo configurado para rel√©
        periodoAnalizador={periodoAnalizador}                            // periodo configurado para analizador
        contadorRele={contadorRele}                                      // contador de lecturas del rel√©
        contadorAnalizador={contadorAnalizador}                          // contador de lecturas del analizador
        // Polling de lecturas desde BD
        estaPolling={estaPolling}                                        // indica si hay polling activo
        mostrarProgresoPolling={mostrarProgresoPolling}                  // controla animaci√≥n de borde del polling
        periodoPolling={periodoPolling}                                  // periodo de polling en segundos
        contadorPolling={contadorPolling}                                // contador de lecturas de polling
        // Error de polling por zona
        tieneError={zonaConError}                                        // indica si esta zona tiene error de lectura
        // Estilos globales para box
        estilosBox={{
          tituloBox: {
            fontFamily: estilosGlobales?.tituloBox?.fontFamily || "inherit",
            fontSize: estilosGlobales?.tituloBox?.fontSize || "1rem",
          },
          valorBox: {
            fontFamily: estilosGlobales?.valorBox?.fontFamily || "'DS-Digital', 'Courier New', monospace",
            fontSize: estilosGlobales?.valorBox?.fontSize || "1.5rem",
            color: estilosGlobales?.valorBox?.color || "#ffff00",
            decimales: estilosGlobales?.valorBox?.decimales ?? 2,
          },
          box: {
            width: estilosGlobales?.box?.width || "80px",
            height: estilosGlobales?.box?.height || "auto",
          },
        }}
      />
    );
  };

  // Determinar si la escala es diferente al default (para mostrar indicador)
  const escalaModificada = escala !== 1.0;

  // Calcular estilos de escala para el contenedor
  const estiloEscala = escala !== 1.0 ? {
    transform: `scale(${escala})`,
    transformOrigin: "top left",
  } : {};

  return (
    <div
      ref={cardRef}
      className={clasesCard.join(" ")}
      style={{
        cursor: draggable ? "grab" : "default",
        ...estiloEscala,
      }}
      draggable={draggable}
      onDragStart={onDragStart}
      onDragOver={onDragOver}
      onDrop={onDrop}
      onDragEnd={onDragEnd}
    >
        {/* Header con nombre y botones de acciones */}
        <div
          className="alim-card-header"
          style={{
            background: `linear-gradient(to right, ${color || "#0ea5e9"}, ${color || "#0ea5e9"}80)`
          }}
        >
          {/* Flecha animada para desplegar men√∫ */}
          <button
            type="button"
            className={`alim-card-menu-toggle ${menuAbierto ? "alim-card-menu-toggle--abierto" : ""}`}
            onClick={toggleMenu}
            title="Opciones"
          >
            <span className="alim-card-menu-arrow">‚ñº</span>
          </button>

          <span
            className="alim-card-title"
            style={{
              fontFamily: estilosGlobales?.header?.fontFamily || "inherit",
              fontSize: estilosGlobales?.header?.fontSize || "1rem",
              fontWeight: estilosGlobales?.header?.fontWeight || 700,
            }}
          >{nombre}</span>
        </div>

        {/* Barra de progreso de polling */}
        {estaPolling && mostrarProgresoPolling && (
          <div className="alim-card-progress-track" key={cicloPolling}>
            <div
              className="alim-card-progress-fill"
              style={{ "--progress-duration": `${periodoPolling}s` }}
            >
              <div className="alim-card-progress-spark" />
            </div>
          </div>
        )}

        {/* Cuerpo con los 2 bloques (superior / inferior) */}
        <div className="alim-card-body">
          {/* ===== PARTE SUPERIOR ===== */}
          {!sup.oculto && (
            <GrupoMedidores
              titulo={sup.titulo}
              boxes={sup.boxes}
              zona="sup"
              renderizarCaja={renderizarCaja}
              estiloTitulo={{
                fontFamily: estilosGlobales?.tituloZona?.fontFamily || "inherit",
                fontSize: estilosGlobales?.tituloZona?.fontSize || "0.8rem",
              }}
              gap={estilosGlobales?.box?.gap}
            />
          )}

          {/* ===== PARTE INFERIOR ===== */}
          {!inf.oculto && (
            <GrupoMedidores
              titulo={inf.titulo}
              boxes={inf.boxes}
              zona="inf"
              renderizarCaja={renderizarCaja}
              estiloTitulo={{
                fontFamily: estilosGlobales?.tituloZona?.fontFamily || "inherit",
                fontSize: estilosGlobales?.tituloZona?.fontSize || "0.8rem",
              }}
              gap={estilosGlobales?.box?.gap}
            />
          )}

          {/* ===== OVERLAY DE ERROR ===== */}
          {/* Mostrar overlay solo cuando hay 3+ errores consecutivos (error cr√≠tico) */}
          {tieneErrorCritico && (
            <div className="alim-card-error-overlay alim-card-error-overlay--parpadeo">
              <div className="alim-card-error-content">
                <span className="alim-card-error-icon">‚ö†</span>
                <span className="alim-card-error-title">ATENCI√ìN</span>
                <span className="alim-card-error-message">Posiblemente fuera de servicio</span>
                <span className="alim-card-error-detail">Las √∫ltimas 3 lecturas no fueron v√°lidas o dieron error</span>
              </div>
            </div>
          )}

          {/* ===== TRI√ÅNGULO DE ESCALA ===== */}
          {/* Posicionado absolutamente dentro del body para no agregar altura */}
          {onEscalaChange && (
            <button
              ref={triangleRef}
              type="button"
              className={`alim-card-scale-btn${escalaModificada ? " alim-card-scale-btn--active" : ""}`}
              onClick={togglePopoverEscala}
              title={`Escala: ${escala}x (click para cambiar)`}
            >
              <span className="alim-card-scale-triangle">‚ñº</span>
              {escalaModificada && (
                <span className="alim-card-scale-value">{escala}x</span>
              )}
            </button>
          )}
        </div>

      {/* Popover de escala (portal) */}
      {mostrarPopoverEscala &&
        createPortal(
          <div
            ref={popoverRef}
            className="alim-card-scale-popover"
            style={{ top: `${posicionPopover.top}px`, left: `${posicionPopover.left}px` }}
            onClick={(e) => e.stopPropagation()}
            onMouseDown={(e) => e.stopPropagation()}
          >
            <label className="alim-card-scale-label">
              Escala ({ESCALA_MIN} - {ESCALA_MAX})
            </label>
            <div className="alim-card-scale-controls">
              <button
                type="button"
                className="alim-card-scale-pm-btn"
                onClick={handleDecrementarEscala}
                disabled={parseFloat(valorEscalaInput) <= ESCALA_MIN}
                title="Reducir escala"
              >
                -
              </button>
              <input
                type="number"
                step="0.01"
                min={ESCALA_MIN}
                max={ESCALA_MAX}
                value={valorEscalaInput}
                onChange={handleEscalaInputChange}
                onKeyDown={handleEscalaKeyDown}
                className="alim-card-scale-input"
                autoFocus
              />
              <button
                type="button"
                className="alim-card-scale-pm-btn"
                onClick={handleIncrementarEscala}
                disabled={parseFloat(valorEscalaInput) >= ESCALA_MAX}
                title="Aumentar escala"
              >
                +
              </button>
            </div>
            <div className="alim-card-scale-actions">
              <button
                type="button"
                className="alim-card-scale-reset"
                onClick={handleResetearEscala}
              >
                Reset (1.0)
              </button>
            </div>
          </div>,
          document.body
        )}

      {/* Men√∫ flotante desplegable (portal) */}
      {menuAbierto &&
        createPortal(
          <div
            ref={menuRef}
            className="alim-card-menu-flotante"
            style={{
              top: `${posicionMenu.top}px`,
              left: `${posicionMenu.left}px`,
              width: `${posicionMenu.width}px`,
            }}
            onClick={(e) => e.stopPropagation()}
            onMouseDown={(e) => e.stopPropagation()}
          >
            <div className="alim-card-menu-flotante-content">
              {/* Bot√≥n de configuraci√≥n */}
              <button
                type="button"
                className="alim-card-menu-flotante-btn"
                onClick={(e) => {
                  e.stopPropagation();
                  setMenuAbierto(false);
                  onConfigClick?.();
                }}
                title="Configurar registrador"
              >
                <img src={configIcon} alt="Configurar" className="alim-card-menu-flotante-icon" />
              </button>

              {/* Bot√≥n de historial/estad√≠sticas (oculto para observadores) */}
              {onHistorialClick && !esObservador && (
                <button
                  type="button"
                  className="alim-card-menu-flotante-btn"
                  onClick={(e) => {
                    e.stopPropagation();
                    setMenuAbierto(false);
                    onHistorialClick();
                  }}
                  title="Ver historial de lecturas"
                >
                  <span className="alim-card-menu-flotante-emoji">üìà</span>
                </button>
              )}
            </div>
          </div>,
          document.body
        )}
    </div>
  );
};

export default TarjetaAlimentador;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (TarjetaAlimentador.jsx)

 - Este componente representa una tarjeta de alimentador (un registrador) con
   dos bloques de mediciones: parte superior e inferior.

 - `construirLado` se encarga de tomar el dise√±o y las lecturas de cada lado y
   devolver siempre una estructura consistente `{ titulo, boxes }`, rellenando
   con valores por defecto si falta informaci√≥n.

 - El estado local `mostrarProgresoRele` / `mostrarProgresoAnalizador` se usa
   para decidir si se dibuja la animaci√≥n de borde en `CajaMedicion`. Solo se
   activa cuando llega al menos una lectura (contador > 0) y se resetea si se
   detiene la medici√≥n o se cambia de puesto.

 - `isWide` y las clases `alim-card`, `alim-card-wide`, `alim-card-dragging`
   controlan el layout y el aspecto visual de la tarjeta en funci√≥n de cu√°ntas
   boxes tiene y si est√° siendo arrastrada.

 - Toda la l√≥gica de mediciones (periodos, contadores, timestamps) viene desde
   el contexto; esta tarjeta solo la usa para decidir qu√© mostrar y c√≥mo
   animarlo.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (TarjetaAlimentador.jsx)

0) Visi√≥n general del componente

   `TarjetaAlimentador` representa visualmente un alimentador (registrador) en la grilla:

   - Muestra un encabezado con:
       ‚Ä¢ nombre del alimentador,
       ‚Ä¢ bot√≥n de configuraci√≥n (tuerca),
       ‚Ä¢ bot√≥n de mapeo (√≠cono de mapas).

   - En el cuerpo muestra dos bloques de medici√≥n:
       ‚Ä¢ parte superior (`topSide`) ‚Üí t√≠picamente corrientes (A),
       ‚Ä¢ parte inferior (`bottomSide`) ‚Üí t√≠picamente tensiones (kV).

   - Cada bloque est√° compuesto por cajas (`CajaMedicion`) agrupadas por `GrupoMedidores`,
     y puede tener hasta 4 boxes por fila.

   - Adem√°s:
       ‚Ä¢ puede ser arrastrable (drag & drop) para reordenar tarjetas,
       ‚Ä¢ reacciona al estado de mediciones (rel√© / analizador) para animar bordes de progreso.


1) Helper construirLado

   const construirLado = (side, tituloDefault) => { ... }

   - Par√°metros:
       ‚Ä¢ `side`: objeto de configuraci√≥n del lado (sup/inf) que viene del mapeo.
       ‚Ä¢ `tituloDefault`: texto por defecto a usar como t√≠tulo si no hay uno configurado.

   - Crea primero un set de cajas por defecto:

     const cajasPorDefecto = ["R", "S", "T"].map((label) => ({
       etiqueta: label,
       valor: "--,--",
       enabled: false,
       origen: null,
     }));

     - Tres cajas con etiquetas ‚ÄúR‚Äù, ‚ÄúS‚Äù y ‚ÄúT‚Äù.

     - Valor inicial `"--,--"` para indicar que a√∫n no hay lectura.

     - `enabled: false` ‚Üí por defecto no est√°n activas.

     - `origen: null` ‚Üí todav√≠a no se defini√≥ si la lectura viene de rel√© o analizador.

   - Si `side` no existe:

     if (!side) {
       return {
         titulo: tituloDefault,
         boxes: cajasPorDefecto,
       };
     }

     - Devuelve un lado con:
         ‚Ä¢ `titulo`: el por defecto,
         ‚Ä¢ `boxes`: las 3 cajas b√°sicas R/S/T sin lecturas.

   - Si s√≠ hay `side`, se normalizan t√≠tulo y cajas:

     const titulo =
       (side.titulo && String(side.titulo).trim()) || tituloDefault;

     - Usa `side.titulo` si viene definido y no vac√≠o,
     - si no, cae en `tituloDefault`.

     let boxes = Array.isArray(side.boxes) ? side.boxes : [];
     boxes = boxes.slice(0, 4);

     - Garantiza que `boxes` sea un array.

     - Recorta a m√°ximo 4 cajas por lado (l√≠mite visual de la tarjeta).

   - Si no hay ninguna caja configurada (`boxes.length === 0`):

     boxes = cajasPorDefecto;

     - Vuelve a usar las 3 cajas R/S T por defecto.

   - Si hay cajas, se mapean y ‚Äúlimpian‚Äù:

     boxes = boxes.map((b, idx) => ({
       etiqueta:
         (b?.etiqueta && String(b.etiqueta).trim()) ||
         `Box ${idx + 1}`,
       valor:
         b?.valor == null || b.valor === ""
           ? "--,--"
           : String(b.valor),
       enabled: !!b?.enabled,
       origen: b?.origen || null,
     }));

     - `etiqueta`:
         ‚Ä¢ usa la etiqueta del mapeo si existe,
         ‚Ä¢ si no, genera ‚ÄúBox 1‚Äù, ‚ÄúBox 2‚Äù, etc.

     - `valor`:
         ‚Ä¢ si no hay valor o est√° vac√≠o ‚Üí `"--,--"`,
         ‚Ä¢ si hay valor ‚Üí lo convierte a string.

     - `enabled`:
         ‚Ä¢ fuerza a booleano con `!!b?.enabled` (true/false).

     - `origen`:
         ‚Ä¢ mantiene el origen declarado (`"rele"` / `"analizador"`),
         ‚Ä¢ o `null` si no se defini√≥.

   - Al final devuelve siempre un objeto con forma homog√©nea:

     return { titulo, boxes };

     - Esto asegura que el componente pueda renderizar un lado aunque falten
       partes de la configuraci√≥n o todav√≠a no haya lecturas.


2) Props del componente principal

   const TarjetaAlimentador = ({
     nombre,
     color,
     onConfigClick,
     onMapClick,
     topSide,
     bottomSide,
     draggable = false,
     isDragging = false,
     onDragStart,
     onDragOver,
     onDrop,
     onDragEnd,
     mideRele = false,
     mideAnalizador = false,
     periodoRele = 60,
     periodoAnalizador = 60,
     timestampInicioRele = null,
     timestampInicioAnalizador = null,
     contadorRele = 0,
     contadorAnalizador = 0,
   }) => { ... }

   - Datos b√°sicos:
       ‚Ä¢ `nombre`: texto que se muestra en el encabezado de la tarjeta.
       ‚Ä¢ `color`: color de fondo del header (identifica al alimentador).

   - Acciones de √≠conos:
       ‚Ä¢ `onConfigClick()`:
           - abre el modal de configuraci√≥n del alimentador (IP, registros, etc.).
       ‚Ä¢ `onMapClick()`:
           - abre el modal de mapeo de mediciones (definir qu√© se muestra en cada box).

   - Dise√±o y valores de los lados:
       ‚Ä¢ `topSide`: config + valores para la parte superior.
       ‚Ä¢ `bottomSide`: config + valores para la parte inferior.
       ‚Ä¢ Ambos se pasan a `construirLado` para obtener `{ titulo, boxes }`.

   - Drag & drop:
       ‚Ä¢ `draggable` (boolean):
           - indica si la tarjeta se puede arrastrar.
       ‚Ä¢ `isDragging` (boolean):
           - indica si esta tarjeta es la que est√° en arrastre (para estilo visual).
       ‚Ä¢ `onDragStart`, `onDragOver`, `onDrop`, `onDragEnd`:
           - callbacks que se conectan con el hook de drag & drop
             (`usarArrastrarSoltar`), usados por la vista.

   - Informaci√≥n de mediciones:
       ‚Ä¢ `mideRele`, `mideAnalizador`:
           - true/false seg√∫n si hay medici√≥n activa de cada equipo.
       ‚Ä¢ `periodoRele`, `periodoAnalizador`:
           - per√≠odo de actualizaci√≥n en segundos (se usa en la animaci√≥n).
       ‚Ä¢ `timestampInicioRele`, `timestampInicioAnalizador`:
           - reservados por si se quiere sincronizar animaciones en el futuro.
       ‚Ä¢ `contadorRele`, `contadorAnalizador`:
           - cu√°ntas lecturas se realizaron desde que se inici√≥ la medici√≥n.


3) Estado local y refs para animaciones

   const [mostrarProgresoRele, setMostrarProgresoRele] = useState(false);
   const [mostrarProgresoAnalizador, setMostrarProgresoAnalizador] = useState(false);

   - Controlan si se debe mostrar la animaci√≥n de borde de progreso en las cajas:
       ‚Ä¢ para el rel√© (`mostrarProgresoRele`),
       ‚Ä¢ para el analizador (`mostrarProgresoAnalizador`).

   - Empiezan en `false` porque inicialmente no hay lecturas.

   const ultimoContadorReleRef = useRef(contadorRele);
   const ultimoContadorAnalizadorRef = useRef(contadorAnalizador);

   - Guardan el √∫ltimo valor de `contadorRele` / `contadorAnalizador` sin
     provocar re-renders (porque son refs).

   - Sirven para detectar si el contador cambi√≥ (es decir, si lleg√≥ una lectura nueva).


4) useEffect para rel√©

   useEffect(() => {
     if (!mideRele) {
       setMostrarProgresoRele(false);
       ultimoContadorReleRef.current = contadorRele;
       return;
     }

     if (contadorRele !== ultimoContadorReleRef.current) {
       ultimoContadorReleRef.current = contadorRele;
       setMostrarProgresoRele(contadorRele > 0);
     }
   }, [contadorRele, mideRele]);

   - Dependencias:
       ‚Ä¢ `contadorRele`,
       ‚Ä¢ `mideRele`.

   - Si `mideRele` es false:
       ‚Ä¢ la medici√≥n est√° apagada,
       ‚Ä¢ apaga la animaci√≥n (`setMostrarProgresoRele(false)`),
       ‚Ä¢ sincroniza la ref con el contador actual.

   - Si `mideRele` es true y el contador cambi√≥:
       ‚Ä¢ actualiza la ref (`ultimoContadorReleRef.current = contadorRele`),
       ‚Ä¢ vuelve a evaluar `setMostrarProgresoRele(contadorRele > 0)`:
           - si ya hubo al menos una lectura (`> 0`), deja la animaci√≥n encendida.

   - En resumen:
       ‚Ä¢ cuando se inicia o avanza una medici√≥n de rel√©, la animaci√≥n se activa,
       ‚Ä¢ cuando se detiene, se apaga y se resetea el seguimiento.


5) useEffect para analizador

   useEffect(() => {
     if (!mideAnalizador) {
       setMostrarProgresoAnalizador(false);
       ultimoContadorAnalizadorRef.current = contadorAnalizador;
       return;
     }

     if (contadorAnalizador !== ultimoContadorAnalizadorRef.current) {
       ultimoContadorAnalizadorRef.current = contadorAnalizador;
       setMostrarProgresoAnalizador(contadorAnalizador > 0);
     }
   }, [contadorAnalizador, mideAnalizador]);

   - Mismo patr√≥n que el del rel√©, pero aplicado al analizador.

   - Permite tener animaciones independientes:
       ‚Ä¢ puede estar midiendo solo rel√©, solo analizador o ambos.


6) Preparaci√≥n de los lados y ancho de la tarjeta

   const sup = construirLado(topSide, "CONSUMO (A)");
   const inf = construirLado(bottomSide, "TENSI√ìN (kV)");

   - `sup` y `inf` quedan con forma:
       ‚Ä¢ `{ titulo: string, boxes: Array<...> }`
   - T√≠tulos por defecto:
       ‚Ä¢ ‚ÄúCONSUMO (A)‚Äù para la parte superior,
       ‚Ä¢ ‚ÄúTENSI√ìN (kV)‚Äù para la inferior.

   const maxBoxes = Math.max(sup.boxes.length, inf.boxes.length);
   const isWide = maxBoxes >= 4;

   - Calcula cu√°ntas cajas tiene el lado m√°s poblado.
	
   - Si tiene 4 o m√°s, marca la tarjeta como ‚Äúancha‚Äù (`isWide = true`) para ensancharla.

   const clasesCard = ["alim-card"];
   if (isWide) clasesCard.push("alim-card-wide");
   if (isDragging) clasesCard.push("alim-card-dragging");

   - Construye un array de clases CSS:
       ‚Ä¢ siempre incluye `"alim-card"`,
       ‚Ä¢ agrega `"alim-card-wide"` si la tarjeta debe ser m√°s ancha,
       ‚Ä¢ agrega `"alim-card-dragging"` si est√° siendo arrastrada (para cambiar estilo
         durante el drag & drop).


7) Helper renderizarCaja

   const renderizarCaja = (box, idx, zona) => (
     <CajaMedicion
       key={`${zona}-${idx}`}
       box={box}
       indice={idx}
       zona={zona}
       mideRele={mideRele}
       mideAnalizador={mideAnalizador}
       mostrarProgresoRele={mostrarProgresoRele}
       mostrarProgresoAnalizador={mostrarProgresoAnalizador}
       periodoRele={periodoRele}
       periodoAnalizador={periodoAnalizador}
       contadorRele={contadorRele}
       contadorAnalizador={contadorAnalizador}
     />
   );

   - Funci√≥n de ayuda que devuelve una `CajaMedicion` correctamente parametrizada.

   - Par√°metros:
       ‚Ä¢ `box`: objeto con la informaci√≥n de la caja (etiqueta, valor, enabled, origen),
       ‚Ä¢ `idx`: √≠ndice dentro del grupo,
       ‚Ä¢ `zona`: "sup" o "inf" (parte superior o inferior).

   - Props importantes que se pasan a `CajaMedicion`:
       ‚Ä¢ `mideRele` / `mideAnalizador` ‚Üí para saber qu√© equipos est√°n activos.
       ‚Ä¢ `mostrarProgresoRele` / `mostrarProgresoAnalizador` ‚Üí para animar bordes.
       ‚Ä¢ `periodoRele` / `periodoAnalizador` ‚Üí para sincronizar la animaci√≥n con el per√≠odo.
       ‚Ä¢ `contadorRele` / `contadorAnalizador` ‚Üí para detectar nuevos ciclos.


8) JSX principal (estructura de la tarjeta)

   // Contenedor principal de la tarjeta (card)
   return (
     <div
       className={clasesCard.join(" ")}
       style={{ cursor: draggable ? "grab" : "default" }}
       draggable={draggable}
       onDragStart={onDragStart}
       onDragOver={onDragOver}
       onDrop={onDrop}
       onDragEnd={onDragEnd}
     >
       // Header con nombre y botones de acciones
       <div
         className="alim-card-header"
         style={{ backgroundColor: color || "#0ea5e9" }}
       >
         <div className="alim-card-icons">
           <button ... onClick={onConfigClick}> [icono tuerca] </button>
           <button ... onClick={onMapClick}>   [icono mapeo]  </button>
         </div>

         <span className="alim-card-title">{nombre}</span>
       </div>

       // Cuerpo con los 2 bloques (superior / inferior)
       <div className="alim-card-body">
         <GrupoMedidores
           titulo={sup.titulo}
           boxes={sup.boxes}
           zona="sup"
           renderizarCaja={renderizarCaja}
         />

         <GrupoMedidores
           titulo={inf.titulo}
           boxes={inf.boxes}
           zona="inf"
           renderizarCaja={renderizarCaja}
         />
       </div>
     </div>
   );

   - Contenedor `<div className={clasesCard.join(" ")} ...>`:
       ‚Ä¢ envuelve toda la tarjeta,
       ‚Ä¢ `cursor: "grab"` si es arrastrable,
       ‚Ä¢ atributos `draggable`, `onDragStart`, `onDragOver`, `onDrop`, `onDragEnd`
         conectan la tarjeta con la l√≥gica de drag & drop.

   - Header:
       ‚Ä¢ fondo con `color` del alimentador (o celeste por defecto),
       ‚Ä¢ botones de:
           - configuraci√≥n (`onConfigClick`),
           - mapeo (`onMapClick`),
       ‚Ä¢ t√≠tulo con el nombre del alimentador.

   - Cuerpo:
       ‚Ä¢ dos `GrupoMedidores`, uno para la parte superior (‚Äúsup‚Äù) y otro para
         la inferior (‚Äúinf‚Äù),
       ‚Ä¢ cada grupo recibe:
           - t√≠tulo,
           - lista de `boxes`,
           - funci√≥n `renderizarCaja` para generar cada `CajaMedicion`.


9) Export

   export default TarjetaAlimentador;

   - Permite usar esta tarjeta dentro de `GrillaTarjetas` para construir la vista
     completa de alimentadores.

---------------------------------------------------------------------------*/

// ===== ./src/paginas/PaginaAlimentadores/constantes/clavesAlmacenamiento.js =====

// src/paginas/PaginaAlimentadores/constantes/clavesAlmacenamiento.js

/**
 * Claves para guardar datos en localStorage
 * Centralizadas ac√° para evitar typos y mantener consistencia.
 */
export const CLAVES_STORAGE = {
	PUESTOS: "rw-puestos",                    // lista completa de puestos configurados
	PUESTO_SELECCIONADO: "rw-puesto-seleccionado", // id del puesto que qued√≥ seleccionado
	CONFIGURACION_SELECCIONADA: "rw-configuracion-seleccionada", // id del workspace activo
	USUARIOS_RECORDADOS: "usuariosRecordados",     // lista de usuarios recordados (login)
	GAP_TARJETAS: "rw-gap-tarjetas",          // espaciado horizontal entre tarjetas (en px)
	GAP_FILAS: "rw-gap-filas",                // espaciado vertical entre filas (en px)
	ESCALA_GLOBAL: "rw-escala-global",        // escala global de todas las tarjetas
	ESCALA_PUESTOS: "rw-escala-puestos",      // escala por puesto { puestoId: escala }
	ESCALA_TARJETAS: "rw-escala-tarjetas",    // escala individual por tarjeta { alimId: escala }
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (clavesAlmacenamiento.js)

 - Ac√° defino todas las claves de `localStorage` que usa la pantalla de
   alimentadores (y algunas compartidas, como `USUARIOS_RECORDADOS`).

 - La idea es nunca escribir las strings a mano en el resto del c√≥digo,
   sino importar `CLAVES_STORAGE` y usar `CLAVES_STORAGE.PUESTOS`, etc., para
   evitar errores de tipeo y poder cambiar el prefijo f√°cilmente si hace falta.
---------------------------------------------------------------------------*/}


// ===== ./src/paginas/PaginaAlimentadores/constantes/colores.js =====

// src/paginas/PaginaAlimentadores/constantes/colores.js

/**
 * Paleta de colores del sistema
 * Usada para puestos y alimentadores (botones, tarjetas, etc.).
 */
export const COLORES_SISTEMA = [
	"#22c55e", // Verde
	"#0ea5e9", // Azul cielo
	"#3b82f6", // Azul
	"#a855f7", // P√∫rpura
	"#ec4899", // Rosa
	"#f97316", // Naranja
	"#ef4444", // Rojo
	"#eab308", // Amarillo
	"#14b8a6", // Turquesa
	"#10b981", // Verde esmeralda
	"#6366f1", // √çndigo
	"#64748b", // Gris azulado
];

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (colores.js)

 - `COLORES_SISTEMA` es la paleta central para elegir colores de puestos y
   alimentadores. En el modal de configuraci√≥n se recorre este array para
   dibujar los cuadrados de color.

 - Si en alg√∫n momento quiero cambiar el look&feel (por ejemplo, usar otros
   verdes o agregar m√°s opciones), basta con modificar esta lista sin tocar
   el resto de los componentes.
---------------------------------------------------------------------------*/}


// ===== ./src/paginas/PaginaAlimentadores/constantes/estilosGlobalesTarjeta.js =====

/**
 * Constantes de estilos globales para las tarjetas de alimentador
 * Estos valores son los defaults que se usan si el usuario no ha personalizado nada
 */

// Lista curada de fuentes disponibles (ordenada alfab√©ticamente)
export const FUENTES_DISPONIBLES = [
  // Opci√≥n por defecto (siempre primera)
  { id: "inherit", label: "Por defecto" },
  // Resto ordenado alfab√©ticamente
  { id: "'Arial', sans-serif", label: "Arial" },
  { id: "'Barlow', sans-serif", label: "Barlow" },
  { id: "'Bebas Neue', sans-serif", label: "Bebas Neue" },
  { id: "'Cabin', sans-serif", label: "Cabin" },
  { id: "'Comfortaa', sans-serif", label: "Comfortaa" },
  { id: "'Consolas', monospace", label: "Consolas" },
  { id: "'Digital-7', 'Courier New', monospace", label: "Digital-7" },
  { id: "'Digital-7-Mono', 'Courier New', monospace", label: "Digital-7 Mono" },
  { id: "'DS-Digital', 'Courier New', monospace", label: "DS-Digital" },
  { id: "'DS-Digital-Bold', 'Courier New', monospace", label: "DS-Digital Bold" },
  { id: "'Exo 2', sans-serif", label: "Exo 2" },
  { id: "'Fira Code', monospace", label: "Fira Code" },
  { id: "'IBM Plex Sans', sans-serif", label: "IBM Plex Sans" },
  { id: "'Inconsolata', monospace", label: "Inconsolata" },
  { id: "'Inter', sans-serif", label: "Inter" },
  { id: "'JetBrains Mono', monospace", label: "JetBrains Mono" },
  { id: "'Kanit', sans-serif", label: "Kanit" },
  { id: "'Lato', sans-serif", label: "Lato" },
  { id: "'Montserrat', sans-serif", label: "Montserrat" },
  { id: "'Nunito', sans-serif", label: "Nunito" },
  { id: "'Open Sans', sans-serif", label: "Open Sans" },
  { id: "'Orbitron', sans-serif", label: "Orbitron" },
  { id: "'Oswald', sans-serif", label: "Oswald" },
  { id: "'Oxanium', sans-serif", label: "Oxanium" },
  { id: "'Play', sans-serif", label: "Play" },
  { id: "'Playfair Display', serif", label: "Playfair Display" },
  { id: "'Poppins', sans-serif", label: "Poppins" },
  { id: "'Quicksand', sans-serif", label: "Quicksand" },
  { id: "'Rajdhani', sans-serif", label: "Rajdhani" },
  { id: "'Roboto', sans-serif", label: "Roboto" },
  { id: "'Roboto Mono', monospace", label: "Roboto Mono" },
  { id: "'Rubik', sans-serif", label: "Rubik" },
  { id: "'Russo One', sans-serif", label: "Russo One" },
  { id: "'Segoe UI', sans-serif", label: "Segoe UI" },
  { id: "'Share Tech Mono', monospace", label: "Share Tech Mono" },
  { id: "'Source Sans 3', sans-serif", label: "Source Sans" },
  { id: "'Space Mono', monospace", label: "Space Mono" },
  { id: "'Teko', sans-serif", label: "Teko" },
  { id: "'Titillium Web', sans-serif", label: "Titillium Web" },
  { id: "'Ubuntu', sans-serif", label: "Ubuntu" },
  { id: "'Work Sans', sans-serif", label: "Work Sans" },
  { id: "'Zilla Slab', serif", label: "Zilla Slab" },
];

// Alias para compatibilidad (usa la misma lista)
export const FUENTES_DIGITALES = FUENTES_DISPONIBLES;

// Key para localStorage
export const ESTILOS_GLOBALES_STORAGE_KEY = "alimentadores_estilos_globales";

// Valores por defecto (extra√≠dos del CSS actual)
export const ESTILOS_GLOBALES_DEFAULT = {
  // 1. Header de la tarjeta (t√≠tulo como "TRAFO 1")
  header: {
    fontFamily: "inherit",
    fontSize: "1rem",        // ~16px
    fontWeight: 700,
  },

  // 2. T√≠tulos de zona (superior e inferior como conjunto)
  // Ej: "CORRIENTE DE L√çNEA (A) (EN 33 KV)"
  tituloZona: {
    fontFamily: "inherit",
    fontSize: "0.8rem",      // ~12.8px
  },

  // 3. T√≠tulos de los boxes (R, S, T) como conjunto
  tituloBox: {
    fontFamily: "inherit",
    fontSize: "1rem",        // ~16px
  },

  // 4. Contenido de los boxes (valores como "--,--")
  valorBox: {
    fontFamily: "'DS-Digital', 'Courier New', monospace",
    fontSize: "1.5rem",      // ~24px
    color: "#ffff00",        // amarillo
    decimales: 2,            // cantidad de decimales a mostrar (0, 1 o 2)
  },

  // 5. Configuraci√≥n del box contenedor
  box: {
    gap: "18px",                  // espacio entre boxes (igual a CSS: gap: 18px)
    width: "80px",                // ancho fijo del box
    height: "auto",               // alto del box ("auto" = se ajusta al contenido)
  },
};

// L√≠mites para los sliders de tama√±o
export const LIMITES_TAMA√ëO = {
  header: { min: 0.7, max: 1.6, step: 0.05 },           // rem
  tituloZona: { min: 0.6, max: 1.2, step: 0.05 },       // rem
  tituloBox: { min: 0.7, max: 1.4, step: 0.05 },        // rem
  valorBox: { min: 0, max: 2.5, step: 0.1 },             // rem (0 a 2.5)
  gap: { min: 5, max: 40, step: 1 },                    // px (espacio entre boxes)
  boxWidth: { min: 60, max: 120, step: 2 },             // px (ancho del box)
  boxHeight: { min: 24, max: 60, step: 2 },             // px (alto del box, 0 = auto)
};

// Opciones de decimales para los valores
export const OPCIONES_DECIMALES = [
  { valor: 2, label: "2 decimales" },
  { valor: 1, label: "1 decimal" },
  { valor: 0, label: "Sin decimales" },
];

// Colores predefinidos para el texto de los valores
export const COLORES_VALOR_PREDEFINIDOS = [
  "#ffff00", // amarillo (default)
  "#00ff00", // verde
  "#00ffff", // cyan
  "#ff9900", // naranja
  "#ff6666", // rojo claro
  "#ffffff", // blanco
  "#99ccff", // azul claro
];

// ===== ./src/paginas/PaginaAlimentadores/constantes/funcionalidadesRele.js =====

/**
 * Funcionalidades disponibles para configurar rel√©s de protecci√≥n ABB Serie 615.
 * Cada funcionalidad define qu√© datos se pueden monitorear y su registro Modbus por defecto.
 */

export const FUNCIONALIDADES_DISPONIBLES = {
  // MEDICIONES
  corrientes: {
    id: "corrientes",
    nombre: "Corrientes de fase (IL1, IL2, IL3)",
    categoria: "mediciones",
    registroDefault: 137,
    cantidad: 3,
  },
  tensiones: {
    id: "tensiones",
    nombre: "Tensiones (VA, VB, VC, VAB, VBC, VCA)",
    categoria: "mediciones",
    registroDefault: 151,
    cantidad: 6,
  },
  corrienteResidual: {
    id: "corrienteResidual",
    nombre: "Corriente residual Io",
    categoria: "mediciones",
    registroDefault: 141,
    cantidad: 1,
  },
  potencias: {
    id: "potencias",
    nombre: "Potencias (P, Q, S, FP)",
    categoria: "mediciones",
    registroDefault: 160,
    cantidad: 7,
  },

  // ESTADOS Y ALARMAS
  estadoRele: {
    id: "estadoRele",
    nombre: "Estado del rel√© (Ready/Start/Trip)",
    categoria: "estados",
    registroDefault: 170,
    cantidad: 1,
  },
  leds: {
    id: "leds",
    nombre: "LEDs del panel (alarmas visibles)",
    categoria: "estados",
    registroDefault: 172,
    cantidad: 1,
  },
  posicionCB: {
    id: "posicionCB",
    nombre: "Posici√≥n del interruptor (CB)",
    categoria: "estados",
    registroDefault: 175,
    cantidad: 1,
  },

  // SISTEMA
  saludDispositivo: {
    id: "saludDispositivo",
    nombre: "Salud del dispositivo (SSR1 - Ready)",
    categoria: "sistema",
    registroDefault: 127,
    cantidad: 1,
  },
  heartbeat: {
    id: "heartbeat",
    nombre: "Heartbeat (SSR5 - Alive counter)",
    categoria: "sistema",
    registroDefault: 131,
    cantidad: 1,
  },
};

/**
 * Categor√≠as de funcionalidades para agrupar en la UI
 */
export const CATEGORIAS_FUNCIONALIDADES = {
  mediciones: {
    id: "mediciones",
    nombre: "Mediciones",
    icono: "üìä",
  },
  estados: {
    id: "estados",
    nombre: "Estados y Alarmas",
    icono: "üö¶",
  },
  sistema: {
    id: "sistema",
    nombre: "Sistema",
    icono: "‚öôÔ∏è",
  },
};

/**
 * Obtiene las funcionalidades agrupadas por categor√≠a
 */
export const getFuncionalidadesPorCategoria = () => {
  const agrupadas = {};

  Object.values(FUNCIONALIDADES_DISPONIBLES).forEach((func) => {
    if (!agrupadas[func.categoria]) {
      agrupadas[func.categoria] = {
        ...CATEGORIAS_FUNCIONALIDADES[func.categoria],
        funcionalidades: [],
      };
    }
    agrupadas[func.categoria].funcionalidades.push(func);
  });

  return agrupadas;
};

/**
 * Key de localStorage para las plantillas de rel√©
 */
export const STORAGE_KEY_PLANTILLAS = "rw-plantillas-rele";

// ===== ./src/paginas/PaginaAlimentadores/constantes/historialConfig.js =====

/**
 * Configuraci√≥n y constantes para el sistema de historial y gr√°ficos
 */

// Retenci√≥n de datos en IndexedDB (horas)
export const HORAS_RETENCION_LOCAL = 48;

// Umbral de cobertura para considerar cache v√°lido (85%)
export const UMBRAL_COBERTURA_CACHE = 0.85;

// Umbral de cobertura para complementar con datos remotos (90%)
export const UMBRAL_COBERTURA_REMOTO = 0.90;

// Margen adicional al l√≠mite de 48h para evitar edge cases (5 minutos en ms)
export const MARGEN_LIMITE_LOCAL_MS = 5 * 60 * 1000;

// Antig√ºedad m√°xima permitida para el √∫ltimo dato en cache (minutos)
// Si el √∫ltimo dato es m√°s antiguo que esto, se fuerza recarga del servidor
export const MAX_ANTIGUEDAD_CACHE_MINUTOS = 15;

// Opciones de rango de tiempo predefinidas
export const RANGOS_TIEMPO = [
  { id: "1h", label: "1h", ms: 60 * 60 * 1000 },
  { id: "2h", label: "2h", ms: 2 * 60 * 60 * 1000 },
  { id: "6h", label: "6h", ms: 6 * 60 * 60 * 1000 },
  { id: "12h", label: "12h", ms: 12 * 60 * 60 * 1000 },
  { id: "24h", label: "24h", ms: 24 * 60 * 60 * 1000 },
  { id: "48h", label: "48h", ms: 48 * 60 * 60 * 1000 },
  { id: "7d", label: "7d", ms: 7 * 24 * 60 * 60 * 1000 },
  { id: "custom", label: "Custom", ms: null },
];

// Tipos de gr√°fico disponibles
export const TIPOS_GRAFICO = [
  { id: "line", label: "L√≠nea", icon: "üìà" },
  { id: "area", label: "√Årea", icon: "üìä" },
  { id: "bar", label: "Barras", icon: "üì∂" },
];

// Intervalos de muestreo para informes (en minutos)
export const INTERVALOS_INFORME = [
  { id: 15, label: "15 min", minutos: 15 },
  { id: 30, label: "30 min", minutos: 30 },
  { id: 60, label: "1 hora", minutos: 60 },
  { id: 180, label: "3 horas", minutos: 180 },
  { id: 360, label: "6 horas", minutos: 360 },
  { id: 720, label: "12 horas", minutos: 720 },
];

// Intervalos de filtro para panel de datos (en minutos)
export const INTERVALOS_FILTRO = [
  { value: 0, label: "Todos" },
  { value: 15, label: "cada 15m" },
  { value: 30, label: "cada 30m" },
  { value: 60, label: "cada 60m" },
];

// Colores del gradiente verde-amarillo-rojo
export const COLORES_GRADIENTE = {
  verde: { r: 34, g: 197, b: 94 },     // #22c55e
  amarillo: { r: 234, g: 179, b: 8 },  // #eab308
  rojo: { r: 239, g: 68, b: 68 },      // #ef4444
};

// Configuraci√≥n de IndexedDB
export const INDEXEDDB_CONFIG = {
  nombre: "RelayWatchHistorial",
  version: 1,
  store: "lecturas",
};

// Estilos del gr√°fico base (tema oscuro)
export const ESTILOS_GRAFICO_BASE = {
  background: "#0f172a",
  foreColor: "#e2e8f0",
  gridColor: "#334155",
  labelColor: "#94a3b8",
  borderColor: "#334155",
};

// Estilos del gr√°fico para exportaci√≥n (tema claro)
export const ESTILOS_GRAFICO_EXPORT = {
  background: "#ffffff",
  foreColor: "#1a1a1a",
  gridColor: "#bbbbbb",
  labelColor: "#1a1a1a",
  borderColor: "#333333",
  fontSize: "16px",
  fontSizeTitle: "17px",
  fontWeight: 600,
  fontWeightTitle: 700,
};

// ===== ./src/paginas/PaginaAlimentadores/constantes/titulosMediciones.js =====

// src/paginas/PaginaAlimentadores/constantes/titulosMediciones.js

/**
 * T√≠tulos descriptivos para cada tipo de medici√≥n.
 * Aparecen en las tarjetas de alimentadores (parte superior/inferior).
 */
export const TITULOS_MEDICIONES = {
	tension_linea: "Tensi√≥n de l√≠nea (kV)",
	tension_entre_lineas: "Tensi√≥n entre l√≠neas (kV)",
	corriente_132: "Corriente de l√≠nea (A) (en 13,2 kV)",
	corriente_33: "Corriente de l√≠nea (A) (en 33 kV)",
	potencia_activa: "Potencia activa (kW)",
	potencia_reactiva: "Potencia reactiva (kVAr)",
	potencia_aparente: "Potencia aparente (kVA)",
	factor_potencia: "Factor de Potencia",
	frecuencia: "Frecuencia (Hz)",
	corriente_neutro: "Corriente de Neutro (A)",
};

/**
 * Etiquetas que aparecen en cada medidor (R, S, T, etc.),
 * organizadas por tipo de medici√≥n.
 */
export const ETIQUETAS_POR_DEFECTO = {
	corriente_132: ["R", "S", "T", "N"],
	corriente_33: ["R", "S", "T", "N"],
	tension_linea: ["R", "S", "T", "N"],
	tension_entre_lineas: ["L1-L2", "L2-L3", "L1-L3", ""],
	potencia_activa: ["L1", "L2", "L3", "Total"],
	potencia_reactiva: ["L1", "L2", "L3", "Total"],
	potencia_aparente: ["L1", "L2", "L3", "Total"],
	factor_potencia: ["L1", "L2", "L3", ""],
	frecuencia: ["L1", "L2", "L3", ""],
	corriente_neutro: ["N", "", "", ""],
};

/**
 * Dise√±o por defecto de una tarjeta de alimentador.
 * Define qu√© se muestra en la parte superior e inferior.
 */
export const DISE√ëO_TARJETA_POR_DEFECTO = {
	superior: {
		tituloId: "corriente_132", // arriba se muestran corrientes de l√≠nea (13,2 kV)
		tituloCustom: "",
		cantidad: 3,               // por defecto R, S, T
		boxes: [],
	},
	inferior: {
		tituloId: "tension_linea", // abajo se muestran tensiones de l√≠nea (kV)
		tituloCustom: "",
		cantidad: 3,
		boxes: [],
	},
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (titulosMediciones.js)

 - `TITULOS_MEDICIONES` traduce ids como `corriente_132` o `tension_linea`
   a textos legibles que aparecen como t√≠tulos en los lados de la tarjeta.

 - `ETIQUETAS_POR_DEFECTO` define las etiquetas iniciales de cada box seg√∫n
   el tipo de magnitud (por ejemplo, R/S/T/N para corrientes y L1/L2/L3/Total
   para potencias).

 - `DISE√ëO_TARJETA_POR_DEFECTO` se usa en `calculosMediciones.js` como base
   cuando todav√≠a no hay ning√∫n `cardDesign` configurado por el usuario, de
   modo que siempre exista una estructura razonable para mostrar.
---------------------------------------------------------------------------*/}


// ===== ./src/paginas/PaginaAlimentadores/contexto/ContextoAlimentadoresSupabase.jsx =====

// src/paginas/PaginaAlimentadores/contexto/ContextoAlimentadoresSupabase.jsx
// Contexto de alimentadores que usa Supabase para persistencia

import React, { createContext, useContext, useMemo, useEffect, useState, useCallback } from "react";

import { usePuestosSupabase } from "../hooks/usePuestosSupabase";
import { useMediciones } from "../hooks/useMediciones";
import { usePreferenciasUI } from "../hooks/usePreferenciasUI";
import { usePreferenciasVisuales } from "../hooks/usePreferenciasVisuales";
import { useCambiosPendientes } from "../hooks/useCambiosPendientes";
import { usarContextoConfiguracion } from "./ContextoConfiguracion";

import { obtenerDisenoTarjeta, calcularValoresLadoTarjeta } from "../utilidades/calculosMediciones";

const ContextoAlimentadores = createContext(null);

/**
 * Provider de alimentadores que usa Supabase.
 * Requiere estar envuelto por ProveedorConfiguracion.
 */
export const ProveedorAlimentadoresSupabase = ({ children }) => {
  // Obtener workspace activo del contexto superior
  const {
    configuracionSeleccionada,
    configuracionSeleccionadaId,
    cargando: cargandoConfig,
  } = usarContextoConfiguracion();

  // Determinar si el usuario es creador del workspace
  // IMPORTANTE: No asumir true por defecto, usar null hasta que se cargue
  // Esto evita que se apliquen valores incorrectos durante la carga inicial
  const esCreador = configuracionSeleccionada?.esCreador ?? null;

  // Hook de puestos conectado a Supabase
  const puestosHook = usePuestosSupabase(configuracionSeleccionadaId);

  // Hook de mediciones (sin cambios, funciona igual)
  const medicionesHook = useMediciones();

  // Hook de preferencias UI (gaps horizontales y verticales) - localStorage
  const preferenciasHook = usePreferenciasUI();

  // Hook de preferencias visuales persistentes en BD (para invitados)
  const preferenciasVisualesHook = usePreferenciasVisuales(
    configuracionSeleccionadaId,
    esCreador,
    puestosHook.puestos,
    puestosHook.cargarPuestos
  );

  // Hook de cambios pendientes (draft/publish pattern)
  const cambiosPendientesHook = useCambiosPendientes();

  const { registrosEnVivo } = medicionesHook;
  const { puestoSeleccionado, puestos, cargando: cargandoPuestos } = puestosHook;
  const { gapsPorTarjeta, gapsPorFila, escalasPorPuesto, escalasPorTarjeta } = preferenciasHook;
  const { guardarSnapshot, detectarCambios, sincronizarConBD, sincronizando, errorSincronizacion } = cambiosPendientesHook;

  const [lecturasTarjetas, setLecturasTarjetas] = useState({});
  const [hayCambiosPendientes, setHayCambiosPendientes] = useState(false);
  // Flag para saber si ya guardamos el snapshot inicial de BD
  const [snapshotGuardado, setSnapshotGuardado] = useState(false);

  // Estado de carga combinado
  // - Siempre esperar a que cargue la configuraci√≥n (para determinar esCreador)
  // - Siempre esperar a que carguen los puestos
  // - Para invitados (esCreador === false), tambi√©n esperamos a que carguen las preferencias personales
  // - Cuando esCreador es null, tambi√©n esperamos las preferencias para evitar mostrar datos incorrectos
  const cargando = cargandoConfig || cargandoPuestos || (esCreador !== true && preferenciasVisualesHook.cargando);

  /**
   * Para invitados: aplica las preferencias personales sobre los puestos base.
   * Esto crea una vista "merged" que el invitado ve como su configuraci√≥n inicial.
   */
  const obtenerPuestosConPreferencias = useCallback(() => {
    if (esCreador || !preferenciasVisualesHook.preferenciasUsuario) {
      return puestos;
    }

    // Aplicar preferencias personales sobre los puestos base
    return puestos.map(puesto => {
      const prefsPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puesto.id);

      // Aplicar preferencias del puesto si existen
      const puestoMerged = {
        ...puesto,
        color: prefsPuesto?.color || puesto.color,
        bgColor: prefsPuesto?.bg_color || puesto.bgColor || puesto.bg_color,
        escala: prefsPuesto?.escala ?? puesto.escala,
        gapsVerticales: {
          ...(puesto.gapsVerticales || { "0": 40 }),
          ...(prefsPuesto?.gapsVerticales || {}),
        },
        // Aplicar preferencias a los alimentadores
        alimentadores: (puesto.alimentadores || []).map(alim => {
          const prefsAlim = preferenciasVisualesHook.obtenerConfigAlimentador(alim.id, puesto.id);
          return {
            ...alim,
            color: prefsAlim?.color || alim.color,
            escala: prefsAlim?.escala ?? alim.escala,
            gapHorizontal: prefsAlim?.gapHorizontal ?? alim.gapHorizontal ?? 10,
          };
        }),
      };

      return puestoMerged;
    });
  }, [esCreador, puestos, preferenciasVisualesHook]);

  // Guardar snapshot SOLO cuando terminamos de cargar de BD (una sola vez)
  // Para invitados: esperamos tambi√©n a que carguen las preferencias personales
  // y usamos los datos merged (BASE + preferencias)
  useEffect(() => {
    // Solo guardar snapshot cuando:
    // 1. Hay puestos cargados
    // 2. Ya no estamos cargando (termin√≥ la carga de BD)
    // 3. esCreador ya tiene un valor definitivo (true o false, no null)
    // 4. Para invitados: tambi√©n termin√≥ de cargar preferencias
    // 5. No hemos guardado el snapshot a√∫n para esta sesi√≥n de carga
    if (esCreador === null) return; // Esperar a que se determine el rol

    const prefsListas = esCreador || !preferenciasVisualesHook.cargando;

    if (puestos.length > 0 && !cargandoPuestos && prefsListas && !snapshotGuardado) {
      // Para invitados, guardar snapshot con datos merged
      const puestosParaSnapshot = esCreador ? puestos : obtenerPuestosConPreferencias();
      guardarSnapshot(puestosParaSnapshot);
      setSnapshotGuardado(true);
    }
  }, [puestos, cargandoPuestos, snapshotGuardado, guardarSnapshot, esCreador, preferenciasVisualesHook.cargando, obtenerPuestosConPreferencias]);

  // Resetear flag cuando cambia el workspace (para recargar snapshot)
  useEffect(() => {
    setSnapshotGuardado(false);
  }, [configuracionSeleccionadaId]);

  // Detectar cambios cada vez que cambian los datos locales
  // Funciona igual para creadores e invitados:
  // - Creador: cambios van a BASE
  // - Invitado: cambios visuales van a preferencias_usuario
  useEffect(() => {
    // Esperar a que esCreador tenga un valor definitivo
    if (esCreador === null) return;

    if (puestos.length > 0) {
      // Para invitados, usamos datos merged (preferencias + base) para comparar con el snapshot
      // Esto evita falsos positivos cuando el snapshot tiene colores de preferencias personales
      const puestosParaDeteccion = esCreador ? puestos : obtenerPuestosConPreferencias();

      // Para gaps verticales por puesto, construimos un objeto
      // Extraemos de gapsPorFila solo los gaps de cada puesto (formato clave: "puestoId:rowIndex")
      const gapsPorFilaPorPuesto = {};
      puestosParaDeteccion.forEach((p) => {
        const gapsDelPuesto = {};
        // Buscar en gapsPorFila todas las claves que empiezan con este puestoId
        Object.entries(gapsPorFila).forEach(([clave, valor]) => {
          if (clave.startsWith(`${p.id}:`)) {
            // Extraer el rowIndex de la clave "puestoId:rowIndex"
            const rowIndex = clave.split(':')[1];
            gapsDelPuesto[rowIndex] = valor;
          }
        });
        // Combinar: BD primero, luego localStorage (localStorage tiene prioridad)
        gapsPorFilaPorPuesto[p.id] = { ...p.gapsVerticales, ...gapsDelPuesto };
      });

      const { hayCambios } = detectarCambios(puestosParaDeteccion, gapsPorTarjeta, gapsPorFilaPorPuesto, escalasPorPuesto, escalasPorTarjeta);
      setHayCambiosPendientes(hayCambios);
    }
  }, [puestos, gapsPorTarjeta, gapsPorFila, escalasPorPuesto, escalasPorTarjeta, detectarCambios, esCreador, obtenerPuestosConPreferencias]);

  /**
   * Sincroniza cambios visuales de un invitado a preferencias_usuario.
   * Solo guarda: colores, gaps, escalas (NO estructura de puestos/alimentadores).
   */
  const sincronizarCambiosInvitado = useCallback(async (cambios) => {
    try {
      // Guardar cambios de puestos en preferencias
      for (const { id, campos } of cambios.puestos) {
        const prefsToSave = {};
        if (campos.color !== undefined) prefsToSave.color = campos.color;
        if (campos.bgColor !== undefined) prefsToSave.bg_color = campos.bgColor;
        if (campos.gapsVerticales !== undefined) prefsToSave.gapsVerticales = campos.gapsVerticales;
        if (campos.escala !== undefined) prefsToSave.escala = campos.escala;

        if (Object.keys(prefsToSave).length > 0) {
          await preferenciasVisualesHook.guardarPreferenciasPuesto(id, prefsToSave);
        }
      }

      // Guardar cambios de alimentadores en preferencias
      for (const { id, campos } of cambios.alimentadores) {
        const prefsToSave = {};
        if (campos.color !== undefined) prefsToSave.color = campos.color;
        if (campos.gapHorizontal !== undefined) prefsToSave.gapHorizontal = campos.gapHorizontal;
        if (campos.escala !== undefined) prefsToSave.escala = campos.escala;

        if (Object.keys(prefsToSave).length > 0) {
          await preferenciasVisualesHook.guardarPreferenciasAlimentador(id, prefsToSave);
        }
      }

      // Nota: El orden de alimentadores (reordenarAlimentadores) NO se guarda en preferencias
      // porque afecta la estructura visual para todos. Si se quiere permitir orden personalizado,
      // habr√≠a que agregar soporte para eso en el futuro.

      return true;
    } catch (error) {
      console.error("Error sincronizando preferencias de invitado:", error);
      throw error;
    }
  }, [preferenciasVisualesHook]);

  // Funci√≥n para sincronizar cambios con BD
  // Para creadores: guarda en BASE
  // Para invitados: guarda cambios visuales en preferencias_usuario
  const sincronizarCambios = useCallback(async () => {
    if (!hayCambiosPendientes) return;

    // Para invitados, usamos datos merged para detectar cambios correctamente
    const puestosParaSync = esCreador ? puestos : obtenerPuestosConPreferencias();

    // Construir gapsPorFilaPorPuesto extrayendo solo los gaps de cada puesto
    const gapsPorFilaPorPuesto = {};
    puestosParaSync.forEach((p) => {
      const gapsDelPuesto = {};
      Object.entries(gapsPorFila).forEach(([clave, valor]) => {
        if (clave.startsWith(`${p.id}:`)) {
          const rowIndex = clave.split(':')[1];
          gapsDelPuesto[rowIndex] = valor;
        }
      });
      gapsPorFilaPorPuesto[p.id] = { ...p.gapsVerticales, ...gapsDelPuesto };
    });

    const { cambios } = detectarCambios(puestosParaSync, gapsPorTarjeta, gapsPorFilaPorPuesto, escalasPorPuesto, escalasPorTarjeta);

    if (esCreador) {
      // CREADOR: Guardar todo en BASE
      await sincronizarConBD(
        cambios,
        // onSuccess
        async () => {
          // Limpiar gaps del localStorage ya que ahora est√°n en la BD
          preferenciasHook.resetearTodosLosGaps();
          preferenciasHook.resetearTodosLosRowGaps();
          preferenciasHook.resetearTodasLasEscalasPuestos();
          preferenciasHook.resetearTodasLasEscalasTarjetas();
          // Resetear flag para que se guarde nuevo snapshot al recargar
          setSnapshotGuardado(false);
          // Recargar datos para actualizar snapshot
          await puestosHook.cargarPuestos();
        },
        (error) => {
          console.error("Error al sincronizar:", error);
        }
      );
    } else {
      // INVITADO: Guardar cambios visuales en preferencias_usuario
      try {
        await sincronizarCambiosInvitado(cambios);

        // Limpiar localStorage
        preferenciasHook.resetearTodosLosGaps();
        preferenciasHook.resetearTodosLosRowGaps();
        preferenciasHook.resetearTodasLasEscalasPuestos();
        preferenciasHook.resetearTodasLasEscalasTarjetas();

        // Recargar preferencias del usuario para actualizar snapshot
        await preferenciasVisualesHook.cargarPreferencias();
        // Resetear flag para que se guarde nuevo snapshot
        setSnapshotGuardado(false);
        // Recargar puestos tambi√©n (para que el snapshot use datos frescos)
        await puestosHook.cargarPuestos();
      } catch (error) {
        console.error("Error al sincronizar preferencias:", error);
      }
    }
  }, [hayCambiosPendientes, puestos, gapsPorTarjeta, gapsPorFila, escalasPorPuesto, escalasPorTarjeta, detectarCambios, sincronizarConBD, puestosHook, preferenciasHook, esCreador, sincronizarCambiosInvitado, preferenciasVisualesHook, obtenerPuestosConPreferencias]);

  // Funci√≥n para descartar cambios
  // Limpia localStorage y recarga datos de BD para restaurar orden original
  const descartarCambios = useCallback(async () => {
    // Limpiar localStorage de gaps
    preferenciasHook.resetearTodosLosGaps();
    preferenciasHook.resetearTodosLosRowGaps();
    // Limpiar localStorage de escalas (por puesto y por tarjeta)
    preferenciasHook.resetearTodasLasEscalasPuestos();
    preferenciasHook.resetearTodasLasEscalasTarjetas();
    // Resetear flag y recargar datos de BD para restaurar orden original
    setSnapshotGuardado(false);

    // Para invitados, tambi√©n recargar preferencias personales
    if (!esCreador) {
      await preferenciasVisualesHook.cargarPreferencias();
    }

    await puestosHook.cargarPuestos();
  }, [preferenciasHook, puestosHook, esCreador, preferenciasVisualesHook]);

  // Funci√≥n para limpiar todo el localStorage de preferencias UI (al salir)
  const limpiarPreferenciasUI = useCallback(() => {
    preferenciasHook.resetearTodosLosGaps();
    preferenciasHook.resetearTodosLosRowGaps();
  }, [preferenciasHook]);

  // ===== NOTA SOBRE GUARDADO =====
  // Tanto creadores como invitados usan localStorage para cambios locales.
  // Al hacer clic en "Guardar":
  // - Creador: sincroniza cambios a BASE (tabla puestos/alimentadores)
  // - Invitado: sincroniza cambios visuales a preferencias_usuario
  //
  // Las funciones de establecerGap, establecerRowGap, etc. del preferenciasHook
  // se usan directamente sin wrappers ya que ambos roles usan localStorage.

  /**
   * Obtiene el color del bot√≥n de un puesto.
   * - Creador: devuelve el color de la BD
   * - Invitado: devuelve preferencia personal > BD
   */
  const obtenerColorPuesto = useCallback((puestoId) => {
    const puesto = puestosHook.puestos.find(p => p.id === puestoId);
    if (!puesto) return null;

    // Para invitados, verificar si tienen preferencia personal
    if (!esCreador) {
      const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
      if (configPuesto?.color) {
        return configPuesto.color;
      }
    }

    return puesto.color;
  }, [esCreador, puestosHook.puestos, preferenciasVisualesHook]);

  /**
   * Obtiene el color de fondo de un puesto.
   * - Creador: devuelve el color de la BD
   * - Invitado: devuelve preferencia personal > BD
   */
  const obtenerBgColorPuesto = useCallback((puestoId) => {
    const puesto = puestosHook.puestos.find(p => p.id === puestoId);
    if (!puesto) return null;

    // Para invitados, verificar si tienen preferencia personal
    if (!esCreador) {
      const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
      if (configPuesto?.bg_color) {
        return configPuesto.bg_color;
      }
    }

    return puesto.bgColor || puesto.bg_color;
  }, [esCreador, puestosHook.puestos, preferenciasVisualesHook]);

  /**
   * Actualiza puestos seg√∫n el rol del usuario.
   * - Creador: guarda en BASE (tabla puestos) - puede editar nombres y colores
   * - Invitado: solo guarda colores en preferencias_usuario (no puede editar nombres)
   *
   * @param {Array} puestosEditados - Lista de puestos editados
   */
  const actualizarPuestosInteligente = useCallback(async (puestosEditados) => {
    if (esCreador) {
      // Creador: guardar todo en BASE
      await puestosHook.actualizarPuestos(puestosEditados);
    } else {
      // Invitado: solo guardar colores en preferencias_usuario
      // Los nombres NO se guardan (invitados no pueden cambiar nombres)
      // IMPORTANTE: Comparamos contra el color "merged" (preferencia actual > BD)
      // para detectar solo los cambios reales del usuario
      for (const puesto of puestosEditados) {
        const puestoBase = puestosHook.puestos.find(p => p.id === puesto.id);
        if (!puestoBase) continue;

        // Obtener el color actual considerando preferencias existentes
        const colorActual = obtenerColorPuesto(puesto.id) || puestoBase.color;
        const bgColorActual = obtenerBgColorPuesto(puesto.id) || puestoBase.bgColor || puestoBase.bg_color;

        // Detectar si cambiaron los colores respecto al estado merged
        const cambios = {};
        if (puesto.color !== colorActual) {
          cambios.color = puesto.color;
        }
        if ((puesto.bgColor || puesto.bg_color) !== bgColorActual) {
          cambios.bg_color = puesto.bgColor || puesto.bg_color;
        }

        // Si hay cambios de color, guardarlos en preferencias
        if (Object.keys(cambios).length > 0) {
          await preferenciasVisualesHook.guardarPreferenciasPuesto(puesto.id, cambios);
        }
      }
    }
  }, [esCreador, puestosHook, preferenciasVisualesHook, obtenerColorPuesto, obtenerBgColorPuesto]);

  // Recalcular lecturas de tarjetas cuando cambian los datos
  useEffect(() => {
    if (!puestoSeleccionado) {
      setLecturasTarjetas({});
      return;
    }

    setLecturasTarjetas(() => {
      const nuevo = {};

      puestoSeleccionado.alimentadores.forEach((alim) => {
        const regsDelAlim = registrosEnVivo[alim.id] || null;
        // Usar card_design (nuevo) o mapeoMediciones (legacy) para compatibilidad
        const cardDesignData = alim.card_design || alim.mapeoMediciones || {};
        const diseno = obtenerDisenoTarjeta(cardDesignData);

        const parteSuperior = calcularValoresLadoTarjeta(regsDelAlim, diseno.superior);
        const parteInferior = calcularValoresLadoTarjeta(regsDelAlim, diseno.inferior);

        nuevo[alim.id] = { parteSuperior, parteInferior };
      });

      return nuevo;
    });
  }, [puestoSeleccionado, registrosEnVivo]);

  // ===== FUNCIONES DE GAP COMBINADAS (localStorage + BD + preferencias usuario) =====
  // Prioridad para AMBOS ROLES: localStorage > preferencias_usuario > BD > default
  // localStorage tiene prioridad porque representa cambios "en progreso" antes de guardar

  /**
   * Obtiene el gap horizontal de un alimentador.
   * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > default
   * localStorage tiene prioridad porque representa cambios "en progreso" antes de guardar
   */
  const obtenerGapCombinado = useCallback((alimId) => {
    // 1. Primero mirar localStorage (cambios no guardados, aplica a ambos roles)
    const gapLocal = gapsPorTarjeta[alimId];
    if (gapLocal !== undefined) {
      return gapLocal;
    }

    // 2. Para invitados, mirar preferencias visuales persistentes (ya guardadas en BD)
    if (!esCreador) {
      const configAlim = preferenciasVisualesHook.obtenerConfigAlimentador(alimId, puestoSeleccionado?.id);
      if (configAlim?.gapHorizontal !== undefined) {
        return configAlim.gapHorizontal;
      }
    }

    // 3. Buscar en los datos de BD base
    if (puestoSeleccionado) {
      const alimentador = puestoSeleccionado.alimentadores.find(a => a.id === alimId);
      if (alimentador && alimentador.gapHorizontal !== undefined) {
        return alimentador.gapHorizontal;
      }
    }

    // 4. Default
    return preferenciasHook.GAP_DEFAULT;
  }, [esCreador, gapsPorTarjeta, puestoSeleccionado, preferenciasHook.GAP_DEFAULT, preferenciasVisualesHook]);

  /**
   * Obtiene el gap vertical de una fila en un puesto espec√≠fico.
   * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > default
   * localStorage tiene prioridad porque representa cambios "en progreso" antes de guardar
   * @param {string} puestoId - ID del puesto
   * @param {number} rowIndex - √çndice de la fila
   */
  const obtenerRowGapCombinado = useCallback((puestoId, rowIndex) => {
    // 1. Primero mirar localStorage (cambios no guardados, aplica a ambos roles)
    const claveLocal = `${puestoId}:${rowIndex}`;
    const gapLocal = gapsPorFila[claveLocal];
    if (gapLocal !== undefined) {
      return gapLocal;
    }

    // 2. Para invitados, mirar preferencias visuales persistentes (ya guardadas en BD)
    if (!esCreador) {
      const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
      if (configPuesto?.gapsVerticales?.[rowIndex] !== undefined) {
        return configPuesto.gapsVerticales[rowIndex];
      }
    }

    // 3. Buscar en los gaps verticales del puesto espec√≠fico (BD base)
    const puesto = puestos.find(p => p.id === puestoId);
    if (puesto && puesto.gapsVerticales) {
      const gapBD = puesto.gapsVerticales[rowIndex];
      if (gapBD !== undefined) {
        return gapBD;
      }
    }

    // 4. Default
    return preferenciasHook.ROW_GAP_DEFAULT;
  }, [esCreador, gapsPorFila, puestos, preferenciasHook.ROW_GAP_DEFAULT, preferenciasVisualesHook]);

  // ===== FUNCIONES DE ESCALA COMBINADAS (localStorage + BD + preferencias usuario) =====
  // Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > null

  /**
   * Obtiene la escala de un puesto.
   * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > null
   * localStorage tiene prioridad porque representa cambios "en progreso" antes de guardar
   * @param {string} puestoId - ID del puesto
   * @returns {number|null} Escala del puesto o null si no est√° definida
   */
  const obtenerEscalaPuestoCombinada = useCallback((puestoId) => {
    if (!puestoId) return null;

    // 1. Primero mirar localStorage (cambios no guardados, aplica a ambos roles)
    const escalaLocal = escalasPorPuesto[puestoId];
    if (escalaLocal !== undefined) {
      return escalaLocal;
    }

    // 2. Para invitados, mirar preferencias visuales persistentes (ya guardadas en BD)
    if (!esCreador) {
      const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
      if (configPuesto?.escala !== undefined && configPuesto?.escala !== null) {
        return configPuesto.escala;
      }
    }

    // 3. Buscar en los datos de BD base
    const puesto = puestos.find(p => String(p.id) === String(puestoId));
    if (puesto && puesto.escala !== undefined && puesto.escala !== null) {
      return puesto.escala;
    }

    // 4. No hay escala definida (usar jerarqu√≠a global)
    return null;
  }, [esCreador, escalasPorPuesto, puestos, preferenciasVisualesHook]);

  /**
   * Obtiene la escala de un alimentador (tarjeta individual).
   * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > null
   * localStorage tiene prioridad porque representa cambios "en progreso" antes de guardar
   * @param {string} alimId - ID del alimentador
   * @returns {number|null} Escala del alimentador o null si no est√° definida
   */
  const obtenerEscalaTarjetaCombinada = useCallback((alimId) => {
    if (!alimId) return null;

    // 1. Primero mirar localStorage (cambios no guardados, aplica a ambos roles)
    const escalaLocal = escalasPorTarjeta[alimId];
    // Si es null expl√≠cito, significa "ignorar escala individual" (usar puesto/global)
    if (escalaLocal === null) {
      return null;
    }
    // Si tiene un valor num√©rico, usarlo
    if (escalaLocal !== undefined) {
      return escalaLocal;
    }

    // 2. Para invitados, mirar preferencias visuales persistentes (ya guardadas en BD)
    if (!esCreador) {
      const configAlim = preferenciasVisualesHook.obtenerConfigAlimentador(alimId, puestoSeleccionado?.id);
      if (configAlim?.escala !== undefined && configAlim?.escala !== null) {
        return configAlim.escala;
      }
    }

    // 3. Buscar en los datos de BD base (en el puesto seleccionado)
    if (puestoSeleccionado) {
      const alimentador = puestoSeleccionado.alimentadores.find(a => String(a.id) === String(alimId));
      if (alimentador && alimentador.escala !== undefined && alimentador.escala !== null) {
        return alimentador.escala;
      }
    }

    // 4. No hay escala definida (usar jerarqu√≠a puesto/global)
    return null;
  }, [esCreador, escalasPorTarjeta, puestoSeleccionado, preferenciasVisualesHook]);

  /**
   * Obtiene la escala efectiva de una tarjeta considerando toda la jerarqu√≠a:
   * Individual > Por puesto > Global > Default
   * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > default
   * @param {string} alimId - ID del alimentador
   * @param {string} puestoId - ID del puesto
   * @returns {number} Escala efectiva a aplicar
   */
  const obtenerEscalaEfectivaCombinada = useCallback((alimId, puestoId) => {
    // Usar las funciones combinadas que ya consideran localStorage > preferencias > BD
    // 1. Escala individual (m√°xima prioridad)
    const escalaIndividual = obtenerEscalaTarjetaCombinada(alimId);
    if (escalaIndividual !== null) return escalaIndividual;

    // 2. Escala por puesto
    const escalaPuesto = obtenerEscalaPuestoCombinada(puestoId);
    if (escalaPuesto !== null) return escalaPuesto;

    // 3. Escala global (solo localStorage, no se guarda en BD)
    if (preferenciasHook.escalaGlobal !== preferenciasHook.ESCALA_DEFAULT) {
      return preferenciasHook.escalaGlobal;
    }

    // 4. Default
    return preferenciasHook.ESCALA_DEFAULT;
  }, [obtenerEscalaTarjetaCombinada, obtenerEscalaPuestoCombinada, preferenciasHook.escalaGlobal, preferenciasHook.ESCALA_DEFAULT]);

  // Objeto de contexto
  const valorContexto = useMemo(
    () => ({
      // Estados de carga
      cargando,
      error: puestosHook.error,

      // Workspace actual
      configuracionSeleccionada,
      configuracionSeleccionadaId,

      // Datos de puestos
      puestos: puestosHook.puestos,
      puestoSeleccionado: puestosHook.puestoSeleccionado,
      puestoSeleccionadoId: puestosHook.puestoSeleccionadoId,

      agregarPuesto: puestosHook.agregarPuesto,
      eliminarPuesto: puestosHook.eliminarPuesto,
      seleccionarPuesto: puestosHook.seleccionarPuesto,
      // actualizarPuestos: usa la versi√≥n inteligente que considera el rol
      actualizarPuestos: actualizarPuestosInteligente,
      setPuestos: puestosHook.setPuestos,
      cargarPuestos: puestosHook.cargarPuestos,

      // Getters de colores (consideran preferencias de invitados)
      obtenerColorPuesto,
      obtenerBgColorPuesto,

      // Alimentadores
      agregarAlimentador: puestosHook.agregarAlimentador,
      actualizarAlimentador: puestosHook.actualizarAlimentador,
      eliminarAlimentador: puestosHook.eliminarAlimentador,
      reordenarAlimentadores: puestosHook.reordenarAlimentadores,

      // Mediciones y lecturas
      lecturasTarjetas,
      registrosEnVivo: medicionesHook.registrosEnVivo,

      detenerMedicion: medicionesHook.detenerMedicion,
      obtenerRegistros: medicionesHook.obtenerRegistros,
      estaMidiendo: medicionesHook.estaMidiendo,
      obtenerTimestampInicio: medicionesHook.obtenerTimestampInicio,
      obtenerContadorLecturas: medicionesHook.obtenerContadorLecturas,
      actualizarRegistros: medicionesHook.actualizarRegistros,

      // Preferencias UI (gaps)
      // Las funciones obtener* combinan localStorage/preferencias + BD
      // Las funciones establecer* guardan en localStorage (se sincronizan con "Guardar")
      gapsPorTarjeta: preferenciasHook.gapsPorTarjeta,
      gapsPorFila: preferenciasHook.gapsPorFila,
      obtenerGap: obtenerGapCombinado,
      establecerGap: preferenciasHook.establecerGap,
      obtenerRowGap: obtenerRowGapCombinado,
      establecerRowGap: preferenciasHook.establecerRowGap,
      GAP_MIN: preferenciasHook.GAP_MIN,
      GAP_MAX: preferenciasHook.GAP_MAX,
      GAP_DEFAULT: preferenciasHook.GAP_DEFAULT,
      ROW_GAP_MIN: preferenciasHook.ROW_GAP_MIN,
      ROW_GAP_MAX: preferenciasHook.ROW_GAP_MAX,
      ROW_GAP_DEFAULT: preferenciasHook.ROW_GAP_DEFAULT,

      // Escala de tarjetas
      // Las funciones obtener* combinan localStorage/preferencias + BD
      // Las funciones establecer* guardan en localStorage (se sincronizan con "Guardar")
      escalaGlobal: preferenciasHook.escalaGlobal,
      establecerEscalaGlobal: preferenciasHook.establecerEscalaGlobal,
      resetearEscalaGlobal: preferenciasHook.resetearEscalaGlobal,
      escalasPorPuesto: preferenciasHook.escalasPorPuesto,
      obtenerEscalaPuesto: obtenerEscalaPuestoCombinada,
      establecerEscalaPuesto: preferenciasHook.establecerEscalaPuesto,
      resetearEscalaPuesto: preferenciasHook.resetearEscalaPuesto,
      escalasPorTarjeta: preferenciasHook.escalasPorTarjeta,
      obtenerEscalaTarjeta: obtenerEscalaTarjetaCombinada,
      establecerEscalaTarjeta: preferenciasHook.establecerEscalaTarjeta,
      resetearEscalaTarjeta: preferenciasHook.resetearEscalaTarjeta,
      obtenerEscalaEfectiva: obtenerEscalaEfectivaCombinada,
      resetearTodasLasEscalas: preferenciasHook.resetearTodasLasEscalas,
      ESCALA_MIN: preferenciasHook.ESCALA_MIN,
      ESCALA_MAX: preferenciasHook.ESCALA_MAX,
      ESCALA_DEFAULT: preferenciasHook.ESCALA_DEFAULT,

      // Cambios pendientes (draft/publish)
      hayCambiosPendientes,
      sincronizando,
      errorSincronizacion,
      sincronizarCambios,
      descartarCambios,

      // Limpieza al salir
      limpiarPreferenciasUI,

      // Info del rol del usuario en el workspace
      esCreador,

      // Preferencias visuales persistentes (para invitados)
      // Expone funciones para guardar preferencias personalizadas
      preferenciasVisuales: {
        cargando: preferenciasVisualesHook.cargando,
        guardando: preferenciasVisualesHook.guardando,
        tienePreferenciasPersonales: preferenciasVisualesHook.tienePreferenciasPersonales,
        guardarPreferencia: preferenciasVisualesHook.guardarPreferencia,
        guardarPreferenciasPuesto: preferenciasVisualesHook.guardarPreferenciasPuesto,
        guardarPreferenciasAlimentador: preferenciasVisualesHook.guardarPreferenciasAlimentador,
        resetearPreferencias: preferenciasVisualesHook.resetearPreferencias,
        obtenerConfigPuesto: preferenciasVisualesHook.obtenerConfigPuesto,
        obtenerConfigAlimentador: preferenciasVisualesHook.obtenerConfigAlimentador,
      },
    }),
    [puestosHook, medicionesHook, preferenciasHook, preferenciasVisualesHook, lecturasTarjetas, configuracionSeleccionada, cargando, hayCambiosPendientes, sincronizando, errorSincronizacion, sincronizarCambios, descartarCambios, obtenerGapCombinado, obtenerRowGapCombinado, obtenerEscalaPuestoCombinada, obtenerEscalaTarjetaCombinada, obtenerEscalaEfectivaCombinada, limpiarPreferenciasUI, esCreador, actualizarPuestosInteligente, obtenerColorPuesto, obtenerBgColorPuesto]
  );

  return (
    <ContextoAlimentadores.Provider value={valorContexto}>
      {children}
    </ContextoAlimentadores.Provider>
  );
};

export const usarContextoAlimentadores = () => {
  const contexto = useContext(ContextoAlimentadores);

  if (!contexto) {
    throw new Error(
      "usarContextoAlimentadores debe usarse dentro de ProveedorAlimentadoresSupabase"
    );
  }

  return contexto;
};

// ===== ./src/paginas/PaginaAlimentadores/contexto/ContextoConfiguracion.jsx =====

// src/paginas/PaginaAlimentadores/contexto/ContextoConfiguracion.jsx
// Contexto global para manejar el workspace activo del usuario y estilos globales

import React, { createContext, useContext, useMemo } from "react";
import { useConfiguracion } from "../hooks/useConfiguracion";
import useEstilosGlobales from "../hooks/useEstilosGlobales";

const ContextoConfiguracion = createContext(null);

/**
 * Provider que maneja los workspaces del usuario y los estilos globales de tarjetas.
 * Debe envolver a ProveedorAlimentadores para que este tenga acceso
 * al workspace seleccionado.
 */
export const ProveedorConfiguracion = ({ children }) => {
  const configuracionHook = useConfiguracion();
  const estilosGlobalesHook = useEstilosGlobales();

  // Combinar ambos hooks en un solo valor de contexto
  const valorContexto = useMemo(() => ({
    ...configuracionHook,
    // Estilos globales de tarjetas
    estilosGlobales: estilosGlobalesHook.estilos,
    guardarEstilosGlobales: estilosGlobalesHook.aplicarTodosEstilos,
    obtenerEstilosCSS: estilosGlobalesHook.obtenerEstilosCSS,
  }), [configuracionHook, estilosGlobalesHook]);

  return (
    <ContextoConfiguracion.Provider value={valorContexto}>
      {children}
    </ContextoConfiguracion.Provider>
  );
};

/**
 * Hook para acceder al contexto de workspace
 */
export const usarContextoConfiguracion = () => {
  const contexto = useContext(ContextoConfiguracion);

  if (!contexto) {
    throw new Error(
      "usarContextoConfiguracion debe usarse dentro de ProveedorConfiguracion"
    );
  }

  return contexto;
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/useArrastrarSoltar.js =====

// src/paginas/PaginaAlimentadores/hooks/usarArrastrarSoltar.js

import { useState } from "react"; // hook de React para manejar estado local

/**
 * Hook personalizado para manejar drag & drop (arrastrar y soltar).
 * Simplifica la l√≥gica de reordenamiento de alimentadores.
 *
 * @returns {Object} Estado y funciones para drag & drop.
 */
export const useArrastrarSoltar = () => {
	// ID del elemento que se est√° arrastrando actualmente (o null si ninguno)
	const [elementoArrastrandoId, setElementoArrastrandoId] = useState(null);

	/**
	 * Maneja el inicio del arrastre.
	 *
	 * @param {number} id - ID del elemento arrastrado.
	 */
	const alIniciarArrastre = (id) => {
		setElementoArrastrandoId(id);
	};

	/**
	 * Maneja el fin del arrastre.
	 * Limpia el estado interno.
	 */
	const alTerminarArrastre = () => {
		setElementoArrastrandoId(null);
	};

	/**
	 * Permite que un elemento sea un destino v√°lido de drop.
	 *
	 * @param {DragEvent} evento - Evento dragover.
	 */
	const alPasarPorEncima = (evento) => {
		evento.preventDefault(); // sin esto, el navegador no permite soltar
	};

	/**
	 * Reordena una lista moviendo un elemento a la posici√≥n de otro.
	 *
	 * @param {Array} lista - Lista original.
	 * @param {number} idOrigen - ID del elemento a mover.
	 * @param {number} idDestino - ID del elemento destino.
	 * @returns {Array} Nueva lista reordenada.
	 */
	const reordenarLista = (lista, idOrigen, idDestino) => {
		if (idOrigen === idDestino) return lista; // nada que hacer si son el mismo

		const nuevaLista = [...lista];
		const indiceOrigen = nuevaLista.findIndex((item) => item.id === idOrigen);
		const indiceDestino = nuevaLista.findIndex((item) => item.id === idDestino);

		if (indiceOrigen === -1 || indiceDestino === -1) return lista; // ids inv√°lidos

		// Remover elemento del origen
		const [elementoMovido] = nuevaLista.splice(indiceOrigen, 1);

		// Insertar en la posici√≥n destino
		nuevaLista.splice(indiceDestino, 0, elementoMovido);

		return nuevaLista;
	};

	/**
	 * Mueve un elemento al final de la lista.
	 *
	 * @param {Array} lista - Lista original.
	 * @param {number} idElemento - ID del elemento a mover.
	 * @returns {Array} Nueva lista con elemento al final.
	 */
	const moverAlFinal = (lista, idElemento) => {
		const nuevaLista = [...lista];
		const indice = nuevaLista.findIndex((item) => item.id === idElemento);

		if (indice === -1) return lista; // id no encontrado

		// Remover y agregar al final
		const [elementoMovido] = nuevaLista.splice(indice, 1);
		nuevaLista.push(elementoMovido);

		return nuevaLista;
	};

	return {
		// Estado
		elementoArrastrandoId,
		estaArrastrando: elementoArrastrandoId !== null,

		// Handlers de eventos
		alIniciarArrastre,
		alTerminarArrastre,
		alPasarPorEncima,

		// Funciones de utilidad
		reordenarLista,
		moverAlFinal,
	};
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (usarArrastrarSoltar.js)

 - Este hook concentra la l√≥gica de drag & drop usada para reordenar tarjetas
   de alimentadores en la grilla.

 - `elementoArrastrandoId` guarda el id de la tarjeta que estoy arrastrando; si
   es `null`, significa que no hay ning√∫n drag activo. La propiedad derivada
   `estaArrastrando` es simplemente un atajo (`id !== null`).

 - `alIniciarArrastre(id)` se llama en `onDragStart` de una tarjeta: marca qu√©
   tarjeta se est√° moviendo.

 - `alTerminarArrastre()` se llama en `onDragEnd` o despu√©s de soltar: limpia el
   estado y vuelve todo a "sin arrastre".

 - `alPasarPorEncima(evento)` se usa en `onDragOver` de los destinos; la llamada
   a `evento.preventDefault()` es lo que le dice al navegador "ac√° s√≠ se puede
   soltar", sin eso el drop no se dispara.

 - `reordenarLista(lista, idOrigen, idDestino)` recibe la lista actual de
   alimentadores y los ids origen/destino, calcula los √≠ndices y devuelve una
   nueva lista con el elemento movido a la posici√≥n correcta.

 - `moverAlFinal(lista, idElemento)` se usa para el √°rea de "solt√° ac√° para
   enviar al final": quita el elemento de su posici√≥n actual y lo agrega al
   final del array.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (usarArrastrarSoltar.js)

0) Visi√≥n general del hook

   Este hook encapsula toda la l√≥gica b√°sica de ‚Äúarrastrar y soltar‚Äù que se usa para reordenar tarjetas de 
	alimentadores.

   La idea es que los componentes de UI no tengan que:
     - recordar qu√© tarjeta se est√° arrastrando,
     - calcular a mano el nuevo orden,
     - ni saber c√≥mo funciona el drag & drop nativo del navegador.

   En cambio, solo usan:
     - estado: `elementoArrastrandoId` y `estaArrastrando`,
     - handlers: `alIniciarArrastre`, `alTerminarArrastre`, `alPasarPorEncima`,
     - utilidades: `reordenarLista` y `moverAlFinal`.


1) Estado: elementoArrastrandoId

   const [elementoArrastrandoId, setElementoArrastrandoId] = useState(null);

   - Guarda el id del elemento (tarjeta) que se est√° arrastrando en este momento.

   - Si vale `null`, significa que actualmente NO hay ning√∫n drag activo.

   - Es el ‚Äúmarcador‚Äù que nos permite saber:
       ‚Ä¢ qui√©n es el origen,
       ‚Ä¢ qu√© elemento hay que mover cuando se suelta sobre otro,
       ‚Ä¢ o si debemos mostrar estilos especiales cuando hay un arrastre activo.

   En el return se expone tambi√©n:

     estaArrastrando: elementoArrastrandoId !== null

   - Es un booleano derivado:
       ‚Ä¢ true  ‚Üí si hay algo en movimiento,
       ‚Ä¢ false ‚Üí si no.

   - Sirve para que la UI pueda cambiar estilos (por ejemplo, resaltar zonas de drop) sin tener que 
	  comparar directamente contra `null`.


2) alIniciarArrastre

   const alIniciarArrastre = (id) => {
     setElementoArrastrandoId(id);
   };

   - Se llama normalmente desde el evento `onDragStart` de una tarjeta.

   - Recibe el `id` del elemento que se empez√≥ a arrastrar.

   - Actualiza el estado `elementoArrastrandoId` con ese id.

   - En otras palabras:
       ‚Ä¢ marca ‚Äúesta tarjeta es la que estoy moviendo‚Äù.

   - A partir de ese momento, las funciones de reordenamiento pueden usar ese id como `idOrigen`.


3) alTerminarArrastre

   const alTerminarArrastre = () => {
     setElementoArrastrandoId(null);
   };

   - Se llama al finalizar el drag:
       ‚Ä¢ t√≠picamente en `onDragEnd`,
       ‚Ä¢ o despu√©s de procesar un drop exitoso.

   - Vuelve a poner `elementoArrastrandoId` en `null`.

   - Deja al hook en estado ‚Äúneutral‚Äù:
       ‚Ä¢ no hay arrastres activos,
       ‚Ä¢ `estaArrastrando` pasa a ser `false`.

   - Es importante para que no queden marcadas tarjetas como si siguieran en movimiento.


4) alPasarPorEncima

   const alPasarPorEncima = (evento) => {
     evento.preventDefault();
   };

   - Se usa en el evento `onDragOver` de los elementos que pueden recibir un drop 
	  (por ejemplo, otras tarjetas o una zona especial ‚Äúsoltar aqu√≠‚Äù).

   - La llamada a `evento.preventDefault()` es la clave:
       ‚Ä¢ por defecto, el navegador NO permite soltar en todos lados,
       ‚Ä¢ al hacer preventDefault() le indicamos que este elemento S√ç acepta drops.

   - Si no se llama a esto, el evento `onDrop` no se dispara en ese destino.


5) reordenarLista

   const reordenarLista = (lista, idOrigen, idDestino) => {
     if (idOrigen === idDestino) return lista;

     const nuevaLista = [...lista];
     const indiceOrigen = nuevaLista.findIndex((item) => item.id === idOrigen);
     const indiceDestino = nuevaLista.findIndex((item) => item.id === idDestino);

     if (indiceOrigen === -1 || indiceDestino === -1) return lista;

     const [elementoMovido] = nuevaLista.splice(indiceOrigen, 1);
     nuevaLista.splice(indiceDestino, 0, elementoMovido);

     return nuevaLista;
   };

   - Esta funci√≥n no toca el estado por s√≠ misma, solo calcula un NUEVO array.

   - Recibe:
       ‚Ä¢ `lista`: la lista actual de elementos (ej: alimentadores),
       ‚Ä¢ `idOrigen`: id del elemento que se est√° moviendo,
       ‚Ä¢ `idDestino`: id del elemento sobre el que se suelta.

   - Pasos que sigue:
       1) Si el origen y el destino son el mismo id, no hace nada y devuelve la lista tal cual (no tiene sentido moverlo sobre s√≠ mismo).
		 
       2) Clona la lista original con `[...]` para no mutarla directamente.

       3) Busca las posiciones (√≠ndices) de origen y destino en ese nuevo array.

       4) Si alguno de los ids no existe (`findIndex === -1`), devuelve la lista sin cambios.

       5) Usa `splice` para:
            ‚Ä¢ sacar el elemento de su posici√≥n original,
            ‚Ä¢ y volver a insertarlo en la posici√≥n del destino.

       6) Devuelve la `nuevaLista` con el elemento movido.

   - Esta funci√≥n suele usarse junto con el estado de `puestos`:
       ‚Ä¢ primero se calcula el nuevo orden de alimentadores con `reordenarLista`,
       ‚Ä¢ luego se guarda ese orden llamando a `reordenarAlimentadores` del hook `usarPuestos`.


6) moverAlFinal

   const moverAlFinal = (lista, idElemento) => {
     const nuevaLista = [...lista];
     const indice = nuevaLista.findIndex((item) => item.id === idElemento);

     if (indice === -1) return lista;

     const [elementoMovido] = nuevaLista.splice(indice, 1);
     nuevaLista.push(elementoMovido);

     return nuevaLista;
   };

   - Permite tomar un elemento de la lista y mandarlo al final.

   - Recibe:
       ‚Ä¢ `lista`: lista original,
       ‚Ä¢ `idElemento`: id del elemento que queremos mover.

   - Pasos:
       1) Clona la lista para no mutar la original.
       2) Busca el √≠ndice del elemento con ese id.
       3) Si no lo encuentra, devuelve la lista original.
       4) Usa `splice` para quitarlo de donde est√°,
       5) y luego `push` para agregarlo al final.

   - Esta funci√≥n est√° pensada para zonas como:
       ‚Ä¢ ‚Äúsolt√° ac√° para enviar al final‚Äù, donde no interesa la posici√≥n exacta del destino, solo que el elemento
       vaya al √∫ltimo lugar.


7) return del hook

   return {
     // Estado
     elementoArrastrandoId,
     estaArrastrando: elementoArrastrandoId !== null,

     // Handlers de eventos
     alIniciarArrastre,
     alTerminarArrastre,
     alPasarPorEncima,

     // Funciones de utilidad
     reordenarLista,
     moverAlFinal,
   };

   - Expone:
       ‚Ä¢ `elementoArrastrandoId`: id actual en movimiento (o null),
       ‚Ä¢ `estaArrastrando`: booleano de conveniencia para la UI.
		 
   - Y las funciones que la vista usa directamente:
       ‚Ä¢ `alIniciarArrastre`   ‚Üí se pega a `onDragStart`,
       ‚Ä¢ `alTerminarArrastre`  ‚Üí se pega a `onDragEnd` / luego de un drop,
       ‚Ä¢ `alPasarPorEncima`    ‚Üí se pega a `onDragOver`,
       ‚Ä¢ `reordenarLista` y `moverAlFinal` ‚Üí sirven para calcular el nuevo
         orden antes de actualizar el estado global de puestos/alimentadores.
---------------------------------------------------------------------------*/

// ===== ./src/paginas/PaginaAlimentadores/hooks/useCalculosHistorial.js =====

/**
 * Hook para c√°lculos y transformaciones de datos del historial
 * Centraliza la l√≥gica de c√°lculo de promedios y formateo de datos para gr√°ficos
 */

import { useMemo, useCallback } from "react";
import { aplicarFormula } from "../utilidades/calculosFormulas";
import { TITULOS_MEDICIONES } from "../constantes/titulosMediciones";
import { COLORES_GRADIENTE } from "../constantes/historialConfig";

/**
 * Obtiene el t√≠tulo de una zona desde la configuraci√≥n del dise√±o
 * @param {Object} cardDesign - Configuraci√≥n del dise√±o de la tarjeta
 * @param {string} zona - "superior" o "inferior"
 * @returns {string} - T√≠tulo de la zona
 */
export const obtenerTituloZona = (cardDesign, zona) => {
  const config = cardDesign?.[zona];
  if (!config) return zona === "superior" ? "Superior" : "Inferior";
  if (config.tituloCustom?.trim()) return config.tituloCustom;
  if (config.tituloId && TITULOS_MEDICIONES[config.tituloId]) {
    return TITULOS_MEDICIONES[config.tituloId];
  }
  return zona === "superior" ? "Superior" : "Inferior";
};

/**
 * Calcula el promedio de valores para una zona espec√≠fica
 * Aplica f√≥rmulas configuradas y excluye valores nulos o cero
 * @param {Object} lectura - Datos de la lectura
 * @param {Object} zonaConfig - Configuraci√≥n de la zona
 * @returns {number|null} - Promedio calculado o null si no hay datos v√°lidos
 */
export const calcularPromedioZona = (lectura, zonaConfig) => {
  if (!lectura?.valores || !Array.isArray(lectura.valores)) return null;
  if (!zonaConfig?.boxes) return null;

  const indiceInicial = lectura.indiceInicial ?? lectura.indice_inicial ?? 0;
  const valoresCalculados = [];

  zonaConfig.boxes.forEach((box) => {
    if (!box.enabled) return;
    const registro = box.registro ?? box.indice;
    if (registro === null || registro === undefined) return;
    const indiceEnArray = registro - indiceInicial;
    if (indiceEnArray < 0 || indiceEnArray >= lectura.valores.length) return;
    const valorCrudo = lectura.valores[indiceEnArray];
    if (valorCrudo === null || valorCrudo === undefined) return;
    const valorCalculado = aplicarFormula(box.formula || "x", valorCrudo);
    if (valorCalculado !== null && !Number.isNaN(valorCalculado) && valorCalculado !== 0) {
      valoresCalculados.push(valorCalculado);
    }
  });

  if (valoresCalculados.length === 0) return null;
  const suma = valoresCalculados.reduce((a, b) => a + b, 0);
  return suma / valoresCalculados.length;
};

/**
 * Interpola color de verde a rojo basado en porcentaje (0-1)
 * 0 = verde, 0.5 = amarillo, 1 = rojo
 * @param {number} porcentaje - Valor entre 0 y 1
 * @returns {string} - Color en formato rgb()
 */
export const interpolarColorVerdeRojo = (porcentaje) => {
  const p = Math.max(0, Math.min(1, porcentaje));
  const { verde, amarillo, rojo } = COLORES_GRADIENTE;

  let r, g, b;

  if (p <= 0.5) {
    const t = p * 2;
    r = Math.round(verde.r + (amarillo.r - verde.r) * t);
    g = Math.round(verde.g + (amarillo.g - verde.g) * t);
    b = Math.round(verde.b + (amarillo.b - verde.b) * t);
  } else {
    const t = (p - 0.5) * 2;
    r = Math.round(amarillo.r + (rojo.r - amarillo.r) * t);
    g = Math.round(amarillo.g + (rojo.g - amarillo.g) * t);
    b = Math.round(amarillo.b + (rojo.b - amarillo.b) * t);
  }

  return `rgb(${r}, ${g}, ${b})`;
};

/**
 * Hook que proporciona funciones de c√°lculo y datos derivados para el historial
 * @param {Object} params - Par√°metros del hook
 * @param {Object} params.cardDesign - Configuraci√≥n del dise√±o de la tarjeta
 * @param {string} params.zonaSeleccionada - Zona actualmente seleccionada
 * @param {Array} params.datosGrafico - Datos del gr√°fico (array de {x, y})
 * @param {number} params.intervaloFiltro - Intervalo de filtrado en minutos (0 = sin filtro)
 * @returns {Object} - Funciones y datos calculados
 */
export const useCalculosHistorial = ({
  cardDesign,
  zonaSeleccionada,
  datosGrafico,
  intervaloFiltro = 0,
}) => {
  // T√≠tulos de zonas
  const tituloSuperior = useMemo(
    () => obtenerTituloZona(cardDesign, "superior"),
    [cardDesign]
  );

  const tituloInferior = useMemo(
    () => obtenerTituloZona(cardDesign, "inferior"),
    [cardDesign]
  );

  const tituloZonaActual = zonaSeleccionada === "superior" ? tituloSuperior : tituloInferior;

  // Verificar si una zona est√° disponible (tiene boxes habilitados)
  const zonaDisponible = useCallback((zona) => {
    const config = cardDesign?.[zona];
    return config?.boxes?.some((b) => b.enabled);
  }, [cardDesign]);

  // Datos filtrados por intervalo
  const datosFiltrados = useMemo(() => {
    if (intervaloFiltro === 0 || datosGrafico.length === 0) {
      return datosGrafico;
    }

    const intervaloMs = intervaloFiltro * 60 * 1000;
    let ultimoTimestamp = 0;

    return datosGrafico.filter((punto) => {
      const timestamp = new Date(punto.x).getTime();
      if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs) {
        ultimoTimestamp = timestamp;
        return true;
      }
      return false;
    });
  }, [datosGrafico, intervaloFiltro]);

  // Colores para gr√°fico de barras (verde a rojo con normalizaci√≥n min-max)
  const coloresBarras = useMemo(() => {
    if (datosFiltrados.length === 0) return [];
    const valores = datosFiltrados.map((d) => d.y);
    const minVal = Math.min(...valores);
    const maxVal = Math.max(...valores);
    const rango = maxVal - minVal;
    return valores.map((val) => {
      const porcentaje = rango > 0 ? (val - minVal) / rango : 0;
      return interpolarColorVerdeRojo(porcentaje);
    });
  }, [datosFiltrados]);

  // Datos formateados para la tabla del panel lateral
  const datosTabla = useMemo(() => {
    return datosFiltrados.map((punto) => {
      const fecha = new Date(punto.x);
      return {
        fecha: fecha.toLocaleDateString("es-AR", { day: "2-digit", month: "2-digit", year: "2-digit" }),
        hora: fecha.toLocaleTimeString("es-AR", { hour: "2-digit", minute: "2-digit", second: "2-digit" }),
        medicion: Math.ceil(punto.y * 100) / 100,
      };
    });
  }, [datosFiltrados]);

  // T√≠tulo del panel (per√≠odo de fechas)
  const tituloPanelDatos = useMemo(() => {
    if (datosGrafico.length === 0) return "Sin datos";
    const primeraFecha = new Date(datosGrafico[0].x);
    const ultimaFecha = new Date(datosGrafico[datosGrafico.length - 1].x);

    const formatoFecha = { day: "2-digit", month: "2-digit", year: "2-digit" };
    const primeraStr = primeraFecha.toLocaleDateString("es-AR", formatoFecha);
    const ultimaStr = ultimaFecha.toLocaleDateString("es-AR", formatoFecha);

    if (primeraStr === ultimaStr) {
      return primeraStr;
    }
    return `${primeraStr} - ${ultimaStr}`;
  }, [datosGrafico]);

  // Estad√≠sticas del gr√°fico
  const estadisticasGrafico = useMemo(() => {
    if (datosGrafico.length === 0) return null;
    const valores = datosGrafico.map((d) => d.y);
    const minVal = Math.min(...valores);
    const maxVal = Math.max(...valores);
    const promedio = valores.reduce((a, b) => a + b, 0) / valores.length;

    const puntoMin = datosGrafico.find((d) => d.y === minVal);
    const puntoMax = datosGrafico.find((d) => d.y === maxVal);

    const formatearFecha = (date) => {
      if (!date) return "";
      const d = new Date(date);
      const dia = d.getDate().toString().padStart(2, "0");
      const mes = (d.getMonth() + 1).toString().padStart(2, "0");
      const anio = d.getFullYear().toString().slice(-2);
      const hora = d.getHours().toString().padStart(2, "0");
      const min = d.getMinutes().toString().padStart(2, "0");
      return `${dia}/${mes}/${anio} - ${hora}:${min} hs.`;
    };

    return {
      puntos: datosGrafico.length,
      min: minVal.toFixed(2),
      minFecha: formatearFecha(puntoMin?.x),
      max: maxVal.toFixed(2),
      maxFecha: formatearFecha(puntoMax?.x),
      promedio: promedio.toFixed(2),
    };
  }, [datosGrafico]);

  // Transformar datos crudos a formato de gr√°fico
  const transformarDatosParaGrafico = useCallback((datos, zonaConfig) => {
    return datos
      .map((lectura) => {
        const promedio = calcularPromedioZona(lectura, zonaConfig);
        if (promedio === null) return null;
        return { x: new Date(lectura.timestamp), y: promedio };
      })
      .filter((d) => d !== null);
  }, []);

  return {
    // T√≠tulos
    tituloSuperior,
    tituloInferior,
    tituloZonaActual,
    tituloPanelDatos,
    // Funciones
    zonaDisponible,
    transformarDatosParaGrafico,
    // Datos calculados
    datosFiltrados,
    coloresBarras,
    datosTabla,
    estadisticasGrafico,
  };
};

export default useCalculosHistorial;

// ===== ./src/paginas/PaginaAlimentadores/hooks/useCambiosPendientes.js =====

// src/paginas/PaginaAlimentadores/hooks/usarCambiosPendientes.js
// Hook para manejar cambios pendientes de sincronizaci√≥n con la BD
//
// Conceptos:
// - Pbase: Par√°metros guardados en la base de datos (snapshot)
// - Pnavegador: Par√°metros actuales en el navegador (estado local + localStorage)
//
// El bot√≥n "Guardar" se habilita cuando Pbase !== Pnavegador, incluyendo:
// - Valores diferentes (colores, gaps)
// - Elementos nuevos en Pnavegador que no existen en Pbase (alimentadores agregados)
// - Elementos eliminados de Pnavegador que s√≠ existen en Pbase (alimentadores borrados)
// - Diferente cantidad de filas (afecta gaps verticales)

import { useState, useCallback, useRef } from "react";
import {
  actualizarPuesto as actualizarPuestoAPI,
  actualizarAlimentadorAPI,
  reordenarAlimentadores as reordenarAlimentadoresAPI,
} from "../../../servicios/apiService";

/**
 * Hook para detectar y sincronizar cambios pendientes entre estado local y BD.
 *
 * Trackea:
 * - Colores de puestos (color, bgColor)
 * - Gaps verticales de puestos (por fila)
 * - Escala de puestos
 * - Colores de alimentadores
 * - Gaps horizontales de alimentadores
 * - Escala de alimentadores (individual)
 * - Orden de alimentadores
 * - Cantidad de alimentadores (elementos nuevos/eliminados)
 *
 * NO trackea (van directo a BD):
 * - Crear/eliminar puestos
 * - Crear/eliminar alimentadores
 * - Configuraci√≥n Modbus
 */
export const useCambiosPendientes = () => {
  // Snapshot original de los datos cargados de BD (Pbase)
  const snapshotRef = useRef({
    puestos: {},      // { [id]: { color, bgColor, gapsVerticales, cantidadAlimentadores, escala } }
    alimentadores: {}, // { [id]: { color, gapHorizontal, orden, puestoId, escala } }
    alimentadoresIds: new Set(), // Set de IDs de alimentadores en Pbase
  });

  // Estado de sincronizaci√≥n
  const [sincronizando, setSincronizando] = useState(false);
  const [errorSincronizacion, setErrorSincronizacion] = useState(null);

  /**
   * Guarda el snapshot original de los datos cargados de BD (Pbase).
   * Llamar despu√©s de cargar datos del backend.
   *
   * IMPORTANTE: Todos los IDs se guardan como strings para evitar
   * problemas de comparaci√≥n entre tipos (n√∫meros vs strings).
   */
  const guardarSnapshot = useCallback((puestos) => {
    const snapshot = {
      puestos: {},
      alimentadores: {},
      alimentadoresIds: new Set(), // Set de strings
    };

    puestos.forEach((puesto) => {
      const alimentadoresDelPuesto = puesto.alimentadores || [];
      const puestoIdStr = String(puesto.id);

      snapshot.puestos[puestoIdStr] = {
        color: puesto.color,
        bgColor: puesto.bgColor || puesto.bg_color,
        gapsVerticales: JSON.stringify(puesto.gapsVerticales || { "0": 40 }),
        cantidadAlimentadores: alimentadoresDelPuesto.length,
        escala: puesto.escala, // null si no est√° definida en BD
      };

      alimentadoresDelPuesto.forEach((alim, index) => {
        const alimIdStr = String(alim.id);
        snapshot.alimentadores[alimIdStr] = {
          color: alim.color,
          gapHorizontal: alim.gapHorizontal ?? 10,
          orden: index,
          puestoId: puestoIdStr, // tambi√©n string
          escala: alim.escala, // null si no est√° definida en BD
        };
        snapshot.alimentadoresIds.add(alimIdStr);
      });
    });

    snapshotRef.current = snapshot;
  }, []);

  /**
   * Detecta si hay cambios entre el estado actual (Pnavegador) y el snapshot (Pbase).
   *
   * Detecta:
   * 1. Cambios en valores existentes (colores, gaps)
   * 2. Alimentadores nuevos (en Pnavegador pero no en Pbase)
   * 3. Alimentadores eliminados (en Pbase pero no en Pnavegador)
   * 4. Cambios en cantidad de filas (afecta gaps verticales)
   *
   * @param {Array} puestosActuales - Lista actual de puestos con alimentadores
   * @param {Object} gapsPorTarjeta - Gaps horizontales de localStorage { alimId: gap }
   * @param {Object} gapsPorFilaPorPuesto - Gaps verticales de localStorage por puesto { puestoId: { "0": gap, ... } }
   * @param {Object} escalasPorPuesto - Escalas por puesto de localStorage { puestoId: escala }
   * @param {Object} escalasPorTarjeta - Escalas por tarjeta de localStorage { alimId: escala }
   * @returns {Object} { hayCambios, cambios, hayNuevosElementos, hayElementosEliminados }
   */
  const detectarCambios = useCallback((puestosActuales, gapsPorTarjeta = {}, gapsPorFilaPorPuesto = {}, escalasPorPuesto = {}, escalasPorTarjeta = {}) => {
    const cambios = {
      puestos: [],      // [{ id, campos: { color?, bgColor?, gapsVerticales?, escala? } }]
      alimentadores: [], // [{ id, campos: { color?, gapHorizontal?, escala? } }]
      ordenPorPuesto: {}, // { puestoId: [alimentadorIds en nuevo orden] }
    };

    const snapshot = snapshotRef.current;

    // Trackear IDs actuales para detectar elementos nuevos/eliminados
    // IMPORTANTE: Usamos Set de strings para comparaci√≥n consistente
    const alimentadoresActualesIds = new Set();
    let hayNuevosElementos = false;
    let hayElementosEliminados = false;

    // Comparar puestos
    puestosActuales.forEach((puesto) => {
      const puestoIdStr = String(puesto.id);
      const original = snapshot.puestos[puestoIdStr];
      const alimentadoresDelPuesto = puesto.alimentadores || [];

      // Recolectar IDs de alimentadores actuales (como strings)
      alimentadoresDelPuesto.forEach((alim) => {
        const alimIdStr = String(alim.id);
        alimentadoresActualesIds.add(alimIdStr);

        // Detectar alimentadores nuevos (no estaban en Pbase)
        if (!snapshot.alimentadoresIds.has(alimIdStr)) {
          hayNuevosElementos = true;
        }
      });

      // Detectar cambio de orden comparando arrays de IDs (todos como strings)
      const ordenActualIds = alimentadoresDelPuesto.map(a => String(a.id));
      const ordenOriginalIds = Object.entries(snapshot.alimentadores)
        .filter(([_, data]) => data.puestoId === puestoIdStr)
        .sort((a, b) => a[1].orden - b[1].orden)
        .map(([id, _]) => id); // ya es string porque es key de objeto

      // Comparar si el orden cambi√≥ (solo si tienen la misma cantidad de elementos)
      if (ordenActualIds.length === ordenOriginalIds.length && ordenActualIds.length > 0) {
        const ordenCambio = ordenActualIds.some((id, idx) => id !== ordenOriginalIds[idx]);
        if (ordenCambio) {
          cambios.ordenPorPuesto[puesto.id] = alimentadoresDelPuesto.map(a => a.id);
        }
      }

      // Si es un puesto nuevo, no comparar valores pero s√≠ registrar sus gaps
      if (!original) {
        // Puesto nuevo: considerar como cambio si tiene gaps personalizados
        const gapsFilaActuales = gapsPorFilaPorPuesto[puesto.id] || puesto.gapsVerticales || { "0": 40 };
        const gapsDefault = JSON.stringify({ "0": 40 });
        if (JSON.stringify(gapsFilaActuales) !== gapsDefault) {
          cambios.puestos.push({ id: puesto.id, campos: { gapsVerticales: gapsFilaActuales } });
        }
        return;
      }

      const cambiosPuesto = {};
      const bgColorActual = puesto.bgColor || puesto.bg_color;

      // Comparar colores
      if (puesto.color !== original.color) {
        cambiosPuesto.color = puesto.color;
      }
      if (bgColorActual !== original.bgColor) {
        cambiosPuesto.bgColor = bgColorActual;
      }

      // Gaps verticales: combinar los de la BD con los de localStorage para este puesto
      const gapsFilaActuales = gapsPorFilaPorPuesto[puesto.id] || puesto.gapsVerticales || { "0": 40 };
      const gapsFilaActualesStr = JSON.stringify(gapsFilaActuales);
      if (gapsFilaActualesStr !== original.gapsVerticales) {
        cambiosPuesto.gapsVerticales = gapsFilaActuales;
      }

      // Detectar cambio en cantidad de alimentadores
      if (alimentadoresDelPuesto.length !== original.cantidadAlimentadores) {
        // La cantidad cambi√≥, esto puede afectar los gaps verticales
        // Asegurarse de incluir los gaps actualizados
        if (!cambiosPuesto.gapsVerticales) {
          cambiosPuesto.gapsVerticales = gapsFilaActuales;
        }
      }

      // Escala del puesto: preferir localStorage, luego valor del objeto
      // Si hay escala en localStorage, usarla; si no, usar la del puesto
      const puestoIdStrLS = String(puesto.id);
      const escalaLocalPuesto = escalasPorPuesto[puestoIdStrLS] ?? escalasPorPuesto[puesto.id];
      const escalaActualPuesto = escalaLocalPuesto !== undefined ? escalaLocalPuesto : puesto.escala;
      // Comparar con el snapshot (ambos pueden ser null)
      if (escalaActualPuesto !== original.escala) {
        cambiosPuesto.escala = escalaActualPuesto;
      }

      if (Object.keys(cambiosPuesto).length > 0) {
        cambios.puestos.push({ id: puesto.id, campos: cambiosPuesto });
      }

      // Comparar alimentadores del puesto
      alimentadoresDelPuesto.forEach((alim) => {
        const alimIdStr = String(alim.id);
        const originalAlim = snapshot.alimentadores[alimIdStr];

        // Alimentador nuevo: registrar sus gaps si son diferentes al default
        if (!originalAlim) {
          const gapActual = gapsPorTarjeta[alimIdStr] ?? gapsPorTarjeta[alim.id] ?? alim.gapHorizontal ?? 10;
          if (gapActual !== 10) { // Solo si es diferente al default
            cambios.alimentadores.push({ id: alim.id, campos: { gapHorizontal: gapActual } });
          }
          return;
        }

        const cambiosAlim = {};

        // Comparar color
        if (alim.color !== originalAlim.color) {
          cambiosAlim.color = alim.color;
        }

        // Gap horizontal: preferir localStorage, luego el del objeto
        // Buscar tanto por string como por n√∫mero en gapsPorTarjeta
        const gapActual = gapsPorTarjeta[alimIdStr] ?? gapsPorTarjeta[alim.id] ?? alim.gapHorizontal ?? 10;
        if (gapActual !== originalAlim.gapHorizontal) {
          cambiosAlim.gapHorizontal = gapActual;
        }

        // Escala individual: preferir localStorage, luego valor del objeto
        const escalaLocalAlim = escalasPorTarjeta[alimIdStr] ?? escalasPorTarjeta[alim.id];
        const escalaActualAlim = escalaLocalAlim !== undefined ? escalaLocalAlim : alim.escala;
        // Comparar con el snapshot (ambos pueden ser null)
        if (escalaActualAlim !== originalAlim.escala) {
          cambiosAlim.escala = escalaActualAlim;
        }

        if (Object.keys(cambiosAlim).length > 0) {
          cambios.alimentadores.push({ id: alim.id, campos: cambiosAlim });
        }
      });
    });

    // Detectar alimentadores eliminados (estaban en Pbase pero ya no est√°n en Pnavegador)
    // Ambos Sets ahora contienen strings
    snapshot.alimentadoresIds.forEach((idBase) => {
      if (!alimentadoresActualesIds.has(idBase)) {
        hayElementosEliminados = true;
      }
    });

    // Tambi√©n detectar si hay gaps en localStorage para alimentadores que ya no existen
    // Object.keys devuelve strings, as√≠ que la comparaci√≥n funciona
    Object.keys(gapsPorTarjeta).forEach((alimIdStr) => {
      if (!alimentadoresActualesIds.has(alimIdStr) && snapshot.alimentadoresIds.has(alimIdStr)) {
        // Hay un gap guardado para un alimentador que fue eliminado
        hayElementosEliminados = true;
      }
    });

    const hayCambios =
      cambios.puestos.length > 0 ||
      cambios.alimentadores.length > 0 ||
      Object.keys(cambios.ordenPorPuesto).length > 0 ||
      hayNuevosElementos ||
      hayElementosEliminados;

    return {
      hayCambios,
      cambios,
      hayNuevosElementos,
      hayElementosEliminados,
    };
  }, []);

  /**
   * Sincroniza todos los cambios pendientes con la BD.
   * Despu√©s de sincronizar exitosamente, el snapshot se actualiza
   * al recargar datos en el callback onSuccess.
   *
   * @param {Object} cambios - Cambios detectados por detectarCambios()
   * @param {Function} onSuccess - Callback al completar exitosamente (puede ser async)
   * @param {Function} onError - Callback en caso de error
   */
  const sincronizarConBD = useCallback(async (cambios, onSuccess, onError) => {
    setSincronizando(true);
    setErrorSincronizacion(null);

    try {
      // 1. Actualizar puestos
      for (const { id, campos } of cambios.puestos) {
        const datosAPI = {};
        if (campos.color !== undefined) datosAPI.color = campos.color;
        if (campos.bgColor !== undefined) datosAPI.bg_color = campos.bgColor;
        if (campos.gapsVerticales !== undefined) datosAPI.gaps_verticales = campos.gapsVerticales;
        if (campos.escala !== undefined) datosAPI.escala = campos.escala;

        await actualizarPuestoAPI(id, datosAPI);
      }

      // 2. Actualizar alimentadores
      for (const { id, campos } of cambios.alimentadores) {
        const datosAPI = {};
        if (campos.color !== undefined) datosAPI.color = campos.color;
        if (campos.gapHorizontal !== undefined) datosAPI.gap_horizontal = campos.gapHorizontal;
        if (campos.escala !== undefined) datosAPI.escala = campos.escala;

        await actualizarAlimentadorAPI(id, datosAPI);
      }

      // 3. Reordenar alimentadores
      for (const [puestoId, ordenIds] of Object.entries(cambios.ordenPorPuesto)) {
        await reordenarAlimentadoresAPI(puestoId, ordenIds);
      }

      // El callback onSuccess debe recargar los datos de BD,
      // lo cual disparar√° guardarSnapshot() con los nuevos datos
      // IMPORTANTE: Esperamos al callback para mantener el overlay visible
      if (onSuccess) await onSuccess();
    } catch (error) {
      console.error("Error sincronizando cambios:", error);
      setErrorSincronizacion(error.message);
      if (onError) onError(error);
    } finally {
      setSincronizando(false);
    }
  }, []);

  /**
   * Descarta los cambios locales y recarga desde BD.
   * @param {Function} recargarDatos - Funci√≥n para recargar datos desde BD
   */
  const descartarCambios = useCallback(async (recargarDatos) => {
    if (recargarDatos) {
      await recargarDatos();
    }
  }, []);

  /**
   * Obtiene el snapshot actual (Pbase) para debugging o comparaci√≥n.
   */
  const obtenerSnapshot = useCallback(() => {
    return snapshotRef.current;
  }, []);

  return {
    // Funciones principales
    guardarSnapshot,
    detectarCambios,
    sincronizarConBD,
    descartarCambios,
    obtenerSnapshot,
    // Estado
    sincronizando,
    errorSincronizacion,
  };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/useChispas.js =====

// src/paginas/PaginaAlimentadores/hooks/usarChispas.js

import { useState, useCallback, useRef, useEffect } from "react";
import {
	construirGrafo,
	calcularRutasDesdeEmisor,
} from "../utilidades/calculadorRutas.js";

/**
 * L√≠mite m√°ximo de chispas simult√°neas para evitar problemas de rendimiento
 */
const MAX_CHISPAS = 100;

/**
 * Hook para manejar la animaci√≥n de chispas en el diagrama unifilar.
 *
 * OPTIMIZADO: Las chispas se manejan con refs mutables, sin usar setState
 * durante la animaci√≥n. Esto elimina los re-renders de React y el GC.
 *
 * @param {Object} params - Par√°metros del hook
 * @param {Array} params.bornes - Array de bornes
 * @param {Object} params.celdas - Objeto de celdas pintadas
 * @param {Object} params.chispasConfig - Configuraci√≥n de chispas
 * @param {number} params.grosorLinea - Grosor de l√≠nea en p√≠xeles
 * @returns {Object} Estado y funciones para manejar chispas
 */
const useChispas = ({
	bornes = [],
	celdas = {},
	chispasConfig = {},
	grosorLinea = 12,
}) => {
	// Estado de animaci√≥n activa (solo este causa re-render, y solo al iniciar/detener)
	const [animando, setAnimando] = useState(false);
	const animandoRef = useRef(false);

	// *** CAMBIO CLAVE: Las chispas son un REF, no un estado ***
	// Esto evita re-renders durante la animaci√≥n
	const chispasRef = useRef([]);

	// Referencias para el loop de animaci√≥n
	const animationFrameRef = useRef(null);
	const lastTimeRef = useRef(0);

	// Referencias para timers de emisi√≥n
	const emisionTimersRef = useRef({});

	// Grafo de conectividad (se recalcula cuando cambian las celdas)
	const grafoRef = useRef({});

	// Rutas precalculadas desde cada emisor
	const rutasRef = useRef({});

	// Refs para la configuraci√≥n actual (para evitar closures obsoletos)
	const configRef = useRef(chispasConfig);
	const bornesRef = useRef(bornes);
	const grosorLineaRef = useRef(grosorLinea);

	// ID counter para chispas (evita Date.now() y Math.random())
	const chispaIdRef = useRef(0);

	// Mantener refs actualizados
	useEffect(() => {
		configRef.current = chispasConfig;
	}, [chispasConfig]);

	useEffect(() => {
		bornesRef.current = bornes;
	}, [bornes]);

	useEffect(() => {
		grosorLineaRef.current = grosorLinea;
	}, [grosorLinea]);

	/**
	 * Recalcular el grafo cuando cambian las celdas
	 */
	useEffect(() => {
		grafoRef.current = construirGrafo(celdas);
	}, [celdas]);

	/**
	 * Recalcular rutas cuando cambian bornes o celdas
	 */
	useEffect(() => {
		const emisores = bornes.filter(b => b.tipo === "EMISOR");
		const nuevasRutas = {};

		emisores.forEach(emisor => {
			nuevasRutas[emisor.id] = calcularRutasDesdeEmisor(emisor, bornes, grafoRef.current);
		});

		rutasRef.current = nuevasRutas;
	}, [bornes, celdas]);

	/**
	 * Crear una nueva chispa desde un emisor
	 */
	const crearChispa = useCallback((emisor) => {
		const rutas = rutasRef.current[emisor.id] || [];

		// Si no hay rutas a receptores, no crear chispa
		if (rutas.length === 0) {
			return null;
		}

		// Elegir una ruta aleatoria si hay varias
		const rutaElegida = rutas[Math.floor(Math.random() * rutas.length)];

		chispaIdRef.current += 1;

		return {
			id: chispaIdRef.current,
			ruta: rutaElegida.ruta,
			posicion: 0,
			progreso: 0, // 0-1 entre celdas
			emisorId: emisor.id,
			receptorId: rutaElegida.receptorId,
			estela: [], // Array mutable - se modifica in-place
		};
	}, []);

	/**
	 * Emitir una chispa desde un emisor espec√≠fico
	 * *** MODIFICADO: Agrega directamente al ref, sin setState ***
	 */
	const emitirDesdeEmisor = useCallback((emisorId) => {
		const emisor = bornesRef.current.find(b => b.id === emisorId && b.tipo === "EMISOR");
		if (!emisor || !emisor.activo) {
			return;
		}

		// Verificar l√≠mite de chispas
		if (chispasRef.current.length >= MAX_CHISPAS) {
			return;
		}

		const nuevaChispa = crearChispa(emisor);
		if (!nuevaChispa) {
			return;
		}

		// *** Agregar directamente al array del ref ***
		chispasRef.current.push(nuevaChispa);
	}, [crearChispa]);

	/**
	 * Loop de animaci√≥n - actualiza posiciones de chispas
	 * *** MODIFICADO: Modifica el ref directamente, sin setState ***
	 */
	const loopAnimacion = useCallback((timestamp) => {
		if (!animandoRef.current) {
			return;
		}

		const deltaTime = lastTimeRef.current === 0 ? 16 : timestamp - lastTimeRef.current;
		lastTimeRef.current = timestamp;

		// Velocidad en celdas por segundo
		const velocidad = configRef.current.velocidad || 8;
		const longitudEstela = configRef.current.longitudEstela || 5;

		// Calcular cu√°nto avanzar
		const avance = (velocidad * deltaTime) / 1000;

		const chispas = chispasRef.current;

		// Actualizar chispas IN-PLACE
		for (let i = chispas.length - 1; i >= 0; i--) {
			const chispa = chispas[i];
			chispa.progreso += avance;

			// Manejar m√∫ltiples avances de celda si la velocidad es muy alta
			while (chispa.progreso >= 1) {
				const estela = chispa.estela;

				// Shift estela hacia el final (in-place)
				for (let j = Math.min(estela.length, longitudEstela - 1); j > 0; j--) {
					estela[j] = estela[j - 1];
				}
				// Agregar posici√≥n actual al inicio
				estela[0] = chispa.ruta[chispa.posicion];

				// Ajustar longitud de estela
				if (estela.length < longitudEstela) {
					estela.length = Math.min(estela.length + 1, longitudEstela);
				} else if (estela.length > longitudEstela) {
					estela.length = longitudEstela;
				}

				chispa.posicion += 1;
				chispa.progreso -= 1;

				// Verificar si llegamos al final de la ruta
				if (chispa.posicion >= chispa.ruta.length - 1) {
					// Eliminar chispa del array (in-place)
					chispas.splice(i, 1);
					break;
				}
			}
		}

		// Continuar el loop
		animationFrameRef.current = requestAnimationFrame(loopAnimacion);
	}, []);

	/**
	 * Iniciar los timers de emisi√≥n para todos los emisores activos
	 */
	const iniciarEmisiones = useCallback(() => {
		// Limpiar timers anteriores
		Object.values(emisionTimersRef.current).forEach(clearInterval);
		emisionTimersRef.current = {};

		const emisores = bornesRef.current.filter(b => b.tipo === "EMISOR" && b.activo);
		const frecuencia = configRef.current.frecuenciaEmision || 2000;

		emisores.forEach(emisor => {
			// Emitir una chispa inmediatamente
			emitirDesdeEmisor(emisor.id);

			// Configurar timer para emisiones peri√≥dicas
			const timer = setInterval(() => {
				if (animandoRef.current) {
					emitirDesdeEmisor(emisor.id);
				}
			}, frecuencia);

			emisionTimersRef.current[emisor.id] = timer;
		});
	}, [emitirDesdeEmisor]);

	/**
	 * Detener todos los timers de emisi√≥n
	 */
	const detenerEmisiones = useCallback(() => {
		Object.values(emisionTimersRef.current).forEach(clearInterval);
		emisionTimersRef.current = {};
	}, []);

	/**
	 * Reiniciar timers cuando cambia la frecuencia de emisi√≥n (mientras est√° animando)
	 */
	const frecuenciaActual = chispasConfig.frecuenciaEmision || 2000;

	useEffect(() => {
		if (animandoRef.current) {
			// Limpiar timers anteriores
			Object.values(emisionTimersRef.current).forEach(clearInterval);
			emisionTimersRef.current = {};

			const emisores = bornesRef.current.filter(b => b.tipo === "EMISOR" && b.activo);

			emisores.forEach(emisor => {
				// Configurar timer con la nueva frecuencia
				const timer = setInterval(() => {
					if (animandoRef.current) {
						emitirDesdeEmisor(emisor.id);
					}
				}, frecuenciaActual);

				emisionTimersRef.current[emisor.id] = timer;
			});
		}
	}, [frecuenciaActual, emitirDesdeEmisor]);

	/**
	 * Iniciar animaci√≥n
	 */
	const iniciarAnimacion = useCallback(() => {
		// Verificar que hay emisores y receptores
		const emisores = bornesRef.current.filter(b => b.tipo === "EMISOR" && b.activo);
		const receptores = bornesRef.current.filter(b => b.tipo === "RECEPTOR");

		if (emisores.length === 0 || receptores.length === 0) {
			return;
		}

		animandoRef.current = true;
		setAnimando(true);
		lastTimeRef.current = 0;

		// Limpiar chispas anteriores
		chispasRef.current = [];

		// Iniciar emisiones
		iniciarEmisiones();

		// Iniciar loop de animaci√≥n
		animationFrameRef.current = requestAnimationFrame(loopAnimacion);
	}, [iniciarEmisiones, loopAnimacion]);

	/**
	 * Detener animaci√≥n
	 */
	const detenerAnimacion = useCallback(() => {
		animandoRef.current = false;
		setAnimando(false);
		detenerEmisiones();
		chispasRef.current = [];

		if (animationFrameRef.current) {
			cancelAnimationFrame(animationFrameRef.current);
			animationFrameRef.current = null;
		}
	}, [detenerEmisiones]);

	/**
	 * Toggle animaci√≥n
	 */
	const toggleAnimacion = useCallback(() => {
		if (animandoRef.current) {
			detenerAnimacion();
		} else {
			iniciarAnimacion();
		}
	}, [iniciarAnimacion, detenerAnimacion]);

	/**
	 * Obtener posici√≥n en p√≠xeles de una chispa para renderizado
	 * Usa interpolaci√≥n lineal para movimiento constante y fluido
	 *
	 * @param {Object} chispa - Objeto chispa con ruta, posicion y progreso
	 * @returns {Object} { x, y } posici√≥n en p√≠xeles
	 */
	const obtenerPosicionPixel = useCallback((chispa) => {
		const { ruta, posicion, progreso } = chispa;
		const grosor = grosorLineaRef.current;

		if (!ruta || ruta.length === 0) {
			return { x: 0, y: 0 };
		}

		// Posici√≥n actual
		const [x1, y1] = ruta[posicion].split(",").map(Number);

		// Si estamos al final de la ruta, retornar la √∫ltima posici√≥n
		if (posicion >= ruta.length - 1) {
			return {
				x: x1 * grosor + grosor / 2,
				y: y1 * grosor + grosor / 2,
			};
		}

		// Posici√≥n siguiente para interpolaci√≥n
		const [x2, y2] = ruta[posicion + 1].split(",").map(Number);

		// Interpolaci√≥n lineal simple - movimiento constante sin aceleraci√≥n
		const x = (x1 + (x2 - x1) * progreso) * grosor + grosor / 2;
		const y = (y1 + (y2 - y1) * progreso) * grosor + grosor / 2;

		return { x, y };
	}, []);

	/**
	 * Obtener posiciones de la estela de una chispa
	 *
	 * @param {Object} chispa - Objeto chispa
	 * @returns {Array} Array de { x, y, opacidad }
	 */
	const obtenerEstelaPixeles = useCallback((chispa) => {
		const { estela } = chispa;
		const grosor = grosorLineaRef.current;

		if (!estela || estela.length === 0) {
			return [];
		}

		const resultado = [];
		for (let i = 0; i < estela.length; i++) {
			const clave = estela[i];
			if (!clave) continue;
			const [x, y] = clave.split(",").map(Number);
			resultado.push({
				x: x * grosor + grosor / 2,
				y: y * grosor + grosor / 2,
				opacidad: 1 - (i + 1) / (estela.length + 1),
			});
		}
		return resultado;
	}, []);

	/**
	 * Limpiar al desmontar
	 */
	useEffect(() => {
		return () => {
			animandoRef.current = false;
			detenerEmisiones();
			if (animationFrameRef.current) {
				cancelAnimationFrame(animationFrameRef.current);
			}
			chispasRef.current = [];
		};
	}, [detenerEmisiones]);

	return {
		// Estado
		animando,
		// *** CAMBIO: Devolver la referencia al array de chispas ***
		// El componente que usa este hook debe leer chispasRef.current
		chispas: chispasRef.current,
		chispasRef, // Tambi√©n exponer el ref directamente

		// Acciones
		iniciarAnimacion,
		detenerAnimacion,
		toggleAnimacion,

		// Utilidades para renderizado
		obtenerPosicionPixel,
		obtenerEstelaPixeles,
	};
};

export default useChispas;

// ===== ./src/paginas/PaginaAlimentadores/hooks/useConfiguracion.js =====

// src/paginas/PaginaAlimentadores/hooks/usarConfiguracion.js
// Hook para manejar workspaces del usuario en Supabase

import { useState, useEffect, useCallback } from "react";
import {
  obtenerWorkspaces,
  crearWorkspace,
  actualizarWorkspace as actualizarWorkspaceAPI,
  eliminarWorkspace as eliminarWorkspaceAPI,
  obtenerPerfil,
  actualizarWorkspaceDefault,
} from "../../../servicios/apiService";
import { CLAVES_STORAGE } from "../constantes/clavesAlmacenamiento";

/**
 * Hook para manejar workspaces del usuario.
 * Los workspaces son contenedores que agrupan puestos y alimentadores.
 *
 * @returns {Object} Estado y funciones para trabajar con workspaces.
 */
export const useConfiguracion = () => {
  // Lista de workspaces del usuario
  const [configuraciones, setConfiguraciones] = useState([]);

  // ID del workspace actualmente seleccionado (UUID string)
  const [configuracionSeleccionadaId, setConfiguracionSeleccionadaId] = useState(() => {
    const guardado = localStorage.getItem(CLAVES_STORAGE.CONFIGURACION_SELECCIONADA);
    return guardado || null;
  });

  // Estado de carga
  const [cargando, setCargando] = useState(true);

  // Error si ocurre
  const [error, setError] = useState(null);

  // Perfil del usuario (incluye rol global)
  const [perfil, setPerfil] = useState(null);

  // ID del workspace por defecto (derivado del perfil)
  const workspaceDefaultId = perfil?.workspace_default_id || null;

  // Workspace seleccionado (derivado)
  const configuracionSeleccionada = configuraciones.find(
    (c) => c.id === configuracionSeleccionadaId
  ) || configuraciones[0] || null;

  // Permisos derivados del perfil
  const puedeCrearWorkspaces = perfil?.puedeCrearWorkspaces ?? false;
  const rolGlobal = perfil?.rolGlobal ?? 'observador';

  /**
   * Carga el perfil del usuario y los workspaces desde el backend
   */
  const cargarConfiguraciones = useCallback(async () => {
    try {
      setCargando(true);
      setError(null);

      // Cargar perfil y workspaces en paralelo
      const [perfilData, workspacesData] = await Promise.all([
        obtenerPerfil(),
        obtenerWorkspaces(),
      ]);

      setPerfil(perfilData);
      setConfiguraciones(workspacesData);

      // Validar la selecci√≥n guardada contra los workspaces del usuario
      if (workspacesData.length > 0) {
        const seleccionActualValida = workspacesData.some((c) => c.id === configuracionSeleccionadaId);
        const defaultId = perfilData?.workspace_default_id;
        const defaultValido = defaultId && workspacesData.some((c) => c.id === defaultId);

        // Prioridad: 1) selecci√≥n actual v√°lida, 2) workspace default, 3) primer workspace
        if (!seleccionActualValida) {
          if (defaultValido) {
            setConfiguracionSeleccionadaId(defaultId);
          } else {
            setConfiguracionSeleccionadaId(workspacesData[0].id);
          }
        }
      } else {
        // Si el usuario no tiene workspaces, limpiar cualquier selecci√≥n guardada
        setConfiguracionSeleccionadaId(null);
      }
    } catch (err) {
      console.error("Error cargando configuraciones:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  }, [configuracionSeleccionadaId]);

  // Cargar configuraciones al montar
  useEffect(() => {
    cargarConfiguraciones();
  }, []);

  // Guardar selecci√≥n en localStorage cuando cambie
  useEffect(() => {
    if (configuracionSeleccionadaId != null) {
      localStorage.setItem(
        CLAVES_STORAGE.CONFIGURACION_SELECCIONADA,
        configuracionSeleccionadaId.toString()
      );
    } else {
      localStorage.removeItem(CLAVES_STORAGE.CONFIGURACION_SELECCIONADA);
    }
  }, [configuracionSeleccionadaId]);

  /**
   * Crea un nuevo workspace
   * @param {string} nombre - Nombre del workspace
   * @param {string} descripcion - Descripci√≥n opcional
   */
  const agregarConfiguracion = async (nombre, descripcion = "") => {
    try {
      setError(null);
      const nueva = await crearWorkspace(nombre, descripcion);
      setConfiguraciones((prev) => [...prev, nueva]);
      setConfiguracionSeleccionadaId(nueva.id);
      return nueva;
    } catch (err) {
      console.error("Error creando workspace:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Actualiza un workspace existente
   * @param {number} id - ID del workspace
   * @param {Object} datos - Datos a actualizar
   */
  const actualizarConfiguracion = async (id, datos) => {
    try {
      setError(null);
      const actualizada = await actualizarWorkspaceAPI(id, datos);
      setConfiguraciones((prev) =>
        prev.map((c) => (c.id === id ? actualizada : c))
      );
      return actualizada;
    } catch (err) {
      console.error("Error actualizando workspace:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Elimina un workspace
   * @param {number} id - ID del workspace a eliminar
   */
  const eliminarConfiguracion = async (id) => {
    try {
      setError(null);
      await eliminarWorkspaceAPI(id);
      setConfiguraciones((prev) => prev.filter((c) => c.id !== id));

      // Si se elimin√≥ el seleccionado, seleccionar otro
      if (configuracionSeleccionadaId === id) {
        const restantes = configuraciones.filter((c) => c.id !== id);
        setConfiguracionSeleccionadaId(restantes[0]?.id || null);
      }
    } catch (err) {
      console.error("Error eliminando workspace:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Selecciona un workspace como activo
   * @param {number} id - ID del workspace
   */
  const seleccionarConfiguracion = (id) => {
    setConfiguracionSeleccionadaId(id);
  };

  /**
   * Alterna el workspace por defecto con optimistic update.
   * El cambio se aplica inmediatamente en la UI y se revierte si hay error.
   * @param {string} id - UUID del workspace
   */
  const toggleWorkspaceDefault = async (id) => {
    const nuevoDefault = workspaceDefaultId === id ? null : id;
    const valorAnterior = perfil?.workspace_default_id;

    // Optimistic update: aplicar cambio inmediatamente
    setPerfil((prev) => ({ ...prev, workspace_default_id: nuevoDefault }));

    try {
      setError(null);
      await actualizarWorkspaceDefault(nuevoDefault);
    } catch (err) {
      // Revertir en caso de error
      console.error("Error cambiando workspace default:", err);
      setPerfil((prev) => ({ ...prev, workspace_default_id: valorAnterior }));
      setError(err.message);
    }
  };

  return {
    // Estados
    configuraciones,
    configuracionSeleccionada,
    configuracionSeleccionadaId,
    workspaceDefaultId,
    cargando,
    error,

    // Perfil y permisos
    perfil,
    rolGlobal,
    puedeCrearWorkspaces,

    // Funciones
    cargarConfiguraciones,
    agregarConfiguracion,
    actualizarConfiguracion,
    eliminarConfiguracion,
    seleccionarConfiguracion,
    toggleWorkspaceDefault,
  };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/useEstilosGlobales.js =====

/**
 * Hook para manejar los estilos globales de las tarjetas de alimentador
 * Persiste en localStorage y proporciona funciones para actualizar cada secci√≥n
 */

import { useState, useCallback, useEffect } from "react";
import {
  ESTILOS_GLOBALES_DEFAULT,
  ESTILOS_GLOBALES_STORAGE_KEY,
} from "../constantes/estilosGlobalesTarjeta";

/**
 * Hook que maneja los estilos globales de las tarjetas
 * @returns {Object} Estado y funciones para manejar estilos globales
 */
const useEstilosGlobales = () => {
  const [estilos, setEstilos] = useState(() => {
    // Intentar cargar desde localStorage al inicializar
    try {
      const guardado = localStorage.getItem(ESTILOS_GLOBALES_STORAGE_KEY);
      if (guardado) {
        const parseado = JSON.parse(guardado);
        // Merge con defaults para asegurar que todos los campos existan
        return {
          header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...parseado.header },
          tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...parseado.tituloZona },
          tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...parseado.tituloBox },
          valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...parseado.valorBox },
          box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...parseado.box },
        };
      }
    } catch (e) {
      console.warn("[EstilosGlobales] Error cargando estilos:", e);
    }
    return ESTILOS_GLOBALES_DEFAULT;
  });

  // Guardar en localStorage cuando cambian los estilos
  useEffect(() => {
    try {
      localStorage.setItem(ESTILOS_GLOBALES_STORAGE_KEY, JSON.stringify(estilos));
    } catch (e) {
      console.warn("[EstilosGlobales] Error guardando estilos:", e);
    }
  }, [estilos]);

  /**
   * Actualiza los estilos del header
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarHeader = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      header: { ...prev.header, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos del t√≠tulo de zona (afecta superior e inferior)
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarTituloZona = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      tituloZona: { ...prev.tituloZona, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos de los t√≠tulos de box (R, S, T)
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarTituloBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      tituloBox: { ...prev.tituloBox, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos del valor dentro del box
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarValorBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      valorBox: { ...prev.valorBox, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos del contenedor del box
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      box: { ...prev.box, ...cambios },
    }));
  }, []);

  /**
   * Resetea todos los estilos a los valores por defecto
   */
  const resetearEstilos = useCallback(() => {
    setEstilos(ESTILOS_GLOBALES_DEFAULT);
  }, []);

  /**
   * Aplica un objeto completo de estilos (para guardar desde TabApariencia)
   * @param {Object} nuevosEstilos - Objeto con todos los estilos a aplicar
   */
  const aplicarTodosEstilos = useCallback((nuevosEstilos) => {
    setEstilos({
      header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...nuevosEstilos.header },
      tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...nuevosEstilos.tituloZona },
      tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...nuevosEstilos.tituloBox },
      valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...nuevosEstilos.valorBox },
      box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...nuevosEstilos.box },
    });
  }, []);

  /**
   * Genera el objeto de estilos CSS para aplicar en TarjetaAlimentador
   * @returns {Object} Objeto con estilos CSS listos para usar
   */
  const obtenerEstilosCSS = useCallback(() => {
    return {
      // Estilos para .alim-card-title
      headerTitle: {
        fontFamily: estilos.header.fontFamily,
        fontSize: estilos.header.fontSize,
        fontWeight: estilos.header.fontWeight,
      },
      // Estilos para .alim-card-section-title
      tituloZona: {
        fontFamily: estilos.tituloZona.fontFamily,
        fontSize: estilos.tituloZona.fontSize,
      },
      // Estilos para .alim-card-meter-phase
      tituloBox: {
        fontFamily: estilos.tituloBox.fontFamily,
        fontSize: estilos.tituloBox.fontSize,
      },
      // Estilos para .alim-card-meter-value
      valorBox: {
        fontFamily: estilos.valorBox.fontFamily,
        fontSize: estilos.valorBox.fontSize,
        color: estilos.valorBox.color,
      },
      // Estilos para .alim-card-meter y .alim-card-meters
      box: {
        gap: estilos.box.gap,
        width: estilos.box.width,
        height: estilos.box.height,
      },
    };
  }, [estilos]);

  return {
    estilos,
    actualizarHeader,
    actualizarTituloZona,
    actualizarTituloBox,
    actualizarValorBox,
    actualizarBox,
    resetearEstilos,
    aplicarTodosEstilos,
    obtenerEstilosCSS,
  };
};

export default useEstilosGlobales;

// ===== ./src/paginas/PaginaAlimentadores/hooks/useGestorModales.js =====

// src/paginas/PaginaAlimentadores/hooks/useGestorModales.js

import { useState, useCallback } from "react"; // estado y memoizaci√≥n de callbacks de React

/**
 * Gestor simple de modales identificados por una clave.
 * Permite abrir/cerrar y guardar datos asociados al modal.
 *
 * Estructura interna:
 *   estadoModales = {
 *     [idModal]: { abierto: boolean, datos: any }
 *   }
 */
export const useGestorModales = () => {
	const [estadoModales, setEstadoModales] = useState({});        // mapa de estados por id de modal

	const abrirModal = useCallback((idModal, datos = null) => {
		setEstadoModales((prev) => ({
			...prev,
			[idModal]: { abierto: true, datos },           // marca el modal como abierto y guarda datos opcionales
		}));
	}, []);

	const cerrarModal = useCallback((idModal) => {
		setEstadoModales((prev) => ({
			...prev,
			[idModal]: { abierto: false, datos: null },     // lo marca como cerrado y limpia datos
		}));
	}, []);

	const obtenerEstado = useCallback(
		(idModal) => estadoModales[idModal] || { abierto: false, datos: null }, // estado por defecto si nunca se abri√≥
		[estadoModales]
	);

	return { abrirModal, cerrarModal, obtenerEstado, estadoModales };
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (useGestorModales.js)

 - Este hook es un "mini gestor de ventanas": centraliza el estado de todos los modales usando una 
   clave (`idModal`) para cada uno.

 - `abrirModal(id, datos)` abre el modal con esa clave y opcionalmente le asocia un objeto `datos` 
   (por ejemplo, el alimentador que se est√° editando).

 - `cerrarModal(id)` cierra el modal y descarta cualquier dato previo asociado.

 - `obtenerEstado(id)` devuelve siempre un objeto con la forma `{ abierto: boolean, datos: any }`, 
   aunque ese modal nunca se haya abierto.

 - Al usar este hook en `VistaAlimentadores`, cada modal (nuevo puesto, editar puestos, configuraci√≥n 
   de alimentador, mapeo) simplemente pide su estado con `obtenerEstado("clave")` y lo abre/cierra 
	llamando a `abrirModal` o `cerrarModal`.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (useGestorModales.js)

0) Visi√≥n general del hook

   Este hook es un ‚Äúmini centro de control de modales‚Äù. Sirve para manejar
   varios modales a la vez usando una clave de texto (idModal) para cada uno.

   La estructura interna es:

     estadoModales = {
       [idModal]: {
         abierto: boolean,   // si el modal est√° visible o no
         datos: any          // info asociada al modal (por ejemplo, el alimentador a editar)
       }
     }

   En vez de tener un useState por cada modal (`isNuevoPuestoAbierto`, `isEditarPuestoAbierto`, etc.), 
	todo se maneja en un solo objeto y con tres funciones simples: abrir, cerrar y leer estado.


1) estadoModales (useState)

   const [estadoModales, setEstadoModales] = useState({});

   - `estadoModales` empieza como un objeto vac√≠o: no hay modales abiertos.

   - Cada vez que abrimos o cerramos un modal, vamos agregando o modificando entradas en este objeto 
	  con la forma:
       estadoModales["configAlim1"] = { abierto: true/false, datos: ... }

   - Tener todo en un solo estado hace f√°cil:
       ‚Ä¢ pasar el estado completo para debug,
       ‚Ä¢ o mostrar un panel de ‚Äúqu√© modales est√°n abiertos‚Äù si se necesitara.


2) abrirModal

   const abrirModal = useCallback((idModal, datos = null) => {
     setEstadoModales((prev) => ({
       ...prev,
       [idModal]: { abierto: true, datos },
     }));
   }, []);

   - Recibe:
       ‚Ä¢ `idModal`: una clave string que identifica al modal (ej: "nuevoPuesto", "editarAlimentador",
		   "mapeoAlim3", etc.),
       ‚Ä¢ `datos` (opcional): cualquier objeto que queramos asociar a ese modal (por ejemplo, el alimentador 
		   que se est√° editando).

   - Usa `setEstadoModales` con funci√≥n para tomar el estado anterior (`prev`) y devolver uno nuevo:
       ‚Ä¢ copia todo lo que ya exist√≠a (`...prev`),
       ‚Ä¢ reemplaza o crea la entrada para esa clave `idModal` con:
           { abierto: true, datos }.

   - Resultado: el modal queda marcado como abierto y con los datos que le pasamos.

   - Est√° envuelto en `useCallback(..., [])` para que la referencia de la funci√≥n se mantenga estable entre 
	  renders (ayuda a evitar renders extra si se pasa como prop a otros componentes).


3) cerrarModal

   const cerrarModal = useCallback((idModal) => {
     setEstadoModales((prev) => ({
       ...prev,
       [idModal]: { abierto: false, datos: null },
     }));
   }, []);

   - Recibe `idModal`, la misma clave que se us√≥ para abrir el modal.

   - Actualiza el estado:
       ‚Ä¢ mantiene el resto del objeto igual (`...prev`),
       ‚Ä¢ para esa clave, pone:
           { abierto: false, datos: null }.

   - Es decir:
       ‚Ä¢ marca el modal como cerrado,
       ‚Ä¢ y borra cualquier dato que se hubiera guardado antes.

   - Tambi√©n est√° memoizada con `useCallback` para que su referencia no cambie en cada render sin necesidad.


4) obtenerEstado

   const obtenerEstado = useCallback(
     (idModal) => estadoModales[idModal] || { abierto: false, datos: null },
     [estadoModales]
   );

   - Recibe `idModal` y devuelve SIEMPRE un objeto con esta forma:
       { abierto: boolean, datos: any }

   - Si ese modal ya fue usado antes:
       ‚Ä¢ devuelve el estado real guardado en `estadoModales[idModal]`.

   - Si ese modal nunca se abri√≥:
       ‚Ä¢ devuelve un estado ‚Äúpor defecto‚Äù:
           { abierto: false, datos: null }.

   - Esto simplifica mucho la UI porque evita tener que hacer chequeos tipo:
       if (estado && estado.abierto) ...
     En cambio, el componente puede hacer directamente:
       const { abierto, datos } = obtenerEstado("configAlim1");

   - Est√° envuelta en `useCallback` dependiente de `estadoModales` para que solo cambie la referencia 
	  de la funci√≥n cuando cambia el estado de los modales, no en cada render.


5) return del hook

   return { abrirModal, cerrarModal, obtenerEstado, estadoModales };

   - Expone cuatro cosas hacia los componentes que usan este hook:

       ‚Ä¢ `abrirModal(id, datos?)`
           ‚Üí marca el modal como abierto y asocia datos opcionales.

       ‚Ä¢ `cerrarModal(id)`
           ‚Üí marca el modal como cerrado y limpia los datos asociados.

       ‚Ä¢ `obtenerEstado(id)`
           ‚Üí devuelve siempre un objeto `{ abierto, datos }` para ese modal, aunque jam√°s se haya abierto.

       ‚Ä¢ `estadoModales`
           ‚Üí estado completo con todos los modales; √∫til para debug o para vistas que quieran mostrar 
			    un resumen general.

   - En `VistaAlimentadores`, cada modal se maneja as√≠:
       const { abierto, datos } = obtenerEstado("claveDelModal");

       y se abre/cierra con:
         abrirModal("claveDelModal", datosOpcionales);
         cerrarModal("claveDelModal");

   - De esta forma, no se acumula l√≥gica de ‚Äúqu√© modal est√° abierto‚Äù en cada
     componente: todo pasa por este hook centralizado.
---------------------------------------------------------------------------*/



// ===== ./src/paginas/PaginaAlimentadores/hooks/useGrillaUnifilar.js =====

// src/paginas/PaginaAlimentadores/hooks/usarGrillaUnifilar.js

import { useState, useCallback, useEffect, useRef } from "react";

/**
 * Clave base para localStorage - cada puesto tendr√° su propio dibujo
 */
const CLAVE_BASE = "rw-grilla-unifilar";

/**
 * Colores predefinidos para dibujar el diagrama unifiliar
 */
export const COLORES_UNIFILAR = [
	{ id: "rojo", color: "#dc2626", nombre: "Rojo" },
	{ id: "azul", color: "#2563eb", nombre: "Azul" },
	{ id: "verde", color: "#16a34a", nombre: "Verde" },
	{ id: "amarillo", color: "#ca8a04", nombre: "Amarillo" },
	{ id: "naranja", color: "#ea580c", nombre: "Naranja" },
	{ id: "rosa", color: "#db2777", nombre: "Rosa" },
	{ id: "violeta", color: "#7c3aed", nombre: "Violeta" },
	{ id: "celeste", color: "#0891b2", nombre: "Celeste" },
	{ id: "blanco", color: "#ffffff", nombre: "Blanco" },
	{ id: "negro", color: "#000000", nombre: "Negro" },
];

/**
 * Fuentes disponibles para texto
 */
export const FUENTES_DISPONIBLES = [
	{ id: "arial", nombre: "Arial", familia: "Arial, sans-serif" },
	{ id: "helvetica", nombre: "Helvetica", familia: "Helvetica, Arial, sans-serif" },
	{ id: "times", nombre: "Times New Roman", familia: "Times New Roman, serif" },
	{ id: "courier", nombre: "Courier", familia: "Courier New, monospace" },
	{ id: "georgia", nombre: "Georgia", familia: "Georgia, serif" },
	{ id: "verdana", nombre: "Verdana", familia: "Verdana, sans-serif" },
];

/**
 * Tama√±os de fuente disponibles
 */
export const TAMANOS_FUENTE = [10, 12, 14, 16, 18, 20, 24, 28, 32, 36, 42, 48];

/**
 * Grosores de l√≠nea disponibles (en p√≠xeles)
 */
export const GROSORES_LINEA = [
	{ id: "fino", valor: 8, nombre: "Fino" },
	{ id: "normal", valor: 12, nombre: "Normal" },
	{ id: "medio", valor: 16, nombre: "Medio" },
	{ id: "grueso", valor: 20, nombre: "Grueso" },
	{ id: "extra", valor: 28, nombre: "Extra" },
];

/**
 * Tipos de bornes para el sistema de chispas
 */
export const TIPOS_BORNE = {
	EMISOR: "EMISOR",
	RECEPTOR: "RECEPTOR",
};

/**
 * Configuraci√≥n por defecto de chispas
 */
export const CONFIG_CHISPAS_DEFAULT = {
	velocidad: 8,        // celdas por segundo
	tamano: 4,           // radio en p√≠xeles
	color: "#fef08a",    // amarillo brillante
	estela: true,        // mostrar estela
	longitudEstela: 5,   // cantidad de posiciones en la estela
	frecuenciaEmision: 2000, // ms entre emisiones
};

/**
 * Hook para manejar la grilla de dibujo unifiliar
 *
 * @param {string} puestoId - ID del puesto actual
 * @param {string} workspaceId - ID del workspace actual
 * @returns {Object} Estado y funciones para manejar la grilla
 */
const useGrillaUnifilar = (puestoId, workspaceId) => {
	// Estado del dibujo: objeto con claves "x,y" y valores de color
	const [celdas, setCeldas] = useState({});
	// Textos: array de { id, x, y, texto, color, fuente, tamano, negrita, cursiva }
	const [textos, setTextos] = useState([]);
	// Modo edici√≥n activo
	const [modoEdicion, setModoEdicion] = useState(false);
	// Color seleccionado para pintar
	const [colorSeleccionado, setColorSeleccionado] = useState(COLORES_UNIFILAR[0].color);
	// Herramienta activa: "pincel", "borrador", "texto", "balde" o "mover"
	const [herramienta, setHerramienta] = useState("pincel");
	// Grosor de l√≠nea seleccionado (tama√±o de celda en p√≠xeles)
	const [grosorLinea, setGrosorLinea] = useState(GROSORES_LINEA[1].valor); // Normal por defecto
	// Estado de pintando (mouse presionado)
	const [estaPintando, setEstaPintando] = useState(false);
	// Punto inicial para l√≠neas rectas con Shift
	const puntoInicialRef = useRef(null);
	// Direcci√≥n bloqueada para Shift (null, "horizontal", "vertical")
	const direccionBloqueadaRef = useRef(null);

	// Configuraci√≥n de texto
	const [configTexto, setConfigTexto] = useState({
		fuente: FUENTES_DISPONIBLES[0].familia,
		tamano: 16,
		negrita: false,
		cursiva: false,
	});

	// Texto seleccionado para editar/eliminar
	const [textoSeleccionadoId, setTextoSeleccionadoId] = useState(null);

	// === SISTEMA DE BORNES Y CHISPAS ===
	// Bornes: array de { id, tipo, x, y, color, activo, frecuenciaMs, nombre }
	const [bornes, setBornes] = useState([]);
	// Configuraci√≥n de chispas
	const [chispasConfig, setChispasConfig] = useState(CONFIG_CHISPAS_DEFAULT);

	/**
	 * Genera la clave √∫nica de localStorage para este puesto/workspace
	 */
	const obtenerClave = useCallback(() => {
		if (!puestoId || !workspaceId) return null;
		return `${CLAVE_BASE}-${workspaceId}-${puestoId}`;
	}, [puestoId, workspaceId]);

	/**
	 * Cargar datos del localStorage al montar o cambiar de puesto
	 */
	useEffect(() => {
		const clave = obtenerClave();
		if (!clave) {
			setCeldas({});
			setTextos([]);
			setGrosorLinea(GROSORES_LINEA[1].valor);
			setBornes([]);
			setChispasConfig(CONFIG_CHISPAS_DEFAULT);
			return;
		}

		try {
			const datos = localStorage.getItem(clave);
			if (datos) {
				const parsed = JSON.parse(datos);
				// Compatibilidad: si es objeto plano (formato antiguo), son solo celdas
				if (parsed && typeof parsed === "object" && !parsed.celdas) {
					setCeldas(parsed);
					setTextos([]);
					setGrosorLinea(GROSORES_LINEA[1].valor);
					setBornes([]);
					setChispasConfig(CONFIG_CHISPAS_DEFAULT);
				} else {
					// Formato nuevo con celdas, textos, grosor, bornes y chispasConfig
					setCeldas(parsed.celdas || {});
					setTextos(parsed.textos || []);
					setGrosorLinea(parsed.grosor || GROSORES_LINEA[1].valor);
					setBornes(parsed.bornes || []);
					setChispasConfig(parsed.chispasConfig || CONFIG_CHISPAS_DEFAULT);
				}
			} else {
				setCeldas({});
				setTextos([]);
				setGrosorLinea(GROSORES_LINEA[1].valor);
				setBornes([]);
				setChispasConfig(CONFIG_CHISPAS_DEFAULT);
			}
		} catch (error) {
			console.error("Error al cargar grilla unifiliar:", error);
			setCeldas({});
			setTextos([]);
			setGrosorLinea(GROSORES_LINEA[1].valor);
			setBornes([]);
			setChispasConfig(CONFIG_CHISPAS_DEFAULT);
		}
	}, [obtenerClave]);

	/**
	 * Guardar en localStorage (celdas, textos, grosor, bornes y chispasConfig)
	 */
	const guardarDatos = useCallback((nuevasCeldas, nuevosTextos, nuevoGrosor = null, nuevosBornes = null, nuevaChispasConfig = null) => {
		const clave = obtenerClave();
		if (!clave) return;

		try {
			const sinCeldas = Object.keys(nuevasCeldas).length === 0;
			const sinTextos = nuevosTextos.length === 0;
			const bornesAGuardar = nuevosBornes !== null ? nuevosBornes : bornes;
			const sinBornes = bornesAGuardar.length === 0;

			if (sinCeldas && sinTextos && sinBornes) {
				localStorage.removeItem(clave);
			} else {
				localStorage.setItem(clave, JSON.stringify({
					celdas: nuevasCeldas,
					textos: nuevosTextos,
					grosor: nuevoGrosor !== null ? nuevoGrosor : grosorLinea,
					bornes: bornesAGuardar,
					chispasConfig: nuevaChispasConfig !== null ? nuevaChispasConfig : chispasConfig,
				}));
			}
		} catch (error) {
			console.error("Error al guardar grilla unifiliar:", error);
		}
	}, [obtenerClave, grosorLinea, bornes, chispasConfig]);

	/**
	 * Pintar una celda con el color seleccionado
	 * @param {number} x - Coordenada X de la celda
	 * @param {number} y - Coordenada Y de la celda
	 * @param {boolean} shiftPresionado - Si Shift est√° presionado para l√≠nea recta
	 */
	const pintarCelda = useCallback((x, y, shiftPresionado = false) => {
		let xFinal = x;
		let yFinal = y;

		// Si Shift est√° presionado, restringir a l√≠nea recta
		if (shiftPresionado && puntoInicialRef.current) {
			const { x: xInicial, y: yInicial } = puntoInicialRef.current;
			const deltaX = Math.abs(x - xInicial);
			const deltaY = Math.abs(y - yInicial);

			// Determinar direcci√≥n si no est√° bloqueada
			if (direccionBloqueadaRef.current === null && (deltaX > 1 || deltaY > 1)) {
				direccionBloqueadaRef.current = deltaX > deltaY ? "horizontal" : "vertical";
			}

			// Aplicar restricci√≥n seg√∫n direcci√≥n
			if (direccionBloqueadaRef.current === "horizontal") {
				yFinal = yInicial;
			} else if (direccionBloqueadaRef.current === "vertical") {
				xFinal = xInicial;
			}
		}

		const claveCelda = `${xFinal},${yFinal}`;

		setCeldas(prev => {
			let nuevasCeldas;

			if (herramienta === "borrador") {
				// Borrar celda
				nuevasCeldas = { ...prev };
				delete nuevasCeldas[claveCelda];
			} else {
				// Pintar celda con el color seleccionado
				nuevasCeldas = {
					...prev,
					[claveCelda]: colorSeleccionado
				};
			}

			// Guardar inmediatamente (usamos textos actuales)
			setTextos(currentTextos => {
				guardarDatos(nuevasCeldas, currentTextos);
				return currentTextos;
			});
			return nuevasCeldas;
		});
	}, [colorSeleccionado, herramienta, guardarDatos]);

	/**
	 * Limpiar todo el dibujo (celdas y textos)
	 */
	const limpiarTodo = useCallback(() => {
		setCeldas({});
		setTextos([]);
		guardarDatos({}, []);
	}, [guardarDatos]);

	/**
	 * Activar modo edici√≥n
	 */
	const activarEdicion = useCallback(() => {
		setModoEdicion(true);
	}, []);

	/**
	 * Desactivar modo edici√≥n
	 */
	const desactivarEdicion = useCallback(() => {
		setModoEdicion(false);
		setEstaPintando(false);
	}, []);

	/**
	 * Toggle modo edici√≥n
	 */
	const toggleEdicion = useCallback(() => {
		if (modoEdicion) {
			desactivarEdicion();
		} else {
			activarEdicion();
		}
	}, [modoEdicion, activarEdicion, desactivarEdicion]);

	/**
	 * Iniciar pintado (mouse down)
	 * @param {number} x - Coordenada X inicial
	 * @param {number} y - Coordenada Y inicial
	 */
	const iniciarPintado = useCallback((x, y) => {
		setEstaPintando(true);
		// Guardar punto inicial para l√≠neas rectas con Shift
		puntoInicialRef.current = { x, y };
		direccionBloqueadaRef.current = null;
	}, []);

	/**
	 * Detener pintado (mouse up)
	 */
	const detenerPintado = useCallback(() => {
		setEstaPintando(false);
		// Limpiar punto inicial
		puntoInicialRef.current = null;
		direccionBloqueadaRef.current = null;
	}, []);

	/**
	 * Seleccionar herramienta pincel
	 */
	const seleccionarPincel = useCallback(() => {
		setHerramienta("pincel");
	}, []);

	/**
	 * Seleccionar herramienta borrador
	 */
	const seleccionarBorrador = useCallback(() => {
		setHerramienta("borrador");
		setTextoSeleccionadoId(null);
	}, []);

	/**
	 * Seleccionar herramienta texto
	 */
	const seleccionarTexto = useCallback(() => {
		setHerramienta("texto");
	}, []);

	/**
	 * Seleccionar herramienta balde (flood fill)
	 */
	const seleccionarBalde = useCallback(() => {
		setHerramienta("balde");
		setTextoSeleccionadoId(null);
	}, []);

	/**
	 * Seleccionar herramienta mover (arrastrar l√≠neas conectadas)
	 */
	const seleccionarMover = useCallback(() => {
		setHerramienta("mover");
		setTextoSeleccionadoId(null);
	}, []);

	/**
	 * Obtener todas las celdas conectadas a una celda dada (BFS)
	 * Retorna un array de claves "x,y" de las celdas conectadas del mismo color
	 * @param {number} x - Coordenada X de la celda inicial
	 * @param {number} y - Coordenada Y de la celda inicial
	 * @param {Object} celdasActuales - Objeto de celdas actual
	 * @returns {Array<string>} Array de claves de celdas conectadas
	 */
	const obtenerCeldasConectadas = useCallback((x, y, celdasActuales) => {
		const claveCelda = `${x},${y}`;
		const colorOriginal = celdasActuales[claveCelda];

		if (!colorOriginal) return []; // No hay celda pintada en esa posici√≥n

		const visitadas = new Set();
		const cola = [[x, y]];
		const celdasConectadas = [];

		while (cola.length > 0) {
			const [cx, cy] = cola.shift();
			const claveActual = `${cx},${cy}`;

			if (visitadas.has(claveActual)) continue;
			visitadas.add(claveActual);

			// Solo incluir celdas que tengan el mismo color
			if (celdasActuales[claveActual] !== colorOriginal) continue;

			celdasConectadas.push(claveActual);

			// Agregar vecinos a la cola (arriba, abajo, izquierda, derecha)
			cola.push([cx, cy - 1]); // arriba
			cola.push([cx, cy + 1]); // abajo
			cola.push([cx - 1, cy]); // izquierda
			cola.push([cx + 1, cy]); // derecha
		}

		return celdasConectadas;
	}, []);

	/**
	 * Mover todas las celdas conectadas por un delta
	 * @param {Array<string>} celdasAMover - Array de claves "x,y" a mover
	 * @param {number} deltaX - Desplazamiento en X (en unidades de celda)
	 * @param {number} deltaY - Desplazamiento en Y (en unidades de celda)
	 */
	const moverCeldasConectadas = useCallback((celdasAMover, deltaX, deltaY) => {
		if (deltaX === 0 && deltaY === 0) return;
		if (celdasAMover.length === 0) return;

		setCeldas(prev => {
			const nuevasCeldas = { ...prev };

			// Primero, remover todas las celdas que vamos a mover
			const coloresOriginales = {};
			celdasAMover.forEach(clave => {
				coloresOriginales[clave] = prev[clave];
				delete nuevasCeldas[clave];
			});

			// Luego, agregar las celdas en sus nuevas posiciones
			celdasAMover.forEach(clave => {
				const [x, y] = clave.split(",").map(Number);
				const nuevaClave = `${x + deltaX},${y + deltaY}`;
				nuevasCeldas[nuevaClave] = coloresOriginales[clave];
			});

			// Guardar
			setTextos(currentTextos => {
				guardarDatos(nuevasCeldas, currentTextos);
				return currentTextos;
			});

			return nuevasCeldas;
		});
	}, [guardarDatos]);

	/**
	 * Borrar todas las celdas dentro de un √°rea rectangular
	 * @param {number} x1 - Coordenada X de la esquina inicial
	 * @param {number} y1 - Coordenada Y de la esquina inicial
	 * @param {number} x2 - Coordenada X de la esquina final
	 * @param {number} y2 - Coordenada Y de la esquina final
	 */
	const borrarArea = useCallback((x1, y1, x2, y2) => {
		// Normalizar coordenadas (asegurar que min <= max)
		const minX = Math.min(x1, x2);
		const maxX = Math.max(x1, x2);
		const minY = Math.min(y1, y2);
		const maxY = Math.max(y1, y2);

		setCeldas(prev => {
			const nuevasCeldas = { ...prev };
			let huboCambios = false;

			// Iterar sobre todas las celdas del √°rea y eliminarlas
			for (let x = minX; x <= maxX; x++) {
				for (let y = minY; y <= maxY; y++) {
					const clave = `${x},${y}`;
					if (nuevasCeldas[clave]) {
						delete nuevasCeldas[clave];
						huboCambios = true;
					}
				}
			}

			if (!huboCambios) return prev;

			// Guardar
			setTextos(currentTextos => {
				guardarDatos(nuevasCeldas, currentTextos);
				return currentTextos;
			});

			return nuevasCeldas;
		});
	}, [guardarDatos]);

	/**
	 * Rellenar todas las celdas conectadas con el color seleccionado (flood fill)
	 * Busca celdas adyacentes (arriba, abajo, izquierda, derecha) del mismo color original
	 * @param {number} x - Coordenada X de la celda inicial
	 * @param {number} y - Coordenada Y de la celda inicial
	 */
	const rellenarConectadas = useCallback((x, y) => {
		const claveCelda = `${x},${y}`;

		setCeldas(prev => {
			// Verificar que la celda inicial existe y tiene un color
			const colorOriginal = prev[claveCelda];
			if (!colorOriginal) return prev; // No hay celda pintada en esa posici√≥n

			// Si el color original es igual al seleccionado, no hacer nada
			if (colorOriginal === colorSeleccionado) return prev;

			// Conjunto de celdas visitadas
			const visitadas = new Set();
			// Cola para BFS (Breadth-First Search)
			const cola = [[x, y]];
			// Celdas a cambiar
			const celdasARellenar = [];

			while (cola.length > 0) {
				const [cx, cy] = cola.shift();
				const claveActual = `${cx},${cy}`;

				// Si ya visitamos esta celda, saltar
				if (visitadas.has(claveActual)) continue;
				visitadas.add(claveActual);

				// Si la celda no existe o no tiene el color original, saltar
				if (prev[claveActual] !== colorOriginal) continue;

				// Agregar a la lista de celdas a rellenar
				celdasARellenar.push(claveActual);

				// Agregar vecinos a la cola (arriba, abajo, izquierda, derecha)
				cola.push([cx, cy - 1]); // arriba
				cola.push([cx, cy + 1]); // abajo
				cola.push([cx - 1, cy]); // izquierda
				cola.push([cx + 1, cy]); // derecha
			}

			// Crear nuevo objeto de celdas con las celdas rellenadas
			const nuevasCeldas = { ...prev };
			celdasARellenar.forEach(clave => {
				nuevasCeldas[clave] = colorSeleccionado;
			});

			// Guardar
			setTextos(currentTextos => {
				guardarDatos(nuevasCeldas, currentTextos);
				return currentTextos;
			});

			return nuevasCeldas;
		});
	}, [colorSeleccionado, guardarDatos]);

	/**
	 * Agregar un nuevo texto
	 * @param {number} x - Coordenada X en p√≠xeles
	 * @param {number} y - Coordenada Y en p√≠xeles
	 * @param {string} contenido - Texto a mostrar
	 */
	const agregarTexto = useCallback((x, y, contenido) => {
		if (!contenido.trim()) return;

		const nuevoTexto = {
			id: `texto-${Date.now()}`,
			x,
			y,
			texto: contenido,
			color: colorSeleccionado,
			fuente: configTexto.fuente,
			tamano: configTexto.tamano,
			negrita: configTexto.negrita,
			cursiva: configTexto.cursiva,
		};

		setTextos(prev => {
			const nuevosTextos = [...prev, nuevoTexto];
			setCeldas(currentCeldas => {
				guardarDatos(currentCeldas, nuevosTextos);
				return currentCeldas;
			});
			return nuevosTextos;
		});
	}, [colorSeleccionado, configTexto, guardarDatos]);

	/**
	 * Actualizar un texto existente
	 */
	const actualizarTexto = useCallback((id, cambios) => {
		setTextos(prev => {
			const nuevosTextos = prev.map(t =>
				t.id === id ? { ...t, ...cambios } : t
			);
			setCeldas(currentCeldas => {
				guardarDatos(currentCeldas, nuevosTextos);
				return currentCeldas;
			});
			return nuevosTextos;
		});
	}, [guardarDatos]);

	/**
	 * Eliminar un texto
	 */
	const eliminarTexto = useCallback((id) => {
		setTextos(prev => {
			const nuevosTextos = prev.filter(t => t.id !== id);
			setCeldas(currentCeldas => {
				guardarDatos(currentCeldas, nuevosTextos);
				return currentCeldas;
			});
			return nuevosTextos;
		});
		setTextoSeleccionadoId(null);
	}, [guardarDatos]);

	/**
	 * Cambiar el grosor de l√≠nea y guardar
	 */
	const cambiarGrosor = useCallback((nuevoGrosor) => {
		setGrosorLinea(nuevoGrosor);
		// Guardar inmediatamente con el nuevo grosor
		setCeldas(currentCeldas => {
			setTextos(currentTextos => {
				guardarDatos(currentCeldas, currentTextos, nuevoGrosor);
				return currentTextos;
			});
			return currentCeldas;
		});
	}, [guardarDatos]);

	// === FUNCIONES CRUD PARA BORNES ===

	/**
	 * Seleccionar herramienta borne
	 * @param {string} tipo - "EMISOR" o "RECEPTOR"
	 */
	const seleccionarBorne = useCallback((tipo) => {
		setHerramienta("borne");
		// El tipo se pasa como par√°metro a agregarBorne
	}, []);

	/**
	 * Agregar un nuevo borne en una celda
	 * @param {number} x - Coordenada X de la celda
	 * @param {number} y - Coordenada Y de la celda
	 * @param {string} tipo - "EMISOR" o "RECEPTOR"
	 * @returns {boolean} - true si se agreg√≥ correctamente
	 */
	const agregarBorne = useCallback((x, y, tipo) => {
		const claveCelda = `${x},${y}`;

		// Verificar que la celda tenga una l√≠nea pintada
		if (!celdas[claveCelda]) {
			console.warn("Solo se pueden colocar bornes sobre l√≠neas pintadas");
			return false;
		}

		// Verificar que no haya otro borne en la misma posici√≥n
		if (bornes.some(b => b.x === x && b.y === y)) {
			console.warn("Ya existe un borne en esta posici√≥n");
			return false;
		}

		const contadorTipo = bornes.filter(b => b.tipo === tipo).length + 1;
		const nuevoBorne = {
			id: `borne-${Date.now()}`,
			tipo,
			x,
			y,
			color: tipo === TIPOS_BORNE.EMISOR ? "#22d3ee" : "#f97316",
			activo: true,
			frecuenciaMs: chispasConfig.frecuenciaEmision,
			nombre: `${tipo === TIPOS_BORNE.EMISOR ? "E" : "R"}${contadorTipo}`,
		};

		const nuevosBornes = [...bornes, nuevoBorne];
		setBornes(nuevosBornes);

		// Guardar inmediatamente
		setCeldas(currentCeldas => {
			setTextos(currentTextos => {
				guardarDatos(currentCeldas, currentTextos, grosorLinea, nuevosBornes);
				return currentTextos;
			});
			return currentCeldas;
		});

		return true;
	}, [celdas, bornes, chispasConfig.frecuenciaEmision, grosorLinea, guardarDatos]);

	/**
	 * Eliminar un borne por su ID
	 * @param {string} borneId - ID del borne a eliminar
	 */
	const eliminarBorne = useCallback((borneId) => {
		const nuevosBornes = bornes.filter(b => b.id !== borneId);
		setBornes(nuevosBornes);

		// Guardar inmediatamente
		setCeldas(currentCeldas => {
			setTextos(currentTextos => {
				guardarDatos(currentCeldas, currentTextos, grosorLinea, nuevosBornes);
				return currentTextos;
			});
			return currentCeldas;
		});
	}, [bornes, grosorLinea, guardarDatos]);

	/**
	 * Eliminar borne en una posici√≥n espec√≠fica
	 * @param {number} x - Coordenada X
	 * @param {number} y - Coordenada Y
	 * @returns {boolean} - true si se elimin√≥ un borne
	 */
	const eliminarBorneEnPosicion = useCallback((x, y) => {
		const borneEnPosicion = bornes.find(b => b.x === x && b.y === y);
		if (borneEnPosicion) {
			eliminarBorne(borneEnPosicion.id);
			return true;
		}
		return false;
	}, [bornes, eliminarBorne]);

	/**
	 * Actualizar propiedades de un borne
	 * @param {string} borneId - ID del borne
	 * @param {Object} cambios - Propiedades a actualizar
	 */
	const actualizarBorne = useCallback((borneId, cambios) => {
		const nuevosBornes = bornes.map(b =>
			b.id === borneId ? { ...b, ...cambios } : b
		);
		setBornes(nuevosBornes);

		// Guardar inmediatamente
		setCeldas(currentCeldas => {
			setTextos(currentTextos => {
				guardarDatos(currentCeldas, currentTextos, grosorLinea, nuevosBornes);
				return currentTextos;
			});
			return currentCeldas;
		});
	}, [bornes, grosorLinea, guardarDatos]);

	/**
	 * Actualizar configuraci√≥n de chispas
	 * @param {Object} nuevaConfig - Nueva configuraci√≥n (parcial o completa)
	 */
	const actualizarChispasConfig = useCallback((nuevaConfig) => {
		const configActualizada = { ...chispasConfig, ...nuevaConfig };
		setChispasConfig(configActualizada);

		// Guardar inmediatamente
		setCeldas(currentCeldas => {
			setTextos(currentTextos => {
				guardarDatos(currentCeldas, currentTextos, grosorLinea, bornes, configActualizada);
				return currentTextos;
			});
			return currentCeldas;
		});
	}, [chispasConfig, grosorLinea, bornes, guardarDatos]);

	/**
	 * Obtener borne en una posici√≥n espec√≠fica
	 * @param {number} x - Coordenada X
	 * @param {number} y - Coordenada Y
	 * @returns {Object|null} - Borne encontrado o null
	 */
	const obtenerBorneEnPosicion = useCallback((x, y) => {
		return bornes.find(b => b.x === x && b.y === y) || null;
	}, [bornes]);

	/**
	 * Exportar el dibujo a un archivo JSON
	 */
	const exportarAArchivo = useCallback(() => {
		const datos = {
			version: 1,
			celdas,
			textos,
			grosor: grosorLinea,
			exportadoEn: new Date().toISOString(),
		};

		const blob = new Blob([JSON.stringify(datos, null, 2)], { type: "application/json" });
		const url = URL.createObjectURL(blob);
		const link = document.createElement("a");
		link.href = url;
		link.download = `diagrama-unifiliar-${puestoId || "sin-puesto"}.json`;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
		URL.revokeObjectURL(url);
	}, [celdas, textos, grosorLinea, puestoId]);

	/**
	 * Importar un dibujo desde un archivo JSON
	 * @param {File} archivo - Archivo JSON a importar
	 * @returns {Promise<boolean>} - true si se import√≥ correctamente
	 */
	const importarDesdeArchivo = useCallback((archivo) => {
		return new Promise((resolve) => {
			const reader = new FileReader();

			reader.onload = (e) => {
				try {
					const datos = JSON.parse(e.target.result);

					// Validar estructura b√°sica
					if (!datos || typeof datos !== "object") {
						console.error("Archivo inv√°lido: no es un objeto JSON");
						resolve(false);
						return;
					}

					// Extraer datos (compatible con formato antiguo y nuevo)
					const nuevasCeldas = datos.celdas || (datos.version ? {} : datos);
					const nuevosTextos = datos.textos || [];
					const nuevoGrosor = datos.grosor || GROSORES_LINEA[1].valor;

					// Validar que celdas sea un objeto
					if (typeof nuevasCeldas !== "object" || Array.isArray(nuevasCeldas)) {
						console.error("Archivo inv√°lido: celdas no es un objeto");
						resolve(false);
						return;
					}

					// Aplicar los datos importados
					setCeldas(nuevasCeldas);
					setTextos(nuevosTextos);
					setGrosorLinea(nuevoGrosor);
					guardarDatos(nuevasCeldas, nuevosTextos, nuevoGrosor);

					resolve(true);
				} catch (error) {
					console.error("Error al parsear archivo JSON:", error);
					resolve(false);
				}
			};

			reader.onerror = () => {
				console.error("Error al leer archivo");
				resolve(false);
			};

			reader.readAsText(archivo);
		});
	}, [guardarDatos]);

	/**
	 * Verificar si hay celdas o textos dibujados
	 */
	const tieneDibujo = Object.keys(celdas).length > 0 || textos.length > 0;

	return {
		// Estado
		celdas,
		textos,
		modoEdicion,
		colorSeleccionado,
		herramienta,
		estaPintando,
		tieneDibujo,
		grosorLinea,

		// Configuraci√≥n de texto
		configTexto,
		setConfigTexto,
		textoSeleccionadoId,
		setTextoSeleccionadoId,

		// Colores, fuentes y grosores disponibles
		coloresDisponibles: COLORES_UNIFILAR,
		fuentesDisponibles: FUENTES_DISPONIBLES,
		tamanosDisponibles: TAMANOS_FUENTE,
		grosoresDisponibles: GROSORES_LINEA,

		// Acciones de edici√≥n
		toggleEdicion,
		activarEdicion,
		desactivarEdicion,

		// Acciones de pintado
		pintarCelda,
		limpiarTodo,
		iniciarPintado,
		detenerPintado,
		rellenarConectadas,
		borrarArea,

		// Acciones de texto
		agregarTexto,
		actualizarTexto,
		eliminarTexto,

		// Selecci√≥n de herramientas
		setColorSeleccionado,
		seleccionarPincel,
		seleccionarBorrador,
		seleccionarTexto,
		seleccionarBalde,
		seleccionarMover,

		// Funciones para mover l√≠neas conectadas
		obtenerCeldasConectadas,
		moverCeldasConectadas,

		// Grosor de l√≠nea
		cambiarGrosor,

		// Importar/Exportar archivo
		exportarAArchivo,
		importarDesdeArchivo,

		// === SISTEMA DE BORNES Y CHISPAS ===
		bornes,
		chispasConfig,
		tiposBorne: TIPOS_BORNE,

		// Acciones de bornes
		seleccionarBorne,
		agregarBorne,
		eliminarBorne,
		eliminarBorneEnPosicion,
		actualizarBorne,
		obtenerBorneEnPosicion,

		// Configuraci√≥n de chispas
		actualizarChispasConfig,
	};
};

export default useGrillaUnifilar;

// ===== ./src/paginas/PaginaAlimentadores/hooks/useHistorialLocal.js =====

/**
 * Hook para manejar el historial local de lecturas
 * Usa IndexedDB como cach√© inteligente que se auto-alimenta:
 * - Guarda lecturas del polling en tiempo real
 * - Cachea datos remotos cuando se consultan por primera vez
 * - Evita duplicados por timestamp
 */

import { useState, useCallback, useRef, useEffect } from "react";
import {
  abrirDB,
  guardarLectura,
  obtenerLecturasRango,
  limpiarLecturasAntiguas,
  obtenerEstadisticas,
  cachearLecturasRemotas,
  limpiarTodo,
} from "../utilidades/indexedDBHelper";
import { obtenerLecturasHistoricasPorRegistrador } from "@/servicios/apiService";
import {
  HORAS_RETENCION_LOCAL,
  UMBRAL_COBERTURA_CACHE,
  UMBRAL_COBERTURA_REMOTO,
  MARGEN_LIMITE_LOCAL_MS,
  MAX_ANTIGUEDAD_CACHE_MINUTOS,
} from "../constantes/historialConfig";

export const useHistorialLocal = () => {
  const [cargando, setCargando] = useState(false);
  const [error, setError] = useState(null);
  const [estadisticas, setEstadisticas] = useState(null);
  const [dbLista, setDbLista] = useState(false); // Indica cuando IndexedDB est√° lista

  // Estado de precarga de 48h
  const [precargaProgreso, setPrecargaProgreso] = useState(0); // 0-100
  const [precargaCompleta, setPrecargaCompleta] = useState(false);
  const [precargando, setPrecargando] = useState(false);
  const [datosDeBD, setDatosDeBD] = useState(false); // Indica si los datos fueron descargados de la BD
  const precargaAbortRef = useRef(false);

  const dbRef = useRef(null);

  // Inicializar IndexedDB
  useEffect(() => {
    const init = async () => {
      // Si ya tenemos conexi√≥n, marcar como lista
      if (dbRef.current) {
        setDbLista(true);
        return;
      }

      try {
        dbRef.current = await abrirDB();

        // Limpiar datos antiguos al iniciar
        const eliminados = await limpiarLecturasAntiguas(
          dbRef.current,
          HORAS_RETENCION_LOCAL
        );
        if (eliminados > 0) {
          console.log(`[Historial] Limpiados ${eliminados} registros antiguos`);
        }

        // Obtener estad√≠sticas
        const stats = await obtenerEstadisticas(dbRef.current);
        setEstadisticas(stats);

        // Marcar como lista
        setDbLista(true);

      } catch (err) {
        console.error("[Historial] Error inicializando IndexedDB:", err);
      }
    };

    init();
  }, []);

  /**
   * Guarda una lectura en IndexedDB (llamado desde el polling)
   */
  const guardarLecturaLocal = useCallback(
    async (alimentadorId, registradorId, zona, lectura) => {
      if (!dbRef.current) return;

      try {
        await guardarLectura(dbRef.current, {
          alimentadorId,
          registradorId,
          zona,
          timestamp: lectura.timestamp || Date.now(),
          valores: lectura.valores,
          indiceInicial: lectura.indice_inicial ?? lectura.indiceInicial ?? 0,
          exito: lectura.exito !== false,
        });
      } catch (err) {
        // No logueamos errores de guardado para no saturar la consola
        // ya que el polling es frecuente
      }
    },
    []
  );

  /**
   * Consulta datos remotos y los cachea en IndexedDB
   * @returns {Array} Datos remotos ya normalizados
   */
  const consultarYCachearRemoto = useCallback(
    async (alimentadorId, registradorId, zona, desde, hasta) => {
      // Consultar al backend
      const datosRemotos = await obtenerLecturasHistoricasPorRegistrador(
        registradorId,
        new Date(desde).toISOString(),
        new Date(hasta).toISOString()
      );

      if (!datosRemotos || datosRemotos.length === 0) {
        return [];
      }

      // Cachear los datos remotos antes de devolverlos
      // Esto asegura que consultas posteriores m√°s cortas encuentren los datos en local
      if (dbRef.current) {
        try {
          const guardadas = await cachearLecturasRemotas(
            dbRef.current,
            alimentadorId,
            registradorId,
            zona,
            datosRemotos
          );
          console.log("[Historial] CACHEO COMPLETADO:", {
            alimentadorId,
            registradorId,
            zona,
            lecturasRecibidas: datosRemotos.length,
            lecturasGuardadas: guardadas,
            rangoGuardado: datosRemotos.length > 0 ? {
              desde: new Date(Math.min(...datosRemotos.map(d =>
                typeof d.timestamp === 'string' ? new Date(d.timestamp).getTime() : d.timestamp
              ))).toISOString(),
              hasta: new Date(Math.max(...datosRemotos.map(d =>
                typeof d.timestamp === 'string' ? new Date(d.timestamp).getTime() : d.timestamp
              ))).toISOString()
            } : null
          });
        } catch (err) {
          console.error("[Historial] Error en cacheo:", err);
        }
      }

      // Normalizar timestamps a milisegundos para consistencia
      return datosRemotos.map((l) => ({
        ...l,
        timestamp:
          typeof l.timestamp === "string"
            ? new Date(l.timestamp).getTime()
            : l.timestamp,
        indiceInicial: l.indice_inicial ?? l.indiceInicial ?? 0,
      }));
    },
    []
  );

  /**
   * Obtiene datos para el gr√°fico (l√≥gica h√≠brida con cache inteligente)
   *
   * Estrategia:
   * - Si precargaCompleta = true, SIEMPRE usar solo local (sin verificaci√≥n de cobertura)
   * - Si no hay precarga completa:
   *   1. Intentar local primero
   *   2. Si local est√° vac√≠o o incompleto, ir a remoto
   *   3. Cachear datos remotos para futuras consultas
   *
   * @param {boolean} forzarSoloLocal - Si true, fuerza usar solo datos locales sin ir a remoto
   */
  const obtenerDatosGrafico = useCallback(
    async (alimentadorId, registradorId, zona, desde, hasta, forzarSoloLocal = false) => {
      setCargando(true);
      setError(null);

      try {
        const ahora = Date.now();
        // A√±adir margen al l√≠mite para evitar edge cases
        // cuando el usuario selecciona exactamente 48h
        const limiteLocal = ahora - (HORAS_RETENCION_LOCAL * 60 * 60 * 1000) - MARGEN_LIMITE_LOCAL_MS;

        // Calcular si el rango solicitado est√° dentro de las 48h de retenci√≥n local
        const rangoSolicitadoMs = hasta - desde;
        const rangoMaximoLocalMs = HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
        const rangoExcede48h = rangoSolicitadoMs > rangoMaximoLocalMs;

        // MODO PRECARGA COMPLETA: usar SOLO datos locales, pero solo si el rango es ‚â§ 48h
        // Para rangos > 48h, SIEMPRE ir a remoto
        if (forzarSoloLocal && !rangoExcede48h) {
          let datosLocales = [];
          if (dbRef.current) {
            datosLocales = await obtenerLecturasRango(
              dbRef.current,
              alimentadorId,
              registradorId,
              zona,
              desde,
              hasta
            );
          }

          console.log("[Historial] MODO SOLO LOCAL (precarga completa):", {
            alimentadorId,
            registradorId,
            zona,
            rangoBuscado: {
              desde: new Date(desde).toISOString(),
              hasta: new Date(hasta).toISOString(),
              horasSolicitadas: rangoSolicitadoMs / (1000 * 60 * 60)
            },
            datosEncontrados: datosLocales.length,
          });

          return { datos: datosLocales, fuente: "local" };
        }

        // Para rangos > 48h, ir directo a remoto
        if (rangoExcede48h) {
          console.log("[Historial] Rango excede 48h, consultando remoto:", {
            horasSolicitadas: rangoSolicitadoMs / (1000 * 60 * 60),
          });

          const datosRemotos = await consultarYCachearRemoto(
            alimentadorId,
            registradorId,
            zona,
            desde,
            hasta
          );
          return { datos: datosRemotos, fuente: "remoto" };
        }

        // MODO NORMAL (h√≠brido): verificar cobertura y complementar con remoto si es necesario

        // Caso 1: Todo el rango est√° dentro del periodo local (48h + margen)
        if (desde >= limiteLocal) {
          // Intentar obtener de local si est√° disponible
          let datosLocales = [];
          if (dbRef.current) {
            datosLocales = await obtenerLecturasRango(
              dbRef.current,
              alimentadorId,
              registradorId,
              zona,
              desde,
              hasta
            );
          }

          console.log("[Historial] CONSULTA LOCAL:", {
            alimentadorId,
            registradorId,
            zona,
            rangoBuscado: {
              desde: new Date(desde).toISOString(),
              hasta: new Date(hasta).toISOString(),
              horasSolicitadas: (hasta - desde) / (1000 * 60 * 60)
            },
            datosEncontrados: datosLocales.length,
            rangoEncontrado: datosLocales.length > 0 ? {
              primero: new Date(Math.min(...datosLocales.map(d => d.timestamp))).toISOString(),
              ultimo: new Date(Math.max(...datosLocales.map(d => d.timestamp))).toISOString()
            } : null
          });

          // Verificar si los datos locales cubren el rango solicitado
          if (datosLocales.length > 0) {
            const primerTimestamp = Math.min(...datosLocales.map((d) => d.timestamp));

            // Calcular cu√°nto tiempo de datos tenemos vs cu√°nto pedimos
            const rangoSolicitadoMs = hasta - desde;
            const rangoCubiertoMs = hasta - primerTimestamp;
            const porcentajeCubierto = rangoCubiertoMs / rangoSolicitadoMs;

            console.log("[Historial] COBERTURA:", {
              rangoSolicitadoHoras: rangoSolicitadoMs / (1000 * 60 * 60),
              rangoCubiertoHoras: rangoCubiertoMs / (1000 * 60 * 60),
              porcentaje: (porcentajeCubierto * 100).toFixed(1) + "%",
              decision: porcentajeCubierto < UMBRAL_COBERTURA_REMOTO ? "IR A REMOTO" : "USAR LOCAL"
            });

            // Si cubrimos menos del umbral, consultar remoto para completar
            if (porcentajeCubierto < UMBRAL_COBERTURA_REMOTO) {
              const datosRemotos = await consultarYCachearRemoto(
                alimentadorId,
                registradorId,
                zona,
                desde,
                hasta
              );

              // Combinar remotos + locales y deduplicar
              const mapaTimestamps = new Map();
              for (const dato of datosRemotos) {
                mapaTimestamps.set(dato.timestamp, dato);
              }
              for (const dato of datosLocales) {
                mapaTimestamps.set(dato.timestamp, dato);
              }
              const datosCombinados = Array.from(mapaTimestamps.values());
              datosCombinados.sort((a, b) => a.timestamp - b.timestamp);

              return { datos: datosCombinados, fuente: "mixto" };
            }

            return { datos: datosLocales, fuente: "local" };
          }

          // FALLBACK: Si no hay datos locales o IndexedDB no disponible, consultar remoto
          const datosRemotos = await consultarYCachearRemoto(
            alimentadorId,
            registradorId,
            zona,
            desde,
            hasta
          );
          return { datos: datosRemotos, fuente: "remoto" };
        }

        // Caso 2: Todo el rango est√° fuera del periodo local (>48h atr√°s)
        if (hasta < limiteLocal) {
          // Primero intentar local (por si ya cacheamos antes)
          let datosLocales = [];
          if (dbRef.current) {
            datosLocales = await obtenerLecturasRango(
              dbRef.current,
              alimentadorId,
              registradorId,
              zona,
              desde,
              hasta
            );
          }

          // Si hay datos locales (cacheados previamente), usarlos
          if (datosLocales.length > 0) {
            return { datos: datosLocales, fuente: "local" };
          }

          // Si no, ir a remoto y cachear
          const datosRemotos = await consultarYCachearRemoto(
            alimentadorId,
            registradorId,
            zona,
            desde,
            hasta
          );
          return { datos: datosRemotos, fuente: "remoto" };
        }

        // Caso 3: Rango mixto (parte antigua, parte reciente)
        // Primero intentar obtener TODO desde local (por si ya cacheamos)
        let datosLocalesCompletos = [];
        if (dbRef.current) {
          datosLocalesCompletos = await obtenerLecturasRango(
            dbRef.current,
            alimentadorId,
            registradorId,
            zona,
            desde,
            hasta
          );
        }

        // Si hay suficientes datos locales, usarlos
        // (Heur√≠stica: si hay al menos algunos puntos, probablemente tenemos todo)
        if (datosLocalesCompletos.length > 0) {
          // Verificar si cubrimos el rango consultando el primer timestamp
          const primerTimestamp = Math.min(...datosLocalesCompletos.map((d) => d.timestamp));

          // Si el primer dato est√° cerca del inicio del rango (dentro de 5 min), asumir completo
          if (primerTimestamp <= desde + 5 * 60 * 1000) {
            return { datos: datosLocalesCompletos, fuente: "local" };
          }
        }

        // Necesitamos combinar: remoto para la parte antigua + local para reciente
        const datosRemotosAntiguos = await consultarYCachearRemoto(
          alimentadorId,
          registradorId,
          zona,
          desde,
          limiteLocal
        );

        // Obtener datos locales frescos (desde el l√≠mite hasta ahora)
        let datosLocalesRecientes = [];
        if (dbRef.current) {
          datosLocalesRecientes = await obtenerLecturasRango(
            dbRef.current,
            alimentadorId,
            registradorId,
            zona,
            limiteLocal,
            hasta
          );
        }

        // Si no hay datos locales recientes, intentar remoto tambi√©n para esa parte
        if (datosLocalesRecientes.length === 0) {
          const datosRemotosRecientes = await consultarYCachearRemoto(
            alimentadorId,
            registradorId,
            zona,
            limiteLocal,
            hasta
          );
          datosLocalesRecientes = datosRemotosRecientes;
        }

        // Combinar y deduplicar por timestamp
        const mapaTimestamps = new Map();

        // Primero agregar remotos antiguos
        for (const dato of datosRemotosAntiguos) {
          mapaTimestamps.set(dato.timestamp, dato);
        }

        // Luego agregar locales recientes (sobrescriben si hay duplicados)
        for (const dato of datosLocalesRecientes) {
          mapaTimestamps.set(dato.timestamp, dato);
        }

        // Convertir a array y ordenar
        const datosCombinados = Array.from(mapaTimestamps.values());
        datosCombinados.sort((a, b) => a.timestamp - b.timestamp);

        return { datos: datosCombinados, fuente: "mixto" };
      } catch (err) {
        console.error("[Historial] Error obteniendo datos:", err);
        setError(err.message);
        return { datos: [], fuente: "error" };
      } finally {
        setCargando(false);
      }
    },
    [consultarYCachearRemoto]
  );

  /**
   * Verifica si ya hay datos suficientes y recientes en cache para un registrador/zona
   * @returns {Promise<boolean>} true si el cache ya tiene datos suficientes y recientes
   */
  const verificarCacheExistente = useCallback(
    async (alimentadorId, registradorId, zona) => {
      if (!dbRef.current || !registradorId) return false;

      const ahora = Date.now();
      const desde = ahora - HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
      const hasta = ahora;

      try {
        const datosLocales = await obtenerLecturasRango(
          dbRef.current,
          alimentadorId,
          registradorId,
          zona,
          desde,
          hasta
        );

        if (datosLocales.length === 0) return false;

        // Verificar cobertura temporal
        const primerTimestamp = Math.min(...datosLocales.map((d) => d.timestamp));
        const ultimoTimestamp = Math.max(...datosLocales.map((d) => d.timestamp));
        const rangoSolicitadoMs = hasta - desde;
        const rangoCubiertoMs = hasta - primerTimestamp;
        const porcentajeCubierto = rangoCubiertoMs / rangoSolicitadoMs;

        // Verificar antig√ºedad del √∫ltimo dato
        const antiguedadUltimoDatoMs = ahora - ultimoTimestamp;
        const maxAntiguedadMs = MAX_ANTIGUEDAD_CACHE_MINUTOS * 60 * 1000;
        const datosRecientes = antiguedadUltimoDatoMs <= maxAntiguedadMs;

        // El cache es v√°lido si cubre el porcentaje requerido Y los datos son recientes
        const coberturaOK = porcentajeCubierto >= UMBRAL_COBERTURA_CACHE;
        const cacheValido = coberturaOK && datosRecientes;

        console.log(`[Historial] Cache existente para ${zona}:`, {
          registradorId,
          datosEncontrados: datosLocales.length,
          porcentajeCubierto: (porcentajeCubierto * 100).toFixed(1) + "%",
          antiguedadUltimoDato: Math.round(antiguedadUltimoDatoMs / 60000) + " min",
          maxAntiguedadPermitida: MAX_ANTIGUEDAD_CACHE_MINUTOS + " min",
          datosRecientes,
          cacheValido,
        });

        return cacheValido;
      } catch (err) {
        console.error("[Historial] Error verificando cache:", err);
        return false;
      }
    },
    []
  );

  /**
   * Precarga las √∫ltimas 48h de datos para ambas zonas
   * Se ejecuta de forma independiente al seleccionar el rango
   * Verifica primero si ya hay datos en cache para evitar recargas innecesarias
   *
   * IMPORTANTE: Cuando ambas zonas usan el mismo registrador pero diferentes
   * √≠ndices de registro, igual se debe guardar en cache para AMBAS zonas,
   * porque IndexedDB indexa por [alimentadorId, zona, timestamp]
   *
   * @param {string} alimentadorId - ID del alimentador
   * @param {string} registradorIdSuperior - ID del registrador de zona superior
   * @param {string} registradorIdInferior - ID del registrador de zona inferior
   * @returns {Promise<boolean>} - true si la precarga fue exitosa
   */
  const precargar48h = useCallback(
    async (alimentadorId, registradorIdSuperior, registradorIdInferior) => {
      // Resetear estado
      setPrecargaProgreso(0);
      setPrecargaCompleta(false);
      setPrecargando(true);
      setDatosDeBD(false);
      precargaAbortRef.current = false;

      const ahora = Date.now();
      const desde = ahora - HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
      const hasta = ahora;

      // Verificar si ya hay cache v√°lido para las zonas
      const cacheSuperiorOK = await verificarCacheExistente(
        alimentadorId,
        registradorIdSuperior,
        "superior"
      );
      const cacheInferiorOK = await verificarCacheExistente(
        alimentadorId,
        registradorIdInferior,
        "inferior"
      );

      // Si ambas zonas tienen cache v√°lido, no hacer nada
      if (cacheSuperiorOK && cacheInferiorOK) {
        console.log("[Historial] Cache ya v√°lido para ambas zonas, omitiendo precarga");
        setPrecargaProgreso(100);
        setPrecargaCompleta(true);
        setPrecargando(false);
        return true;
      }

      // Determinar qu√© zonas cargar y de qu√© registrador
      // IMPORTANTE: Si ambas zonas usan el mismo registrador, solo consultamos
      // una vez pero guardamos para AMBAS zonas
      const mismoRegistrador = registradorIdSuperior === registradorIdInferior;

      // Lista de tareas de consulta a la API (evitar duplicados cuando mismo registrador)
      const tareasConsulta = [];

      if (registradorIdSuperior && !cacheSuperiorOK) {
        tareasConsulta.push({ registradorId: registradorIdSuperior, zonas: ["superior"] });
      }

      if (registradorIdInferior && !cacheInferiorOK) {
        if (mismoRegistrador) {
          // Mismo registrador: agregar zona inferior a la consulta existente o crear nueva
          const consultaExistente = tareasConsulta.find(t => t.registradorId === registradorIdInferior);
          if (consultaExistente) {
            consultaExistente.zonas.push("inferior");
          } else {
            // Superior ya tiene cache, pero inferior no - consultar y guardar solo para inferior
            tareasConsulta.push({ registradorId: registradorIdInferior, zonas: ["inferior"] });
          }
        } else {
          // Diferente registrador: consulta independiente
          tareasConsulta.push({ registradorId: registradorIdInferior, zonas: ["inferior"] });
        }
      }

      if (tareasConsulta.length === 0) {
        console.log("[Historial] No hay registradores configurados para precargar");
        setPrecargando(false);
        setPrecargaCompleta(true);
        setPrecargaProgreso(100);
        return true;
      }

      // Calcular total de operaciones para el progreso
      const totalZonas = tareasConsulta.reduce((sum, t) => sum + t.zonas.length, 0);
      const progresoPorZona = 100 / totalZonas;
      let progresoActual = 0;

      try {
        for (const tarea of tareasConsulta) {
          if (precargaAbortRef.current) {
            console.log("[Historial] Precarga abortada");
            setPrecargando(false);
            return false;
          }

          console.log(`[Historial] Precargando registrador ${tarea.registradorId} para zonas: ${tarea.zonas.join(", ")}...`);

          // Actualizar progreso al iniciar
          setPrecargaProgreso(Math.round(progresoActual + progresoPorZona * 0.1));

          // Consultar datos remotos (una sola vez por registrador)
          const datosRemotos = await obtenerLecturasHistoricasPorRegistrador(
            tarea.registradorId,
            new Date(desde).toISOString(),
            new Date(hasta).toISOString()
          );

          if (precargaAbortRef.current) {
            setPrecargando(false);
            return false;
          }

          // Actualizar progreso al 50%
          setPrecargaProgreso(Math.round(progresoActual + (progresoPorZona * tarea.zonas.length) * 0.5));

          if (datosRemotos && datosRemotos.length > 0 && dbRef.current) {
            // Marcar que los datos vinieron de la BD
            setDatosDeBD(true);
            // Cachear datos para CADA zona que lo necesita
            for (const zona of tarea.zonas) {
              const guardadas = await cachearLecturasRemotas(
                dbRef.current,
                alimentadorId,
                tarea.registradorId,
                zona,
                datosRemotos
              );

              console.log(`[Historial] Precarga ${zona} completada:`, {
                registradorId: tarea.registradorId,
                lecturasRecibidas: datosRemotos.length,
                lecturasGuardadas: guardadas,
              });

              progresoActual += progresoPorZona;
              setPrecargaProgreso(Math.round(progresoActual));
            }
          } else {
            console.log(`[Historial] No hay datos remotos para registrador ${tarea.registradorId}`);
            progresoActual += progresoPorZona * tarea.zonas.length;
            setPrecargaProgreso(Math.round(progresoActual));
          }
        }

        // Completado
        setPrecargaProgreso(100);
        setPrecargaCompleta(true);
        setPrecargando(false);

        console.log("[Historial] Precarga de 48h completada exitosamente");
        return true;
      } catch (err) {
        console.error("[Historial] Error en precarga:", err);
        setPrecargando(false);
        setPrecargaProgreso(0);
        // A√∫n as√≠ marcar como completa para que el componente pueda mostrar "sin datos"
        // en lugar de quedarse cargando infinitamente
        setPrecargaCompleta(true);
        return false;
      }
    },
    [verificarCacheExistente]
  );

  /**
   * Cancela la precarga en curso
   */
  const cancelarPrecarga = useCallback(() => {
    precargaAbortRef.current = true;
  }, []);

  /**
   * Resetea el estado de precarga (al cerrar modal)
   */
  const resetearPrecarga = useCallback(() => {
    precargaAbortRef.current = true;
    setPrecargaProgreso(0);
    setPrecargaCompleta(false);
    setPrecargando(false);
    setDatosDeBD(false);
  }, []);

  /**
   * Precarga datos para todos los alimentadores de un puesto
   * Se llama una sola vez cuando se abre cualquier ventana de historial del puesto
   * Beneficia a todas las dem√°s cards del mismo puesto
   *
   * @param {Array} alimentadores - Lista de alimentadores del puesto
   * @returns {Promise<boolean>} - true si la precarga fue exitosa
   */
  const precargarPuesto = useCallback(
    async (alimentadores) => {
      if (!alimentadores || alimentadores.length === 0) return true;

      // Resetear estado
      setPrecargaProgreso(0);
      setPrecargaCompleta(false);
      setPrecargando(true);
      setDatosDeBD(false);
      precargaAbortRef.current = false;

      const ahora = Date.now();
      const desde = ahora - HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
      const hasta = ahora;

      // Recopilar todas las tareas de precarga necesarias
      const tareasPendientes = [];

      for (const alimentador of alimentadores) {
        if (precargaAbortRef.current) break;

        const cardDesign = alimentador.card_design || {};

        // Obtener registradores de ambas zonas
        const regSuperior = cardDesign.superior?.registrador_id || alimentador.registrador_id;
        const regInferior = cardDesign.inferior?.registrador_id || alimentador.registrador_id;

        // Verificar cache para zona superior
        if (regSuperior) {
          const cacheSuperiorOK = await verificarCacheExistente(alimentador.id, regSuperior, "superior");
          if (!cacheSuperiorOK) {
            tareasPendientes.push({
              alimentadorId: alimentador.id,
              registradorId: regSuperior,
              zona: "superior",
            });
          }
        }

        // Verificar cache para zona inferior (si es diferente registrador)
        if (regInferior && regInferior !== regSuperior) {
          const cacheInferiorOK = await verificarCacheExistente(alimentador.id, regInferior, "inferior");
          if (!cacheInferiorOK) {
            tareasPendientes.push({
              alimentadorId: alimentador.id,
              registradorId: regInferior,
              zona: "inferior",
            });
          }
        } else if (regInferior && regInferior === regSuperior) {
          // Mismo registrador pero verificar si zona inferior necesita datos
          const cacheInferiorOK = await verificarCacheExistente(alimentador.id, regInferior, "inferior");
          if (!cacheInferiorOK) {
            tareasPendientes.push({
              alimentadorId: alimentador.id,
              registradorId: regInferior,
              zona: "inferior",
            });
          }
        }
      }

      // Si no hay tareas pendientes, ya est√° todo cacheado y reciente
      if (tareasPendientes.length === 0) {
        console.log("[Historial] Cache del puesto ya est√° actualizado");
        setPrecargaProgreso(100);
        setPrecargaCompleta(true);
        setPrecargando(false);
        return true;
      }

      console.log(`[Historial] Precargando puesto: ${tareasPendientes.length} tareas pendientes`);

      // Agrupar tareas por registrador para evitar consultas duplicadas
      const tareasPorRegistrador = {};
      for (const tarea of tareasPendientes) {
        if (!tareasPorRegistrador[tarea.registradorId]) {
          tareasPorRegistrador[tarea.registradorId] = [];
        }
        tareasPorRegistrador[tarea.registradorId].push(tarea);
      }

      const totalRegistradores = Object.keys(tareasPorRegistrador).length;
      let registradoresProcesados = 0;

      try {
        for (const [registradorId, tareas] of Object.entries(tareasPorRegistrador)) {
          if (precargaAbortRef.current) {
            console.log("[Historial] Precarga de puesto abortada");
            setPrecargando(false);
            return false;
          }

          // Consultar datos remotos una vez por registrador
          const datosRemotos = await obtenerLecturasHistoricasPorRegistrador(
            registradorId,
            new Date(desde).toISOString(),
            new Date(hasta).toISOString()
          );

          if (datosRemotos && datosRemotos.length > 0 && dbRef.current) {
            // Marcar que los datos vinieron de la BD
            setDatosDeBD(true);
            // Cachear para todas las zonas/alimentadores que usan este registrador
            for (const tarea of tareas) {
              await cachearLecturasRemotas(
                dbRef.current,
                tarea.alimentadorId,
                tarea.registradorId,
                tarea.zona,
                datosRemotos
              );
            }
          }

          registradoresProcesados++;
          setPrecargaProgreso(Math.round((registradoresProcesados / totalRegistradores) * 100));
        }

        setPrecargaProgreso(100);
        setPrecargaCompleta(true);
        setPrecargando(false);
        console.log("[Historial] Precarga de puesto completada");
        return true;
      } catch (err) {
        console.error("[Historial] Error en precarga de puesto:", err);
        setPrecargando(false);
        setPrecargaProgreso(0);
        // A√∫n as√≠ marcar como completa para que el componente pueda mostrar "sin datos"
        // en lugar de quedarse cargando infinitamente
        setPrecargaCompleta(true);
        return false;
      }
    },
    [verificarCacheExistente]
  );

  /**
   * Limpia lecturas antiguas manualmente
   */
  const limpiarHistorial = useCallback(async () => {
    if (!dbRef.current) return 0;

    try {
      const eliminados = await limpiarLecturasAntiguas(
        dbRef.current,
        HORAS_RETENCION_LOCAL
      );
      const stats = await obtenerEstadisticas(dbRef.current);
      setEstadisticas(stats);
      return eliminados;
    } catch (err) {
      console.error("[Historial] Error limpiando historial:", err);
      return 0;
    }
  }, []);

  /**
   * Limpia TODO el cache local (para testing o reset completo)
   * @returns {Promise<boolean>} true si se limpi√≥ correctamente
   */
  const limpiarCacheCompleto = useCallback(async () => {
    if (!dbRef.current) return false;

    try {
      await limpiarTodo(dbRef.current);
      const stats = await obtenerEstadisticas(dbRef.current);
      setEstadisticas(stats);
      // Resetear estado de precarga
      setPrecargaProgreso(0);
      setPrecargaCompleta(false);
      setDatosDeBD(false);
      console.log("[Historial] Cache local limpiado completamente");
      return true;
    } catch (err) {
      console.error("[Historial] Error limpiando cache completo:", err);
      return false;
    }
  }, []);

  /**
   * Actualiza estad√≠sticas
   */
  const actualizarEstadisticas = useCallback(async () => {
    if (!dbRef.current) return;

    try {
      const stats = await obtenerEstadisticas(dbRef.current);
      setEstadisticas(stats);
    } catch (err) {
      console.error("[Historial] Error actualizando estad√≠sticas:", err);
    }
  }, []);

  return {
    guardarLecturaLocal,
    obtenerDatosGrafico,
    limpiarHistorial,
    limpiarCacheCompleto,
    actualizarEstadisticas,
    // Precarga 48h
    precargar48h,
    precargarPuesto,
    cancelarPrecarga,
    resetearPrecarga,
    precargaProgreso,
    precargaCompleta,
    precargando,
    datosDeBD, // Indica si los datos fueron descargados de la BD remota
    // Estado general
    dbLista, // Indica cuando IndexedDB est√° lista para usar
    cargando,
    error,
    estadisticas,
    horasRetencion: HORAS_RETENCION_LOCAL,
  };
};

export default useHistorialLocal;

// ===== ./src/paginas/PaginaAlimentadores/hooks/useMediciones.js =====

// src/paginas/PaginaAlimentadores/hooks/usarMediciones.js

import { useState, useCallback } from "react";

/**
 * Hook para manejar el estado de registros/mediciones de alimentadores.
 *
 * Este hook gestiona el estado de los registros le√≠dos desde Supabase (via polling)
 * y provee funciones auxiliares para consultar el estado de las mediciones.
 *
 * NOTA: El flujo anterior de lectura directa Modbus (simulado/real con timers internos)
 * fue eliminado. Ahora las lecturas vienen del polling en VistaAlimentadores que
 * consulta la tabla `lecturas` de Supabase.
 */
export const useMediciones = () => {
	// Registros le√≠dos en vivo por alimentador
	// Estructura: { [alimId]: { rele: [{index, address, value}], analizador: [...] } }
	const [registrosEnVivo, setRegistrosEnVivo] = useState({});

	// Timestamps de √∫ltima actualizaci√≥n por alimentador/equipo
	// Estructura: { [alimId]: { rele: timestamp, analizador: timestamp } }
	const [timestampsInicio, setTimestampsInicio] = useState({});

	// Contador de lecturas por alimentador/equipo
	// Estructura: { [alimId]: { rele: number, analizador: number } }
	const [contadorLecturas, setContadorLecturas] = useState({});

	/**
	 * Actualiza los registros de un alimentador.
	 * Usado por el polling de Supabase para cargar nuevas lecturas.
	 *
	 * @param {string} alimId - ID del alimentador.
	 * @param {Object|Function} nuevosDatosOFuncion - Datos nuevos o funci√≥n actualizadora.
	 */
	const actualizarRegistros = useCallback((alimId, nuevosDatosOFuncion) => {
		const ahora = Date.now();

		setRegistrosEnVivo((anteriores) => {
			const registrosAnteriores = anteriores[alimId] || {};
			const nuevosDatos = typeof nuevosDatosOFuncion === 'function'
				? nuevosDatosOFuncion(registrosAnteriores)
				: nuevosDatosOFuncion;

			return {
				...anteriores,
				[alimId]: {
					...registrosAnteriores,
					...nuevosDatos,
				},
			};
		});

		// Actualizar timestamp
		setTimestampsInicio((anteriores) => ({
			...anteriores,
			[alimId]: {
				...(anteriores[alimId] || {}),
				rele: ahora, // Por ahora usamos rele como default
			},
		}));

		// Incrementar contador
		setContadorLecturas((anteriores) => ({
			...anteriores,
			[alimId]: {
				...(anteriores[alimId] || {}),
				rele: (anteriores[alimId]?.rele || 0) + 1,
			},
		}));
	}, []);

	/**
	 * Obtiene los registros de un alimentador y equipo.
	 */
	const obtenerRegistros = useCallback((alimId, equipo) => {
		return registrosEnVivo[alimId]?.[equipo] || [];
	}, [registrosEnVivo]);

	/**
	 * Verifica si un alimentador tiene datos cargados (est√° "midiendo").
	 * En el nuevo flujo, esto indica si hay datos de polling disponibles.
	 */
	const estaMidiendo = useCallback((alimId, equipo) => {
		const registros = registrosEnVivo[alimId]?.[equipo];
		return Array.isArray(registros) && registros.length > 0;
	}, [registrosEnVivo]);

	/**
	 * Obtiene el timestamp de la √∫ltima actualizaci√≥n.
	 */
	const obtenerTimestampInicio = useCallback((alimId, equipo) => {
		return timestampsInicio[alimId]?.[equipo] || null;
	}, [timestampsInicio]);

	/**
	 * Obtiene el contador de lecturas.
	 */
	const obtenerContadorLecturas = useCallback((alimId, equipo) => {
		return contadorLecturas[alimId]?.[equipo] || 0;
	}, [contadorLecturas]);

	/**
	 * Limpia los datos de un alimentador (usado al eliminar).
	 */
	const detenerMedicion = useCallback((alimId, equipo) => {
		// Limpiar registros del equipo
		setRegistrosEnVivo((anteriores) => {
			if (!anteriores[alimId]) return anteriores;

			const nuevo = { ...anteriores };
			if (nuevo[alimId]?.[equipo]) {
				delete nuevo[alimId][equipo];
				if (Object.keys(nuevo[alimId]).length === 0) {
					delete nuevo[alimId];
				}
			}
			return nuevo;
		});

		// Limpiar timestamp
		setTimestampsInicio((anteriores) => {
			if (!anteriores[alimId]) return anteriores;

			const nuevo = { ...anteriores };
			if (nuevo[alimId]?.[equipo]) {
				delete nuevo[alimId][equipo];
				if (Object.keys(nuevo[alimId]).length === 0) {
					delete nuevo[alimId];
				}
			}
			return nuevo;
		});

		// Limpiar contador
		setContadorLecturas((anteriores) => {
			if (!anteriores[alimId]) return anteriores;

			const nuevo = { ...anteriores };
			if (nuevo[alimId]?.[equipo]) {
				delete nuevo[alimId][equipo];
				if (Object.keys(nuevo[alimId]).length === 0) {
					delete nuevo[alimId];
				}
			}
			return nuevo;
		});
	}, []);

	return {
		// Estado
		registrosEnVivo,

		// Funciones
		actualizarRegistros,
		obtenerRegistros,
		estaMidiendo,
		obtenerTimestampInicio,
		obtenerContadorLecturas,
		detenerMedicion,
	};
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/usePlantillasRele.js =====

import { useState, useEffect, useCallback } from "react";
import {
  FUNCIONALIDADES_DISPONIBLES,
  STORAGE_KEY_PLANTILLAS,
} from "../constantes/funcionalidadesRele";

/**
 * Hook para gestionar plantillas de rel√©s de protecci√≥n.
 * Maneja CRUD de plantillas en localStorage.
 */
export const usePlantillasRele = () => {
  const [plantillas, setPlantillas] = useState([]);
  const [cargando, setCargando] = useState(true);

  // Cargar plantillas al montar
  useEffect(() => {
    cargarPlantillas();
  }, []);

  /**
   * Carga las plantillas desde localStorage
   */
  const cargarPlantillas = useCallback(() => {
    setCargando(true);
    try {
      const datos = localStorage.getItem(STORAGE_KEY_PLANTILLAS);
      const plantillasGuardadas = datos ? JSON.parse(datos) : [];
      setPlantillas(plantillasGuardadas);
    } catch (error) {
      console.error("Error al cargar plantillas:", error);
      setPlantillas([]);
    } finally {
      setCargando(false);
    }
  }, []);

  /**
   * Guarda las plantillas en localStorage
   */
  const guardarEnStorage = useCallback((nuevasPlantillas) => {
    try {
      localStorage.setItem(
        STORAGE_KEY_PLANTILLAS,
        JSON.stringify(nuevasPlantillas)
      );
      setPlantillas(nuevasPlantillas);
      return true;
    } catch (error) {
      console.error("Error al guardar plantillas:", error);
      return false;
    }
  }, []);

  /**
   * Genera un UUID simple
   */
  const generarId = () => {
    return "plt-" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  };

  /**
   * Crea una nueva plantilla
   * @param {Object} datos - { nombre, descripcion, funcionalidades, etiquetasBits, plantillaEtiquetasId }
   * funcionalidades es un objeto con { [idFuncionalidad]: { habilitado, registro } }
   * etiquetasBits es un objeto con { [bit]: { texto, severidad } }
   * plantillaEtiquetasId es el ID de la plantilla de etiquetas seleccionada (para restaurar al editar)
   */
  const crearPlantilla = useCallback(
    (datos) => {
      const nuevaPlantilla = {
        id: generarId(),
        nombre: datos.nombre.trim(),
        descripcion: datos.descripcion?.trim() || "",
        fechaCreacion: new Date().toISOString(),
        funcionalidades: datos.funcionalidades || {},
        etiquetasBits: datos.etiquetasBits || {},
        plantillaEtiquetasId: datos.plantillaEtiquetasId || null,
      };

      const nuevasPlantillas = [...plantillas, nuevaPlantilla];
      const exito = guardarEnStorage(nuevasPlantillas);

      return exito ? nuevaPlantilla : null;
    },
    [plantillas, guardarEnStorage]
  );

  /**
   * Actualiza una plantilla existente
   * @param {string} id - ID de la plantilla
   * @param {Object} datos - Datos a actualizar
   */
  const actualizarPlantilla = useCallback(
    (id, datos) => {
      const indice = plantillas.findIndex((p) => p.id === id);
      if (indice === -1) return false;

      const plantillaActualizada = {
        ...plantillas[indice],
        nombre: datos.nombre?.trim() || plantillas[indice].nombre,
        descripcion: datos.descripcion?.trim() ?? plantillas[indice].descripcion,
        funcionalidades: datos.funcionalidades || plantillas[indice].funcionalidades,
        etiquetasBits: datos.etiquetasBits ?? plantillas[indice].etiquetasBits ?? {},
        plantillaEtiquetasId: datos.plantillaEtiquetasId !== undefined
          ? datos.plantillaEtiquetasId
          : plantillas[indice].plantillaEtiquetasId ?? null,
        fechaModificacion: new Date().toISOString(),
      };

      const nuevasPlantillas = [...plantillas];
      nuevasPlantillas[indice] = plantillaActualizada;

      return guardarEnStorage(nuevasPlantillas);
    },
    [plantillas, guardarEnStorage]
  );

  /**
   * Elimina una plantilla
   * @param {string} id - ID de la plantilla a eliminar
   */
  const eliminarPlantilla = useCallback(
    (id) => {
      const nuevasPlantillas = plantillas.filter((p) => p.id !== id);
      return guardarEnStorage(nuevasPlantillas);
    },
    [plantillas, guardarEnStorage]
  );

  /**
   * Obtiene una plantilla por ID
   * @param {string} id - ID de la plantilla
   */
  const obtenerPlantilla = useCallback(
    (id) => {
      return plantillas.find((p) => p.id === id) || null;
    },
    [plantillas]
  );

  /**
   * Obtiene las funcionalidades de una plantilla con sus valores por defecto
   * @param {string} plantillaId - ID de la plantilla
   * @returns {Object} - { [idFunc]: { habilitado, registro } }
   */
  const obtenerFuncionalidadesPlantilla = useCallback(
    (plantillaId) => {
      const plantilla = obtenerPlantilla(plantillaId);
      if (!plantilla) return {};

      // Construir objeto con todas las funcionalidades de la plantilla
      const funcionalidades = {};
      Object.keys(plantilla.funcionalidades).forEach((funcId) => {
        const funcPlantilla = plantilla.funcionalidades[funcId];
        const funcBase = FUNCIONALIDADES_DISPONIBLES[funcId];

        if (funcBase && funcPlantilla.habilitado) {
          funcionalidades[funcId] = {
            habilitado: true,
            registro: funcPlantilla.registro || funcBase.registroDefault,
            cantidad: funcBase.cantidad,
            nombre: funcBase.nombre,
          };
        }
      });

      return funcionalidades;
    },
    [obtenerPlantilla]
  );

  /**
   * Genera la configuraci√≥n de funcionalidades activas por defecto basada en una plantilla
   * @param {string} plantillaId - ID de la plantilla
   * @returns {Object} - Configuraci√≥n inicial para funcionalidadesActivas
   */
  const generarConfiguracionInicial = useCallback(
    (plantillaId) => {
      const plantilla = obtenerPlantilla(plantillaId);
      if (!plantilla) return {};

      const config = {};
      Object.keys(plantilla.funcionalidades).forEach((funcId) => {
        const funcPlantilla = plantilla.funcionalidades[funcId];
        const funcBase = FUNCIONALIDADES_DISPONIBLES[funcId];

        if (funcBase && funcPlantilla.habilitado) {
          config[funcId] = {
            habilitado: true,
            registro: funcPlantilla.registro || funcBase.registroDefault,
          };
        }
      });

      return config;
    },
    [obtenerPlantilla]
  );

  return {
    plantillas,
    cargando,
    crearPlantilla,
    actualizarPlantilla,
    eliminarPlantilla,
    obtenerPlantilla,
    obtenerFuncionalidadesPlantilla,
    generarConfiguracionInicial,
    recargar: cargarPlantillas,
  };
};

export default usePlantillasRele;

// ===== ./src/paginas/PaginaAlimentadores/hooks/usePreferenciasUI.js =====

// src/paginas/PaginaAlimentadores/hooks/usarPreferenciasUI.js

import { useState, useEffect, useCallback } from "react";
import { CLAVES_STORAGE } from "../constantes/clavesAlmacenamiento";

// Valores por defecto - Gaps horizontales (entre tarjetas)
const GAP_DEFAULT = 10;
const GAP_MIN = 0;
const GAP_MAX = 500;

// Valores por defecto - Gaps verticales (entre filas)
const ROW_GAP_DEFAULT = 40;
const ROW_GAP_MIN = 0;
const ROW_GAP_MAX = 400;

// Valores por defecto - Escala de tarjetas
const ESCALA_DEFAULT = 1.0;
const ESCALA_MIN = 0.5;
const ESCALA_MAX = 2.0;

/**
 * Hook para manejar preferencias de UI:
 * - Espaciado horizontal individual por tarjeta
 * - Espaciado vertical por fila (√≠ndice de fila + puestoId)
 * - Escala de tarjetas (global, por puesto, individual)
 *
 * Persiste autom√°ticamente en localStorage.
 *
 * Gaps horizontales: { "alimId1": 10, "alimId2": 50, ... }
 * Gaps verticales: { "puestoId:rowIndex": 20, ... } (combinaci√≥n puesto+fila como key)
 * Escala global: n√∫mero (ej: 1.0)
 * Escala por puesto: { "puestoId": 0.8, ... }
 * Escala por tarjeta: { "alimId": 1.2, ... }
 * Prioridad: Individual > Por puesto > Global > Default (1.0)
 */
export const usePreferenciasUI = () => {
	// ===== GAPS HORIZONTALES (entre tarjetas) =====
	const [gapsPorTarjeta, setGapsPorTarjetaState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.GAP_TARJETAS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.GAP_TARJETAS, JSON.stringify(gapsPorTarjeta));
	}, [gapsPorTarjeta]);

	const obtenerGap = useCallback((alimId) => {
		const gap = gapsPorTarjeta[alimId];
		return gap !== undefined ? gap : GAP_DEFAULT;
	}, [gapsPorTarjeta]);

	const establecerGap = useCallback((alimId, nuevoGap) => {
		const gapValidado = Math.max(GAP_MIN, Math.min(GAP_MAX, nuevoGap));
		setGapsPorTarjetaState(prev => ({
			...prev,
			[alimId]: gapValidado
		}));
	}, []);

	const resetearGap = useCallback((alimId) => {
		setGapsPorTarjetaState(prev => {
			const nuevo = { ...prev };
			delete nuevo[alimId];
			return nuevo;
		});
	}, []);

	const resetearTodosLosGaps = useCallback(() => {
		setGapsPorTarjetaState({});
	}, []);

	// ===== GAPS VERTICALES (entre filas) =====
	const [gapsPorFila, setGapsPorFilaState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.GAP_FILAS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.GAP_FILAS, JSON.stringify(gapsPorFila));
	}, [gapsPorFila]);

	// Generar clave √∫nica para un gap de fila (combinando puestoId y rowIndex)
	const generarClaveRowGap = (puestoId, rowIndex) => `${puestoId}:${rowIndex}`;

	// Obtener el gap de una fila espec√≠fica en un puesto espec√≠fico
	const obtenerRowGap = useCallback((puestoId, rowIndex) => {
		if (!puestoId) return ROW_GAP_DEFAULT;
		const clave = generarClaveRowGap(puestoId, rowIndex);
		const gap = gapsPorFila[clave];
		return gap !== undefined ? gap : ROW_GAP_DEFAULT;
	}, [gapsPorFila]);

	// Establecer el gap de una fila espec√≠fica en un puesto espec√≠fico
	const establecerRowGap = useCallback((puestoId, rowIndex, nuevoGap) => {
		if (!puestoId) return;
		const clave = generarClaveRowGap(puestoId, rowIndex);
		const gapValidado = Math.max(ROW_GAP_MIN, Math.min(ROW_GAP_MAX, nuevoGap));
		setGapsPorFilaState(prev => ({
			...prev,
			[clave]: gapValidado
		}));
	}, []);

	// Resetear gap de una fila al valor por defecto
	const resetearRowGap = useCallback((puestoId, rowIndex) => {
		if (!puestoId) return;
		const clave = generarClaveRowGap(puestoId, rowIndex);
		setGapsPorFilaState(prev => {
			const nuevo = { ...prev };
			delete nuevo[clave];
			return nuevo;
		});
	}, []);

	// Resetear todos los gaps de filas
	const resetearTodosLosRowGaps = useCallback(() => {
		setGapsPorFilaState({});
	}, []);

	// ===== ESCALA GLOBAL =====
	const [escalaGlobal, setEscalaGlobalState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.ESCALA_GLOBAL);
		if (guardado) {
			const valor = parseFloat(guardado);
			if (!isNaN(valor)) return valor;
		}
		return ESCALA_DEFAULT;
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.ESCALA_GLOBAL, escalaGlobal.toString());
	}, [escalaGlobal]);

	const establecerEscalaGlobal = useCallback((nuevaEscala) => {
		const escalaValidada = Math.max(ESCALA_MIN, Math.min(ESCALA_MAX, nuevaEscala));
		setEscalaGlobalState(escalaValidada);
	}, []);

	const resetearEscalaGlobal = useCallback(() => {
		setEscalaGlobalState(ESCALA_DEFAULT);
	}, []);

	// ===== ESCALA POR PUESTO =====
	const [escalasPorPuesto, setEscalasPorPuestoState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.ESCALA_PUESTOS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.ESCALA_PUESTOS, JSON.stringify(escalasPorPuesto));
	}, [escalasPorPuesto]);

	const obtenerEscalaPuesto = useCallback((puestoId) => {
		if (!puestoId) return null;
		return escalasPorPuesto[puestoId];
	}, [escalasPorPuesto]);

	const establecerEscalaPuesto = useCallback((puestoId, nuevaEscala) => {
		if (!puestoId) return;
		const escalaValidada = Math.max(ESCALA_MIN, Math.min(ESCALA_MAX, nuevaEscala));
		setEscalasPorPuestoState(prev => ({
			...prev,
			[puestoId]: escalaValidada
		}));
	}, []);

	const resetearEscalaPuesto = useCallback((puestoId) => {
		if (!puestoId) return;
		setEscalasPorPuestoState(prev => {
			const nuevo = { ...prev };
			delete nuevo[puestoId];
			return nuevo;
		});
	}, []);

	const resetearTodasLasEscalasPuestos = useCallback(() => {
		setEscalasPorPuestoState({});
	}, []);

	// ===== ESCALA POR TARJETA (individual) =====
	const [escalasPorTarjeta, setEscalasPorTarjetaState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.ESCALA_TARJETAS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.ESCALA_TARJETAS, JSON.stringify(escalasPorTarjeta));
	}, [escalasPorTarjeta]);

	const obtenerEscalaTarjeta = useCallback((alimId) => {
		if (!alimId) return null;
		return escalasPorTarjeta[alimId];
	}, [escalasPorTarjeta]);

	const establecerEscalaTarjeta = useCallback((alimId, nuevaEscala) => {
		if (!alimId) return;
		const escalaValidada = Math.max(ESCALA_MIN, Math.min(ESCALA_MAX, nuevaEscala));
		setEscalasPorTarjetaState(prev => ({
			...prev,
			[alimId]: escalaValidada
		}));
	}, []);

	const resetearEscalaTarjeta = useCallback((alimId) => {
		if (!alimId) return;
		// Guardamos null para indicar "ignorar escala individual (incluso de BD)"
		// Esto permite que la escala del puesto tenga efecto
		setEscalasPorTarjetaState(prev => ({
			...prev,
			[alimId]: null
		}));
	}, []);

	const resetearTodasLasEscalasTarjetas = useCallback(() => {
		setEscalasPorTarjetaState({});
	}, []);

	/**
	 * Obtiene la escala efectiva de una tarjeta considerando la jerarqu√≠a:
	 * Individual > Por puesto > Global > Default
	 * @param {string} alimId - ID del alimentador
	 * @param {string} puestoId - ID del puesto (opcional, para escala por puesto)
	 * @returns {number} Escala efectiva a aplicar
	 */
	const obtenerEscalaEfectiva = useCallback((alimId, puestoId) => {
		// 1. Escala individual (m√°xima prioridad)
		const escalaIndividual = escalasPorTarjeta[alimId];
		if (escalaIndividual !== undefined) return escalaIndividual;

		// 2. Escala por puesto
		if (puestoId) {
			const escalaPuesto = escalasPorPuesto[puestoId];
			if (escalaPuesto !== undefined) return escalaPuesto;
		}

		// 3. Escala global
		if (escalaGlobal !== ESCALA_DEFAULT) return escalaGlobal;

		// 4. Default
		return ESCALA_DEFAULT;
	}, [escalasPorTarjeta, escalasPorPuesto, escalaGlobal]);

	// Resetear todas las escalas
	const resetearTodasLasEscalas = useCallback(() => {
		setEscalaGlobalState(ESCALA_DEFAULT);
		setEscalasPorPuestoState({});
		setEscalasPorTarjetaState({});
	}, []);

	return {
		// Gaps horizontales
		gapsPorTarjeta,
		obtenerGap,
		establecerGap,
		resetearGap,
		resetearTodosLosGaps,
		GAP_MIN,
		GAP_MAX,
		GAP_DEFAULT,
		// Gaps verticales
		gapsPorFila,
		obtenerRowGap,
		establecerRowGap,
		resetearRowGap,
		resetearTodosLosRowGaps,
		ROW_GAP_MIN,
		ROW_GAP_MAX,
		ROW_GAP_DEFAULT,
		// Escala global
		escalaGlobal,
		establecerEscalaGlobal,
		resetearEscalaGlobal,
		// Escala por puesto
		escalasPorPuesto,
		obtenerEscalaPuesto,
		establecerEscalaPuesto,
		resetearEscalaPuesto,
		resetearTodasLasEscalasPuestos,
		// Escala por tarjeta (individual)
		escalasPorTarjeta,
		obtenerEscalaTarjeta,
		establecerEscalaTarjeta,
		resetearEscalaTarjeta,
		resetearTodasLasEscalasTarjetas,
		// Escala efectiva (combina jerarqu√≠a)
		obtenerEscalaEfectiva,
		resetearTodasLasEscalas,
		// Constantes de escala
		ESCALA_MIN,
		ESCALA_MAX,
		ESCALA_DEFAULT,
	};
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/usePreferenciasVisuales.js =====

// src/paginas/PaginaAlimentadores/hooks/usePreferenciasVisuales.js
// Hook para manejar preferencias visuales personalizadas por usuario
// Implementa el patr√≥n "User Preferences Override":
// - Creador: guarda en BASE (tablas puestos/alimentadores)
// - Invitado: guarda en preferencias_usuario (solo √©l lo ve)

import { useState, useEffect, useCallback, useMemo } from "react";
import {
  obtenerPreferencias,
  guardarPreferencias,
  actualizarPuesto,
  actualizarAlimentadorAPI,
} from "../../../servicios/apiService";

// Valores por defecto
const DEFAULTS = {
  escalaGlobal: 1.0,
  GAP_DEFAULT: 10,
  ROW_GAP_DEFAULT: 40,
};

/**
 * Hook para manejar preferencias visuales con patr√≥n de override.
 *
 * Flujo de lectura:
 * 1. Carga config BASE de puestos/alimentadores
 * 2. Carga preferencias personales del usuario
 * 3. Hace merge (preferencia personal > base)
 * 4. Limpia preferencias hu√©rfanas
 *
 * Flujo de escritura:
 * - esCreador=true: guarda en BASE (todos ven el cambio)
 * - esCreador=false: guarda en preferencias_usuario (solo √©l lo ve)
 *
 * @param {string} workspaceId - ID del workspace activo
 * @param {boolean} esCreador - Si el usuario es creador del workspace
 * @param {Array} puestos - Lista de puestos con alimentadores (config BASE)
 * @param {Function} recargarPuestos - Funci√≥n para recargar puestos despu√©s de guardar en BASE
 */
export const usePreferenciasVisuales = (workspaceId, esCreador, puestos, recargarPuestos) => {
  // Preferencias personales del usuario (override)
  const [preferenciasUsuario, setPreferenciasUsuario] = useState(null);
  const [cargando, setCargando] = useState(true);
  const [error, setError] = useState(null);
  const [guardando, setGuardando] = useState(false);
  // Flag para evitar que limpiarHuerfanos se ejecute durante/despu√©s de un guardado
  const [saltarLimpiezaHuerfanos, setSaltarLimpiezaHuerfanos] = useState(false);

  // Estructura de preferenciasUsuario:
  // {
  //   escalaGlobal: 1.0,
  //   puestos: {
  //     "uuid-puesto": { color, bg_color, escala, gapsVerticales }
  //   },
  //   alimentadores: {
  //     "uuid-alim": { color, escala, gapHorizontal }
  //   }
  // }

  /**
   * Carga las preferencias del usuario desde la BD
   */
  const cargarPreferencias = useCallback(async () => {
    if (!workspaceId) {
      setPreferenciasUsuario(null);
      setCargando(false);
      return;
    }

    try {
      setCargando(true);
      setError(null);
      const response = await obtenerPreferencias(workspaceId);
      const prefs = response?.preferencias || {};
      setPreferenciasUsuario(prefs);
    } catch (err) {
      console.error("Error cargando preferencias:", err);
      setError(err.message);
      setPreferenciasUsuario({});
    } finally {
      setCargando(false);
    }
  }, [workspaceId, esCreador]);

  // Cargar preferencias cuando cambie el workspace
  // Nota: cargarPreferencias depende de workspaceId, as√≠ que se recrea cuando cambia
  useEffect(() => {
    cargarPreferencias();
  }, [cargarPreferencias]);

  /**
   * Limpia preferencias hu√©rfanas (referencias a puestos/alimentadores que ya no existen)
   * IMPORTANTE: Solo ejecutar cuando puestos ya est√° cargado para evitar borrar todo
   * IMPORTANTE: Solo ejecutar si los puestos pertenecen al workspace actual
   */
  const limpiarHuerfanos = useCallback(async () => {
    // Verificar que hay datos para comparar
    if (!preferenciasUsuario || !puestos || puestos.length === 0) {
      return;
    }

    // Verificar que hay preferencias que limpiar
    const prefsPuestos = preferenciasUsuario.puestos || {};
    const prefsAlimentadores = preferenciasUsuario.alimentadores || {};
    if (Object.keys(prefsPuestos).length === 0 && Object.keys(prefsAlimentadores).length === 0) {
      return;
    }

    // CR√çTICO: Verificar que los puestos pertenecen al workspace actual
    // Si los puestos tienen un workspace_id diferente, NO ejecutar la limpieza
    // porque significar√≠a que estamos comparando preferencias de un workspace
    // con puestos de otro workspace (durante el cambio de workspace)
    const primerPuesto = puestos[0];
    if (primerPuesto && primerPuesto.workspace_id && primerPuesto.workspace_id !== workspaceId) {
      return;
    }

    // Verificar que al menos uno de los puestos con preferencias existe en la lista actual
    // Si NINGUNO existe, probablemente los puestos son de otro workspace (cambio en progreso)
    const idsPuestos = new Set(puestos.map(p => p.id));
    const prefsPuestosIds = Object.keys(prefsPuestos);
    const algunoPuestoExiste = prefsPuestosIds.some(id => idsPuestos.has(id));

    // Si hay preferencias de puestos pero NINGUNO est√° en la lista actual,
    // es probable que estemos en medio de un cambio de workspace
    if (prefsPuestosIds.length > 0 && !algunoPuestoExiste) {
      return;
    }

    const idsAlimentadores = new Set(
      puestos.flatMap(p => (p.alimentadores || []).map(a => a.id))
    );

    let hayHuerfanos = false;
    const nuevasPrefs = { ...preferenciasUsuario };

    // Limpiar puestos hu√©rfanos
    if (nuevasPrefs.puestos) {
      const puestosLimpios = {};
      for (const [id, prefs] of Object.entries(nuevasPrefs.puestos)) {
        if (idsPuestos.has(id)) {
          puestosLimpios[id] = prefs;
        } else {
          hayHuerfanos = true;
        }
      }
      nuevasPrefs.puestos = puestosLimpios;
    }

    // Limpiar alimentadores hu√©rfanos
    if (nuevasPrefs.alimentadores) {
      const alimentadoresLimpios = {};
      for (const [id, prefs] of Object.entries(nuevasPrefs.alimentadores)) {
        if (idsAlimentadores.has(id)) {
          alimentadoresLimpios[id] = prefs;
        } else {
          hayHuerfanos = true;
        }
      }
      nuevasPrefs.alimentadores = alimentadoresLimpios;
    }

    // Si hubo limpieza, guardar en BD
    if (hayHuerfanos) {
      try {
        await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        setPreferenciasUsuario(nuevasPrefs);
      } catch (err) {
        console.error("Error limpiando preferencias hu√©rfanas:", err);
      }
    }
  }, [preferenciasUsuario, puestos, workspaceId]);

  // Ejecutar limpieza de hu√©rfanos cuando cambian los puestos
  // IMPORTANTE: Solo ejecutar si puestos tiene elementos para evitar borrar preferencias v√°lidas
  // IMPORTANTE: Saltar si estamos en medio de un guardado para evitar race conditions
  useEffect(() => {
    if (saltarLimpiezaHuerfanos) {
      return;
    }
    if (!cargando && preferenciasUsuario && puestos && puestos.length > 0) {
      limpiarHuerfanos();
    }
  }, [puestos, cargando, limpiarHuerfanos, saltarLimpiezaHuerfanos]);

  /**
   * Obtiene la configuraci√≥n visual de un puesto (merge base + override)
   */
  const obtenerConfigPuesto = useCallback((puestoId) => {
    const puesto = puestos.find(p => p.id === puestoId);
    if (!puesto) return null;

    // Config base del puesto
    const base = {
      color: puesto.color,
      bg_color: puesto.bg_color || puesto.bgColor,
      escala: puesto.escala,
      gapsVerticales: puesto.gapsVerticales || { "0": DEFAULTS.ROW_GAP_DEFAULT },
    };

    // Override del usuario (si no es creador)
    const override = preferenciasUsuario?.puestos?.[puestoId] || {};

    // Merge: override tiene prioridad
    return {
      ...base,
      ...override,
      // Para gapsVerticales, hacer merge a nivel de keys
      gapsVerticales: {
        ...base.gapsVerticales,
        ...(override.gapsVerticales || {}),
      },
    };
  }, [puestos, preferenciasUsuario, esCreador]);

  /**
   * Obtiene la configuraci√≥n visual de un alimentador (merge base + override)
   */
  const obtenerConfigAlimentador = useCallback((alimentadorId, puestoId) => {
    const puesto = puestos.find(p => p.id === puestoId);
    const alimentador = puesto?.alimentadores?.find(a => a.id === alimentadorId);
    if (!alimentador) return null;

    // Config base del alimentador
    const base = {
      color: alimentador.color,
      escala: alimentador.escala,
      gapHorizontal: alimentador.gapHorizontal ?? DEFAULTS.GAP_DEFAULT,
    };

    // Override del usuario
    const override = preferenciasUsuario?.alimentadores?.[alimentadorId] || {};

    return { ...base, ...override };
  }, [puestos, preferenciasUsuario]);

  /**
   * Obtiene la escala global (override > default)
   */
  const escalaGlobal = useMemo(() => {
    return preferenciasUsuario?.escalaGlobal ?? DEFAULTS.escalaGlobal;
  }, [preferenciasUsuario]);

  /**
   * Guarda una preferencia visual.
   * - Si esCreador: guarda en BASE (tabla puestos/alimentadores)
   * - Si es invitado: guarda en preferencias_usuario
   *
   * @param {string} tipo - 'puesto' | 'alimentador' | 'global'
   * @param {string} id - ID del elemento (null para global)
   * @param {string} campo - Nombre del campo (color, escala, etc.)
   * @param {any} valor - Nuevo valor
   * @param {string} puestoId - ID del puesto (solo para alimentadores)
   */
  const guardarPreferencia = useCallback(async (tipo, id, campo, valor, puestoId = null) => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      setError(null);

      if (esCreador) {
        // === CREADOR: Guardar en BASE ===
        if (tipo === 'puesto') {
          await actualizarPuesto(id, { [campo]: valor });
          // Recargar para reflejar cambios
          if (recargarPuestos) await recargarPuestos();
        } else if (tipo === 'alimentador') {
          // Mapear campos frontend a backend
          const campoBackend = campo === 'gapHorizontal' ? 'gap_horizontal' : campo;
          await actualizarAlimentadorAPI(id, { [campoBackend]: valor });
          if (recargarPuestos) await recargarPuestos();
        } else if (tipo === 'global') {
          // La escala global no tiene tabla base, se guarda en preferencias
          const nuevasPrefs = {
            ...preferenciasUsuario,
            escalaGlobal: valor,
          };
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
          setPreferenciasUsuario(nuevasPrefs);
        }
      } else {
        // === INVITADO: Guardar en preferencias_usuario ===
        // Activar flag para evitar que limpiarHuerfanos se ejecute durante el guardado
        setSaltarLimpiezaHuerfanos(true);

        // Optimistic update: actualizar estado local primero para evitar lag
        const nuevasPrefs = { ...preferenciasUsuario };

        if (tipo === 'puesto') {
          nuevasPrefs.puestos = nuevasPrefs.puestos || {};
          nuevasPrefs.puestos[id] = nuevasPrefs.puestos[id] || {};
          nuevasPrefs.puestos[id][campo] = valor;
        } else if (tipo === 'alimentador') {
          nuevasPrefs.alimentadores = nuevasPrefs.alimentadores || {};
          nuevasPrefs.alimentadores[id] = nuevasPrefs.alimentadores[id] || {};
          nuevasPrefs.alimentadores[id][campo] = valor;
        } else if (tipo === 'global') {
          nuevasPrefs.escalaGlobal = valor;
        }

        setPreferenciasUsuario(nuevasPrefs);
        // Luego guardar en BD (con await para asegurar que se complete)
        try {
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        } catch (err) {
          console.error("Error guardando preferencia:", err);
          setError(err.message);
        } finally {
          setTimeout(() => {
            setSaltarLimpiezaHuerfanos(false);
          }, 500);
        }
      }
    } catch (err) {
      console.error("Error guardando preferencia:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId, esCreador, preferenciasUsuario, recargarPuestos]);

  /**
   * Guarda m√∫ltiples preferencias de un puesto de una vez
   */
  const guardarPreferenciasPuesto = useCallback(async (puestoId, cambios) => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      setError(null);

      if (esCreador) {
        // Mapear campos frontend a backend
        const cambiosBackend = {};
        for (const [campo, valor] of Object.entries(cambios)) {
          if (campo === 'bgColor') {
            cambiosBackend.bg_color = valor;
          } else if (campo === 'gapsVerticales') {
            cambiosBackend.gaps_verticales = valor;
          } else {
            cambiosBackend[campo] = valor;
          }
        }
        await actualizarPuesto(puestoId, cambiosBackend);
        if (recargarPuestos) await recargarPuestos();
      } else {
        // Activar flag para evitar que limpiarHuerfanos se ejecute durante el guardado
        setSaltarLimpiezaHuerfanos(true);

        // Optimistic update: actualizar estado local primero para evitar lag
        const nuevasPrefs = { ...preferenciasUsuario };
        nuevasPrefs.puestos = nuevasPrefs.puestos || {};
        nuevasPrefs.puestos[puestoId] = {
          ...(nuevasPrefs.puestos[puestoId] || {}),
          ...cambios,
        };
        setPreferenciasUsuario(nuevasPrefs);
        // Luego guardar en BD (con await para asegurar que se complete antes de permitir limpiezaHuerfanos)
        try {
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        } catch (err) {
          console.error("Error guardando preferencias puesto:", err);
          setError(err.message);
        } finally {
          // Reactivar limpiezaHuerfanos despu√©s de un delay para evitar race condition
          setTimeout(() => {
            setSaltarLimpiezaHuerfanos(false);
          }, 500);
        }
      }
    } catch (err) {
      console.error("Error guardando preferencias puesto:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId, esCreador, preferenciasUsuario, recargarPuestos]);

  /**
   * Guarda m√∫ltiples preferencias de un alimentador de una vez
   */
  const guardarPreferenciasAlimentador = useCallback(async (alimentadorId, cambios) => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      setError(null);

      if (esCreador) {
        // Mapear campos frontend a backend
        const cambiosBackend = {};
        for (const [campo, valor] of Object.entries(cambios)) {
          if (campo === 'gapHorizontal') {
            cambiosBackend.gap_horizontal = valor;
          } else {
            cambiosBackend[campo] = valor;
          }
        }
        await actualizarAlimentadorAPI(alimentadorId, cambiosBackend);
        if (recargarPuestos) await recargarPuestos();
      } else {
        // Activar flag para evitar que limpiarHuerfanos se ejecute durante el guardado
        setSaltarLimpiezaHuerfanos(true);

        // Optimistic update: actualizar estado local primero para evitar lag
        const nuevasPrefs = { ...preferenciasUsuario };
        nuevasPrefs.alimentadores = nuevasPrefs.alimentadores || {};
        nuevasPrefs.alimentadores[alimentadorId] = {
          ...(nuevasPrefs.alimentadores[alimentadorId] || {}),
          ...cambios,
        };
        setPreferenciasUsuario(nuevasPrefs);
        // Luego guardar en BD (con await para asegurar que se complete)
        try {
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        } catch (err) {
          console.error("Error guardando preferencias alimentador:", err);
          setError(err.message);
        } finally {
          setTimeout(() => {
            setSaltarLimpiezaHuerfanos(false);
          }, 500);
        }
      }
    } catch (err) {
      console.error("Error guardando preferencias alimentador:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId, esCreador, preferenciasUsuario, recargarPuestos]);

  /**
   * Resetea las preferencias personales (vuelve a usar la config base)
   */
  const resetearPreferencias = useCallback(async () => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      await guardarPreferencias(workspaceId, { preferencias: {} });
      setPreferenciasUsuario({});
    } catch (err) {
      console.error("Error reseteando preferencias:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId]);

  /**
   * Obtiene la escala efectiva de un alimentador considerando la jerarqu√≠a:
   * Individual > Por puesto > Global > Default
   */
  const obtenerEscalaEfectiva = useCallback((alimentadorId, puestoId) => {
    // 1. Escala individual del alimentador
    const configAlim = obtenerConfigAlimentador(alimentadorId, puestoId);
    if (configAlim?.escala != null) return configAlim.escala;

    // 2. Escala del puesto
    const configPuesto = obtenerConfigPuesto(puestoId);
    if (configPuesto?.escala != null) return configPuesto.escala;

    // 3. Escala global
    if (escalaGlobal !== DEFAULTS.escalaGlobal) return escalaGlobal;

    // 4. Default
    return DEFAULTS.escalaGlobal;
  }, [obtenerConfigAlimentador, obtenerConfigPuesto, escalaGlobal]);

  /**
   * Verifica si el usuario tiene preferencias personales para este workspace
   */
  const tienePreferenciasPersonales = useMemo(() => {
    if (!preferenciasUsuario) return false;
    return (
      preferenciasUsuario.escalaGlobal != null ||
      Object.keys(preferenciasUsuario.puestos || {}).length > 0 ||
      Object.keys(preferenciasUsuario.alimentadores || {}).length > 0
    );
  }, [preferenciasUsuario]);

  return {
    // Estado
    preferenciasUsuario,
    cargando,
    error,
    guardando,
    esCreador,
    tienePreferenciasPersonales,

    // Getters (con merge base+override)
    obtenerConfigPuesto,
    obtenerConfigAlimentador,
    obtenerEscalaEfectiva,
    escalaGlobal,

    // Setters (guardan en base o preferencias seg√∫n rol)
    guardarPreferencia,
    guardarPreferenciasPuesto,
    guardarPreferenciasAlimentador,
    resetearPreferencias,

    // Utilidades
    cargarPreferencias,
    limpiarHuerfanos,

    // Constantes
    DEFAULTS,
  };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/usePuestosSupabase.js =====

// src/paginas/PaginaAlimentadores/hooks/usarPuestosSupabase.js
// Hook para manejar puestos y alimentadores usando Supabase

import { useState, useEffect, useCallback } from "react";
import {
  obtenerPuestos,
  crearPuesto,
  actualizarPuesto,
  eliminarPuesto as eliminarPuestoAPI,
  reordenarPuestos,
  obtenerAlimentadores,
  crearAlimentador,
  actualizarAlimentadorAPI,
  eliminarAlimentadorAPI,
  reordenarAlimentadores as reordenarAlimentadoresAPI,
} from "../../../servicios/apiService";
import { CLAVES_STORAGE } from "../constantes/clavesAlmacenamiento";
import { COLORES_SISTEMA } from "../constantes/colores";

/**
 * Hook para manejar puestos y alimentadores conectados a Supabase.
 * Requiere un workspace seleccionado para funcionar.
 *
 * @param {number|null} workspaceId - ID del workspace activo
 * @returns {Object} Estado y funciones para trabajar con puestos y alimentadores.
 */
export const usePuestosSupabase = (workspaceId) => {
  const COLOR_FONDO_POR_DEFECTO = "#e5e7eb";

  // Estado: lista de puestos (cada uno con sus alimentadores)
  const [puestos, setPuestos] = useState([]);

  // Estado de carga
  const [cargando, setCargando] = useState(false);

  // Error si ocurre
  const [error, setError] = useState(null);

  // Estado: ID del puesto actualmente seleccionado
  const [puestoSeleccionadoId, setPuestoSeleccionadoId] = useState(() => {
    const idGuardado = localStorage.getItem(CLAVES_STORAGE.PUESTO_SELECCIONADO);
    return idGuardado ? Number(idGuardado) : null;
  });

  // Derivado: objeto completo del puesto seleccionado
  const puestoSeleccionado =
    puestos.find((p) => p.id === puestoSeleccionadoId) ||
    puestos[0] ||
    null;

  /**
   * Transforma un puesto de la DB al formato del frontend
   * Convierte snake_case a camelCase para consistencia
   */
  function transformarPuestoDeDB(puesto) {
    // Parsear gaps_verticales si viene como string JSON
    let gapsVerticales = { "0": 40 };
    if (puesto.gaps_verticales) {
      if (typeof puesto.gaps_verticales === "string") {
        try {
          gapsVerticales = JSON.parse(puesto.gaps_verticales);
        } catch {
          gapsVerticales = { "0": 40 };
        }
      } else {
        gapsVerticales = puesto.gaps_verticales;
      }
    }

    return {
      ...puesto,
      bgColor: puesto.bg_color || "#e5e7eb",
      // Mantener bg_color por compatibilidad con c√≥digo existente
      bg_color: puesto.bg_color || "#e5e7eb",
      // Gaps verticales por fila
      gapsVerticales,
      // Escala del puesto (puede ser null si no est√° definida)
      escala: puesto.escala != null ? puesto.escala : null,
    };
  }

  /**
   * Carga los puestos y sus alimentadores desde el backend
   */
  const cargarPuestos = useCallback(async () => {
    if (!workspaceId) {
      setPuestos([]);
      return;
    }

    try {
      setCargando(true);
      setError(null);

      // Obtener puestos del workspace
      const puestosData = await obtenerPuestos(workspaceId);

      // Para cada puesto, cargar sus alimentadores
      const puestosConAlimentadores = await Promise.all(
        puestosData.map(async (puesto) => {
          try {
            const alimentadores = await obtenerAlimentadores(puesto.id);
            return {
              ...transformarPuestoDeDB(puesto),
              alimentadores: alimentadores.map(transformarAlimentadorDeDB),
            };
          } catch (err) {
            console.error(`Error cargando alimentadores del puesto ${puesto.id}:`, err);
            return { ...transformarPuestoDeDB(puesto), alimentadores: [] };
          }
        })
      );

      setPuestos(puestosConAlimentadores);

      // Auto-seleccionar primer puesto si no hay selecci√≥n v√°lida
      if (puestosConAlimentadores.length > 0) {
        const seleccionValida = puestosConAlimentadores.some(
          (p) => p.id === puestoSeleccionadoId
        );
        if (!seleccionValida) {
          setPuestoSeleccionadoId(puestosConAlimentadores[0].id);
        }
      }
    } catch (err) {
      console.error("Error cargando puestos:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  }, [workspaceId, puestoSeleccionadoId]);

  // Cargar puestos cuando cambie el workspace
  useEffect(() => {
    cargarPuestos();
  }, [workspaceId]);

  // Guardar selecci√≥n de puesto en localStorage
  useEffect(() => {
    if (puestoSeleccionadoId != null) {
      localStorage.setItem(CLAVES_STORAGE.PUESTO_SELECCIONADO, puestoSeleccionadoId.toString());
    } else {
      localStorage.removeItem(CLAVES_STORAGE.PUESTO_SELECCIONADO);
    }
  }, [puestoSeleccionadoId]);

  /**
   * Transforma un alimentador de la DB al formato del frontend
   * Genera el formato con objetos rele/analizador que espera el modal
   * Tambi√©n soporta el nuevo formato con registrador_id, intervalo_consulta_ms y card_design
   */
  function transformarAlimentadorDeDB(alim) {
    // Para campos num√©ricos opcionales: si no hay valor en DB, devolver null/undefined
    // para que el modal muestre el placeholder en lugar de un valor por defecto
    const releConfig = alim.config_rele || {};
    const analizadorConfig = alim.config_analizador || {};

    return {
      id: alim.id,
      nombre: alim.nombre,
      color: alim.color || COLORES_SISTEMA[0],
      tipoDispositivo: alim.tipo || "rele",
      // Gap horizontal a la derecha de esta tarjeta
      gapHorizontal: alim.gap_horizontal != null ? alim.gap_horizontal : 0,
      // Escala individual de la tarjeta (puede ser null si no est√° definida)
      escala: alim.escala != null ? alim.escala : null,

      // === NUEVOS CAMPOS para el modal v2 ===
      registrador_id: alim.registrador_id || null,
      intervalo_consulta_ms: alim.intervalo_consulta_ms || 60000,
      card_design: alim.card_design || {},

      // Formato nuevo que espera el modal
      // Si no hay valor guardado, dejamos null para que se muestre el placeholder
      rele: {
        ip: releConfig.ip || "",
        puerto: releConfig.puerto != null ? releConfig.puerto : null,
        unitId: releConfig.unitId || 1,
        indiceInicial: releConfig.indiceInicial != null ? releConfig.indiceInicial : null,
        cantRegistros: releConfig.cantRegistros != null ? releConfig.cantRegistros : null,
      },
      periodoSegundos: releConfig.periodoLectura != null ? releConfig.periodoLectura : 60,
      analizador: {
        ip: analizadorConfig.ip || "",
        puerto: analizadorConfig.puerto != null ? analizadorConfig.puerto : null,
        unitId: analizadorConfig.unitId || 2,
        indiceInicial: analizadorConfig.indiceInicial != null ? analizadorConfig.indiceInicial : null,
        cantRegistros: analizadorConfig.cantRegistros != null ? analizadorConfig.cantRegistros : null,
        periodoSegundos: analizadorConfig.periodoLectura != null ? analizadorConfig.periodoLectura : 60,
      },
      // Campos legacy para compatibilidad con otras partes del c√≥digo
      ip: releConfig.ip || "",
      puerto: releConfig.puerto != null ? releConfig.puerto : null,
      unitId: releConfig.unitId || 1,
      periodoLectura: releConfig.periodoLectura != null ? releConfig.periodoLectura : 60,
      indiceInicio: releConfig.indiceInicial != null ? releConfig.indiceInicial : null,
      indiceFin: releConfig.indiceInicial != null && releConfig.cantRegistros != null
        ? releConfig.indiceInicial + releConfig.cantRegistros
        : null,
      ipAnalizador: analizadorConfig.ip || "",
      puertoAnalizador: analizadorConfig.puerto != null ? analizadorConfig.puerto : null,
      unitIdAnalizador: analizadorConfig.unitId || 2,
      periodoLecturaAnalizador: analizadorConfig.periodoLectura != null ? analizadorConfig.periodoLectura : 60,
      indiceInicioAnalizador: analizadorConfig.indiceInicial != null ? analizadorConfig.indiceInicial : null,
      indiceFinAnalizador: analizadorConfig.indiceInicial != null && analizadorConfig.cantRegistros != null
        ? analizadorConfig.indiceInicial + analizadorConfig.cantRegistros
        : null,
      mapeoMediciones: alim.mapeo_mediciones || {},
    };
  }

  /**
   * Transforma un alimentador del frontend al formato de la DB
   * Acepta tanto el formato plano (legacy) como el formato con objetos rele/analizador anidados
   * Tambi√©n soporta el nuevo formato con registrador_id, intervalo_consulta_ms y card_design
   */
  function transformarAlimentadorADB(alim) {
    // Base com√∫n para todos los formatos
    const base = {
      nombre: alim.nombre,
      color: alim.color,
    };

    // === NUEVO FORMATO: con registrador_id y card_design ===
    // El nuevo modal env√≠a: { nombre, color, registrador_id, intervalo_consulta_ms, card_design }
    if (alim.registrador_id !== undefined || alim.card_design !== undefined || alim.intervalo_consulta_ms !== undefined) {
      return {
        ...base,
        registrador_id: alim.registrador_id || null,
        intervalo_consulta_ms: alim.intervalo_consulta_ms || 60000,
        card_design: alim.card_design || {},
        gap_horizontal: alim.gapHorizontal != null ? alim.gapHorizontal : 0,
        mapeo_mediciones: alim.mapeoMediciones || {},
      };
    }

    // === FORMATO LEGACY: con objetos rele/analizador ===
    const tieneFormatoNuevo = alim.rele || alim.analizador;

    if (tieneFormatoNuevo) {
      // Formato nuevo del modal: { rele: {...}, analizador: {...} }
      // Preservar null para campos num√©ricos opcionales (puerto, indiceInicial, cantRegistros)
      // para que al cargar se muestren los placeholders en lugar de valores por defecto
      return {
        ...base,
        tipo: alim.tipoDispositivo || "rele",
        gap_horizontal: alim.gapHorizontal != null ? alim.gapHorizontal : 10,
        config_rele: alim.rele ? {
          ip: alim.rele.ip || "",
          puerto: alim.rele.puerto != null ? alim.rele.puerto : null,
          unitId: alim.rele.unitId || 1,
          periodoLectura: alim.periodoSegundos || 60,
          indiceInicial: alim.rele.indiceInicial != null ? alim.rele.indiceInicial : null,
          cantRegistros: alim.rele.cantRegistros != null ? alim.rele.cantRegistros : null,
        } : null,
        config_analizador: alim.analizador ? {
          ip: alim.analizador.ip || "",
          puerto: alim.analizador.puerto != null ? alim.analizador.puerto : null,
          unitId: alim.analizador.unitId || 2,
          periodoLectura: alim.analizador.periodoSegundos || 60,
          indiceInicial: alim.analizador.indiceInicial != null ? alim.analizador.indiceInicial : null,
          cantRegistros: alim.analizador.cantRegistros != null ? alim.analizador.cantRegistros : null,
        } : null,
        mapeo_mediciones: alim.mapeoMediciones || {},
      };
    }

    // Formato plano (legacy)
    // Preservar null para campos num√©ricos opcionales
    return {
      ...base,
      tipo: alim.tipoDispositivo || "rele",
      gap_horizontal: alim.gapHorizontal != null ? alim.gapHorizontal : 10,
      config_rele: {
        ip: alim.ip || "",
        puerto: alim.puerto != null ? alim.puerto : null,
        unitId: alim.unitId || 1,
        periodoLectura: alim.periodoLectura || 60,
        indiceInicial: alim.indiceInicio != null ? alim.indiceInicio : null,
        cantRegistros: alim.indiceFin != null && alim.indiceInicio != null
          ? (alim.indiceFin - alim.indiceInicio)
          : null,
      },
      config_analizador: {
        ip: alim.ipAnalizador || "",
        puerto: alim.puertoAnalizador != null ? alim.puertoAnalizador : null,
        unitId: alim.unitIdAnalizador || 2,
        periodoLectura: alim.periodoLecturaAnalizador || 60,
        indiceInicial: alim.indiceInicioAnalizador != null ? alim.indiceInicioAnalizador : null,
        cantRegistros: alim.indiceFinAnalizador != null && alim.indiceInicioAnalizador != null
          ? (alim.indiceFinAnalizador - alim.indiceInicioAnalizador)
          : null,
      },
      mapeo_mediciones: alim.mapeoMediciones || {},
    };
  }

  /**
   * Agrega un nuevo puesto
   */
  const agregarPuesto = async (nombrePuesto, colorPuesto) => {
    if (!workspaceId) return;

    try {
      setError(null);
      const nuevoPuesto = await crearPuesto(workspaceId, {
        nombre: nombrePuesto.trim(),
        color: colorPuesto || COLORES_SISTEMA[0],
        bg_color: COLOR_FONDO_POR_DEFECTO,
      });

      const puestoConAlimentadores = { ...nuevoPuesto, alimentadores: [] };
      setPuestos((prev) => [...prev, puestoConAlimentadores]);
      setPuestoSeleccionadoId(nuevoPuesto.id);

      return nuevoPuesto;
    } catch (err) {
      console.error("Error creando puesto:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Actualiza la lista completa de puestos (para edici√≥n masiva)
   */
  const actualizarPuestos = async (nuevaListaPuestos) => {
    const sinVacios = nuevaListaPuestos.filter((p) => p.nombre.trim() !== "");

    // Actualizar cada puesto en el backend
    try {
      setError(null);

      for (const puesto of sinVacios) {
        await actualizarPuesto(puesto.id, {
          nombre: puesto.nombre,
          color: puesto.color,
          bg_color: puesto.bgColor || puesto.bg_color,
        });
      }

      setPuestos(sinVacios);

      // Si el seleccionado se elimin√≥, seleccionar el primero
      const seleccionExiste = sinVacios.some((p) => p.id === puestoSeleccionadoId);
      if (!seleccionExiste) {
        setPuestoSeleccionadoId(sinVacios[0]?.id || null);
      }
    } catch (err) {
      console.error("Error actualizando puestos:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Elimina un puesto
   */
  const eliminarPuesto = async (idPuesto) => {
    try {
      setError(null);
      await eliminarPuestoAPI(idPuesto);
      setPuestos((prev) => prev.filter((p) => p.id !== idPuesto));

      // Si se elimin√≥ el seleccionado, seleccionar otro
      if (puestoSeleccionadoId === idPuesto) {
        const restantes = puestos.filter((p) => p.id !== idPuesto);
        setPuestoSeleccionadoId(restantes[0]?.id || null);
      }
    } catch (err) {
      console.error("Error eliminando puesto:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Selecciona un puesto como activo
   */
  const seleccionarPuesto = (idPuesto) => {
    setPuestoSeleccionadoId(idPuesto);
  };

  /**
   * Agrega un alimentador al puesto seleccionado
   */
  const agregarAlimentador = async (datosAlimentador) => {
    if (!puestoSeleccionado) return;

    try {
      setError(null);
      const datosDB = transformarAlimentadorADB(datosAlimentador);
      const nuevoAlimentador = await crearAlimentador(puestoSeleccionado.id, datosDB);

      const alimentadorFrontend = transformarAlimentadorDeDB(nuevoAlimentador);

      setPuestos((prev) =>
        prev.map((p) =>
          p.id === puestoSeleccionado.id
            ? { ...p, alimentadores: [...p.alimentadores, alimentadorFrontend] }
            : p
        )
      );

      return alimentadorFrontend;
    } catch (err) {
      console.error("Error creando alimentador:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Actualiza un alimentador existente
   */
  const actualizarAlimentador = async (idPuesto, idAlimentador, nuevosDatos) => {
    try {
      setError(null);
      const datosDB = transformarAlimentadorADB(nuevosDatos);
      const actualizado = await actualizarAlimentadorAPI(idAlimentador, datosDB);

      const alimentadorFrontend = transformarAlimentadorDeDB(actualizado);

      setPuestos((prev) =>
        prev.map((p) =>
          p.id === idPuesto
            ? {
                ...p,
                alimentadores: p.alimentadores.map((a) =>
                  a.id === idAlimentador ? alimentadorFrontend : a
                ),
              }
            : p
        )
      );

      return alimentadorFrontend;
    } catch (err) {
      console.error("Error actualizando alimentador:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Elimina un alimentador
   */
  const eliminarAlimentador = async (idPuesto, idAlimentador) => {
    try {
      setError(null);
      await eliminarAlimentadorAPI(idAlimentador);

      setPuestos((prev) =>
        prev.map((p) =>
          p.id === idPuesto
            ? { ...p, alimentadores: p.alimentadores.filter((a) => a.id !== idAlimentador) }
            : p
        )
      );
    } catch (err) {
      console.error("Error eliminando alimentador:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Reordena los alimentadores de un puesto (solo estado local).
   * La sincronizaci√≥n con BD se hace al presionar "Guardar cambios".
   */
  const reordenarAlimentadores = (idPuesto, nuevoOrdenAlimentadores) => {
    // Solo actualizar estado local - la sincronizaci√≥n con BD
    // se hace mediante el bot√≥n "Guardar cambios" (draft/publish pattern)
    setPuestos((prev) =>
      prev.map((p) =>
        p.id === idPuesto ? { ...p, alimentadores: nuevoOrdenAlimentadores } : p
      )
    );
  };

  return {
    // Estados
    puestos,
    puestoSeleccionado,
    puestoSeleccionadoId,
    cargando,
    error,

    // Funciones de puestos
    cargarPuestos,
    agregarPuesto,
    eliminarPuesto,
    seleccionarPuesto,
    actualizarPuestos,
    setPuestos,

    // Funciones de alimentadores
    agregarAlimentador,
    actualizarAlimentador,
    eliminarAlimentador,
    reordenarAlimentadores,
  };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/useTransformadores.js =====

import { useState, useEffect, useCallback } from "react";

const STORAGE_KEY = "transformadores_ti_tv";

// Transformadores por defecto
const TRANSFORMADORES_DEFAULT = [
  { id: "ti-1", tipo: "TI", nombre: "TI 200/1", formula: "x * 200 / 1000" },
  { id: "ti-2", tipo: "TI", nombre: "TI 400/1", formula: "x * 400 / 1000" },
  { id: "ti-3", tipo: "TI", nombre: "TI 600/1", formula: "x * 600 / 1000" },
  { id: "tv-1", tipo: "TV", nombre: "TV 33kV", formula: "x * 33000 / 10000" },
  { id: "tv-2", tipo: "TV", nombre: "TV 13.2kV", formula: "x * 13200 / 10000" },
];

/**
 * Hook para gestionar transformadores de intensidad (TI) y voltaje (TV)
 * Persiste en localStorage
 */
export const useTransformadores = () => {
  const [transformadores, setTransformadores] = useState([]);
  const [cargando, setCargando] = useState(true);

  // Cargar transformadores del localStorage
  const cargarTransformadores = useCallback(() => {
    try {
      const guardados = localStorage.getItem(STORAGE_KEY);
      if (guardados) {
        setTransformadores(JSON.parse(guardados));
      } else {
        // Primera vez: usar los por defecto
        setTransformadores(TRANSFORMADORES_DEFAULT);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(TRANSFORMADORES_DEFAULT));
      }
    } catch (error) {
      console.error("Error cargando transformadores:", error);
      setTransformadores(TRANSFORMADORES_DEFAULT);
    } finally {
      setCargando(false);
    }
  }, []);

  useEffect(() => {
    cargarTransformadores();
  }, [cargarTransformadores]);

  // Guardar en localStorage
  const guardarEnStorage = useCallback((datos) => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(datos));
      setTransformadores(datos);
      return true;
    } catch (error) {
      console.error("Error guardando transformadores:", error);
      return false;
    }
  }, []);

  // Generar ID √∫nico
  const generarId = () => {
    return "tr-" + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
  };

  // Obtener transformadores por tipo
  const obtenerPorTipo = useCallback(
    (tipo) => {
      return transformadores.filter((t) => t.tipo === tipo);
    },
    [transformadores]
  );

  // Obtener TIs
  const obtenerTIs = useCallback(() => obtenerPorTipo("TI"), [obtenerPorTipo]);

  // Obtener TVs
  const obtenerTVs = useCallback(() => obtenerPorTipo("TV"), [obtenerPorTipo]);

  // Obtener Relaciones
  const obtenerRelaciones = useCallback(() => obtenerPorTipo("REL"), [obtenerPorTipo]);

  // Obtener transformador por ID
  const obtenerPorId = useCallback(
    (id) => {
      return transformadores.find((t) => t.id === id) || null;
    },
    [transformadores]
  );

  // Crear transformador
  const crearTransformador = useCallback(
    (datos) => {
      const nuevo = {
        id: generarId(),
        tipo: datos.tipo,
        nombre: datos.nombre.trim(),
        formula: datos.formula.trim(),
      };

      const nuevos = [...transformadores, nuevo];
      const exito = guardarEnStorage(nuevos);
      return exito ? nuevo : null;
    },
    [transformadores, guardarEnStorage]
  );

  // Actualizar transformador
  const actualizarTransformador = useCallback(
    (id, datos) => {
      const indice = transformadores.findIndex((t) => t.id === id);
      if (indice === -1) return false;

      const actualizado = {
        ...transformadores[indice],
        nombre: datos.nombre?.trim() || transformadores[indice].nombre,
        formula: datos.formula?.trim() || transformadores[indice].formula,
      };

      const nuevos = [...transformadores];
      nuevos[indice] = actualizado;
      return guardarEnStorage(nuevos);
    },
    [transformadores, guardarEnStorage]
  );

  // Eliminar transformador
  const eliminarTransformador = useCallback(
    (id) => {
      const nuevos = transformadores.filter((t) => t.id !== id);
      return guardarEnStorage(nuevos);
    },
    [transformadores, guardarEnStorage]
  );

  return {
    transformadores,
    cargando,
    obtenerTIs,
    obtenerTVs,
    obtenerRelaciones,
    obtenerPorId,
    crearTransformador,
    actualizarTransformador,
    eliminarTransformador,
    recargar: cargarTransformadores,
  };
};

export default useTransformadores;

// ===== ./src/paginas/PaginaAlimentadores/hooks/useVentanaConfigAgente.js =====

/**
 * Hook para gestionar el estado de la ventana flotante de configuraci√≥n de agentes
 * Gestiona: abrir, cerrar, minimizar, maximizar, mover, redimensionar
 */

import { useState, useCallback, useRef } from "react";

// Z-index base para la ventana de config agente
const Z_INDEX_BASE = 1100;

export const useVentanaConfigAgente = () => {
  // Estado de la ventana
  const [ventana, setVentana] = useState({
    abierta: false,
    minimizada: false,
    maximizada: false,
    posicion: { x: 100, y: 50 },
    zIndex: Z_INDEX_BASE,
    workspaceId: null,
  });

  // Contador para z-index (para traer al frente)
  const zIndexCounterRef = useRef(Z_INDEX_BASE);

  /**
   * Obtiene el siguiente z-index y lo incrementa
   */
  const getNextZIndex = useCallback(() => {
    zIndexCounterRef.current += 1;
    return zIndexCounterRef.current;
  }, []);

  /**
   * Abre la ventana de configuraci√≥n de agentes
   */
  const abrirVentana = useCallback((workspaceId) => {
    setVentana((prev) => ({
      ...prev,
      abierta: true,
      minimizada: false,
      workspaceId,
      zIndex: getNextZIndex(),
    }));
  }, [getNextZIndex]);

  /**
   * Cierra la ventana
   */
  const cerrarVentana = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      abierta: false,
      minimizada: false,
      maximizada: false,
    }));
  }, []);

  /**
   * Minimiza/restaura la ventana
   */
  const toggleMinimizar = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      minimizada: !prev.minimizada,
    }));
  }, []);

  /**
   * Maximiza/restaura la ventana
   */
  const toggleMaximizar = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      maximizada: !prev.maximizada,
      zIndex: getNextZIndex(),
    }));
  }, [getNextZIndex]);

  /**
   * Trae la ventana al frente (actualiza z-index)
   */
  const enfocarVentana = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      minimizada: false,
      zIndex: getNextZIndex(),
    }));
  }, [getNextZIndex]);

  /**
   * Actualiza la posici√≥n de la ventana (al arrastrar)
   */
  const moverVentana = useCallback((nuevaPosicion) => {
    setVentana((prev) => ({
      ...prev,
      posicion: nuevaPosicion,
    }));
  }, []);

  return {
    ventana,
    abrirVentana,
    cerrarVentana,
    toggleMinimizar,
    toggleMaximizar,
    enfocarVentana,
    moverVentana,
  };
};

export default useVentanaConfigAgente;

// ===== ./src/paginas/PaginaAlimentadores/hooks/useVentanasHistorial.js =====

/**
 * Hook para gestionar m√∫ltiples ventanas de historial flotantes
 * Permite abrir, minimizar, maximizar y cerrar ventanas de historial
 * Solo permite una ventana por alimentador
 */

import { useState, useCallback, useRef } from "react";

// Z-index base para ventanas flotantes
const Z_INDEX_BASE = 1000;

export const useVentanasHistorial = () => {
  // Map de ventanas abiertas: { [alimentadorId]: estadoVentana }
  const [ventanas, setVentanas] = useState({});

  // Contador para z-index de ventanas (foco) - useRef para persistir sin re-renders
  const zIndexCounterRef = useRef(Z_INDEX_BASE);

  /**
   * Obtiene el siguiente z-index y lo incrementa
   */
  const getNextZIndex = useCallback(() => {
    zIndexCounterRef.current += 1;
    return zIndexCounterRef.current;
  }, []);

  /**
   * Estado inicial de una ventana
   */
  const crearEstadoVentana = useCallback((alimentador, cardDesign, posicionInicial) => ({
    id: alimentador.id,
    alimentador,
    cardDesign,
    minimizada: false,
    maximizada: false,
    posicion: posicionInicial || { x: 100 + Math.random() * 100, y: 50 + Math.random() * 50 },
    tama√±o: { width: 900, height: 600 },
    zIndex: getNextZIndex(),
  }), [getNextZIndex]);

  /**
   * Abre una ventana de historial para un alimentador
   * Si ya existe, la trae al frente y la restaura si estaba minimizada
   */
  const abrirVentana = useCallback((alimentador, cardDesign) => {
    setVentanas((prev) => {
      // Si ya existe la ventana para este alimentador
      if (prev[alimentador.id]) {
        // Traer al frente y restaurar si estaba minimizada
        return {
          ...prev,
          [alimentador.id]: {
            ...prev[alimentador.id],
            minimizada: false,
            zIndex: getNextZIndex(),
          },
        };
      }

      // Calcular posici√≥n escalonada basada en n√∫mero de ventanas
      const numVentanas = Object.keys(prev).length;
      const posicionInicial = {
        x: 50 + (numVentanas % 5) * 30,
        y: 50 + (numVentanas % 5) * 30,
      };

      // Crear nueva ventana
      return {
        ...prev,
        [alimentador.id]: crearEstadoVentana(alimentador, cardDesign, posicionInicial),
      };
    });
  }, [crearEstadoVentana, getNextZIndex]);

  /**
   * Cierra una ventana de historial
   */
  const cerrarVentana = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      const { [alimentadorId]: _, ...rest } = prev;
      return rest;
    });
  }, []);

  /**
   * Minimiza/restaura una ventana
   */
  const toggleMinimizar = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          minimizada: !prev[alimentadorId].minimizada,
        },
      };
    });
  }, []);

  /**
   * Maximiza/restaura una ventana
   */
  const toggleMaximizar = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          maximizada: !prev[alimentadorId].maximizada,
          zIndex: getNextZIndex(),
        },
      };
    });
  }, [getNextZIndex]);

  /**
   * Trae una ventana al frente (actualiza z-index)
   */
  const enfocarVentana = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          minimizada: false,
          zIndex: getNextZIndex(),
        },
      };
    });
  }, [getNextZIndex]);

  /**
   * Actualiza la posici√≥n de una ventana (al arrastrar)
   */
  const moverVentana = useCallback((alimentadorId, nuevaPosicion) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          posicion: nuevaPosicion,
        },
      };
    });
  }, []);

  /**
   * Actualiza el tama√±o de una ventana
   */
  const redimensionarVentana = useCallback((alimentadorId, nuevoTama√±o) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          tama√±o: nuevoTama√±o,
        },
      };
    });
  }, []);

  /**
   * Verifica si hay una ventana abierta para un alimentador
   */
  const tieneVentanaAbierta = useCallback(
    (alimentadorId) => {
      return !!ventanas[alimentadorId];
    },
    [ventanas]
  );

  /**
   * Obtiene la lista de ventanas como array (para renderizar)
   */
  const listaVentanas = Object.values(ventanas);

  /**
   * Obtiene las ventanas minimizadas (para barra de tareas)
   */
  const ventanasMinimizadas = listaVentanas.filter((v) => v.minimizada);

  return {
    ventanas,
    listaVentanas,
    ventanasMinimizadas,
    abrirVentana,
    cerrarVentana,
    toggleMinimizar,
    toggleMaximizar,
    enfocarVentana,
    moverVentana,
    redimensionarVentana,
    tieneVentanaAbierta,
  };
};

export default useVentanasHistorial;

// ===== ./src/paginas/PaginaAlimentadores/PaginaAlimentadoresSupabase.jsx =====

// src/paginas/PaginaAlimentadores/PaginaAlimentadoresSupabase.jsx
// Versi√≥n de la p√°gina que usa Supabase para persistencia

import React from "react";

import { ProveedorConfiguracion } from "./contexto/ContextoConfiguracion";
import { ProveedorAlimentadoresSupabase } from "./contexto/ContextoAlimentadoresSupabase";

import VistaAlimentadores from "./componentes/layout/VistaAlimentadores.jsx";

/**
 * P√°gina de alimentadores conectada a Supabase.
 *
 * Estructura de providers:
 * - ProveedorConfiguracion: maneja los workspaces del usuario
 * - ProveedorAlimentadoresSupabase: maneja puestos y alimentadores con Supabase
 */
const PaginaAlimentadoresSupabase = () => {
  return (
    <ProveedorConfiguracion>
      <ProveedorAlimentadoresSupabase>
        <VistaAlimentadores />
      </ProveedorAlimentadoresSupabase>
    </ProveedorConfiguracion>
  );
};

export default PaginaAlimentadoresSupabase;

// ===== ./src/paginas/PaginaAlimentadores/utilidades/calculadorRutas.js =====

// src/paginas/PaginaAlimentadores/utilidades/calculadorRutas.js

/**
 * Utilidades para calcular rutas en el diagrama unifilar.
 * Las chispas viajan desde bornes emisores hasta bornes receptores
 * siguiendo las l√≠neas (celdas adyacentes) del diagrama.
 */

/**
 * Construye un grafo de adyacencia a partir de las celdas pintadas.
 * Cada celda puede conectarse con sus 4 vecinos (arriba, abajo, izquierda, derecha)
 * si estos tambi√©n est√°n pintados (sin importar el color).
 *
 * @param {Object} celdas - Objeto con claves "x,y" y valores de color
 * @returns {Object} Grafo de adyacencia { "x,y": ["x1,y1", "x2,y2", ...] }
 */
export function construirGrafo(celdas) {
	const grafo = {};
	const clavesCeldas = Object.keys(celdas);

	// Para b√∫squeda r√°pida
	const celdasSet = new Set(clavesCeldas);

	clavesCeldas.forEach(clave => {
		const [x, y] = clave.split(",").map(Number);
		const vecinos = [];

		// Verificar los 4 vecinos
		const posiblesVecinos = [
			`${x},${y - 1}`, // arriba
			`${x},${y + 1}`, // abajo
			`${x - 1},${y}`, // izquierda
			`${x + 1},${y}`, // derecha
		];

		posiblesVecinos.forEach(vecino => {
			if (celdasSet.has(vecino)) {
				vecinos.push(vecino);
			}
		});

		grafo[clave] = vecinos;
	});

	return grafo;
}

/**
 * Calcula todas las rutas posibles desde un emisor hasta cualquier receptor.
 * Usa BFS para encontrar el camino m√°s corto a cada receptor.
 *
 * @param {Object} emisor - Borne emisor { x, y, id, ... }
 * @param {Array} bornes - Array de todos los bornes
 * @param {Object} grafo - Grafo de adyacencia
 * @returns {Array} Array de rutas [{ receptorId, ruta: ["x,y", ...] }, ...]
 */
export function calcularRutasDesdeEmisor(emisor, bornes, grafo) {
	const claveEmisor = `${emisor.x},${emisor.y}`;
	const receptores = bornes.filter(b => b.tipo === "RECEPTOR");

	// Si no hay grafo o el emisor no est√° en el grafo, retornar vac√≠o
	if (!grafo[claveEmisor]) {
		return [];
	}

	// Crear mapa de posici√≥n a borne para b√∫squeda r√°pida
	const posicionAReceptor = {};
	receptores.forEach(r => {
		posicionAReceptor[`${r.x},${r.y}`] = r;
	});

	// BFS para encontrar rutas a todos los receptores
	const rutas = [];
	const visitados = new Set([claveEmisor]);
	const cola = [[claveEmisor, [claveEmisor]]]; // [posici√≥n, rutaHastaAqu√≠]

	while (cola.length > 0) {
		const [posActual, rutaActual] = cola.shift();

		// Si llegamos a un receptor, guardar la ruta
		if (posActual !== claveEmisor && posicionAReceptor[posActual]) {
			rutas.push({
				receptorId: posicionAReceptor[posActual].id,
				ruta: rutaActual,
			});
			// Continuamos buscando para encontrar otros receptores
		}

		// Explorar vecinos
		const vecinos = grafo[posActual] || [];
		vecinos.forEach(vecino => {
			if (!visitados.has(vecino)) {
				visitados.add(vecino);
				cola.push([vecino, [...rutaActual, vecino]]);
			}
		});
	}

	return rutas;
}

/**
 * Verifica si desde una celda se puede llegar a alg√∫n receptor
 * (usado para decisiones en bifurcaciones).
 *
 * @param {string} celda - Clave de la celda "x,y"
 * @param {Set} receptoresSet - Set de claves de receptores
 * @param {Object} grafo - Grafo de adyacencia
 * @param {Set} visitados - Celdas ya visitadas (para evitar ciclos)
 * @returns {boolean} true si se puede llegar a un receptor
 */
export function llegaAReceptor(celda, receptoresSet, grafo, visitados = new Set()) {
	if (receptoresSet.has(celda)) {
		return true;
	}

	if (visitados.has(celda)) {
		return false;
	}

	visitados.add(celda);

	const vecinos = grafo[celda] || [];
	for (const vecino of vecinos) {
		if (!visitados.has(vecino)) {
			if (llegaAReceptor(vecino, receptoresSet, grafo, visitados)) {
				return true;
			}
		}
	}

	return false;
}

/**
 * Dado el estado actual de una chispa en una bifurcaci√≥n,
 * determina hacia qu√© caminos debe continuar.
 *
 * Reglas:
 * - Si ambos caminos llevan a receptores: la chispa se divide (retorna ambos)
 * - Si ambos caminos llevan a emisores: la chispa desaparece (retorna vac√≠o)
 * - Si hay mezcla: sigue solo hacia el receptor (retorna solo el camino correcto)
 *
 * @param {string} posicionActual - Clave de la celda actual
 * @param {string} posicionAnterior - Clave de la celda anterior (de donde viene)
 * @param {Object} grafo - Grafo de adyacencia
 * @param {Array} bornes - Array de todos los bornes
 * @returns {Array} Array de claves de celdas hacia donde continuar
 */
export function decidirDireccionEnBifurcacion(posicionActual, posicionAnterior, grafo, bornes) {
	const vecinos = grafo[posicionActual] || [];

	// Filtrar el vecino de donde venimos
	const posiblesCaminos = vecinos.filter(v => v !== posicionAnterior);

	// Si solo hay un camino o ninguno, no hay decisi√≥n
	if (posiblesCaminos.length <= 1) {
		return posiblesCaminos;
	}

	// Crear sets para b√∫squeda r√°pida
	const emisoresSet = new Set(
		bornes.filter(b => b.tipo === "EMISOR").map(b => `${b.x},${b.y}`)
	);
	const receptoresSet = new Set(
		bornes.filter(b => b.tipo === "RECEPTOR").map(b => `${b.x},${b.y}`)
	);

	// Verificar cada camino si lleva a receptor
	const caminosAReceptor = [];
	const caminosAEmisor = [];

	posiblesCaminos.forEach(camino => {
		// Clonar visitados para cada exploraci√≥n
		const visitados = new Set([posicionActual, posicionAnterior]);

		if (llegaAReceptor(camino, receptoresSet, grafo, visitados)) {
			caminosAReceptor.push(camino);
		} else {
			// Si no llega a receptor, asumimos que lleva a emisor o callej√≥n sin salida
			caminosAEmisor.push(camino);
		}
	});

	// Aplicar reglas de bifurcaci√≥n
	if (caminosAReceptor.length > 0) {
		// Si hay caminos a receptores, seguir todos ellos (dividir chispa)
		return caminosAReceptor;
	} else {
		// Todos llevan a emisores o callejones: la chispa desaparece
		return [];
	}
}

/**
 * Precalcula todas las rutas desde todos los emisores a todos los receptores.
 * √ötil para inicializar el sistema de chispas.
 *
 * @param {Array} bornes - Array de todos los bornes
 * @param {Object} celdas - Objeto de celdas pintadas
 * @returns {Object} Mapa { emisorId: [{ receptorId, ruta }, ...] }
 */
export function precalcularTodasLasRutas(bornes, celdas) {
	const grafo = construirGrafo(celdas);
	const emisores = bornes.filter(b => b.tipo === "EMISOR");
	const resultado = {};

	emisores.forEach(emisor => {
		resultado[emisor.id] = calcularRutasDesdeEmisor(emisor, bornes, grafo);
	});

	return resultado;
}

/**
 * Obtiene el siguiente paso para una chispa en movimiento.
 * Maneja bifurcaciones seg√∫n las reglas del sistema.
 *
 * @param {Object} chispa - Estado de la chispa { ruta, posicion, ... }
 * @param {Object} grafo - Grafo de adyacencia
 * @param {Array} bornes - Array de todos los bornes
 * @returns {Object} { continuar: boolean, nuevasPosiciones: [clave, ...] }
 */
export function obtenerSiguientePaso(chispa, grafo, bornes) {
	const { ruta, posicion } = chispa;

	// Si ya llegamos al final de la ruta
	if (posicion >= ruta.length - 1) {
		return { continuar: false, nuevasPosiciones: [] };
	}

	const posActual = ruta[posicion];
	const posSiguiente = ruta[posicion + 1];

	// Verificar si hay bifurcaci√≥n en el siguiente paso
	const vecinosSiguiente = grafo[posSiguiente] || [];

	if (vecinosSiguiente.length > 2) {
		// Hay bifurcaci√≥n - decidir hacia d√≥nde ir
		const direcciones = decidirDireccionEnBifurcacion(posSiguiente, posActual, grafo, bornes);

		if (direcciones.length === 0) {
			// La chispa desaparece
			return { continuar: false, nuevasPosiciones: [] };
		}

		// Retornar las posibles direcciones (para dividir chispa si hay m√°s de una)
		return { continuar: true, nuevasPosiciones: direcciones };
	}

	// Sin bifurcaci√≥n - continuar normalmente
	return { continuar: true, nuevasPosiciones: [posSiguiente] };
}

// ===== ./src/paginas/PaginaAlimentadores/utilidades/calculosFormulas.js =====

// src/paginas/PaginaAlimentadores/utilidades/calculosFormulas.js

/**
 * Aplica una f√≥rmula matem√°tica a un valor 'x'.
 * Ejemplo: aplicarFormula("x * 2 + 10", 5) => 20.
 *
 * NOTA EDUCATIVA: Usamos new Function() solo para ambiente de aprendizaje.
 * En producci√≥n se usar√≠a una librer√≠a como mathjs para mayor seguridad.
 *
 * @param {string} textoFormula - F√≥rmula en texto, ej: "x / 100".
 * @param {number} x - Valor al que aplicar la f√≥rmula.
 * @returns {number|null} Resultado o null si hay error.
 */
export const aplicarFormula = (textoFormula, x) => {
	const formulaLimpia = (textoFormula || "").trim(); // quita espacios y maneja null/undefined

	// Si no hay f√≥rmula, devolver el valor sin cambios
	if (!formulaLimpia) return x;

	try {
		// Crear funci√≥n din√°mica (solo para ambiente educativo)
		const funcionCalcular = new Function("x", `return ${formulaLimpia};`);
		const resultado = funcionCalcular(x);          // eval√∫a la f√≥rmula con el valor x

		// Verificar que sea n√∫mero v√°lido
		return typeof resultado === "number" && !Number.isNaN(resultado)
			 ? resultado
		 : null;
	} catch (error) {
		console.error("Error al aplicar f√≥rmula:", error);
		return null;                                   // ante error sint√°ctico o ejecuci√≥n, devolvemos null
	}
};

/**
 * Formatea un n√∫mero para mostrarlo en la interfaz.
 * Ejemplos:
 *   - 123.456 => "123,46"
 *   - null => "ERROR"
 *   - NaN => "ERROR"
 *
 * @param {number} valor - N√∫mero a formatear.
 * @returns {string} Valor formateado con 2 decimales y coma.
 */
export const formatearValor = (valor) => {
	// Si es inv√°lido, mostrar ERROR
	if (valor == null || Number.isNaN(valor)) {
		return "ERROR";
	}

	// Convertir a 2 decimales y cambiar punto por coma
	return valor.toFixed(2).replace(".", ",");
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (calculosFormulas.js)

 - `aplicarFormula(textoFormula, x)` permite que cada box de medici√≥n tenga una
   f√≥rmula configurable en texto (por ejemplo, "x * 500 / 1000") que se eval√∫a
   sobre el valor crudo le√≠do del registro Modbus.

 - Para mantenerlo simple se usa `new Function("x", "return ...")`, lo que es
   suficiente en este proyecto educativo pero no ser√≠a adecuado en un entorno
   productivo sin sandboxing.

 - `formatearValor(valor)` toma el n√∫mero ya calculado y lo convierte a un
   string con 2 decimales y coma como separador, o "ERROR" si el valor no es
   v√°lido. Es la salida final que se ve en cada caja de la tarjeta.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (calculosFormulas.js)

0) Visi√≥n general del m√≥dulo

   Este archivo concentra dos utilidades relacionadas con el c√°lculo y
   presentaci√≥n de valores num√©ricos en las tarjetas de medici√≥n:

   - `aplicarFormula`: toma un valor crudo (x) y le aplica una f√≥rmula
     configurable en texto.

   - `formatearValor`: toma el n√∫mero ya calculado y lo convierte a un string
     listo para mostrar en pantalla.


1) aplicarFormula(textoFormula, x)

   export const aplicarFormula = (textoFormula, x) => {
     const formulaLimpia = (textoFormula || "").trim();
     if (!formulaLimpia) return x;

     try {
       const funcionCalcular = new Function("x", `return ${formulaLimpia};`);
       const resultado = funcionCalcular(x);

       return typeof resultado === "number" && !Number.isNaN(resultado)
         ? resultado
         : null;
     } catch (error) {
       console.error("Error al aplicar f√≥rmula:", error);
       return null;
     }
   };

   - Par√°metros:
       ‚Ä¢ `textoFormula`: string con la expresi√≥n matem√°tica, por ejemplo
         "x * 500 / 1000" o "x / 100".
       ‚Ä¢ `x`: valor num√©rico crudo que viene del registro Modbus.

   - Flujo:
       1) Limpia el texto con `trim()` y maneja null/undefined.
       2) Si la f√≥rmula queda vac√≠a, devuelve directamente `x` sin cambios
          (equivale a "no hay f√≥rmula").
       3) Construye din√°micamente una funci√≥n con `new Function("x", ...)` que
          devuelve el resultado de la expresi√≥n.
       4) Llama a esa funci√≥n pasando `x` y guarda el resultado.
       5) Si el resultado es un n√∫mero v√°lido, lo devuelve; si no, devuelve null.

   - Seguridad / contexto educativo:
       ‚Ä¢ `new Function` y cualquier ejecuci√≥n de c√≥digo din√°mico deben evitarse
         en producci√≥n (riesgo de inyecci√≥n de c√≥digo).
       ‚Ä¢ En este proyecto se usa con fines did√°cticos; en un sistema real ser√≠a
         preferible usar una librer√≠a como mathjs o un parser de expresiones
         controlado.


2) formatearValor(valor)

   export const formatearValor = (valor) => {
     if (valor == null || Number.isNaN(valor)) {
       return "ERROR";
     }
     return valor.toFixed(2).replace(".", ",");
   };

   - Par√°metro:
       ‚Ä¢ `valor`: n√∫mero ya procesado (por ejemplo, despu√©s de aplicar la
         f√≥rmula), que se quiere mostrar en la UI.

   - Flujo:
       1) Si `valor` es null, undefined o NaN, devuelve el string "ERROR".
          Esto permite a la interfaz diferenciar claramente un problema de
          c√°lculo de un dato v√°lido.

       2) Si es un n√∫mero v√°lido, usa `toFixed(2)` para dejarlo con dos
          decimales.

       3) Cambia el punto decimal por coma para seguir el formato
          habitual "123,45".

   - Resultado t√≠pico:
       ‚Ä¢ 123.456  ‚Üí "123,46"
       ‚Ä¢ 7        ‚Üí "7,00"
       ‚Ä¢ null     ‚Üí "ERROR"


3) Uso dentro del flujo de mediciones

   - Normalmente, el pipeline es:
       1) Leer registro Modbus ‚Üí valor crudo.

       2) Aplicar `aplicarFormula` con la f√≥rmula definida en el mapeo
          (si falla o devuelve null, se considera error).
			 
       3) Pasar el resultado num√©rico por `formatearValor` para obtener el
          texto final que se mostrar√° en la `CajaMedicion`.

   - Al centralizar estas operaciones en un m√≥dulo, se garantiza un criterio
     uniforme de c√°lculo y de formato a lo largo de toda la app.

---------------------------------------------------------------------------*/
// ===== ./src/paginas/PaginaAlimentadores/utilidades/calculosMediciones.js =====

// src/paginas/PaginaAlimentadores/utilidades/calculosMediciones.js

import { aplicarFormula, formatearValor } from "./calculosFormulas"; // helpers para f√≥rmulas y formato de n√∫meros
import {
	TITULOS_MEDICIONES,
	ETIQUETAS_POR_DEFECTO,
	DISE√ëO_TARJETA_POR_DEFECTO,
} from "../constantes/titulosMediciones";

/**
 * Obtiene la lista de registros seg√∫n el origen (rele o analizador).
 *
 * @param {Object} registrosPorOrigen - { rele: [...], analizador: [...] }.
 * @param {string} origen - "rele" o "analizador".
 * @returns {Array|null} Lista de registros o null.
 */
export const obtenerListaRegistros = (registrosPorOrigen, origen) => {
	if (!registrosPorOrigen) return null;
	const clave = origen === "analizador" ? "analizador" : "rele"; // default: rele
	const lista = registrosPorOrigen[clave];
	return Array.isArray(lista) ? lista : null;
};

/**
 * Obtiene el dise√±o de la tarjeta desde card_design o mapeoMediciones (legacy).
 * Si no hay configuraci√≥n, devuelve el dise√±o por defecto.
 *
 * @param {Object} cardDesign - Configuraci√≥n directa de card_design (nuevo formato)
 *                              o mapeoMediciones.cardDesign (legacy).
 * @returns {Object} Dise√±o con estructura { superior: {...}, inferior: {...} }.
 */
export const obtenerDisenoTarjeta = (cardDesign) => {
	// Si no hay dise√±o, usar por defecto
	if (!cardDesign || Object.keys(cardDesign).length === 0) {
		return DISE√ëO_TARJETA_POR_DEFECTO;
	}

	// Nuevo formato: card_design ya tiene { superior, inferior } directamente
	// Legacy: mapeoMediciones ten√≠a cardDesign.superior/inferior
	const dise√±o = cardDesign.cardDesign || cardDesign;

	// Si el dise√±o tiene superior/inferior, usarlo
	if (dise√±o.superior || dise√±o.inferior) {
		return {
			superior: normalizarLadoDiseno(dise√±o.superior, DISE√ëO_TARJETA_POR_DEFECTO.superior),
			inferior: normalizarLadoDiseno(dise√±o.inferior, DISE√ëO_TARJETA_POR_DEFECTO.inferior),
		};
	}

	return DISE√ëO_TARJETA_POR_DEFECTO;
};

/**
 * Normaliza un lado del dise√±o, convirtiendo el formato del modal al formato esperado.
 * El modal guarda: { tituloId, tituloCustom, cantidad, boxes: [{ enabled, label, indice, formula }] }
 * El c√°lculo espera: { tituloId, tituloCustom, cantidad, boxes: [{ enabled, label, registro, formula, origen }] }
 */
const normalizarLadoDiseno = (lado, ladoDefault) => {
	if (!lado) return ladoDefault;

	// Normalizar los boxes: convertir 'indice' a 'registro' si es necesario
	const boxesNormalizados = (lado.boxes || []).map((box) => ({
		enabled: !!box.enabled,
		label: box.label || "",
		// El modal guarda 'indice', el c√°lculo espera 'registro'
		registro: box.registro !== undefined ? box.registro : box.indice,
		formula: box.formula || "",
		origen: box.origen || "rele", // por defecto rel√©
	}));

	return {
		...ladoDefault,
		...lado,
		boxes: boxesNormalizados,
		oculto: !!lado.oculto, // preservar si la zona est√° marcada como oculta
	};
};

/**
 * Resuelve el t√≠tulo de un lado de la tarjeta.
 * Puede ser un t√≠tulo predefinido o uno personalizado.
 *
 * @param {Object} dise√±oLado - { tituloId, tituloCustom, ... }.
 * @returns {string} T√≠tulo a mostrar.
 */
export const resolverTituloLado = (dise√±oLado) => {
	if (!dise√±oLado) return "";

	// Si es custom, usar el t√≠tulo personalizado
	if (dise√±oLado.tituloId === "custom") {
		return (dise√±oLado.tituloCustom || "").trim();
	}

	// Sino, buscar en la lista de t√≠tulos predefinidos
	return TITULOS_MEDICIONES[dise√±oLado.tituloId] || "";
};

/**
 * Calcula los valores para mostrar en un lado de la tarjeta (superior o inferior).
 * Aplica f√≥rmulas, formatea valores y maneja errores.
 *
 * @param {Object} registrosPorOrigen - { rele: [...], analizador: [...] }.
 * @param {Object} dise√±oLado - Configuraci√≥n del lado de la tarjeta.
 * @returns {Object} { titulo: string, boxes: [{ etiqueta, valor, enabled, origen }] }.
 */
export const calcularValoresLadoTarjeta = (registrosPorOrigen, dise√±oLado) => {
	if (!dise√±oLado) {
		return {
			titulo: "",
			boxes: [],
		};
	}

	const titulo = resolverTituloLado(dise√±oLado); // texto que va arriba del grupo
	const cantidad = Math.min(
		4,
		Math.max(1, Number(dise√±oLado.cantidad) || 1)
	); // fuerza cantidad a [1,4]
	const boxesSalida = [];

	const etiquetasDefault = ETIQUETAS_POR_DEFECTO[dise√±oLado.tituloId] || [];

	for (let i = 0; i < cantidad; i++) {
		const configuracion = dise√±oLado.boxes?.[i] || {};
		const etiqueta =
			(configuracion.label || "").trim() ||
			etiquetasDefault[i] ||
			`Box ${i + 1}`; // etiqueta efectiva que se ver√°

		let valorMostrado = "--,--"; // placeholder por defecto

		if (configuracion.enabled) {
			const numeroRegistro = Number(configuracion.registro);

			// Si hay registro configurado (n√∫mero v√°lido o 0, y no string vac√≠o)
			if (
				(Number.isFinite(numeroRegistro) || numeroRegistro === 0) &&
				configuracion.registro !== ""
			) {
				const origen = configuracion.origen || "rele"; // default: rele
				const listaRegistros = obtenerListaRegistros(
					registrosPorOrigen,
					origen
				);

				if (listaRegistros && listaRegistros.length > 0) {
					// Buscar el registro por su direcci√≥n (address)
					const registroEncontrado = listaRegistros.find(
						(r) => r.address === numeroRegistro
					);

					if (!registroEncontrado) {
						valorMostrado = "ERROR"; // no se encontr√≥ el registro
					} else {
						// Aplicar f√≥rmula al valor del registro
						const valorCalculado = aplicarFormula(
							configuracion.formula || "x",
							registroEncontrado.value
						);

						if (
							valorCalculado == null ||
							Number.isNaN(valorCalculado)
						) {
							valorMostrado = "ERROR";
						} else {
							valorMostrado = formatearValor(valorCalculado);
						}
					}
				}
			}
		}

		boxesSalida.push({
			etiqueta,
			valor: valorMostrado,
			enabled: !!configuracion.enabled,
			origen: configuracion.origen || "rele",
		});
	}

	return { titulo, boxes: boxesSalida, oculto: !!dise√±oLado.oculto };
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (calculosMediciones.js)

 - Este m√≥dulo es el "traductor" entre los registros Modbus crudos y lo que
   termina viendo la tarjeta en pantalla.

 - Flujo general:
     * `obtenerListaRegistros` elige la lista correcta (`rele` o `analizador`)
       dentro del objeto `{ rele, analizador }`.

     * `obtenerDisenoTarjeta` fusiona el `cardDesign` guardado en el mapeo con
       `DISE√ëO_TARJETA_POR_DEFECTO` para garantizar que siempre haya estructura
       v√°lida para superior e inferior.

     * `resolverTituloLado` convierte `tituloId` en un texto legible, o usa
       el `tituloCustom` si se eligi√≥ la opci√≥n "custom".

     * `calcularValoresLadoTarjeta` recorre cada box configurado:
         - busca el registro por `address`,
         - aplica la f√≥rmula configurada (con `aplicarFormula`),
         - formatea el resultado (`formatearValor`),
         - o deja "ERROR" / "--,--" seg√∫n corresponda.

 - El resultado de `calcularValoresLadoTarjeta` es lo que consume la
   `TarjetaAlimentador` para pintar etiquetas y valores en cada caja.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (calculosMediciones.js)

0) Visi√≥n general del m√≥dulo

   Este archivo es el "traductor" entre:
   - los registros Modbus crudos que vienen del rel√© / analizador, y
   - la estructura amigable que necesita la tarjeta para dibujar cada box
     (etiqueta, valor formateado, enabled, origen).

   Se apoya en:
     ‚Ä¢ `calculosFormulas.js` para aplicar f√≥rmulas y formatear n√∫meros,
     ‚Ä¢ las constantes de `titulosMediciones` para t√≠tulos y etiquetas por defecto.


1) obtenerListaRegistros(registrosPorOrigen, origen)

   export const obtenerListaRegistros = (registrosPorOrigen, origen) => {
     if (!registrosPorOrigen) return null;
     const clave = origen === "analizador" ? "analizador" : "rele";
     const lista = registrosPorOrigen[clave];
     return Array.isArray(lista) ? lista : null;
   };

   - Par√°metros:
       ‚Ä¢ `registrosPorOrigen`: objeto con las listas de lecturas, por ejemplo
         `{ rele: [...], analizador: [...] }`.
       ‚Ä¢ `origen`: string `"rele"` o `"analizador"`.

   - Comportamiento:
       ‚Ä¢ Si el origen es `"analizador"`, usa la clave `"analizador"`;
         en cualquier otro caso cae a `"rele"` como valor por defecto.
       ‚Ä¢ Si encuentra una lista y es un array, la devuelve; si no, devuelve null.

   - Uso t√≠pico:
       ‚Ä¢ Desde `calcularValoresLadoTarjeta` para obtener la lista correcta
         antes de buscar un registro por direcci√≥n.


2) obtenerDisenoTarjeta(mapeoMediciones)

   export const obtenerDisenoTarjeta = (mapeoMediciones) => {
     const dise√±o = mapeoMediciones?.cardDesign;
     if (!dise√±o) return DISE√ëO_TARJETA_POR_DEFECTO;

     return {
       superior: {
         ...DISE√ëO_TARJETA_POR_DEFECTO.superior,
         ...(dise√±o.superior || {}),
       },
       inferior: {
         ...DISE√ëO_TARJETA_POR_DEFECTO.inferior,
         ...(dise√±o.inferior || {}),
       },
     };
   };

   - Toma el `cardDesign` guardado en el mapeo (si existe) y lo fusiona con
     `DISE√ëO_TARJETA_POR_DEFECTO`.

   - Objetivo:
       ‚Ä¢ garantizar que siempre haya un objeto bien formado para `superior` e
         `inferior`, con campos y estructuras m√≠nimas aunque falten datos.

   - Si `mapeoMediciones` no tiene `cardDesign`, devuelve directamente el
     dise√±o por defecto (corriente arriba, tensi√≥n abajo, etc.).


3) resolverTituloLado(dise√±oLado)

   export const resolverTituloLado = (dise√±oLado) => {
     if (!dise√±oLado) return "";

     if (dise√±oLado.tituloId === "custom") {
       return (dise√±oLado.tituloCustom || "").trim();
     }

     return TITULOS_MEDICIONES[dise√±oLado.tituloId] || "";
   };

   - Si el `tituloId` es `"custom"`, usa el texto libre `tituloCustom`.

   - En caso contrario, busca el t√≠tulo en `TITULOS_MEDICIONES` usando
     `tituloId` como clave (ej: `"tension_linea"`, `"corriente_132"`, etc.).

   - Si no encuentra nada, devuelve string vac√≠o.


4) calcularValoresLadoTarjeta(registrosPorOrigen, dise√±oLado)

   export const calcularValoresLadoTarjeta = (registrosPorOrigen, dise√±oLado) => {
     if (!dise√±oLado) {
       return { titulo: "", boxes: [] };
     }

     const titulo = resolverTituloLado(dise√±oLado);
     const cantidad = Math.min(4, Math.max(1, Number(dise√±oLado.cantidad) || 1));
     const boxesSalida = [];
     const etiquetasDefault = ETIQUETAS_POR_DEFECTO[dise√±oLado.tituloId] || [];

     for (let i = 0; i < cantidad; i++) {
       const configuracion = dise√±oLado.boxes?.[i] || {};
       const etiqueta =
         (configuracion.label || "").trim() ||
         etiquetasDefault[i] ||
         `Box ${i + 1}`;

       let valorMostrado = "--,--";

       if (configuracion.enabled) {
         const numeroRegistro = Number(configuracion.registro);

         if (
           (Number.isFinite(numeroRegistro) || numeroRegistro === 0) &&
           configuracion.registro !== ""
         ) {
           const origen = configuracion.origen || "rele";
           const listaRegistros = obtenerListaRegistros(registrosPorOrigen, origen);

           if (listaRegistros && listaRegistros.length > 0) {
             const registroEncontrado = listaRegistros.find(
               (r) => r.address === numeroRegistro
             );

             if (!registroEncontrado) {
               valorMostrado = "ERROR";
             } else {
               const valorCalculado = aplicarFormula(
                 configuracion.formula || "x",
                 registroEncontrado.value
               );

               if (valorCalculado == null || Number.isNaN(valorCalculado)) {
                 valorMostrado = "ERROR";
               } else {
                 valorMostrado = formatearValor(valorCalculado);
               }
             }
           }
         }
       }

       boxesSalida.push({
         etiqueta,
         valor: valorMostrado,
         enabled: !!configuracion.enabled,
         origen: configuracion.origen || "rele",
       });
     }

     return { titulo, boxes: boxesSalida };
   };

   - Paso a paso para cada box:

       1) Determina la etiqueta efectiva:
            ‚Ä¢ primero `configuracion.label` (si existe y no est√° vac√≠o),
            ‚Ä¢ si no, una etiqueta por defecto seg√∫n magnitud (R, S, T, Total),
            ‚Ä¢ si tampoco hay, usa "Box 1", "Box 2", etc.

       2) Inicializa `valorMostrado` en `"--,--"` como placeholder.

       3) Si el box est√° habilitado (`enabled === true`):
            ‚Ä¢ Valida el n√∫mero de registro (`configuracion.registro`).
            ‚Ä¢ Determina el origen (`rele` o `analizador`).
            ‚Ä¢ Obtiene la lista de registros correspondiente con
              `obtenerListaRegistros`.
            ‚Ä¢ Busca el registro cuyo `address` coincida con el n√∫mero
              configurado.

       4) Si encuentra el registro:
            ‚Ä¢ Aplica la f√≥rmula de ese box con `aplicarFormula` (o "x" si
              no se defini√≥ f√≥rmula).
            ‚Ä¢ Si el resultado es inv√°lido ‚Üí `"ERROR"`.
            ‚Ä¢ Si es v√°lido ‚Üí lo pasa por `formatearValor` para obtener un
              string "amigable" (dos decimales, coma, etc.).

       5) Agrega al array `boxesSalida` un objeto con:
            ‚Ä¢ `etiqueta`: texto visible en la tarjeta,
            ‚Ä¢ `valor`: texto formateado o "ERROR"/"--,--",
            ‚Ä¢ `enabled`: booleano,
            ‚Ä¢ `origen`: "rele" o "analizador".


5) C√≥mo se integra con el resto de la app

   - `ModalMapeoMediciones` define el `cardDesign` (qu√© boxes hay, qu√©
     registro leen, f√≥rmula, origen, etc.) y lo guarda en `mapeoMediciones`
     dentro de cada alimentador.

   - Cuando llegan lecturas nuevas desde los equipos:

       1) Se arma un objeto `{ rele: [...], analizador: [...] }` con registros
          crudos (`index`, `address`, `value`).

       2) Se obtiene el dise√±o de tarjeta con `obtenerDisenoTarjeta`.

       3) Para cada lado (superior / inferior) se llama a
          `calcularValoresLadoTarjeta` y se obtienen `{ titulo, boxes }`.
			 
       4) Esa estructura es la que consume `TarjetaAlimentador` para renderizar
          cada `CajaMedicion` con su etiqueta, valor y comportamiento visual.

   - De esta forma, todo el c√°lculo num√©rico + mapeo queda concentrado en este
     m√≥dulo y las tarjetas se enfocan s√≥lo en mostrar datos.

---------------------------------------------------------------------------*/

// ===== ./src/paginas/PaginaAlimentadores/utilidades/exportarCSV.js =====

/**
 * Utilidad para exportar datos a formato CSV
 */

/**
 * Exporta datos a un archivo CSV descargable
 * @param {Array} datos - Array de objetos con los datos
 * @param {string} nombreArchivo - Nombre del archivo (sin extensi√≥n)
 * @param {Object} opciones - Opciones de configuraci√≥n
 * @param {Array<string>} opciones.columnas - Columnas a incluir (orden)
 * @param {Object} opciones.etiquetas - Mapeo de nombres de columnas a etiquetas
 */
export const exportarCSV = (datos, nombreArchivo, opciones = {}) => {
  if (!datos || datos.length === 0) {
    console.warn("No hay datos para exportar");
    return;
  }

  const {
    columnas = ["timestamp", "valor"],
    etiquetas = {
      timestamp: "Fecha/Hora",
      valor: "Valor",
      valorCrudo: "Valor Crudo",
      variable: "Variable",
    },
  } = opciones;

  // Crear header con etiquetas
  const header = columnas.map((col) => etiquetas[col] || col);

  // Crear filas de datos
  const filas = datos.map((d) => {
    return columnas
      .map((col) => {
        let valor = obtenerValorColumna(d, col);

        // Escapar valores que contienen separadores
        if (typeof valor === "string" && (valor.includes(";") || valor.includes('"'))) {
          valor = `"${valor.replace(/"/g, '""')}"`;
        }

        return valor;
      })
      .join(";");
  });

  // Unir header y filas
  const contenidoCSV = [header.join(";"), ...filas].join("\n");

  // Crear blob con BOM para Excel
  const BOM = "\uFEFF";
  const blob = new Blob([BOM + contenidoCSV], {
    type: "text/csv;charset=utf-8;",
  });

  // Crear y ejecutar descarga
  descargarBlob(blob, `${nombreArchivo}.csv`);
};

/**
 * Obtiene el valor formateado para una columna espec√≠fica
 * @param {Object} dato - Objeto con los datos
 * @param {string} columna - Nombre de la columna
 * @returns {string} - Valor formateado
 */
const obtenerValorColumna = (dato, columna) => {
  switch (columna) {
    case "timestamp":
      // Formatear timestamp a fecha legible
      const fecha = dato.x instanceof Date ? dato.x : new Date(dato.timestamp || dato.x);
      return formatearFecha(fecha);

    case "valor":
      // Valor calculado con f√≥rmula
      const val = dato.y ?? dato.valor;
      return val != null ? val.toFixed(4).replace(".", ",") : "";

    case "valorCrudo":
      // Valor sin procesar
      const raw = dato.raw ?? dato.valorCrudo;
      return raw != null ? String(raw).replace(".", ",") : "";

    case "variable":
      return dato.variable || dato.etiqueta || "";

    default:
      const v = dato[columna];
      if (v == null) return "";
      if (typeof v === "number") return v.toString().replace(".", ",");
      return String(v);
  }
};

/**
 * Formatea una fecha para el CSV
 * @param {Date} fecha - Fecha a formatear
 * @returns {string} - Fecha formateada DD/MM/YYYY HH:mm:ss
 */
const formatearFecha = (fecha) => {
  if (!(fecha instanceof Date) || isNaN(fecha.getTime())) {
    return "";
  }

  const pad = (n) => String(n).padStart(2, "0");

  const dia = pad(fecha.getDate());
  const mes = pad(fecha.getMonth() + 1);
  const anio = fecha.getFullYear();
  const hora = pad(fecha.getHours());
  const min = pad(fecha.getMinutes());
  const seg = pad(fecha.getSeconds());

  return `${dia}/${mes}/${anio} ${hora}:${min}:${seg}`;
};

/**
 * Descarga un blob como archivo
 * @param {Blob} blob - Blob a descargar
 * @param {string} nombreArchivo - Nombre del archivo
 */
const descargarBlob = (blob, nombreArchivo) => {
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");

  link.href = url;
  link.download = nombreArchivo;
  link.style.display = "none";

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  // Liberar memoria
  URL.revokeObjectURL(url);
};

/**
 * Exporta m√∫ltiples series de datos a CSV
 * @param {Array} series - Array de series [{nombre, datos}]
 * @param {string} nombreArchivo - Nombre del archivo
 */
export const exportarSeriesCSV = (series, nombreArchivo) => {
  if (!series || series.length === 0) return;

  // Combinar todas las series en un formato tabular
  const datosUnificados = [];

  series.forEach((serie) => {
    serie.datos.forEach((punto) => {
      datosUnificados.push({
        variable: serie.nombre,
        x: punto.x,
        y: punto.y,
        raw: punto.raw,
      });
    });
  });

  // Ordenar por timestamp
  datosUnificados.sort((a, b) => {
    const ta = a.x instanceof Date ? a.x.getTime() : a.x;
    const tb = b.x instanceof Date ? b.x.getTime() : b.x;
    return ta - tb;
  });

  exportarCSV(datosUnificados, nombreArchivo, {
    columnas: ["timestamp", "variable", "valor", "valorCrudo"],
    etiquetas: {
      timestamp: "Fecha/Hora",
      variable: "Variable",
      valor: "Valor Calculado",
      valorCrudo: "Valor Crudo",
    },
  });
};

// ===== ./src/paginas/PaginaAlimentadores/utilidades/exportarInformePDF.js =====

/**
 * Utilidad para exportar informes profesionales en formato PDF
 * Usa pdfmake para generar archivos .pdf con tablas, gr√°ficos e informaci√≥n
 */

import pdfMake from "pdfmake/build/pdfmake";
import pdfFonts from "pdfmake/build/vfs_fonts";

// Configurar fuentes de pdfmake
if (pdfFonts.pdfMake) {
  pdfMake.vfs = pdfFonts.pdfMake.vfs;
} else if (pdfFonts.vfs) {
  pdfMake.vfs = pdfFonts.vfs;
}

// Colores del tema (en formato hex para pdfmake)
const COLORES = {
  primario: "#1E3A5F", // Azul oscuro
  secundario: "#0EA5E9", // Azul claro
  fondo: "#F8FAFC", // Gris muy claro
  texto: "#1E293B", // Gris oscuro
  borde: "#CBD5E1", // Gris medio
  minimo: "#DCFCE7", // Verde claro (para valor m√≠nimo)
  maximo: "#FED7AA", // Naranja claro (para valor m√°ximo)
  blanco: "#FFFFFF",
};

/**
 * Formatea una fecha para mostrar en el informe
 * @param {Date|number|string} fecha - Fecha a formatear
 * @returns {string} - Fecha formateada
 */
const formatearFecha = (fecha) => {
  const d = fecha instanceof Date ? fecha : new Date(fecha);
  if (isNaN(d.getTime())) return "--";

  const pad = (n) => String(n).padStart(2, "0");
  return `${pad(d.getDate())}/${pad(d.getMonth() + 1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
};

/**
 * Formatea solo la fecha (sin hora)
 * @param {Date|number|string} fecha - Fecha a formatear
 * @returns {string} - Fecha formateada
 */
const formatearSoloFecha = (fecha) => {
  const d = fecha instanceof Date ? fecha : new Date(fecha);
  if (isNaN(d.getTime())) return "--";

  const pad = (n) => String(n).padStart(2, "0");
  return `${pad(d.getDate())}/${pad(d.getMonth() + 1)}/${d.getFullYear()}`;
};

/**
 * Genera la definici√≥n del documento PDF
 * @param {Object} config - Configuraci√≥n del informe
 * @returns {Object} - Definici√≥n del documento para pdfmake
 */
const generarDefinicionPDF = (config) => {
  const {
    datos,
    tituloMedicion,
    nombreAlimentador,
    fechaDesde,
    fechaHasta,
    solicitadoPor,
    imagenGrafico,
    intervalo,
  } = config;

  // Calcular estad√≠sticas
  let minimo = 0,
    maximo = 0,
    promedio = 0;
  let fechaMinimo = null,
    fechaMaximo = null;

  if (datos.length > 0) {
    const valores = datos.map((d) => d.y).filter((v) => v != null && !isNaN(v));
    minimo = Math.min(...valores);
    maximo = Math.max(...valores);
    promedio = valores.reduce((a, b) => a + b, 0) / valores.length;

    // Encontrar las fechas de los valores m√≠nimo y m√°ximo
    const puntoMin = datos.find((d) => d.y === minimo);
    const puntoMax = datos.find((d) => d.y === maximo);
    fechaMinimo = puntoMin?.x ? formatearFecha(puntoMin.x) : null;
    fechaMaximo = puntoMax?.x ? formatearFecha(puntoMax.x) : null;
  }

  // Texto del intervalo
  const textoIntervalo = intervalo
    ? intervalo === 0
      ? " (todos)"
      : ` (cada ${intervalo} min)`
    : "";

  // Construir contenido del PDF
  const contenido = [];

  // === T√çTULO PRINCIPAL CON FONDO AZUL (estilo Excel) ===
  contenido.push({
    table: {
      widths: ["*"],
      body: [
        [
          {
            text: "INFORME DE MEDICIONES",
            fontSize: 16,
            bold: true,
            color: COLORES.blanco,
            fillColor: COLORES.primario,
            alignment: "center",
          },
        ],
      ],
    },
    layout: {
      hLineWidth: () => 0.5,
      vLineWidth: () => 0.5,
      hLineColor: () => COLORES.borde,
      vLineColor: () => COLORES.borde,
      paddingTop: () => 12,
      paddingBottom: () => 12,
    },
    margin: [0, 0, 0, 0],
  });

  // === INFORMACI√ìN Y ESTAD√çSTICAS EN COLUMNAS (con borde exterior) ===
  contenido.push({
    table: {
      widths: ["*"],
      body: [
        [
          {
            columns: [
              // Columna izquierda: Informaci√≥n del informe
              {
                width: "55%",
                table: {
                  widths: ["auto", "*"],
                  body: [
                    [
                      { text: "Registros para:", style: "etiqueta" },
                      { text: nombreAlimentador, style: "valor" },
                    ],
                    [
                      { text: "Medici√≥n:", style: "etiqueta" },
                      { text: tituloMedicion, style: "valor" },
                    ],
                    [
                      { text: "Fecha de creaci√≥n:", style: "etiqueta" },
                      { text: formatearFecha(new Date()), style: "valor" },
                    ],
                    [
                      { text: "Solicitado por:", style: "etiqueta" },
                      { text: solicitadoPor || "No especificado", style: "valor" },
                    ],
                    [
                      { text: "Per√≠odo desde:", style: "etiqueta" },
                      { text: formatearFecha(fechaDesde), style: "valor" },
                    ],
                    [
                      { text: "Per√≠odo hasta:", style: "etiqueta" },
                      { text: formatearFecha(fechaHasta), style: "valor" },
                    ],
                    [
                      { text: "Total de registros:", style: "etiqueta" },
                      { text: `${datos.length}${textoIntervalo}`, style: "valor" },
                    ],
                  ],
                },
                layout: {
                  hLineWidth: () => 0,
                  vLineWidth: () => 0,
                  paddingTop: () => 3,
                  paddingBottom: () => 3,
                },
              },
              // Columna derecha: Estad√≠sticas
              {
                width: "45%",
                stack: [
                  {
                    text: "ESTAD√çSTICAS",
                    style: "subtitulo",
                    alignment: "center",
                    margin: [0, 0, 0, 8],
                  },
                  {
                    table: {
                      widths: ["auto", "*"],
                      body: [
                        [
                          { text: "Valor m√≠nimo:", style: "etiqueta", alignment: "right" },
                          {
                            stack: [
                              { text: minimo.toFixed(2), style: "valorEstadistica", alignment: "center" },
                              fechaMinimo
                                ? { text: fechaMinimo, fontSize: 8, color: COLORES.texto, alignment: "center" }
                                : null,
                            ].filter(Boolean),
                            fillColor: COLORES.minimo,
                          },
                        ],
                        [
                          { text: "Valor m√°ximo:", style: "etiqueta", alignment: "right" },
                          {
                            stack: [
                              { text: maximo.toFixed(2), style: "valorEstadistica", alignment: "center" },
                              fechaMaximo
                                ? { text: fechaMaximo, fontSize: 8, color: COLORES.texto, alignment: "center" }
                                : null,
                            ].filter(Boolean),
                            fillColor: COLORES.maximo,
                          },
                        ],
                        [
                          { text: "Valor promedio:", style: "etiqueta", alignment: "right" },
                          { text: promedio.toFixed(2), style: "valorEstadistica", alignment: "center" },
                        ],
                      ],
                    },
                    layout: {
                      hLineWidth: () => 0.5,
                      vLineWidth: () => 0.5,
                      hLineColor: () => COLORES.borde,
                      vLineColor: () => COLORES.borde,
                      paddingTop: () => 4,
                      paddingBottom: () => 4,
                      paddingLeft: () => 8,
                      paddingRight: () => 8,
                    },
                  },
                ],
              },
            ],
            columnGap: 15,
          },
        ],
      ],
    },
    layout: {
      hLineWidth: () => 0.5,
      vLineWidth: () => 0.5,
      hLineColor: () => COLORES.borde,
      vLineColor: () => COLORES.borde,
      paddingTop: () => 10,
      paddingBottom: () => 10,
      paddingLeft: () => 10,
      paddingRight: () => 10,
    },
    margin: [0, 0, 0, 20],
  });

  // === GR√ÅFICO (en p√°gina 2) ===
  if (imagenGrafico) {
    contenido.push({
      text: "GR√ÅFICO DE MEDICIONES",
      style: "subtitulo",
      alignment: "center",
      margin: [0, 10, 0, 10],
      pageBreak: "before",
    });

    contenido.push({
      image: imagenGrafico,
      width: 500,
      alignment: "center",
      margin: [0, 0, 0, 20],
    });
  }

  // === TABLA DE DATOS (en p√°gina 3+) ===
  if (datos.length > 0) {
    contenido.push({
      text: "DATOS DE MEDICIONES",
      style: "subtitulo",
      alignment: "center",
      margin: [0, 10, 0, 10],
      pageBreak: "before",
    });

    // Crear filas de la tabla
    const filasTabla = [
      // Encabezados
      [
        { text: "Fecha/Hora", style: "encabezadoTabla" },
        { text: "Valor de Medici√≥n", style: "encabezadoTabla" },
      ],
    ];

    // Datos
    datos.forEach((punto, index) => {
      const fecha = punto.x instanceof Date ? punto.x : new Date(punto.x);

      // Determinar color de fondo (comparar por valor, no por √≠ndice)
      let fillColor = index % 2 === 0 ? COLORES.fondo : COLORES.blanco;
      if (punto.y === minimo && minimo !== maximo) {
        fillColor = COLORES.minimo;
      } else if (punto.y === maximo && minimo !== maximo) {
        fillColor = COLORES.maximo;
      }

      filasTabla.push([
        {
          text: formatearFecha(fecha),
          style: "celdaTabla",
          fillColor,
        },
        {
          text: punto.y.toFixed(2),
          style: "celdaTabla",
          alignment: "center",
          fillColor,
        },
      ]);
    });

    contenido.push({
      table: {
        headerRows: 1,
        widths: ["*", "*"],
        body: filasTabla,
      },
      layout: {
        hLineWidth: () => 0.5,
        vLineWidth: () => 0.5,
        hLineColor: () => COLORES.borde,
        vLineColor: () => COLORES.borde,
        paddingTop: () => 6,
        paddingBottom: () => 6,
        paddingLeft: () => 8,
        paddingRight: () => 8,
      },
    });
  }

  // Definici√≥n completa del documento
  return {
    pageSize: "A4",
    pageOrientation: "portrait",
    pageMargins: [40, 60, 40, 60],

    // Encabezado de cada p√°gina
    header: {
      columns: [
        {
          text: "RelayWatch - Informe de Mediciones",
          style: "header",
          alignment: "left",
          margin: [40, 20, 0, 0],
        },
        {
          text: formatearSoloFecha(new Date()),
          style: "header",
          alignment: "right",
          margin: [0, 20, 40, 0],
        },
      ],
    },

    // Pie de cada p√°gina
    footer: (currentPage, pageCount) => ({
      columns: [
        {
          text: `${nombreAlimentador} - ${tituloMedicion}`,
          style: "footer",
          alignment: "left",
          margin: [40, 0, 0, 0],
        },
        {
          text: `P√°gina ${currentPage} de ${pageCount}`,
          style: "footer",
          alignment: "right",
          margin: [0, 0, 40, 0],
        },
      ],
    }),

    content: contenido,

    // Estilos
    styles: {
      header: {
        fontSize: 9,
        color: COLORES.texto,
      },
      footer: {
        fontSize: 9,
        color: COLORES.texto,
      },
      tituloPrincipal: {
        fontSize: 16,
        bold: true,
        color: COLORES.blanco,
        fillColor: COLORES.primario,
      },
      titulo: {
        fontSize: 18,
        bold: true,
        color: COLORES.primario,
      },
      subtitulo: {
        fontSize: 14,
        bold: true,
        color: COLORES.primario,
      },
      etiqueta: {
        fontSize: 10,
        bold: true,
        color: COLORES.texto,
      },
      valor: {
        fontSize: 10,
        color: COLORES.texto,
      },
      valorEstadistica: {
        fontSize: 11,
        color: COLORES.texto,
        alignment: "center",
      },
      encabezadoTabla: {
        fontSize: 10,
        bold: true,
        color: COLORES.blanco,
        fillColor: COLORES.primario,
        alignment: "center",
      },
      celdaTabla: {
        fontSize: 9,
        color: COLORES.texto,
      },
    },

    // Configuraci√≥n por defecto
    defaultStyle: {
      font: "Roboto",
    },
  };
};

/**
 * Genera y descarga un informe PDF con los datos de mediciones
 * @param {Object} config - Configuraci√≥n del informe
 * @param {string} config.nombreAlimentador - Nombre del alimentador
 * @param {string} config.tituloMedicion - T√≠tulo de la medici√≥n
 * @param {Array} config.datos - Datos de la zona actual [{x, y}]
 * @param {Date} config.fechaInicio - Fecha del primer registro
 * @param {Date} config.fechaFin - Fecha del √∫ltimo registro
 * @param {string} config.solicitadoPor - Nombre del solicitante
 * @param {string|null} config.imagenGrafico - Data URI de la imagen del gr√°fico
 * @param {number} config.intervalo - Intervalo de filtrado (0, 15, 30, 60 minutos)
 * @returns {Promise<string|null>} - Nombre del archivo o null si se cancel√≥
 */
export const generarInformePDF = async (config) => {
  const {
    nombreAlimentador,
    tituloMedicion,
    datos,
    fechaInicio,
    fechaFin,
    solicitadoPor,
    imagenGrafico,
    intervalo,
  } = config;

  // Si no hay datos, no generar
  if (!datos || datos.length === 0) {
    console.warn("No hay datos para generar el informe PDF");
    return null;
  }

  // Generar definici√≥n del documento
  const docDefinition = generarDefinicionPDF({
    datos,
    tituloMedicion: tituloMedicion || "Mediciones",
    nombreAlimentador,
    fechaDesde: fechaInicio,
    fechaHasta: fechaFin,
    solicitadoPor,
    imagenGrafico,
    intervalo,
  });

  // Generar nombre de archivo
  const fechaArchivo = formatearSoloFecha(new Date()).replace(/\//g, "-");
  const nombreArchivo = `Informe_${nombreAlimentador}_${tituloMedicion}_${fechaArchivo}.pdf`;

  // Crear PDF y descargar
  return new Promise((resolve) => {
    const pdfDoc = pdfMake.createPdf(docDefinition);

    // Intentar usar File System Access API (Chrome/Edge) para elegir ubicaci√≥n
    if ("showSaveFilePicker" in window) {
      pdfDoc.getBlob(async (blob) => {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: nombreArchivo,
            types: [
              {
                description: "Archivo PDF",
                accept: { "application/pdf": [".pdf"] },
              },
            ],
          });

          const writable = await handle.createWritable();
          await writable.write(blob);
          await writable.close();

          resolve(handle.name);
        } catch (err) {
          if (err.name === "AbortError") {
            resolve(null); // Usuario cancel√≥
          } else {
            // Fallback a descarga directa
            pdfDoc.download(nombreArchivo);
            resolve(nombreArchivo);
          }
        }
      });
    } else {
      // Fallback: descarga directa
      pdfDoc.download(nombreArchivo);
      resolve(nombreArchivo);
    }
  });
};

// ===== ./src/paginas/PaginaAlimentadores/utilidades/generarGraficoInforme.js =====

/**
 * Genera un gr√°fico temporal con ApexCharts y captura su imagen
 * para incluir en informes Excel.
 *
 * Crea un gr√°fico invisible, lo renderiza con los datos proporcionados,
 * captura la imagen y lo destruye.
 */

import ApexCharts from "apexcharts";

/**
 * Genera una imagen de gr√°fico a partir de datos de series temporales
 * @param {Array} datos - Array de puntos [{x: timestamp, y: valor}]
 * @param {Object} opciones - Opciones de configuraci√≥n
 * @param {string} opciones.tipo - Tipo de gr√°fico (line, area, bar)
 * @param {string} opciones.titulo - T√≠tulo del gr√°fico (opcional)
 * @param {number} opciones.width - Ancho en p√≠xeles (default: 1100)
 * @param {number} opciones.height - Alto en p√≠xeles (default: 450)
 * @param {number} opciones.scale - Escala de la imagen (default: 2)
 * @returns {Promise<string|null>} - Data URI de la imagen o null si falla
 */
export const generarImagenGrafico = async (datos, opciones = {}) => {
  if (!datos || datos.length === 0) {
    return null;
  }

  const {
    tipo = "line",
    titulo = "",
    width = 1100,
    height = 450,
    scale = 2,
  } = opciones;

  // Crear contenedor temporal - usar visibility:hidden para que ApexCharts
  // pueda calcular las dimensiones pero no sea visible
  const tempContainer = document.createElement("div");
  tempContainer.style.cssText = `
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: ${width}px;
    height: ${height}px;
    visibility: hidden;
  `;
  document.body.appendChild(tempContainer);

  // Forzar un reflow para asegurar que el contenedor tenga dimensiones
  tempContainer.offsetHeight;

  // Preparar series para ApexCharts
  const seriesData = datos.map((punto) => ({
    x: punto.x instanceof Date ? punto.x.getTime() : new Date(punto.x).getTime(),
    y: punto.y,
  }));

  // Calcular min/max para el eje Y con margen
  const valores = datos.map((d) => d.y).filter((v) => v != null && !isNaN(v));
  const minY = Math.min(...valores);
  const maxY = Math.max(...valores);
  const rangoY = maxY - minY || 1;
  const margen = rangoY * 0.1;

  // Configuraci√≥n del gr√°fico simplificada para evitar errores de ApexCharts
  const chartConfig = {
    chart: {
      id: `informe-temp-${Date.now()}`,
      type: tipo,
      width: "100%",
      height: "100%",
      background: "#ffffff",
      foreColor: "#1a1a1a",
      animations: { enabled: false },
      toolbar: { show: false },
      zoom: { enabled: false },
      offsetX: 0,
      offsetY: 0,
      sparkline: { enabled: false },
    },
    series: [
      {
        name: titulo || "Medici√≥n",
        data: seriesData,
      },
    ],
    stroke: {
      curve: "smooth",
      width: tipo === "bar" ? 0 : 3,
    },
    colors: ["#0EA5E9"],
    markers: {
      size: datos.length <= 30 ? 4 : 0,
    },
    xaxis: {
      type: "datetime",
      labels: {
        datetimeUTC: false,
        format: "dd/MM HH:mm",
        style: {
          fontSize: "12px",
        },
      },
    },
    yaxis: {
      min: Math.floor(minY - margen),
      max: Math.ceil(maxY + margen),
      labels: {
        formatter: (val) => val.toFixed(2),
      },
    },
    grid: {
      borderColor: "#e0e0e0",
    },
    tooltip: { enabled: false },
    dataLabels: { enabled: false },
    legend: { show: false },
  };

  let tempChart = null;

  try {
    // Crear y renderizar gr√°fico temporal
    tempChart = new ApexCharts(tempContainer, chartConfig);
    await tempChart.render();

    // Esperar a que el gr√°fico se renderice completamente
    await new Promise((resolve) => setTimeout(resolve, 300));

    // Capturar imagen
    const result = await tempChart.dataURI({ scale });

    // dataURI puede devolver { imgURI } o directamente el string
    const imgURI = result?.imgURI || result;

    if (!imgURI || typeof imgURI !== "string") {
      console.warn("dataURI no devolvi√≥ una imagen v√°lida:", result);
      return null;
    }

    return imgURI;
  } catch (err) {
    console.warn("Error generando imagen de gr√°fico para informe:", err);
    return null;
  } finally {
    // Limpiar: destruir gr√°fico y remover contenedor
    if (tempChart) {
      try {
        tempChart.destroy();
      } catch {
        // Ignorar errores de destrucci√≥n
      }
    }
    if (tempContainer.parentNode) {
      tempContainer.parentNode.removeChild(tempContainer);
    }
  }
};

// ===== ./src/paginas/PaginaAlimentadores/utilidades/indexedDBHelper.js =====

/**
 * Helper para operaciones con IndexedDB
 * Almacena lecturas de los √∫ltimos 48 horas para acceso r√°pido local
 */

const DB_NAME = "RelayWatchHistorial";
const DB_VERSION = 1;
const STORE_NAME = "lecturas";

/**
 * Abre la conexi√≥n a IndexedDB y crea el schema si es necesario
 * @returns {Promise<IDBDatabase>}
 */
export const abrirDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => {
      console.error("Error abriendo IndexedDB:", request.error);
      reject(request.error);
    };

    request.onsuccess = () => {
      resolve(request.result);
    };

    request.onupgradeneeded = (event) => {
      const db = event.target.result;

      // Crear object store con √≠ndices
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        const store = db.createObjectStore(STORE_NAME, {
          keyPath: "id",
          autoIncrement: true,
        });

        // √çndices para consultas eficientes
        store.createIndex("alimentadorId", "alimentadorId", { unique: false });
        store.createIndex("registradorId", "registradorId", { unique: false });
        store.createIndex("zona", "zona", { unique: false });
        store.createIndex("timestamp", "timestamp", { unique: false });

        // √çndice compuesto para b√∫squedas por alimentador + zona + tiempo
        store.createIndex(
          "alimZonaTimestamp",
          ["alimentadorId", "zona", "timestamp"],
          { unique: false }
        );
      }
    };
  });
};

/**
 * Guarda una lectura en IndexedDB
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {Object} lectura - Datos de la lectura
 * @returns {Promise<number>} - ID de la lectura insertada
 */
export const guardarLectura = async (db, lectura) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);

    const registro = {
      alimentadorId: lectura.alimentadorId,
      registradorId: lectura.registradorId,
      zona: lectura.zona,
      timestamp: lectura.timestamp || Date.now(),
      valores: lectura.valores,
      indiceInicial: lectura.indiceInicial,
      exito: lectura.exito,
      createdAt: Date.now(),
    };

    const request = store.add(registro);

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

/**
 * Obtiene lecturas en un rango de tiempo para un alimentador/zona espec√≠ficos
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @param {string} registradorId - ID del registrador (opcional, para filtrar)
 * @param {string} zona - "superior" o "inferior"
 * @param {number} desde - Timestamp inicial (ms)
 * @param {number} hasta - Timestamp final (ms)
 * @returns {Promise<Array>} - Array de lecturas
 */
export const obtenerLecturasRango = async (
  db,
  alimentadorId,
  registradorId,
  zona,
  desde,
  hasta
) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("alimZonaTimestamp");

    // Rango de b√∫squeda usando √≠ndice compuesto
    const rango = IDBKeyRange.bound(
      [alimentadorId, zona, desde],
      [alimentadorId, zona, hasta]
    );

    const request = index.getAll(rango);

    request.onsuccess = () => {
      let resultados = request.result;

      // Filtrar por registradorId si se especifica
      if (registradorId) {
        resultados = resultados.filter((r) => r.registradorId === registradorId);
      }

      // Ordenar por timestamp ascendente
      resultados.sort((a, b) => a.timestamp - b.timestamp);

      resolve(resultados);
    };

    request.onerror = () => reject(request.error);
  });
};

/**
 * Elimina lecturas m√°s antiguas que el tiempo de retenci√≥n
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {number} horasRetencion - Horas de datos a mantener (default: 48)
 * @returns {Promise<number>} - Cantidad de registros eliminados
 */
export const limpiarLecturasAntiguas = async (db, horasRetencion = 48) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("timestamp");

    const limite = Date.now() - horasRetencion * 60 * 60 * 1000;
    const rango = IDBKeyRange.upperBound(limite);

    let eliminados = 0;
    const request = index.openCursor(rango);

    request.onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor) {
        cursor.delete();
        eliminados++;
        cursor.continue();
      } else {
        resolve(eliminados);
      }
    };

    request.onerror = () => reject(request.error);
  });
};

/**
 * Cuenta el n√∫mero de lecturas para un alimentador
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @returns {Promise<number>} - Cantidad de lecturas
 */
export const contarLecturas = async (db, alimentadorId) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("alimentadorId");

    const request = index.count(alimentadorId);

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

/**
 * Obtiene estad√≠sticas del almacenamiento
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @returns {Promise<Object>} - Estad√≠sticas
 */
export const obtenerEstadisticas = async (db) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);

    const countRequest = store.count();

    countRequest.onsuccess = () => {
      resolve({
        totalLecturas: countRequest.result,
      });
    };

    countRequest.onerror = () => reject(countRequest.error);
  });
};

/**
 * Elimina todas las lecturas (para testing o reset)
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @returns {Promise<void>}
 */
export const limpiarTodo = async (db) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);

    const request = store.clear();

    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
};

/**
 * Obtiene los timestamps existentes en un rango para evitar duplicados
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @param {string} zona - "superior" o "inferior"
 * @param {number} desde - Timestamp inicial (ms)
 * @param {number} hasta - Timestamp final (ms)
 * @returns {Promise<Set<number>>} - Set de timestamps existentes
 */
export const obtenerTimestampsExistentes = async (
  db,
  alimentadorId,
  zona,
  desde,
  hasta
) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("alimZonaTimestamp");

    const rango = IDBKeyRange.bound(
      [alimentadorId, zona, desde],
      [alimentadorId, zona, hasta]
    );

    const request = index.getAll(rango);

    request.onsuccess = () => {
      const timestamps = new Set(request.result.map((r) => r.timestamp));
      resolve(timestamps);
    };

    request.onerror = () => reject(request.error);
  });
};

/**
 * Cachea datos remotos en IndexedDB, evitando duplicados por timestamp
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @param {string} registradorId - ID del registrador
 * @param {string} zona - "superior" o "inferior"
 * @param {Array} lecturas - Array de lecturas remotas a cachear
 * @returns {Promise<number>} - Cantidad de lecturas nuevas guardadas
 */
export const cachearLecturasRemotas = async (
  db,
  alimentadorId,
  registradorId,
  zona,
  lecturas
) => {
  if (!lecturas || lecturas.length === 0) return 0;

  // Obtener rango de timestamps de las lecturas a cachear
  const timestamps = lecturas.map((l) =>
    typeof l.timestamp === "string" ? new Date(l.timestamp).getTime() : l.timestamp
  );
  const desde = Math.min(...timestamps);
  const hasta = Math.max(...timestamps);

  // Obtener timestamps que ya existen en local
  const existentes = await obtenerTimestampsExistentes(
    db,
    alimentadorId,
    zona,
    desde,
    hasta
  );

  // Filtrar solo las lecturas nuevas
  const lecturasNuevas = lecturas.filter((l) => {
    const ts = typeof l.timestamp === "string" ? new Date(l.timestamp).getTime() : l.timestamp;
    return !existentes.has(ts);
  });

  if (lecturasNuevas.length === 0) return 0;

  // Guardar las nuevas en una transacci√≥n
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);
    let guardadas = 0;

    tx.oncomplete = () => resolve(guardadas);
    tx.onerror = () => reject(tx.error);

    for (const lectura of lecturasNuevas) {
      const ts = typeof lectura.timestamp === "string"
        ? new Date(lectura.timestamp).getTime()
        : lectura.timestamp;

      const registro = {
        alimentadorId,
        registradorId,
        zona,
        timestamp: ts,
        valores: lectura.valores,
        indiceInicial: lectura.indice_inicial ?? lectura.indiceInicial ?? 0,
        exito: lectura.exito !== false,
        createdAt: Date.now(),
        fromCache: true, // Marca para identificar datos cacheados
      };

      const request = store.add(registro);
      request.onsuccess = () => guardadas++;
    }
  });
};

// ===== ./src/paginas/PaginaAlimentadores/utilidades/interpreteRegistrosREF615.js =====

/**
 * Int√©rprete de Registros Modbus para Rel√©s ABB REF615/RET615
 *
 * Este m√≥dulo interpreta los valores binarios de los registros de estado
 * del rel√©, decodificando qu√© bits est√°n activos y su significado.
 *
 * MODO DE FUNCIONAMIENTO:
 * 1. Si la plantilla tiene etiquetas personalizadas para el registro, se usan esas
 * 2. Si no, se usan las etiquetas por defecto definidas en este archivo
 *
 * Basado en documentaci√≥n ABB:
 * - REF615 Modbus Point List Manual (1MRS756581)
 * - Documentaci√≥n Rel√©s ABB Serie 615 - Subestaci√≥n CELTA 1
 */

// ============================================================================
// DEFINICIONES DE REGISTROS Y SUS BITS
// ============================================================================

/**
 * Registro 172 - Estado de LEDs del panel frontal
 * Cada bit representa un LED espec√≠fico del rel√©
 */
const REGISTRO_172_LEDS = {
  nombre: "Estado LEDs",
  descripcion: "Indicadores luminosos del panel frontal del rel√©",
  bits: {
    0: { nombre: "Ready", descripcion: "Rel√© listo/operativo", tipo: "estado" },
    1: { nombre: "Start", descripcion: "Protecci√≥n en arranque", tipo: "alarma" },
    2: { nombre: "Trip", descripcion: "Disparo activo", tipo: "alarma" },
    3: { nombre: "Alarm", descripcion: "Alarma general activa", tipo: "alarma" },
    4: { nombre: "Warning", descripcion: "Advertencia activa", tipo: "warning" },
    5: { nombre: "IR Fault", descripcion: "Falla interna del rel√©", tipo: "error" },
    6: { nombre: "Blocked", descripcion: "Protecci√≥n bloqueada", tipo: "warning" },
    7: { nombre: "Test Mode", descripcion: "Modo de prueba activo", tipo: "info" },
    8: { nombre: "LED 9", descripcion: "LED programable 9", tipo: "info" },
    9: { nombre: "LED 10", descripcion: "LED programable 10", tipo: "info" },
    10: { nombre: "LED 11", descripcion: "LED programable 11", tipo: "info" },
    11: { nombre: "LED 12", descripcion: "LED programable 12", tipo: "info" },
  }
};

/**
 * Registro 170 - Estado de Disparo/Trip
 * Indica la causa del √∫ltimo disparo
 */
const REGISTRO_170_DISPARO = {
  nombre: "Estado Disparo",
  descripcion: "Se√±ales de disparo y arranque de protecciones",
  bits: {
    0: { nombre: "Trip General", descripcion: "Se√±al de disparo general", tipo: "alarma" },
    1: { nombre: "Start General", descripcion: "Se√±al de arranque general", tipo: "warning" },
    2: { nombre: "Trip 50", descripcion: "Disparo por sobrecorriente instant√°nea", tipo: "alarma" },
    3: { nombre: "Trip 51", descripcion: "Disparo por sobrecorriente temporizada", tipo: "alarma" },
    4: { nombre: "Trip 50N", descripcion: "Disparo por falla tierra instant√°nea", tipo: "alarma" },
    5: { nombre: "Trip 51N", descripcion: "Disparo por falla tierra temporizada", tipo: "alarma" },
    6: { nombre: "Trip 50BF", descripcion: "Disparo por falla de interruptor", tipo: "alarma" },
    7: { nombre: "Trip 67", descripcion: "Disparo direccional", tipo: "alarma" },
  }
};

/**
 * Registro 173 - Estado del Interruptor (simplificado)
 */
const REGISTRO_173_INTERRUPTOR_SIMPLE = {
  nombre: "Estado Interruptor",
  descripcion: "Posici√≥n del interruptor de potencia",
  bits: {
    0: { nombre: "Cerrado", descripcion: "Interruptor en posici√≥n cerrada", tipo: "estado" },
    1: { nombre: "Abierto", descripcion: "Interruptor en posici√≥n abierta", tipo: "estado" },
    2: { nombre: "Transici√≥n", descripcion: "Interruptor en movimiento", tipo: "warning" },
    3: { nombre: "Error", descripcion: "Error en indicaci√≥n de posici√≥n", tipo: "error" },
  }
};

/**
 * Registro 174 - Estado del Interruptor (detallado con bits 4-6)
 * Seg√∫n documentaci√≥n ABB, bits 4, 5, 6 indican el estado
 */
const REGISTRO_174_INTERRUPTOR = {
  nombre: "Estado Interruptor (CBXCBR)",
  descripcion: "Control y estado del interruptor principal",
  bits: {
    4: { nombre: "Cerrado", descripcion: "Interruptor CERRADO (energizado)", tipo: "estado" },
    5: { nombre: "Abierto", descripcion: "Interruptor ABIERTO (desenergizado)", tipo: "estado" },
    6: { nombre: "Error/Intermedio", descripcion: "Estado intermedio o error", tipo: "error" },
  },
  interpretacionEspecial: (valor) => {
    const cerrado = (valor >> 4) & 1;
    const abierto = (valor >> 5) & 1;
    const error = (valor >> 6) & 1;

    if (error) return { estado: "ERROR", clase: "error", descripcion: "Estado intermedio o falla de contacto auxiliar" };
    if (cerrado && !abierto) return { estado: "CERRADO", clase: "ok", descripcion: "Interruptor cerrado - circuito energizado" };
    if (abierto && !cerrado) return { estado: "ABIERTO", clase: "warning", descripcion: "Interruptor abierto - circuito desenergizado" };
    return { estado: "DESCONOCIDO", clase: "unknown", descripcion: "Estado no determinado" };
  }
};

/**
 * Registro 127 - Estado del Rel√© / SSR1 (Salud del dispositivo)
 *
 * IMPORTANTE: Seg√∫n el manual ABB, solo los bits 0 y 1 son significativos:
 * - Bit 0: Error global del dispositivo (cr√≠tico)
 * - Bit 1: Warning global del dispositivo
 * - Bits 2-15: Reservados (ignorar)
 *
 * Un valor como 4 (bit 2) NO indica alarma - el dispositivo est√° OK.
 */
const REGISTRO_127_RELE = {
  nombre: "Salud Dispositivo (SSR1)",
  descripcion: "Estado de salud general del rel√© de protecci√≥n",
  bits: {
    0: { nombre: "Error Global", descripcion: "Error cr√≠tico del dispositivo - Requiere atenci√≥n inmediata", tipo: "error" },
    1: { nombre: "Warning Global", descripcion: "Advertencia del dispositivo - Revisar cuando sea posible", tipo: "warning" },
    // Bits 2-15 son reservados y se ignoran
  },
  interpretacionEspecial: (valor) => {
    const error = (valor & 0x01) !== 0;    // Bit 0
    const warning = (valor & 0x02) !== 0;  // Bit 1

    if (error) {
      return {
        estado: "ERROR",
        clase: "error",
        icono: "‚õî",
        descripcion: "Error global del dispositivo - Requiere atenci√≥n inmediata"
      };
    } else if (warning) {
      return {
        estado: "WARNING",
        clase: "warning",
        icono: "‚ö†Ô∏è",
        descripcion: "Advertencia del dispositivo - Revisar cuando sea posible"
      };
    } else {
      return {
        estado: "OK",
        clase: "ok",
        icono: "‚úÖ",
        descripcion: "Dispositivo funcionando correctamente"
      };
    }
  }
};

/**
 * Registro 131 - Heartbeat / SSR5
 *
 * Este es un contador que incrementa constantemente mientras el rel√© est√° vivo.
 * NO se debe interpretar como bits - es un valor num√©rico de heartbeat.
 */
const REGISTRO_131_HEARTBEAT = {
  nombre: "Heartbeat (SSR5)",
  descripcion: "Contador de vida del dispositivo",
  bits: {}, // No tiene bits significativos - es un contador
  interpretacionEspecial: (valor) => {
    if (valor > 0) {
      return {
        estado: "CONECTADO",
        clase: "ok",
        icono: "üíö",
        descripcion: `Dispositivo activo (contador: ${valor})`
      };
    } else {
      return {
        estado: "VERIFICAR",
        clase: "warning",
        icono: "‚ùì",
        descripcion: "Heartbeat en cero - Verificar conexi√≥n"
      };
    }
  }
};

/**
 * Registro 179 - Estados de Protecci√≥n (Sobrecorriente Fase)
 */
const REGISTRO_179_PROTECCION = {
  nombre: "Prot. Sobrecorriente Fase",
  descripcion: "Estado de funciones de sobrecorriente de fase",
  bits: {
    0: { nombre: "PHLPTOC1 Start", descripcion: "Sobrecorriente baja - Arranque", tipo: "warning" },
    1: { nombre: "PHLPTOC1 StartL1", descripcion: "Sobrecorriente baja L1 - Arranque", tipo: "warning" },
    2: { nombre: "PHLPTOC1 StartL2", descripcion: "Sobrecorriente baja L2 - Arranque", tipo: "warning" },
    3: { nombre: "PHLPTOC1 StartL3", descripcion: "Sobrecorriente baja L3 - Arranque", tipo: "warning" },
    8: { nombre: "PHLPTOC1 Operate", descripcion: "Sobrecorriente baja - DISPARO", tipo: "alarma" },
    10: { nombre: "PHHPTOC1 Start", descripcion: "Sobrecorriente alta - Arranque", tipo: "warning" },
  }
};

/**
 * Registro 180 - Estados de Protecci√≥n (Sobrecorriente Alta/Instant√°nea)
 */
const REGISTRO_180_PROTECCION = {
  nombre: "Prot. Sobrecorriente Alta",
  descripcion: "Estado de sobrecorriente alta e instant√°nea",
  bits: {
    2: { nombre: "PHHPTOC1 Operate", descripcion: "Sobrecorriente alta 1 - DISPARO", tipo: "alarma" },
    12: { nombre: "PHHPTOC2 Operate", descripcion: "Sobrecorriente alta 2 - DISPARO", tipo: "alarma" },
    14: { nombre: "PHIPTOC1 Start", descripcion: "Instant√°nea - Arranque", tipo: "warning" },
  }
};

/**
 * Registro 181 - Estados de Protecci√≥n (Instant√°nea y Direccional)
 */
const REGISTRO_181_PROTECCION = {
  nombre: "Prot. Instant√°nea/Direccional",
  descripcion: "Estado de protecci√≥n instant√°nea y falla tierra direccional",
  bits: {
    6: { nombre: "PHIPTOC1 Operate", descripcion: "Instant√°nea - DISPARO", tipo: "alarma" },
    8: { nombre: "DEFLPDEF1 Start", descripcion: "Falla tierra dir. baja - Arranque", tipo: "warning" },
    10: { nombre: "DEFLPDEF1 Operate", descripcion: "Falla tierra dir. baja - DISPARO", tipo: "alarma" },
  }
};

/**
 * Registro 182 - Estados de Protecci√≥n (Falla a Tierra)
 */
const REGISTRO_182_PROTECCION = {
  nombre: "Prot. Falla a Tierra",
  descripcion: "Estado de protecciones de falla a tierra",
  bits: {
    4: { nombre: "EFLPTOC1 Start", descripcion: "Falla tierra baja - Arranque", tipo: "warning" },
    6: { nombre: "EFLPTOC1 Operate", descripcion: "Falla tierra baja - DISPARO", tipo: "alarma" },
    12: { nombre: "EFHPTOC1 Start", descripcion: "Falla tierra alta - Arranque", tipo: "warning" },
    14: { nombre: "EFHPTOC1 Operate", descripcion: "Falla tierra alta - DISPARO", tipo: "alarma" },
  }
};

// ============================================================================
// MAPA DE REGISTROS INTERPRETABLES
// ============================================================================

const MAPA_REGISTROS = {
  127: REGISTRO_127_RELE,
  131: REGISTRO_131_HEARTBEAT,
  170: REGISTRO_170_DISPARO,
  172: REGISTRO_172_LEDS,
  173: REGISTRO_173_INTERRUPTOR_SIMPLE,
  174: REGISTRO_174_INTERRUPTOR,
  179: REGISTRO_179_PROTECCION,
  180: REGISTRO_180_PROTECCION,
  181: REGISTRO_181_PROTECCION,
  182: REGISTRO_182_PROTECCION,
};

// Categor√≠as que requieren interpretaci√≥n binaria
const CATEGORIAS_INTERPRETABLES = ["estados", "sistema"];

// ============================================================================
// FUNCIONES DE INTERPRETACI√ìN
// ============================================================================

/**
 * Interpreta un valor de registro y devuelve los bits activos con su significado
 * @param {number} numeroRegistro - N√∫mero del registro Modbus
 * @param {number} valor - Valor le√≠do del registro (0-65535)
 * @param {Object} etiquetasPersonalizadas - Etiquetas de la plantilla (opcional)
 *        Formato: { 0: { texto: "Arranque I>", severidad: "warning" }, ... }
 * @returns {Object} Interpretaci√≥n del registro
 */
export function interpretarRegistro(numeroRegistro, valor, etiquetasPersonalizadas = null) {
  const definicionBase = MAPA_REGISTROS[numeroRegistro];

  // Si hay etiquetas personalizadas, usarlas; si no, usar las por defecto
  const tieneEtiquetasPersonalizadas = etiquetasPersonalizadas &&
    Object.keys(etiquetasPersonalizadas).length > 0;

  // Si no hay definici√≥n base ni etiquetas personalizadas, hacer decodificaci√≥n gen√©rica
  if (!definicionBase && !tieneEtiquetasPersonalizadas) {
    return interpretarGenerico(numeroRegistro, valor);
  }

  const bitsActivos = [];
  const bitsInactivos = [];

  // Determinar qu√© bits analizar (0-15 para registro de 16 bits)
  for (let posicion = 0; posicion < 16; posicion++) {
    const estaActivo = ((valor >> posicion) & 1) === 1;

    // Buscar etiqueta: primero personalizada, luego por defecto
    let etiqueta = null;
    let severidad = "info";
    let descripcion = `Bit ${posicion}`;

    if (tieneEtiquetasPersonalizadas && etiquetasPersonalizadas[posicion]) {
      const etiquetaPersonalizada = etiquetasPersonalizadas[posicion];
      etiqueta = etiquetaPersonalizada.texto || etiquetaPersonalizada;
      severidad = etiquetaPersonalizada.severidad || "info";
      descripcion = etiqueta;
    } else if (definicionBase && definicionBase.bits[posicion]) {
      const bitBase = definicionBase.bits[posicion];
      etiqueta = bitBase.nombre;
      severidad = bitBase.tipo;
      descripcion = bitBase.descripcion;
    }

    // Solo incluir bits que tienen etiqueta definida
    // IMPORTANTE: NO mostrar bits activos sin etiqueta (evita "Bit 12", "Bit 14" sin significado)
    if (etiqueta) {
      const bitData = {
        posicion,
        nombre: etiqueta,
        descripcion,
        tipo: severidad,
        activo: estaActivo
      };

      if (estaActivo) {
        bitsActivos.push(bitData);
      } else {
        // Solo incluir bits inactivos si tienen etiqueta
        bitsInactivos.push(bitData);
      }
    }
  }

  // Interpretaci√≥n especial si existe en la definici√≥n base
  let interpretacionEspecial = null;
  if (definicionBase && definicionBase.interpretacionEspecial) {
    interpretacionEspecial = definicionBase.interpretacionEspecial(valor);
  }

  const nombreRegistro = definicionBase?.nombre || `Registro ${numeroRegistro}`;
  const descripcionRegistro = definicionBase?.descripcion || "Registro con etiquetas personalizadas";

  return {
    tieneInterpretacion: true,
    usaEtiquetasPersonalizadas: tieneEtiquetasPersonalizadas,
    numeroRegistro,
    valor,
    binario: valor.toString(2).padStart(16, "0"),
    hexadecimal: "0x" + valor.toString(16).toUpperCase().padStart(4, "0"),
    nombreRegistro,
    descripcionRegistro,
    bitsActivos,
    bitsInactivos,
    interpretacionEspecial,
    resumen: generarResumen(bitsActivos, interpretacionEspecial)
  };
}

/**
 * Interpretaci√≥n gen√©rica para registros sin definici√≥n
 * Muestra todos los bits activos sin etiquetas
 */
function interpretarGenerico(numeroRegistro, valor) {
  const bitsActivos = [];

  for (let posicion = 0; posicion < 16; posicion++) {
    if (((valor >> posicion) & 1) === 1) {
      bitsActivos.push({
        posicion,
        nombre: `Bit ${posicion}`,
        descripcion: `Bit ${posicion} activo`,
        tipo: "info",
        activo: true
      });
    }
  }

  return {
    tieneInterpretacion: true,
    usaEtiquetasPersonalizadas: false,
    numeroRegistro,
    valor,
    binario: valor.toString(2).padStart(16, "0"),
    hexadecimal: "0x" + valor.toString(16).toUpperCase().padStart(4, "0"),
    nombreRegistro: `Registro ${numeroRegistro}`,
    descripcionRegistro: "Sin definici√≥n de etiquetas",
    bitsActivos,
    bitsInactivos: [],
    interpretacionEspecial: null,
    resumen: bitsActivos.length > 0
      ? `${bitsActivos.length} bit(s) activo(s): ${bitsActivos.map(b => b.posicion).join(", ")}`
      : "Sin bits activos"
  };
}

/**
 * Genera un resumen legible de los bits activos
 */
function generarResumen(bitsActivos, interpretacionEspecial) {
  if (interpretacionEspecial) {
    return interpretacionEspecial.descripcion;
  }

  if (bitsActivos.length === 0) {
    return "Sin se√±ales activas";
  }

  // Priorizar alarmas y errores en el resumen
  const alarmas = bitsActivos.filter(b => b.tipo === "alarma");
  const errores = bitsActivos.filter(b => b.tipo === "error");
  const warnings = bitsActivos.filter(b => b.tipo === "warning");
  const estados = bitsActivos.filter(b => b.tipo === "estado" || b.tipo === "info");

  const partes = [];

  if (errores.length > 0) {
    partes.push(`ERRORES: ${errores.map(e => e.nombre).join(", ")}`);
  }
  if (alarmas.length > 0) {
    partes.push(`ALARMAS: ${alarmas.map(a => a.nombre).join(", ")}`);
  }
  if (warnings.length > 0) {
    partes.push(`Warnings: ${warnings.map(w => w.nombre).join(", ")}`);
  }
  if (estados.length > 0 && partes.length === 0) {
    partes.push(estados.map(e => e.nombre).join(", "));
  }

  return partes.join(" | ");
}

/**
 * Verifica si un registro tiene interpretaci√≥n disponible
 * @param {number} numeroRegistro - N√∫mero del registro
 * @returns {boolean}
 */
export function tieneInterpretacion(numeroRegistro) {
  return Object.prototype.hasOwnProperty.call(MAPA_REGISTROS, numeroRegistro);
}

/**
 * Obtiene la definici√≥n de un registro
 * @param {number} numeroRegistro - N√∫mero del registro
 * @returns {Object|null}
 */
export function obtenerDefinicionRegistro(numeroRegistro) {
  return MAPA_REGISTROS[numeroRegistro] || null;
}

/**
 * Verifica si una categor√≠a de funcionalidad requiere interpretaci√≥n
 * @param {string} categoriaId - ID de la categor√≠a
 * @returns {boolean}
 */
export function categoriaRequiereInterpretacion(categoriaId) {
  return CATEGORIAS_INTERPRETABLES.includes(categoriaId);
}

/**
 * Obtiene el tipo CSS para un bit seg√∫n su tipo
 * @param {string} tipo - Tipo del bit (alarma, error, warning, estado, info)
 * @returns {string} Clase CSS a aplicar
 */
export function obtenerClaseTipo(tipo) {
  const clases = {
    alarma: "interpretacion-alarma",
    error: "interpretacion-error",
    warning: "interpretacion-warning",
    estado: "interpretacion-estado",
    info: "interpretacion-info",
    ok: "interpretacion-ok",
    unknown: "interpretacion-unknown"
  };
  return clases[tipo] || "interpretacion-info";
}

/**
 * Obtiene las etiquetas por defecto de un registro para usar en el formulario
 * @param {number} numeroRegistro - N√∫mero del registro
 * @returns {Object} - { bit: { texto, severidad }, ... }
 */
export function obtenerEtiquetasDefecto(numeroRegistro) {
  const definicion = MAPA_REGISTROS[numeroRegistro];
  if (!definicion) return {};

  const etiquetas = {};
  Object.entries(definicion.bits).forEach(([bitPos, bitInfo]) => {
    etiquetas[bitPos] = {
      texto: bitInfo.nombre,
      severidad: bitInfo.tipo
    };
  });

  return etiquetas;
}

/**
 * Lista de severidades disponibles para etiquetas
 */
export const SEVERIDADES_DISPONIBLES = [
  { id: "info", nombre: "Info", color: "#93c5fd" },
  { id: "estado", nombre: "Estado", color: "#93c5fd" },
  { id: "warning", nombre: "Advertencia", color: "#fde68a" },
  { id: "alarma", nombre: "Alarma", color: "#fca5a5" },
  { id: "error", nombre: "Error", color: "#fca5a5" }
];

/**
 * Plantillas predefinidas de etiquetas para diferentes tipos de rel√©s
 * El usuario puede seleccionar una de estas como base
 */
export const PLANTILLAS_ETIQUETAS_LEDS = {
  alimentador: {
    nombre: "Alimentador (FE03)",
    etiquetas: {
      0: { texto: "Arranque I>", severidad: "warning" },
      1: { texto: "Disparo I>", severidad: "alarma" },
      2: { texto: "Falla a Tierra / Disparo I>>", severidad: "alarma" },
      3: { texto: "Disparo I>>", severidad: "alarma" },
      4: { texto: "Arranque Io>", severidad: "warning" },
      5: { texto: "Disparo Falla a Tierra", severidad: "alarma" },
      6: { texto: "Desbalance de Fases", severidad: "warning" },
      7: { texto: "Recierre Habilitado", severidad: "info" },
      8: { texto: "Recierre en Progreso", severidad: "info" },
      9: { texto: "Pos CB Abierto", severidad: "estado" },
      10: { texto: "Pos CB Cerrado", severidad: "estado" }
    }
  },
  terna: {
    nombre: "TERNA (FE06)",
    etiquetas: {
      0: { texto: "Sobreintensidad", severidad: "warning" },
      1: { texto: "Falta a tierra", severidad: "alarma" },
      2: { texto: "Sobre/sub tensi√≥n", severidad: "warning" },
      3: { texto: "Desbalance de fases", severidad: "warning" },
      4: { texto: "Sobrecarga t√©rmica", severidad: "warning" },
      5: { texto: "Fallo de interruptor", severidad: "error" },
      6: { texto: "Disparo reg. perturb.", severidad: "info" },
      7: { texto: "Monitorizaci√≥n interruptor", severidad: "info" },
      8: { texto: "Supervisi√≥n", severidad: "info" }
    }
  },
  trafoDif: {
    nombre: "TRAFO Diferencial (TE02)",
    etiquetas: {
      0: { texto: "Prot dif pol. etapa baja", severidad: "warning" },
      1: { texto: "Prot. dif. etapa alta", severidad: "alarma" },
      2: { texto: "Sobreintensidad", severidad: "warning" },
      3: { texto: "Falta a tierra restringida", severidad: "alarma" },
      4: { texto: "Falta a tierra", severidad: "alarma" },
      5: { texto: "Fallo de interruptor", severidad: "error" },
      6: { texto: "F. sec. neg. / sobrecarga 1¬∞", severidad: "warning" },
      7: { texto: "Disparo reg. perturb.", severidad: "info" },
      8: { texto: "Supervisi√≥n", severidad: "info" },
      9: { texto: "Disparo externo", severidad: "alarma" }
    }
  }
};

/**
 * Exportar mapa de registros para referencia
 */
export const REGISTROS_INTERPRETABLES = MAPA_REGISTROS;

export default {
  interpretarRegistro,
  tieneInterpretacion,
  obtenerDefinicionRegistro,
  categoriaRequiereInterpretacion,
  obtenerClaseTipo,
  obtenerEtiquetasDefecto,
  REGISTROS_INTERPRETABLES,
  SEVERIDADES_DISPONIBLES,
  PLANTILLAS_ETIQUETAS_LEDS
};

// ===== ./src/paginas/PaginaLogin/PaginaLogin.css =====

/* src/paginas/PaginaLogin/PaginaLogin.css */
/*
   NOTA SOBRE ESTE ARCHIVO CSS:
   - Define el dise√±o visual de la pantalla de login: fondo negro general,
     panel celeste a la derecha y logo centrado en la columna izquierda.

   - Registra la fuente "Baloo Bhai 2" y la usa como tipograf√≠a principal.

   - `.container`, `.izquierda` y `.derecha` arman el layout de dos columnas.

   - El bloque @media (max-width: 768px) adapta el login a m√≥vil: el logo pasa
     arriba y el panel celeste ocupa toda la pantalla.
	  
   - Las clases `.alerta`, `.alerta-error` y `.alerta-exito` estilizan el
     mensaje flotante de feedback que se dispara desde PaginaLogin.jsx.
*/

/* 1) Reset b√°sico */
* {
	box-sizing: border-box;
}

html,
body {
	margin: 0;
	padding: 0;
	height: 100%;
	overflow-x: hidden;
	/* evita la barra horizontal por si algo se pasa */
}

body {
	background-color: black;
	font-family: "Baloo Bhai 2", system-ui, -apple-system, "Segoe UI", sans-serif;
}

/* Fuentes */
@font-face {
	font-family: "Baloo Bhai 2";
	src: url("/fonts/BalooBhai2-Regular.ttf") format("truetype");
	font-weight: 400;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Baloo Bhai 2";
	src: url("/fonts/BalooBhai2-Bold.ttf") format("truetype");
	font-weight: 700;
	font-style: normal;
	font-display: swap;
}

.login-form {
	margin: 0;
	padding: 0;

}

/* 2) Contenedor principal pantalla completa sin overflow */
.container {
	position: relative;
	min-height: 100vh;
	/* ocupa alto de la pantalla */
	min-width: 100%;
	/* ocupa todo el ancho disponible del form/viewport */
	display: flex;
	font-family: "Baloo Bhai 2", system-ui, -apple-system, "Segoe UI", sans-serif;
}


/* 3) Columna izquierda (logo) */
.izquierda {
	flex: 1;
	display: flex;
	align-items: center;
	justify-content: center;

	background-color: #000;
	background-image: radial-gradient(circle at center,
			#202020 0%,
			#050505 60%,
			#000000 100%);
}

.logo {
	max-width: 40%;
	height: auto;
}

/* 4) Columna derecha (fondo azul) */
.derecha {
	flex: 1;
	display: flex;
	align-items: center;
	justify-content: center;

	background-color: rgb(75, 133, 174);
	background-image: radial-gradient(circle at center,
			#5fa0d0 0%,
			#4b85ae 50%,
			#325a80 100%);

	padding: 40px;
	border-radius: 20px;
	margin: 10px;
}

/* 5) Caja del login */
.login {
	width: 100%;
	max-width: 380px;
	display: flex;
	flex-direction: column;
}

/* 6) Textos y campos */
.usuario {
	display: block;
	text-align: left;
	color: rgb(249, 250, 250);
	font-size: 32px;
	margin-top: 48px;
}

.input {
	width: 100%;
	padding: 18px 20px;
	background-color: black;
	border-radius: 10px;
	font-size: 18px;
	color: white;
	border: none;

}

.input-contrase√±a {
	position: relative;
}

.ojito {
	position: absolute;
	right: 12px;
	top: 18px;
	transform: "translateY(-50%)";
	cursor: "pointer";
	font-size: 22px;
	color: #5e5f5f;
}

label.recordarme {
	font-size: 18px;
	margin-top: 6px;
	color: white;
	display: inline-flex;
	align-items: center;
	gap: 6px;
}

/* Checkbox "Recordarme" debajo del input contrase√±a */
.checkbox-recordarme {
	display: flex;
	align-items: center;
	gap: 8px;
	margin-top: 12px;
	color: white;
	font-size: 16px;
	cursor: pointer;
}

.checkbox-recordarme input[type="checkbox"] {
	width: 18px;
	height: 18px;
	accent-color: #176414;
	cursor: pointer;
}

/* 7) Bot√≥n y texto inferior (debajo del checkbox) */
.acciones {
	margin-top: 20px;
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	gap: 6px;
}

.boton {
	width: 100%;
	padding: 12px 24px;
	border: none;
	border-radius: 10px;
	background-color: #176414;
	color: rgba(255, 255, 255, 0.911);
	font-size: 24px;
	font-weight: 700;
	cursor: pointer;
	transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.2s ease;
	margin-top: 10px;
}

.boton:hover {
	background-color: #1ac014c7;
	box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
	transform: translateY(-1px);
}

.recordarme {
	margin-top: 8px;
	font-size: 18px;
	color: white;
	cursor: pointer;
}

.registrarse {
	font-size: 18px;
	color: white;
	cursor: pointer;
}

/* === VISTA MOBILE / PANTALLAS ANGOSTAS === */
@media (max-width: 768px) {
	.container {
		position: relative;
		min-height: 100vh;
		min-height: 100dvh;
		width: 100vw;
		display: flex;
		flex-direction: column;
		overflow-y: auto;
	}

	/* Degradado negro desde arriba hasta debajo del logo */
	.container::before {
		content: "";
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 45vh;
		background: linear-gradient(to bottom,
				rgba(0, 0, 0, 1) 0%,
				rgba(0, 0, 0, 1) 65%,
				rgba(0, 0, 0, 0.6) 80%,
				rgba(0, 0, 0, 0) 100%);
		z-index: 1;
		pointer-events: none;
	}

	/* Contenedor del logo - posicionado sobre el panel celeste */
	.izquierda {
		position: absolute;
		top: 4vh;
		left: 50%;
		transform: translateX(-50%);
		width: auto;
		padding: 0;
		background: transparent;
		justify-content: center;
		align-items: center;
		display: flex;
		z-index: 10;
	}

	.logo {
		max-width: 42vw;
		min-width: 180px;
		max-height: 270px;
		height: auto;
		position: relative;
		z-index: 1;
	}

	/* El panel celeste ocupa toda la pantalla */
	.derecha {
		flex: 1;
		width: 100%;
		margin: 0;
		border-radius: 0;
		padding:
			calc(45vh + var(--safe-area-inset-top, 0px)) calc(5vw + var(--safe-area-inset-right, 0px)) calc(5vh + var(--safe-area-inset-bottom, 0px)) calc(5vw + var(--safe-area-inset-left, 0px));
		display: flex;
		align-items: flex-start;
		justify-content: center;
	}

	.login {
		max-width: 100%;
		width: 100%;
		margin: 0 auto;
	}

	/* Labels m√°s peque√±os y con menos margin en m√≥vil */
	.usuario {
		text-align: left;
		font-size: clamp(18px, 5vw, 24px);
		margin-top: 3vh;
		margin-bottom: 0.5vh;
	}

	/* Primer label sin margin-top extra */
	.login .usuario:first-of-type {
		margin-top: 0;
	}

	.input {
		padding: 3.5vw 4vw;
		font-size: clamp(14px, 4vw, 18px);
	}

	.acciones {
		align-items: center;
		margin-top: 2vh;
		gap: 1vh;
	}

	.boton {
		margin-top: 1vh;
		padding: 3vw 5vw;
		font-size: clamp(18px, 5vw, 22px);
	}

	.recordarme,
	.registrarse {
		font-size: clamp(14px, 4vw, 18px);
	}

	.ojito {
		top: 3.5vw;
		font-size: clamp(18px, 5vw, 22px);
	}

	.checkbox-recordarme {
		margin-top: 2vh;
		font-size: clamp(14px, 4vw, 16px);
	}
}

/* ============================= */
/* ALERTA MODERNA Y BONITA      */
/* ============================= */
.alerta {
	position: fixed;
	top: calc(30px + var(--safe-area-inset-top, 0px));
	left: 50%;
	transform: translateX(-50%);
	padding: 16px 32px;
	border-radius: 16px;
	color: white;
	font-weight: 600;
	font-size: 16px;
	z-index: 9999;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
	animation: bajar 0.6s ease;
	text-align: center;
}

.alerta-error {
	background-color: #d32f2f;
}

.alerta-exito {
	background-color: #388e3c;
}

@keyframes bajar {
	from {
		transform: translate(-50%, -100%);
		opacity: 0;
	}

	to {
		transform: translateX(-50%);
		opacity: 1;
	}
}
// ===== ./src/paginas/PaginaLogin/PaginaLogin.jsx =====

// src/paginas/PaginaLogin/PaginaLogin.jsx

import React, { useState, useEffect, useRef } from "react";
import { Link, useNavigate } from "react-router-dom";
import { useAuth } from "../../contextos/AuthContext";
import { Capacitor } from "@capacitor/core";
import { BiometricAuth } from "@aparajita/capacitor-biometric-auth";
import "./PaginaLogin.css";
import logoApp from "../../assets/imagenes/logo 2 rw.png";

const STORAGE_KEY = "relaywatch_recordarme";

// Icono ojo abierto
const EyeIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
    <circle cx="12" cy="12" r="3"/>
  </svg>
);

// Icono ojo tachado
const EyeOffIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
    <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a21.8 21.8 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a21.8 21.8 0 0 1-2.16 3.19M1 1l22 22"/>
  </svg>
);

const PaginaLogin = () => {
  const [email, setEmail] = useState("");
  const [contrasena, setContrasena] = useState("");
  const [mostrarContrasena, setMostrarContrasena] = useState(false);
  const [recordarme, setRecordarme] = useState(false);
  const [alerta, setAlerta] = useState({ mensaje: "", tipo: "" });
  const [cargando, setCargando] = useState(false);

  // Ref para saber si las credenciales vienen del localStorage (precargadas)
  const credencialesPrecargadas = useRef(false);
  const biometriaYaIntentada = useRef(false);

  const { login } = useAuth();
  const navigate = useNavigate();

  // Cargar credenciales guardadas al montar
  useEffect(() => {
    const guardado = localStorage.getItem(STORAGE_KEY);
    if (guardado) {
      try {
        const { email: emailGuardado, contrasena: contrasenaGuardada } = JSON.parse(guardado);
        if (emailGuardado && contrasenaGuardada) {
          setEmail(emailGuardado);
          setContrasena(contrasenaGuardada);
          setRecordarme(true);
          credencialesPrecargadas.current = true;
        }
      } catch {
        localStorage.removeItem(STORAGE_KEY);
      }
    }
  }, []);

  // Mostrar alerta temporal
  const mostrarAlerta = (mensaje, tipo = "error") => {
    setAlerta({ mensaje, tipo });
    setTimeout(() => {
      setAlerta({ mensaje: "", tipo: "" });
    }, 4000);
  };

  // Mostrar prompt de biometr√≠a autom√°ticamente SOLO si hay credenciales precargadas
  useEffect(() => {
    const intentarBiometria = async () => {
      // Solo ejecutar si:
      // 1. Las credenciales vienen precargadas del localStorage
      // 2. No se ha intentado ya la biometr√≠a
      // 3. Estamos en plataforma nativa
      if (!credencialesPrecargadas.current || biometriaYaIntentada.current) return;
      if (!Capacitor.isNativePlatform()) return;

      biometriaYaIntentada.current = true;

      try {
        const info = await BiometricAuth.checkBiometry();
        if (!info.isAvailable) return;

        await BiometricAuth.authenticate({
          reason: "Inicia sesi√≥n con tu huella digital",
          cancelTitle: "Cancelar",
          allowDeviceCredential: true,
        });

        // Biometr√≠a exitosa, hacer login autom√°tico
        setCargando(true);
        const { exito, error } = await login(email.trim(), contrasena);
        setCargando(false);

        if (!exito) {
          mostrarAlerta(error || "Error al iniciar sesi√≥n", "error");
          return;
        }

        localStorage.setItem(STORAGE_KEY, JSON.stringify({ email: email.trim(), contrasena }));
        mostrarAlerta("¬°Bienvenido!", "exito");

        setTimeout(() => {
          navigate("/alimentadores");
        }, 1200);
      } catch {
        // Usuario cancel√≥ o error de biometr√≠a - no mostrar error
      }
    };

    // Peque√±o delay para que la UI se renderice primero
    const timer = setTimeout(intentarBiometria, 500);
    return () => clearTimeout(timer);
  }, [email, contrasena, login, navigate]);

  // Manejo del submit del formulario
  const handleSubmit = async (event) => {
    event.preventDefault();

    if (!email.trim() || !contrasena.trim()) {
      mostrarAlerta("Por favor completa todos los campos", "error");
      return;
    }

    setCargando(true);

    const { exito, error } = await login(email.trim(), contrasena);

    setCargando(false);

    if (!exito) {
      mostrarAlerta(error || "Error al iniciar sesi√≥n", "error");
      return;
    }

    // Guardar o limpiar credenciales seg√∫n checkbox
    if (recordarme) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ email: email.trim(), contrasena }));
    } else {
      localStorage.removeItem(STORAGE_KEY);
    }

    mostrarAlerta("¬°Bienvenido!", "exito");

    setTimeout(() => {
      navigate("/alimentadores");
    }, 1200);
  };

  return (
    <form onSubmit={handleSubmit} className="login-form">
      <div className="container">
        <div className="izquierda">
          <img
            src={logoApp}
            alt="logoApp"
            className="logo"
          />
        </div>

        <div className="derecha">
          <div className="login">
            <h3 className="usuario">EMAIL</h3>

            <input
              className="input"
              type="email"
              placeholder="Ingrese su email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              autoComplete="email"
              disabled={cargando}
            />

            <h3 className="usuario">CONTRASE√ëA</h3>
            <div className="input-contrase√±a">
              <input
                className="input"
                type={mostrarContrasena ? "text" : "password"}
                placeholder="Ingrese su contrase√±a"
                value={contrasena}
                onChange={(e) => setContrasena(e.target.value)}
                autoComplete="current-password"
                disabled={cargando}
              />
              <span
                onClick={() => setMostrarContrasena(!mostrarContrasena)}
                className='ojito'
              >
                {mostrarContrasena ? <EyeIcon /> : <EyeOffIcon />}
              </span>
            </div>

            <label className="checkbox-recordarme">
              <input
                type="checkbox"
                checked={recordarme}
                onChange={(e) => setRecordarme(e.target.checked)}
                disabled={cargando}
              />
              <span>Recordarme</span>
            </label>

            <div className="acciones">
              <button
                type="submit"
                className="boton"
                disabled={cargando}
              >
                {cargando ? "Iniciando sesi√≥n..." : "Iniciar sesi√≥n"}
              </button>

              <Link to="/recuperarContrase√±a" className="recordarme">
                ¬øOlvidaste tu contrase√±a?
              </Link>

              <Link to="/registro" className="registrarse">
                ¬øNo tienes cuenta? reg√≠strate
              </Link>
            </div>
          </div>
        </div>
      </div>

      {alerta.mensaje && (
        <div className={`alerta alerta-${alerta.tipo}`}>
          {alerta.mensaje}
        </div>
      )}
    </form>
  );
};

export default PaginaLogin;

// ===== ./src/paginas/PaginaRecuperar/recuperarContrase√±a.css =====

/* src/paginas/PaginaRecuperar/recuperarContrase√±a.css */
/*
   NOTA SOBRE ESTE ARCHIVO (recuperarContrase√±a.css)
   - Define el fondo degradado y la tarjeta negra central de la pantalla
     de recuperaci√≥n de contrase√±a.
   - `.recuperar-fondo` centra vertical y horizontalmente la caja;
     `.recuperar-caja` es el panel oscuro con sombra celeste.
   - Tambi√©n estiliza el bot√≥n de volver, el input de email con glow cyan
     y las alertas flotantes de √©xito/error.
*/

/* ====================== FONDO DE LA P√ÅGINA ====================== */
/* Fondo celeste degradado radial, centrado en el medio de la pantalla */
.recuperar-fondo {
    min-height: 100vh;                                   /* ocupa toda la pantalla */
    background-color: rgb(75, 133, 174);                 /* color base por si falla el degradado */
    background-image: radial-gradient(
        circle at center,        /* el degradado sale desde el centro */
        #5fa0d0 0%,              /* celeste claro al principio */
        #4b85ae 50%,             /* celeste medio */
        #325a80 100%             /* azul m√°s oscuro al final */
    );
    display: flex;                                       /* para centrar la tarjeta */
    align-items: center;                                  /* verticalmente centrado */
    justify-content: center;                              /* horizontalmente centrado */
    padding: 20px;                                        /* espacio en pantallas peque√±as */
}

/* ====================== TARJETA CENTRAL ====================== */
/* La caja negra que contiene todo el formulario */
.recuperar-caja {
    background: rgb(8, 8, 8);                             /* negro casi puro */
    padding: 20px 40px;                                   /* espacio interno (arriba/abajo - izquierda/derecha) */
    border-radius: 20px;                                  /* bordes bien redondeados */
    /* Sombra celeste suave + glow sutil para que parezca que flota */
    box-shadow: 0 20px 40px #e0f7fa;                      /* sombra celeste claro (tu color principal) */
    width: 100%;                                          /* en m√≥viles ocupa todo */
    max-width: 420px;                                     /* en pantallas grandes no se hace gigante */
    text-align: center;                                   /* todo el texto centrado */
    position: relative;                                   /* para posicionar la flecha de volver */
}

/* ====================== FLECHA PARA VOLVER ====================== */
.btn-volver {
    position: absolute;                                   /* se sale del flujo normal */
    top: 20px;                                            /* distancia desde arriba */
    left: 40px;                                           /* distancia desde la izquierda */
    background: none;                                     /* sin fondo */
    border: none;                                         /* sin borde */
    font-size: 18px;                                      /* tama√±o grande */
    cursor: pointer;                                      /* manito al pasar el mouse */
    color: #e0f7fa;                                       /* celeste claro (el mismo que us√°s en texto) */
}


/* ====================== LOGO ====================== */
.logo-recuperar {
    align-items: center;                                  /* reservado por si despu√©s uso flex */
}

/* ====================== T√çTULOS Y TEXTO ====================== */
.h2-Recuperar {
    color: #e0f7fa;
    margin: 0 0 15px 0;                                   /* quita margen arriba, deja abajo */
    font-size: 26px;                                      /* t√≠tulo grande */
}

.texto-ayuda {
    color: #e0f7fa;                                       /* mismo celeste claro */
    margin-bottom: 30px;                                  /* espacio antes del input */
    line-height: 1.5;                                     /* m√°s legible */
    font-size: 15px;
}

/* ====================== CAMPO DE EMAIL ====================== */
.input-recuperar {
    width: 100%;                                          /* ocupa todo el ancho */
    padding: 16px;                                        /* espacio interno c√≥modo */
    background: #111111;                                  /* fondo casi negro (modo oscuro) */
    border: 2px solid rgba(0, 255, 255, 0.4);             /* borde cyan neon tenue */
    border-radius: 12px;                                  /* bordes redondeados */
    color: #ffffff;                                       /* texto blanco bien legible */
    font-size: 16px;
    margin-bottom: 25px;                                  /* espacio debajo */
    box-sizing: border-box;                               /* el padding no rompe el ancho */
}

/* Texto de ejemplo dentro del input */
.input-recuperar::placeholder {
    color: #666666;                                       /* gris medio para que no moleste */
}

/* Efecto cuando hac√©s click en el input */
.input-recuperar:focus {
    border-color: #00ffff;                                /* cyan brillante */
    box-shadow: 
        0 0 20px rgba(0, 255, 255, 0.6),
        0 0 40px rgba(0, 255, 255, 0.3);                  /* glow cyan intenso */
    background: #000;                                     /* fondo negro puro al hacer foco */
}

/* ====================== BOT√ìN ENVIAR ====================== */
.btn-enviar {
    background: rgba(3, 185, 246, 0.4);                   /* cyan con transparencia */
    color: #f5f8f8;                                       /* blanco suave */
    padding: 16px;
    border: none;
    border-radius: 12px;
    width: 100%;
    font-size: 17px;
    font-weight: 600;                                     /* negrita */
    cursor: pointer;
    margin-bottom: 20px;                                  /* espacio abajo */
}

/* Efecto al pasar el mouse por el bot√≥n */
.btn-enviar:hover {
    background: #06a1e3;                                  /* cyan m√°s fuerte */
}

/* ====================== ALERTA PERSONALIZADA ====================== */
.alerta {
    position: fixed;                                      /* siempre arriba del todo */
    top: 30px;
    left: 50%;
    transform: translateX(-50%);                          /* centrado perfecto */
    padding: 16px 32px;
    border-radius: 16px;
    color: white;
    font-weight: 600;
    z-index: 9999;                                        /* por encima de todo */
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
    animation: bajar 0.6s ease;                           /* animaci√≥n de entrada */
}

.alerta-error { background: #d32f2f; }                    /* rojo error */
.alerta-exito { background: #388e3c; }                    /* verde √©xito */

/* Animaci√≥n de entrada de la alerta */
@keyframes bajar {
    from {
        transform: translate(-50%, -100%);                /* empieza arriba fuera de pantalla */
        opacity: 0;
    }
    to {
        transform: translateX(-50%);
        opacity: 1;
    }
}


// ===== ./src/paginas/PaginaRecuperar/recuperarContrase√±a.jsx =====

// src/paginas/PaginaRecuperar/recuperarContrase√±a.jsx

import { useState } from "react";                  // hook para manejar estado local (email y alertas)
import { useNavigate } from "react-router-dom";    // navegaci√≥n: volver a /login u otras rutas
import "./recuperarContrase√±a.css";                // estilos espec√≠ficos de la pantalla de recuperaci√≥n
import logoApp from "../../assets/imagenes/logo 2 rw.png";

const RecuperarContrasena = () => {
   const [email, setEmail] = useState("");         // email que escribe el usuario
   const [alerta, setAlerta] = useState({
      mensaje: "",
      tipo: "",
   });                                             // alerta de √©xito o error (controla color y texto)

   const navigate = useNavigate();                 // hook para redirigir de vuelta al login

   const mostrarAlerta = (mensaje, tipo = "exito") => {
      setAlerta({ mensaje, tipo });                // muestra alerta con mensaje y tipo
      setTimeout(() => setAlerta({ mensaje: "", tipo: "" }), 5000); // la oculta a los 5 segundos
   };

   const handleSubmit = (e) => {
      e.preventDefault();                          // evita recarga completa de la p√°gina

      if (!email.trim()) {
         // Validaci√≥n: campo vac√≠o
         mostrarAlerta("Por favor escrib√≠ tu email", "error");
         return;
      }

      if (!email.includes("@") || !email.includes(".")) {
         // Validaci√≥n muy b√°sica de formato de email
         mostrarAlerta("El email no parece v√°lido", "error");
         return;
      }

      mostrarAlerta(`Listo! Te enviamos un enlace a ${email}`, "exito");

      setTimeout(() => {
         navigate("/");                            // despu√©s de 3 segundos volvemos al login
      }, 3000);
   };

   return (
      <div className="recuperar-fondo">
         <div className="recuperar-caja">
            <button
               className="btn-volver"
               onClick={() => navigate("/")}       // vuelve a la pantalla de inicio de sesi√≥n
            >
               ‚Üê Volver al inicio de sesi√≥n
            </button>

            <img
               src={logoApp}
               alt="Logo"
               className="logo-recuperar"
            />

            <h2 className="h2-Recuperar">Recuperar contrase√±a</h2>

            <p className="texto-ayuda">
               Ingres√° tu email y te enviaremos un enlace para crear una nueva
               contrase√±a.
            </p>

            <form onSubmit={handleSubmit}>
               <input
                  type="text"
                  placeholder="tuemail@ejemplo.com"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)} // actualiza el estado con lo que escribe el usuario
                  className="input-recuperar"
               />
               <button type="submit" className="btn-enviar">
                  Enviar enlace
               </button>
            </form>

            {alerta.mensaje && (
               <div className={`alerta alerta-${alerta.tipo}`}>
                  {alerta.mensaje}
               </div>
            )}
         </div>
      </div>
   );
};

export default RecuperarContrasena;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (recuperarContrase√±a.jsx)

 - Pantalla sencilla para simular el flujo de "Recuperar contrase√±a". No
   env√≠a correos reales, s√≥lo muestra un mensaje de confirmaci√≥n.

 - `email` guarda lo que escribe el usuario; `alerta` controla el texto y el
   color (√©xito/error) del mensaje que aparece debajo del formulario.

 - `handleSubmit` valida que el email no est√© vac√≠o y tenga al menos un "@" y
   un ".", luego muestra una alerta de √©xito y, tras 3 segundos, vuelve al
   login (`navigate("/")`).

 - El bot√≥n "‚Üê Volver al inicio de sesi√≥n" permite regresar al login sin
   enviar nada, usando tambi√©n `navigate("/")`.

 - Todo el aspecto visual (fondo, caja, colores de alerta, etc.) se define en
   `recuperarContrase√±a.css`.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (recuperarContrase√±a.jsx)

0) Visi√≥n general de la pantalla

   - RecuperarContrasena implementa una pantalla sencilla para simular el
     flujo de ‚ÄúRecuperar contrase√±a‚Äù.

   - No env√≠a correos reales: valida m√≠nimamente el email, muestra un mensaje
     de confirmaci√≥n y luego redirige de vuelta al login.

   - Toda la parte visual (fondo, caja central, colores de alerta, etc.)
     se define en el archivo de estilos `recuperarContrase√±a.css`.

1) Imports y setup b√°sico

   import { useState } from "react";
   import { Link, useNavigate } from "react-router-dom";
   import "./recuperarContrase√±a.css";

   - useState:
       ‚Ä¢ se usa para manejar el email escrito por el usuario y la estructura
         de alerta (mensaje + tipo).

   - useNavigate:
       ‚Ä¢ permite redirigir program√°ticamente a otra ruta (en este caso, al
         inicio de sesi√≥n "/").

   - El CSS asociado encapsula el look & feel de esta pantalla (fondo difuminado,
     caja centrada, tama√±os de fuente, colores de botones, etc.).

2) Estado interno del componente

   const [email, setEmail] = useState("");
   const [alerta, setAlerta] = useState({ mensaje: "", tipo: "" });

   - email:
       ‚Ä¢ refleja el contenido del input de texto donde el usuario escribe
         su direcci√≥n de correo.
       ‚Ä¢ se actualiza en cada pulsaci√≥n mediante onChange.

   - alerta:
       ‚Ä¢ es un objeto con dos propiedades:
           - mensaje: texto que se muestra al usuario (por ejemplo,
             ‚ÄúPor favor escrib√≠ tu email‚Äù, ‚ÄúListo! Te enviamos un enlace a ...‚Äù).
           - tipo: ‚Äúexito‚Äù o ‚Äúerror‚Äù, que luego se usa como sufijo en la clase
             CSS (alerta-exito / alerta-error).
       ‚Ä¢ cuando mensaje est√° vac√≠o, la alerta no se muestra en la interfaz.

3) Navegaci√≥n con useNavigate

   const navigate = useNavigate();

   - navigate:
       ‚Ä¢ funci√≥n que permite cambiar de ruta desde c√≥digo.
       ‚Ä¢ ac√° se usa para volver al login ("/") tanto desde el bot√≥n de ‚ÄúVolver‚Äù
         como despu√©s de un env√≠o exitoso del formulario.

4) Helper mostrarAlerta(mensaje, tipo)

   const mostrarAlerta = (mensaje, tipo = "exito") => {
      setAlerta({ mensaje, tipo });
      setTimeout(() => setAlerta({ mensaje: "", tipo: "" }), 5000);
   };

   - Recibe un texto y un tipo (‚Äúexito‚Äù por defecto).

   - Actualiza el estado alerta para que la UI muestre un cartel de feedback.

   - Luego de 5 segundos, limpia el estado para ocultar ese cartel
     autom√°ticamente, sin que el usuario tenga que cerrarlo.

5) Manejo del submit del formulario (handleSubmit)

   const handleSubmit = (e) => {
      e.preventDefault();
      ...
   };

   5.1) Evitar recarga de p√°gina

   - e.preventDefault() cancela el comportamiento por defecto del formulario
     (recargar la p√°gina completa).

   5.2) Validaciones b√°sicas

   - Primera validaci√≥n: campo vac√≠o
       if (!email.trim()) {
         mostrarAlerta("Por favor escrib√≠ tu email", "error");
         return;
       }

       ‚Ä¢ trim() elimina espacios al principio y al final.
       ‚Ä¢ Si el resultado queda vac√≠o, se muestra un mensaje de error pidiendo
         que el usuario escriba su email.

   - Segunda validaci√≥n: formato muy b√°sico
       if (!email.includes("@") || !email.includes(".")) {
         mostrarAlerta("El email no parece v√°lido", "error");
         return;
       }

       ‚Ä¢ No es una validaci√≥n ‚Äúreal‚Äù de RFC, s√≥lo verifica que exista ‚Äú@‚Äù
         y un punto, suficiente para un TP o demo.

   5.3) Simulaci√≥n de env√≠o y redirecci√≥n

   - Si pasa las validaciones:
       mostrarAlerta(`Listo! Te enviamos un enlace a ${email}`, "exito");

       ‚Ä¢ Se muestra un mensaje de √©xito usando el email que escribi√≥ el usuario.
       ‚Ä¢ No se hace ning√∫n request real; el env√≠o es puramente simulado.

   - Luego:
       setTimeout(() => {
         navigate("/");
       }, 3000);

       ‚Ä¢ Espera 3 segundos y redirige al login (ruta "/").
       ‚Ä¢ Da tiempo a que el usuario lea la confirmaci√≥n antes de regresar.

6) Estructura visual del componente (render)

   return (
      <div className="recuperar-fondo">
         <div className="recuperar-caja">
            ...
         </div>
      </div>
   );

   - recuperar-fondo:
       ‚Ä¢ contenedor que suele ocupar toda la pantalla, con un fondo de color
         o imagen. Centra la caja principal en el viewport.

   - recuperar-caja:
       ‚Ä¢ tarjeta o panel donde se muestra el contenido de recuperaci√≥n.

   6.1) Bot√≥n ‚ÄúVolver al inicio de sesi√≥n‚Äù

   <button
     className="btn-volver"
     onClick={() => navigate("/")}
   >
     ‚Üê Volver al inicio de sesi√≥n
   </button>

   - Permite regresar inmediatamente al login sin enviar el formulario.

   - Usa navigate("/") para cambiar de ruta.

   6.2) Logo y t√≠tulos

   <img src={logoApp} ... />
   <h2 className="h2-Recuperar">Recuperar contrase√±a</h2>
   <p className="texto-ayuda">...</p>

   - Refuerzan la identidad visual de la app y explican brevemente qu√© debe
     hacer el usuario (ingresar su email para recibir un enlace).

   6.3) Formulario de email

   <form onSubmit={handleSubmit}>
      <input
         type="text"
         placeholder="tuemail@ejemplo.com"
         value={email}
         onChange={(e) => setEmail(e.target.value)}
         className="input-recuperar"
      />
      <button type="submit" className="btn-enviar">
         Enviar enlace
      </button>
   </form>

   - El input est√° controlado por el estado email.

   - Cada pulsaci√≥n dispara setEmail con el nuevo valor.

   - Al presionar el bot√≥n ‚ÄúEnviar enlace‚Äù:
       ‚Ä¢ se dispara handleSubmit,
       ‚Ä¢ se ejecutan las validaciones,
       ‚Ä¢ se muestra la alerta adecuada,
       ‚Ä¢ eventualmente se redirige al login.

   6.4) Alerta de feedback

   {alerta.mensaje && (
      <div className={`alerta alerta-${alerta.tipo}`}>
         {alerta.mensaje}
      </div>
   )}

   - S√≥lo se renderiza si alerta.mensaje no est√° vac√≠o.
	
   - Usa dos clases:
       ‚Ä¢ alerta: estilos comunes (posici√≥n, padding, borde, etc.),
       ‚Ä¢ alerta-{tipo}: variaciones seg√∫n ‚Äúexito‚Äù o ‚Äúerror‚Äù
         (colores verde/rojo, iconos distintos, etc.).

7) Resumen conceptual

   - Este componente representa un paso ‚Äúligero‚Äù de recuperaci√≥n de contrase√±a:
       ‚Ä¢ Comprueba que el usuario introduzca un email con un formato m√≠nimo.
       ‚Ä¢ Muestra un mensaje de feedback claro (√©xito o error).
       ‚Ä¢ No gestiona credenciales reales ni integra un backend de correo,
         sino que sirve como maqueta funcional para el flujo de UX.

   - Su responsabilidad se limita a:
       ‚Ä¢ controlar el estado del input,
       ‚Ä¢ validar ese estado,
       ‚Ä¢ mostrar feedback al usuario,
       ‚Ä¢ decidir cu√°ndo y ad√≥nde navegar.
---------------------------------------------------------------------------*/
// ===== ./src/paginas/PaginaRegistro/PaginaRegistro.css =====

/* src/paginas/PaginaRegistro/PaginaRegistro.css */
/*
   NOTA SOBRE ESTE ARCHIVO (PaginaRegistro.css)
   - Extiende los estilos de PaginaLogin.css para adaptar el panel celeste
     a la pantalla de registro (m√°s compacto y con t√≠tulos/labels propios).

   - Ajusta tama√±os y m√°rgenes de `titulo-registro`, `label-registro` e `input`
     para que el formulario de registro se vea m√°s denso que el login.

   - Posiciona el bot√≥n `.btn-volver` dentro del padding de `.derecha`, en la
     esquina superior izquierda del panel.
	  
   - Define el estilo de los mensajes de error (`.error-text`) que se muestran
     debajo de cada input, incluyendo el asterisco autom√°tico con `::before`.
*/

/* Estilos espec√≠ficos de la pantalla de registro */

/* T√≠tulo "REGISTRO" */
.registro-page .titulo-registro {
	text-align: center;
	color: #ffffff;
	font-size: 30px;
	margin: 8px 0 16px;
}

/* Labels de campos (Nombre completo, Usuario, etc.) */
.registro-page .label-registro {
	text-align: left;
	color: #ffffff;
	font-size: 22px;          /* un poco m√°s chico */
	margin: 10px 0 2px 0;     /* menos espacio vertical */
}

/* Panel celeste un poco m√°s compacto en REGISTRO */
.registro-page .derecha {
	position: relative;
	padding: 24px 32px 24px;  /* antes 40px */
	margin: 10px;             /* menos margen vertical */
}

.registro-page .input {
	padding: 14px 16px;       /* antes 18px 20px */
	margin-bottom: 10px;      /* menos separaci√≥n entre campos */
}

.registro-page .acciones {
	margin-top: 20px;         /* antes 38px */
	align-items: center;
}

/* Bot√≥n volver colocado en el √°rea del padding de .derecha */
.registro-page .btn-volver {
  position: absolute;
  top: 24px;     /* el mismo padding-top que se usa en .derecha */
  left: 32px;    /* el mismo padding-left que se usa en .derecha */

  padding: 8px 20px;
  border-radius: 999px;
  border: none;
  background-color: rgba(0, 0, 0, 0.35);
  color: #ffffff;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.15s ease, transform 0.1s ease;
}

.registro-page .btn-volver:hover {
  background-color: rgba(0, 0, 0, 0.55);
  transform: translateY(-1px);
}

/* Texto de error debajo del campo */
.registro-page .error-text {
  color: #9c0a0a;        /* rojo m√°s intenso */
  font-size: 16px;
  font-weight: 500;
  margin: 4px 0 0 4px;
}

/* Agrega un * delante del mensaje */
.registro-page .error-text::before {
  content: "* ";
  font-weight: bold;
}

/* === VISTA MOBILE PARA REGISTRO === */
@media (max-width: 768px) {
	/* En m√≥vil, ocultar el logo para dar m√°s espacio al formulario */
	form.registro-page .container .izquierda {
		display: none !important;
	}

	/* Panel celeste ocupa toda la pantalla sin espacio para logo */
	form.registro-page .container .derecha {
		padding: 60px 20px 32px;
		margin: 0;
		border-radius: 0;
	}

	/* Bot√≥n volver ajustado para m√≥vil */
	.registro-page .btn-volver {
		top: 16px;
		left: 20px;
		padding: 6px 16px;
		font-size: 14px;
	}

	/* T√≠tulo m√°s peque√±o */
	.registro-page .titulo-registro {
		font-size: 24px;
		margin: 0 0 12px;
	}

	/* Labels m√°s compactos */
	.registro-page .label-registro {
		font-size: 18px;
		margin: 8px 0 2px 0;
	}

	/* Inputs m√°s compactos */
	.registro-page .input {
		padding: 12px 14px;
		font-size: 15px;
		margin-bottom: 4px;
	}

	/* Acciones con menos margen */
	.registro-page .acciones {
		margin-top: 16px;
	}

	/* Bot√≥n crear cuenta */
	.registro-page .boton {
		margin-top: 16px;
		padding: 10px 18px;
		font-size: 18px;
	}

	/* Error text m√°s peque√±o */
	.registro-page .error-text {
		font-size: 13px;
	}
}

// ===== ./src/paginas/PaginaRegistro/PaginaRegistro.jsx =====

// src/paginas/PaginaRegistro/PaginaRegistro.jsx

import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../contextos/AuthContext";
import "../PaginaLogin/PaginaLogin.css";
import "./PaginaRegistro.css";
import logoApp from "../../assets/imagenes/logo 2 rw.png";

const PaginaRegistro = () => {
  const [nombre, setNombre] = useState("");
  const [email, setEmail] = useState("");
  const [contrasena, setContrasena] = useState("");
  const [confirmar, setConfirmar] = useState("");
  const [errores, setErrores] = useState({});
  const [alerta, setAlerta] = useState({ mensaje: "", tipo: "" });
  const [cargando, setCargando] = useState(false);

  const { registro } = useAuth();
  const navigate = useNavigate();

  // Mostrar alerta temporal
  const mostrarAlerta = (mensaje, tipo = "error") => {
    setAlerta({ mensaje, tipo });
    setTimeout(() => {
      setAlerta({ mensaje: "", tipo: "" });
    }, 5000);
  };

  // Validaci√≥n por campo
  const validarCampo = (campo) => {
    let mensaje = "";

    switch (campo) {
      case "nombre":
        if (!nombre.trim()) {
          mensaje = "El nombre es obligatorio.";
        } else if (nombre.trim().length < 3) {
          mensaje = "El nombre debe tener al menos 3 caracteres.";
        }
        break;

      case "email":
        if (!email.trim()) {
          mensaje = "El email es obligatorio.";
        } else {
          const regexEmail = /^\S+@\S+\.\S+$/;
          if (!regexEmail.test(email)) {
            mensaje = "El formato de email no es v√°lido.";
          }
        }
        break;

      case "contrasena":
        if (!contrasena) {
          mensaje = "La contrase√±a es obligatoria.";
        } else if (contrasena.length < 6) {
          mensaje = "La contrase√±a debe tener al menos 6 caracteres.";
        }
        break;

      case "confirmar":
        if (!confirmar) {
          mensaje = "Debes confirmar la contrase√±a.";
        } else if (confirmar !== contrasena) {
          mensaje = "Las contrase√±as no coinciden.";
        }
        break;

      default:
        break;
    }

    setErrores((prev) => {
      const next = { ...prev };
      if (mensaje) {
        next[campo] = mensaje;
      } else {
        delete next[campo];
      }
      return next;
    });

    return mensaje;
  };

  // Validaci√≥n al salir de cada input
  const handleBlur = (campo) => {
    validarCampo(campo);
  };

  // Validaci√≥n global del formulario
  const validarTodo = () => {
    const campos = ["nombre", "email", "contrasena", "confirmar"];
    const mensajes = campos.map((c) => validarCampo(c));
    return mensajes.every((m) => m === "");
  };

  // Env√≠o del formulario
  const handleSubmit = async (event) => {
    event.preventDefault();

    if (!validarTodo()) {
      return;
    }

    setCargando(true);

    const { exito, error, requiereConfirmacion } = await registro(
      email.trim().toLowerCase(),
      contrasena,
      nombre.trim()
    );

    setCargando(false);

    if (!exito) {
      mostrarAlerta(error || "Error al crear la cuenta", "error");
      return;
    }

    if (requiereConfirmacion) {
      mostrarAlerta(
        "¬°Cuenta creada! Revisa tu email para confirmar tu cuenta antes de iniciar sesi√≥n.",
        "exito"
      );
    } else {
      mostrarAlerta("¬°Cuenta creada con √©xito!", "exito");
    }

    // Limpiar formulario
    setNombre("");
    setEmail("");
    setContrasena("");
    setConfirmar("");
    setErrores({});

    // Volver al login despu√©s de un momento
    setTimeout(() => {
      navigate("/");
    }, 3000);
  };

  // Bot√≥n "Volver"
  const handleVolver = () => {
    navigate("/");
  };

  return (
    <form onSubmit={handleSubmit} className="login-form registro-page">
      <div className="container">
        <div className="izquierda">
          <img
            src={logoApp}
            alt="logoApp"
            className="logo"
          />
        </div>

        <div className="derecha">
          <div className="login">
            <button
              type="button"
              className="btn-volver"
              onClick={handleVolver}
              disabled={cargando}
            >
              ‚Üê Volver
            </button>

            <h2 className="titulo-registro">REGISTRO</h2>

            <h3 className="label-registro">Nombre completo</h3>
            <input
              className={`input ${errores.nombre ? "input-error" : ""}`}
              type="text"
              placeholder="Ingrese su nombre"
              value={nombre}
              onChange={(e) => setNombre(e.target.value)}
              onBlur={() => handleBlur("nombre")}
              disabled={cargando}
            />
            {errores.nombre && (
              <p className="error-text">{errores.nombre}</p>
            )}

            <h3 className="label-registro">Email</h3>
            <input
              className={`input ${errores.email ? "input-error" : ""}`}
              type="email"
              placeholder="Ingrese su email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              onBlur={() => handleBlur("email")}
              disabled={cargando}
            />
            {errores.email && (
              <p className="error-text">{errores.email}</p>
            )}

            <h3 className="label-registro">Contrase√±a</h3>
            <input
              className={`input ${errores.contrasena ? "input-error" : ""}`}
              type="password"
              placeholder="Ingrese su contrase√±a (m√≠n. 6 caracteres)"
              value={contrasena}
              onChange={(e) => setContrasena(e.target.value)}
              onBlur={() => handleBlur("contrasena")}
              disabled={cargando}
            />
            {errores.contrasena && (
              <p className="error-text">{errores.contrasena}</p>
            )}

            <h3 className="label-registro">Confirmar contrase√±a</h3>
            <input
              className={`input ${errores.confirmar ? "input-error" : ""}`}
              type="password"
              placeholder="Repita su contrase√±a"
              value={confirmar}
              onChange={(e) => setConfirmar(e.target.value)}
              onBlur={() => handleBlur("confirmar")}
              disabled={cargando}
            />
            {errores.confirmar && (
              <p className="error-text">{errores.confirmar}</p>
            )}

            <div className="acciones">
              <button
                type="submit"
                className="boton"
                disabled={cargando}
              >
                {cargando ? "Creando cuenta..." : "Crear cuenta"}
              </button>
            </div>
          </div>
        </div>
      </div>

      {alerta.mensaje && (
        <div className={`alerta alerta-${alerta.tipo}`}>
          {alerta.mensaje}
        </div>
      )}
    </form>
  );
};

export default PaginaRegistro;

// ===== ./src/servicios/apiService.js =====

// src/servicios/apiService.js
// Servicio para comunicaci√≥n con el backend API

import { supabase } from '../lib/supabase';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

/**
 * Obtiene el token de autenticaci√≥n actual
 */
async function obtenerToken() {
  const { data: { session } } = await supabase.auth.getSession();
  return session?.access_token || null;
}

/**
 * Realiza una petici√≥n al backend con autenticaci√≥n
 */
async function fetchConAuth(endpoint, opciones = {}) {
  const token = await obtenerToken();

  if (!token) {
    throw new Error('No hay sesi√≥n activa');
  }

  const respuesta = await fetch(`${API_URL}${endpoint}`, {
    ...opciones,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
      ...opciones.headers,
    },
  });

  const datos = await respuesta.json();

  if (!respuesta.ok) {
    throw new Error(datos.error || 'Error en la petici√≥n');
  }

  return datos;
}

// ============================================
// USUARIOS
// ============================================

/**
 * Obtiene el perfil del usuario autenticado (incluye rol global)
 */
export async function obtenerPerfil() {
  return fetchConAuth('/api/usuarios/perfil');
}

/**
 * Crea el perfil del usuario despu√©s del registro en Supabase Auth
 * Se debe llamar inmediatamente despu√©s de signUp exitoso
 * @param {string} nombre - Nombre del usuario
 */
export async function crearPerfilUsuario(nombre) {
  return fetchConAuth('/api/usuarios/perfil', {
    method: 'POST',
    body: JSON.stringify({ nombre }),
  });
}

/**
 * Actualiza el workspace por defecto del usuario
 * @param {string|null} workspaceId - ID del workspace o null para quitar el default
 */
export async function actualizarWorkspaceDefault(workspaceId) {
  return fetchConAuth('/api/usuarios/workspace-default', {
    method: 'PUT',
    body: JSON.stringify({ workspaceId }),
  });
}

// ============================================
// WORKSPACES
// ============================================

/**
 * Obtiene todos los workspaces del usuario
 */
export async function obtenerWorkspaces() {
  return fetchConAuth('/api/workspaces');
}

/**
 * Crea un nuevo workspace
 */
export async function crearWorkspace(nombre, descripcion = '') {
  return fetchConAuth('/api/workspaces', {
    method: 'POST',
    body: JSON.stringify({ nombre, descripcion }),
  });
}

/**
 * Actualiza un workspace
 */
export async function actualizarWorkspace(id, datos) {
  return fetchConAuth(`/api/workspaces/${id}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un workspace
 */
export async function eliminarWorkspace(id) {
  return fetchConAuth(`/api/workspaces/${id}`, {
    method: 'DELETE',
  });
}

// ============================================
// PUESTOS
// ============================================

/**
 * Obtiene los puestos de un workspace
 */
export async function obtenerPuestos(workspaceId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/puestos`);
}

/**
 * Crea un nuevo puesto
 */
export async function crearPuesto(workspaceId, datos) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/puestos`, {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

/**
 * Actualiza un puesto
 */
export async function actualizarPuesto(puestoId, datos) {
  return fetchConAuth(`/api/puestos/${puestoId}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un puesto
 */
export async function eliminarPuesto(puestoId) {
  return fetchConAuth(`/api/puestos/${puestoId}`, {
    method: 'DELETE',
  });
}

/**
 * Reordena los puestos
 */
export async function reordenarPuestos(workspaceId, ordenIds) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/puestos/reordenar`, {
    method: 'PUT',
    body: JSON.stringify({ orden: ordenIds }),
  });
}

// ============================================
// ALIMENTADORES
// ============================================

/**
 * Obtiene los alimentadores de un puesto
 */
export async function obtenerAlimentadores(puestoId) {
  return fetchConAuth(`/api/puestos/${puestoId}/alimentadores`);
}

/**
 * Crea un nuevo alimentador
 */
export async function crearAlimentador(puestoId, datos) {
  return fetchConAuth(`/api/puestos/${puestoId}/alimentadores`, {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

/**
 * Actualiza un alimentador
 */
export async function actualizarAlimentadorAPI(alimentadorId, datos) {
  return fetchConAuth(`/api/alimentadores/${alimentadorId}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un alimentador
 */
export async function eliminarAlimentadorAPI(alimentadorId) {
  return fetchConAuth(`/api/alimentadores/${alimentadorId}`, {
    method: 'DELETE',
  });
}

/**
 * Reordena los alimentadores de un puesto
 * @param {number} puestoId - ID del puesto
 * @param {number[]} ordenIds - Array de IDs de alimentadores en el nuevo orden
 */
export async function reordenarAlimentadores(puestoId, ordenIds) {
  // El backend espera { ordenes: [{ id, orden }, ...] }
  const ordenes = ordenIds.map((id, index) => ({ id, orden: index }));

  return fetchConAuth(`/api/puestos/${puestoId}/alimentadores/reordenar`, {
    method: 'PUT',
    body: JSON.stringify({ ordenes }),
  });
}

/**
 * Mueve un alimentador a otro puesto
 */
export async function moverAlimentador(alimentadorId, nuevoPuestoId) {
  return fetchConAuth(`/api/alimentadores/${alimentadorId}/mover`, {
    method: 'PUT',
    body: JSON.stringify({ nuevo_puesto_id: nuevoPuestoId }),
  });
}

// ============================================
// LECTURAS
// ============================================

/**
 * Obtiene las √∫ltimas lecturas de un alimentador
 */
export async function obtenerUltimasLecturas(alimentadorId, tipo = null, limite = 1) {
  let url = `/api/alimentadores/${alimentadorId}/lecturas?limite=${limite}`;
  if (tipo) {
    url += `&tipo=${tipo}`;
  }
  return fetchConAuth(url);
}

/**
 * Obtiene lecturas hist√≥ricas de un alimentador
 */
export async function obtenerLecturasHistoricas(alimentadorId, desde, hasta, tipo = null) {
  let url = `/api/alimentadores/${alimentadorId}/lecturas/historico?desde=${desde}&hasta=${hasta}`;
  if (tipo) {
    url += `&tipo=${tipo}`;
  }
  return fetchConAuth(url);
}

/**
 * Obtiene las √∫ltimas lecturas de un registrador
 * @param {string} registradorId - ID del registrador
 * @param {number} limite - Cantidad de lecturas a obtener (default 1)
 */
export async function obtenerUltimasLecturasPorRegistrador(registradorId, limite = 1) {
  return fetchConAuth(`/api/registradores/${registradorId}/lecturas?limite=${limite}`);
}

/**
 * Obtiene lecturas hist√≥ricas de un registrador en un rango de tiempo
 * @param {string} registradorId - ID del registrador
 * @param {string} desde - Fecha ISO de inicio del rango
 * @param {string} hasta - Fecha ISO de fin del rango
 * @returns {Promise<Array>} Array de lecturas con indice_inicial incluido
 */
export async function obtenerLecturasHistoricasPorRegistrador(registradorId, desde, hasta) {
  return fetchConAuth(`/api/registradores/${registradorId}/lecturas/historico?desde=${desde}&hasta=${hasta}`);
}

// ============================================
// PREFERENCIAS
// ============================================

/**
 * Obtiene las preferencias del usuario para un workspace
 */
export async function obtenerPreferencias(workspaceId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/preferencias`);
}

/**
 * Guarda las preferencias del usuario
 */
export async function guardarPreferencias(workspaceId, preferencias) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/preferencias`, {
    method: 'POST',
    body: JSON.stringify(preferencias),
  });
}

// ============================================
// AGENTES (Legacy - mantener por compatibilidad)
// ============================================

/**
 * Obtiene el estado de vinculaci√≥n del workspace con un agente
 * @deprecated Usar listarAgentesWorkspace
 */
export async function obtenerEstadoAgente(workspaceId) {
  return fetchConAuth(`/api/agentes/estado?workspaceId=${workspaceId}`);
}

/**
 * Solicita un c√≥digo de vinculaci√≥n para conectar el workspace con un agente
 * @deprecated Usar vincularAgenteWorkspace
 */
export async function solicitarVinculacionAgente(workspaceId) {
  return fetchConAuth('/api/agentes/solicitar-vinculacion', {
    method: 'POST',
    body: JSON.stringify({ workspaceId }),
  });
}

/**
 * Desvincula el agente del workspace
 * @deprecated Usar desvincularAgenteWorkspace
 */
export async function desvincularAgente(workspaceId) {
  return fetchConAuth('/api/agentes/desvincular', {
    method: 'POST',
    body: JSON.stringify({ workspaceId }),
  });
}

/**
 * Rota la clave del agente (genera nueva, mantiene anterior por 24h)
 * @deprecated Usar rotarClaveAgentePorId
 */
export async function rotarClaveAgente(workspaceId) {
  return fetchConAuth('/api/agentes/rotar-clave', {
    method: 'POST',
    body: JSON.stringify({ workspaceId }),
  });
}

// ============================================
// AGENTES (Nueva arquitectura N:M)
// ============================================

// --- Panel Admin (solo superadmin) ---

/**
 * Lista todos los agentes del sistema (solo superadmin)
 */
export async function listarTodosLosAgentes() {
  return fetchConAuth('/api/admin/agentes');
}

/**
 * Crea un nuevo agente (solo superadmin)
 */
export async function crearAgente(nombre, descripcion = '') {
  return fetchConAuth('/api/admin/agentes', {
    method: 'POST',
    body: JSON.stringify({ nombre, descripcion }),
  });
}

/**
 * Actualiza un agente (solo superadmin)
 */
export async function actualizarAgente(agenteId, datos) {
  return fetchConAuth(`/api/admin/agentes/${agenteId}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un agente (solo superadmin)
 */
export async function eliminarAgente(agenteId) {
  return fetchConAuth(`/api/admin/agentes/${agenteId}`, {
    method: 'DELETE',
  });
}

/**
 * Rota la clave de un agente (solo superadmin)
 */
export async function rotarClaveAgentePorId(agenteId) {
  return fetchConAuth(`/api/admin/agentes/${agenteId}/rotar-clave`, {
    method: 'POST',
  });
}

// --- Agentes disponibles (admin+) ---

/**
 * Lista agentes disponibles para vincular (admin+)
 */
export async function listarAgentesDisponibles() {
  return fetchConAuth('/api/agentes/disponibles');
}

// --- Vinculaci√≥n workspace-agente (N:M) ---

/**
 * Lista agentes vinculados a un workspace
 */
export async function listarAgentesWorkspace(workspaceId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/agentes`);
}

/**
 * Vincula un agente a un workspace (admin+)
 */
export async function vincularAgenteWorkspace(workspaceId, agenteId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/agentes`, {
    method: 'POST',
    body: JSON.stringify({ agenteId }),
  });
}

/**
 * Desvincula un agente de un workspace (admin+)
 */
export async function desvincularAgenteWorkspace(workspaceId, agenteId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/agentes/${agenteId}`, {
    method: 'DELETE',
  });
}

// --- Registradores de un agente (solo superadmin) ---

/**
 * Lista registradores de un agente espec√≠fico
 */
export async function listarRegistradoresAgente(agenteId) {
  return fetchConAuth(`/api/agentes/${agenteId}/registradores`);
}

/**
 * Crea un registrador para un agente (solo superadmin)
 */
export async function crearRegistradorAgente(agenteId, datos) {
  return fetchConAuth(`/api/agentes/${agenteId}/registradores`, {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

/**
 * Actualiza un registrador de un agente (solo superadmin)
 */
export async function actualizarRegistradorAgente(agenteId, registradorId, datos) {
  return fetchConAuth(`/api/agentes/${agenteId}/registradores/${registradorId}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un registrador de un agente (solo superadmin)
 */
export async function eliminarRegistradorAgente(agenteId, registradorId) {
  return fetchConAuth(`/api/agentes/${agenteId}/registradores/${registradorId}`, {
    method: 'DELETE',
  });
}

/**
 * Toggle activo de un registrador (solo superadmin)
 */
export async function toggleRegistradorAgente(agenteId, registradorId) {
  return fetchConAuth(`/api/agentes/${agenteId}/registradores/${registradorId}/toggle`, {
    method: 'POST',
  });
}

/**
 * Solicita un test de conexi√≥n para un registrador (ejecutado por el agente)
 * @param {string} agenteId - ID del agente que ejecutar√° el test
 * @param {object} datos - Datos del test: ip, puerto, unitId, indiceInicial, cantidadRegistros
 * @returns {Promise<{testId: string, mensaje: string, timeoutSegundos: number}>}
 */
export async function solicitarTestRegistrador(agenteId, datos) {
  return fetchConAuth(`/api/agentes/${agenteId}/test-registrador`, {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

/**
 * Consulta el estado/resultado de un test de registrador
 * @param {string} agenteId - ID del agente
 * @param {string} testId - ID del test
 * @returns {Promise<{estado: string, valores?: number[], error_mensaje?: string, tiempo_respuesta_ms?: number}>}
 */
export async function consultarTestRegistrador(agenteId, testId) {
  return fetchConAuth(`/api/agentes/${agenteId}/test-registrador/${testId}`);
}

/**
 * Solicita un test de lectura de coils (Modbus funci√≥n 01)
 * Para leer estados de protecciones como bits individuales
 * @param {string} agenteId - ID del agente que ejecutar√° el test
 * @param {object} datos - Datos del test: ip, puerto, unitId, direccionCoil, cantidadBits
 * @returns {Promise<{testId: string, mensaje: string, timeoutSegundos: number}>}
 */
export async function solicitarTestCoils(agenteId, datos) {
  return fetchConAuth(`/api/agentes/${agenteId}/test-coils`, {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

// ============================================
// TEST DE CONEXI√ìN MODBUS
// ============================================

/**
 * Prueba la conexi√≥n a un dispositivo Modbus y lee registros
 * @param {string} ip - Direcci√≥n IP del dispositivo
 * @param {number} puerto - Puerto Modbus (usualmente 502)
 * @param {number} unitId - ID de unidad Modbus (por defecto 1)
 * @param {number} indiceInicial - Primer registro a leer (por defecto 0)
 * @param {number} cantRegistros - Cantidad de registros a leer (por defecto 10)
 * @returns {Promise<{exito: boolean, mensaje?: string, error?: string, registros?: Array, tiempoMs?: number}>}
 */
export async function testConexionModbus(ip, puerto, unitId = 1, indiceInicial = 0, cantRegistros = 10) {
  return fetchConAuth('/api/test-conexion', {
    method: 'POST',
    body: JSON.stringify({ ip, puerto, unitId, indiceInicial, cantRegistros }),
  });
}

// ============================================
// REGISTRADORES
// ============================================

/**
 * Obtiene los registradores del workspace
 */
export async function obtenerRegistradores(workspaceId) {
  return fetchConAuth(`/api/registradores?workspaceId=${workspaceId}`);
}

/**
 * Crea un nuevo registrador
 */
export async function crearRegistrador(datos) {
  return fetchConAuth('/api/registradores', {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

/**
 * Actualiza un registrador
 */
export async function actualizarRegistrador(registradorId, datos) {
  return fetchConAuth(`/api/registradores/${registradorId}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un registrador
 */
export async function eliminarRegistrador(registradorId, workspaceId) {
  return fetchConAuth(`/api/registradores/${registradorId}?workspaceId=${workspaceId}`, {
    method: 'DELETE',
  });
}

/**
 * Activa o desactiva la medici√≥n de un registrador
 */
export async function toggleActivoRegistrador(registradorId, workspaceId, activo) {
  return fetchConAuth(`/api/registradores/${registradorId}/toggle-activo`, {
    method: 'POST',
    body: JSON.stringify({ workspaceId, activo }),
  });
}

/**
 * Prueba la conexi√≥n Modbus de un registrador
 */
export async function testConexionRegistrador(ip, puerto, indiceInicial, cantidadRegistros, unitId = 1) {
  return fetchConAuth('/api/registradores/test-conexion', {
    method: 'POST',
    body: JSON.stringify({ ip, puerto, indiceInicial, cantidadRegistros, unitId }),
  });
}

// ============================================
// ADMINISTRACI√ìN DE USUARIOS (solo superadmin)
// ============================================

/**
 * Lista todos los usuarios del sistema (excepto superadmins)
 * @returns {Promise<Array>} Lista de usuarios con sus permisos de agentes
 */
export async function listarUsuariosAdmin() {
  return fetchConAuth('/api/admin/usuarios');
}

/**
 * Cambia el rol global de un usuario
 * @param {string} usuarioId - ID del usuario
 * @param {string} rolCodigo - C√≥digo del rol ('admin', 'operador', 'observador')
 * @returns {Promise<Object>} Usuario actualizado
 */
export async function cambiarRolUsuarioAdmin(usuarioId, rolCodigo) {
  return fetchConAuth(`/api/admin/usuarios/${usuarioId}/rol`, {
    method: 'PUT',
    body: JSON.stringify({ rolCodigo }),
  });
}

/**
 * Actualiza los agentes a los que un usuario tiene acceso
 * @param {string} usuarioId - ID del usuario
 * @param {boolean} accesoTotal - Si es true, tiene acceso a todos los agentes
 * @param {string[]} agentesIds - Array de IDs de agentes (ignorado si accesoTotal es true)
 * @returns {Promise<Object>} Permisos actualizados
 */
export async function actualizarAgentesUsuarioAdmin(usuarioId, accesoTotal, agentesIds = []) {
  return fetchConAuth(`/api/admin/usuarios/${usuarioId}/agentes`, {
    method: 'PUT',
    body: JSON.stringify({ accesoTotal, agentesIds }),
  });
}

/**
 * Lista todos los agentes disponibles para asignar permisos
 * @returns {Promise<Array>} Lista de agentes con id, nombre y activo
 */
export async function listarAgentesParaPermisos() {
  return fetchConAuth('/api/admin/agentes-disponibles');
}

/**
 * Obtiene detalles completos de un usuario (workspaces, puestos, agentes, invitados)
 * @param {string} usuarioId - ID del usuario
 * @returns {Promise<Object>} Detalles del usuario con workspaces propios e invitado
 */
export async function obtenerDetallesUsuarioAdmin(usuarioId) {
  return fetchConAuth(`/api/admin/usuarios/${usuarioId}/detalles`);
}

// ============================================
// DISPOSITIVOS (Push Notifications)
// ============================================

/**
 * Registra el token FCM del dispositivo para recibir push notifications
 * @param {string} fcmToken - Token FCM del dispositivo
 * @param {string} plataforma - Plataforma del dispositivo ('android' o 'ios')
 * @returns {Promise<Object>} Dispositivo registrado
 */
export async function registrarTokenDispositivo(fcmToken, plataforma = 'android') {
  return fetchConAuth('/api/dispositivos/registrar', {
    method: 'POST',
    body: JSON.stringify({ fcmToken, plataforma }),
  });
}

/**
 * Desregistra el token FCM del dispositivo
 * @param {string} fcmToken - Token FCM a desregistrar
 * @returns {Promise<Object>} Confirmaci√≥n
 */
export async function desregistrarTokenDispositivo(fcmToken) {
  return fetchConAuth('/api/dispositivos/desregistrar', {
    method: 'DELETE',
    body: JSON.stringify({ fcmToken }),
  });
}

// ============================================
// PERMISOS DE WORKSPACE
// ============================================

/**
 * Obtiene los usuarios con acceso a un workspace
 * @param {string} workspaceId - ID del workspace
 * @returns {Promise<Array>} Lista de permisos con datos de usuario y rol
 */
export async function obtenerPermisosWorkspace(workspaceId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/permisos`);
}

/**
 * Invita/agrega un usuario a un workspace
 * @param {string} workspaceId - ID del workspace
 * @param {string} email - Email del usuario a invitar
 * @param {string} rol - Rol a asignar ('observador', 'operador', 'admin')
 * @returns {Promise<Object>} Permiso creado
 */
export async function agregarPermisoWorkspace(workspaceId, email, rol) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/permisos`, {
    method: 'POST',
    body: JSON.stringify({ email, rol }),
  });
}

/**
 * Actualiza el rol de un usuario en un workspace
 * @param {string} permisoId - ID del permiso a actualizar
 * @param {string} rol - Nuevo rol ('observador', 'operador', 'admin')
 * @returns {Promise<Object>} Permiso actualizado
 */
export async function actualizarPermisoWorkspace(permisoId, rol) {
  return fetchConAuth(`/api/permisos/${permisoId}`, {
    method: 'PUT',
    body: JSON.stringify({ rol }),
  });
}

/**
 * Elimina el acceso de un usuario a un workspace
 * @param {string} permisoId - ID del permiso a eliminar
 * @returns {Promise<Object>} Mensaje de confirmaci√≥n
 */
export async function eliminarPermisoWorkspace(permisoId) {
  return fetchConAuth(`/api/permisos/${permisoId}`, {
    method: 'DELETE',
  });
}

export default {
  // Usuarios
  obtenerPerfil,
  crearPerfilUsuario,
  actualizarWorkspaceDefault,
  // Workspaces
  obtenerWorkspaces,
  crearWorkspace,
  actualizarWorkspace,
  eliminarWorkspace,
  // Puestos
  obtenerPuestos,
  crearPuesto,
  actualizarPuesto,
  eliminarPuesto,
  reordenarPuestos,
  // Alimentadores
  obtenerAlimentadores,
  crearAlimentador,
  actualizarAlimentadorAPI,
  eliminarAlimentadorAPI,
  reordenarAlimentadores,
  moverAlimentador,
  // Lecturas
  obtenerUltimasLecturas,
  obtenerLecturasHistoricas,
  obtenerUltimasLecturasPorRegistrador,
  obtenerLecturasHistoricasPorRegistrador,
  // Preferencias
  obtenerPreferencias,
  guardarPreferencias,
  // Agentes (legacy)
  obtenerEstadoAgente,
  solicitarVinculacionAgente,
  desvincularAgente,
  rotarClaveAgente,
  // Agentes (nueva arquitectura)
  listarTodosLosAgentes,
  crearAgente,
  actualizarAgente,
  eliminarAgente,
  rotarClaveAgentePorId,
  listarAgentesDisponibles,
  listarAgentesWorkspace,
  vincularAgenteWorkspace,
  desvincularAgenteWorkspace,
  listarRegistradoresAgente,
  crearRegistradorAgente,
  actualizarRegistradorAgente,
  eliminarRegistradorAgente,
  toggleRegistradorAgente,
  solicitarTestRegistrador,
  consultarTestRegistrador,
  solicitarTestCoils,
  // Test conexi√≥n Modbus
  testConexionModbus,
  // Registradores
  obtenerRegistradores,
  crearRegistrador,
  actualizarRegistrador,
  eliminarRegistrador,
  toggleActivoRegistrador,
  testConexionRegistrador,
  // Permisos de workspace
  obtenerPermisosWorkspace,
  agregarPermisoWorkspace,
  actualizarPermisoWorkspace,
  eliminarPermisoWorkspace,
  // Administraci√≥n de usuarios (superadmin)
  listarUsuariosAdmin,
  cambiarRolUsuarioAdmin,
  actualizarAgentesUsuarioAdmin,
  listarAgentesParaPermisos,
  obtenerDetallesUsuarioAdmin,
  // Dispositivos (Push Notifications)
  registrarTokenDispositivo,
  desregistrarTokenDispositivo,
};

// ===== ./src/servicios/authService.js =====

// src/servicios/authService.js
// Servicio de autenticaci√≥n usando Supabase
// NOTA: Las operaciones de supabase.auth.* van directas a Supabase (correcto)
//       Los datos de usuario van por el backend (crearPerfilUsuario, obtenerPerfil)

import { supabase } from '../lib/supabase';
import { crearPerfilUsuario, obtenerPerfil } from './apiService';

/**
 * Iniciar sesi√≥n con email y contrase√±a
 * @param {string} email
 * @param {string} password
 * @returns {Promise<{user, error}>}
 */
export async function iniciarSesion(email, password) {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    return { user: null, error: traducirError(error.message) };
  }

  return { user: data.user, error: null };
}

/**
 * Registrar nuevo usuario
 * @param {string} email
 * @param {string} password
 * @param {string} nombre
 * @returns {Promise<{user, error}>}
 */
export async function registrarUsuario(email, password, nombre) {
  // 1. Crear usuario en Supabase Auth (directo - esto es correcto)
  const { data: authData, error: authError } = await supabase.auth.signUp({
    email,
    password,
    options: {
      data: {
        nombre: nombre,
      },
    },
  });

  if (authError) {
    return { user: null, error: traducirError(authError.message) };
  }

  // 2. Crear perfil en tabla usuarios VIA BACKEND
  // El backend usa SERVICE_ROLE y valida la creaci√≥n
  if (authData.user && authData.session) {
    try {
      await crearPerfilUsuario(nombre);
    } catch (dbError) {
      console.error('Error al crear perfil en DB:', dbError);
      // No retornamos error porque el usuario ya se cre√≥ en Auth
      // El backend puede crear el perfil despu√©s en obtenerPerfil
    }
  }

  return { user: authData.user, error: null };
}

/**
 * Cerrar sesi√≥n
 * Limpia tambi√©n los datos de localStorage para evitar que persistan entre usuarios
 * @returns {Promise<{error}>}
 */
export async function cerrarSesion() {
  // Limpiar datos de sesi√≥n del localStorage
  // Esto evita que al loguearse otro usuario se intente acceder a workspaces del anterior
  localStorage.removeItem('rw-configuracion-seleccionada');
  localStorage.removeItem('rw-puesto-seleccionado');
  localStorage.removeItem('rw-gap-tarjetas');
  localStorage.removeItem('rw-gap-filas');

  const { error } = await supabase.auth.signOut();
  return { error: error ? traducirError(error.message) : null };
}

/**
 * Obtener sesi√≥n actual
 * @returns {Promise<{session, user}>}
 */
export async function obtenerSesion() {
  const { data: { session } } = await supabase.auth.getSession();
  return {
    session,
    user: session?.user || null,
  };
}

/**
 * Obtener datos del usuario actual desde nuestra tabla
 * Usa el backend para obtener el perfil (incluye rol global y permisos)
 * @returns {Promise<{usuario, error}>}
 */
export async function obtenerUsuarioActual() {
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { usuario: null, error: 'No hay sesi√≥n activa' };
  }

  try {
    // Obtener perfil VIA BACKEND
    // El backend crea el usuario si no existe (auto-provisioning)
    const perfil = await obtenerPerfil();
    return { usuario: perfil, error: null };
  } catch (error) {
    return { usuario: null, error: error.message };
  }
}

/**
 * Enviar email para recuperar contrase√±a
 * @param {string} email
 * @returns {Promise<{error}>}
 */
export async function recuperarContrasena(email) {
  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${window.location.origin}/cambiar-contrasena`,
  });

  return { error: error ? traducirError(error.message) : null };
}

/**
 * Suscribirse a cambios de autenticaci√≥n
 * @param {Function} callback
 * @returns {Function} funci√≥n para desuscribirse
 */
export function suscribirseACambiosAuth(callback) {
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    (event, session) => {
      callback(event, session);
    }
  );

  return () => subscription.unsubscribe();
}

/**
 * Traducir mensajes de error de Supabase al espa√±ol
 * @param {string} mensaje
 * @returns {string}
 */
function traducirError(mensaje) {
  const traducciones = {
    'Invalid login credentials': 'Usuario o contrase√±a incorrectos',
    'Email not confirmed': 'Debes confirmar tu email antes de iniciar sesi√≥n',
    'User already registered': 'Este email ya est√° registrado',
    'Password should be at least 6 characters': 'La contrase√±a debe tener al menos 6 caracteres',
    'Unable to validate email address: invalid format': 'El formato del email no es v√°lido',
    'Email rate limit exceeded': 'Demasiados intentos. Intenta m√°s tarde',
  };

  return traducciones[mensaje] || mensaje;
}

// ===== ./src/servicios/pushNotifications.js =====

// src/servicios/pushNotifications.js
// Servicio para gestionar Push Notifications con Capacitor + Firebase

import { PushNotifications } from '@capacitor/push-notifications';
import { Capacitor } from '@capacitor/core';

/**
 * Verifica si estamos en plataforma nativa (Android/iOS)
 */
export const esPlataformaNativa = () => {
  return Capacitor.isNativePlatform();
};

/**
 * Registra el dispositivo para recibir push notifications
 * @param {Function} onTokenRecibido - Callback cuando se obtiene el token FCM
 * @param {Function} onNotificacionRecibida - Callback cuando llega una notificaci√≥n (app en primer plano)
 * @param {Function} onNotificacionTocada - Callback cuando el usuario toca la notificaci√≥n
 * @returns {Promise<boolean>} true si se registr√≥ correctamente
 */
export const registrarPushNotifications = async (
  onTokenRecibido,
  onNotificacionRecibida = null,
  onNotificacionTocada = null
) => {
  if (!esPlataformaNativa()) {
    console.log('[Push] Solo disponible en app nativa, ignorando en web');
    return null;
  }

  try {
    // Verificar/solicitar permisos
    let permStatus = await PushNotifications.checkPermissions();
    console.log('[Push] Estado de permisos:', permStatus.receive);

    if (permStatus.receive === 'prompt') {
      console.log('[Push] Solicitando permisos...');
      permStatus = await PushNotifications.requestPermissions();
    }

    if (permStatus.receive !== 'granted') {
      console.log('[Push] Permisos denegados por el usuario');
      return null;
    }

    // Registrar en FCM
    await PushNotifications.register();
    console.log('[Push] Registro en FCM iniciado');

    // Listener: Token recibido
    PushNotifications.addListener('registration', (token) => {
      console.log('[Push] Token FCM recibido:', token.value);
      if (onTokenRecibido) {
        onTokenRecibido(token.value);
      }
    });

    // Listener: Error de registro
    PushNotifications.addListener('registrationError', (error) => {
      console.error('[Push] Error en registro:', error);
    });

    // Listener: Notificaci√≥n recibida (app en primer plano)
    PushNotifications.addListener('pushNotificationReceived', (notification) => {
      console.log('[Push] Notificaci√≥n recibida:', notification);
      if (onNotificacionRecibida) {
        onNotificacionRecibida({
          titulo: notification.title,
          cuerpo: notification.body,
          datos: notification.data,
        });
      }
    });

    // Listener: Usuario toc√≥ la notificaci√≥n
    PushNotifications.addListener('pushNotificationActionPerformed', (action) => {
      console.log('[Push] Notificaci√≥n tocada:', action);
      if (onNotificacionTocada) {
        onNotificacionTocada({
          actionId: action.actionId,
          datos: action.notification.data,
        });
      }
    });

    return true;
  } catch (error) {
    console.error('[Push] Error configurando push notifications:', error);
    return null;
  }
};

/**
 * Desregistra todos los listeners de push notifications
 * Llamar al desmontar el componente principal
 */
export const desregistrarPushNotifications = async () => {
  if (!esPlataformaNativa()) return;

  try {
    await PushNotifications.removeAllListeners();
    console.log('[Push] Listeners removidos');
  } catch (error) {
    console.error('[Push] Error removiendo listeners:', error);
  }
};

/**
 * Obtiene la lista de notificaciones entregadas (en el centro de notificaciones)
 */
export const obtenerNotificacionesPendientes = async () => {
  if (!esPlataformaNativa()) return [];

  try {
    const { notifications } = await PushNotifications.getDeliveredNotifications();
    return notifications;
  } catch (error) {
    console.error('[Push] Error obteniendo notificaciones:', error);
    return [];
  }
};

/**
 * Limpia todas las notificaciones del centro de notificaciones
 */
export const limpiarNotificaciones = async () => {
  if (!esPlataformaNativa()) return;

  try {
    await PushNotifications.removeAllDeliveredNotifications();
    console.log('[Push] Notificaciones limpiadas');
  } catch (error) {
    console.error('[Push] Error limpiando notificaciones:', error);
  }
};
