========== mi-app/src/App.jsx ==========
// src/App.jsx
import React from "react";
import { Routes, Route, Navigate } from "react-router-dom";                // componentes de enrutado declarativo
import PaginaLogin from "./paginas/PaginaLogin/PaginaLogin.jsx";           // pantalla de login (ruta "/")
import PaginaRegistro from "./paginas/PaginaRegistro/PaginaRegistro.jsx";  // pantalla de registro (ruta "/registro")
import PaginaAlimentadoresSupabase from "./paginas/PaginaAlimentadores/PaginaAlimentadoresSupabase.jsx"; // panel principal conectado a Supabase
import RecuperarContrasena from "./paginas/PaginaRecuperar/recuperarContrase√±a.jsx"; // pantalla de recupero de contrase√±a (ruta "/recuperarContrase√±a")

function App() {                                         // componente ra√≠z que define el mapa de rutas
	return (
		<Routes>                                           {/* contenedor de todas las <Route> */}
			<Route                                           
				path="/"                                     
				element={<PaginaLogin />}                    // ruta principal: muestra login
			/>

			<Route                                           
				path="/registro"                            
				element={<PaginaRegistro />}                 // ruta para crear un nuevo usuario
			/>

			<Route
				path="/recuperarContrase√±a"
				element={<RecuperarContrasena/>}            // ruta para recuperar contrase√±a
			/>

			<Route
				path="/alimentadores"
				element={<PaginaAlimentadoresSupabase />}    // ruta del panel de alimentadores conectado a Supabase
			/>

			<Route                                           
				path="*"                                    
				element={<Navigate to="/" replace />}       // cualquier otra URL redirige al login
			/>
		</Routes>
	);
}

export default App;                                          // se importa en main.jsx como componente principal

// ---------------------------------------------------------------------------
// NOTA PERSONAL SOBRE ESTE ARCHIVO (App.jsx)
// - Este componente define el enrutado de alto nivel de la aplicaci√≥n.
// - Usa <Routes> y <Route> de react-router-dom para asociar paths a componentes.
// - "/" carga PaginaLogin, "/registro" carga PaginaRegistro "/recuperarContrase√±a"
//   carga RecuperarContrase√±a y "/alimentadores" muestra el panel principal 
//   donde se manejan puestos y alimentadores.
// - La √∫ltima ruta con path="*" act√∫a como catch-all: cualquier URL desconocida
//   navega autom√°ticamente a "/", evitando pantallas en blanco o errores.
// - En resumen: App.jsx es el ‚Äúswitch‚Äù de rutas que decide qu√© pantalla ver en
//   funci√≥n de la URL actual del navegador.

========== mi-app/src/componentes/comunes/ApexChartWrapper.jsx ==========
/**
 * Wrapper personalizado para ApexCharts que maneja correctamente
 * el ciclo de vida con React 18 StrictMode.
 *
 * Soluciona el problema conocido de react-apexcharts donde el doble montaje
 * de StrictMode causa errores "parentNode is null" y "Element not found".
 *
 * Usa ApexCharts directamente en lugar del wrapper react-apexcharts.
 */

import { useEffect, useRef, useImperativeHandle, forwardRef, memo } from "react";
import ApexCharts from "apexcharts";

const ApexChartWrapper = forwardRef(({ options, series, type, height, width }, ref) => {
  const containerRef = useRef(null);
  const chartInstanceRef = useRef(null);

  // Exponer el chart instance y m√©todos √∫tiles al componente padre via ref
  useImperativeHandle(ref, () => ({
    get chart() {
      return chartInstanceRef.current;
    },
    /**
     * Captura la imagen del gr√°fico con estilo optimizado para informes
     * (fondo blanco, texto negro, fuentes m√°s grandes)
     * Crea un gr√°fico temporal oculto para la captura, sin afectar el visible.
     * @param {Object} exportOptions - Opciones adicionales para dataURI
     * @returns {Promise<{imgURI: string}>} - Imagen en formato data URI
     */
    async captureForReport(exportOptions = {}) {
      const chart = chartInstanceRef.current;
      if (!chart) {
        return { imgURI: null };
      }

      // Crear un contenedor temporal oculto para el gr√°fico de exportaci√≥n
      const tempContainer = document.createElement("div");
      tempContainer.style.cssText = "position:absolute;left:-9999px;top:-9999px;width:1200px;height:600px;";
      document.body.appendChild(tempContainer);

      // Opciones optimizadas para exportaci√≥n a informe (fondo blanco, texto negro, fuentes grandes)
      const opcionesExport = {
        ...options,
        chart: {
          ...options.chart,
          id: `export-temp-${Date.now()}`,
          background: "#ffffff",
          foreColor: "#1a1a1a",
          animations: { enabled: false },
          toolbar: { show: false },
          width: 1200,
          height: 600,
        },
        states: {
          hover: { filter: { type: "none" } },
          active: { filter: { type: "none" } },
        },
        markers: {
          ...options.markers,
          hover: { size: 0 },
        },
        tooltip: { enabled: false },
        xaxis: {
          ...options.xaxis,
          crosshairs: { show: false },
          labels: {
            ...options.xaxis?.labels,
            style: {
              ...options.xaxis?.labels?.style,
              colors: "#1a1a1a",
              fontSize: "16px",
              fontWeight: 600,
            },
          },
          axisBorder: { color: "#333333", show: true },
          axisTicks: { color: "#333333", show: true },
        },
        yaxis: {
          ...options.yaxis,
          crosshairs: { show: false },
          labels: {
            ...options.yaxis?.labels,
            style: {
              ...options.yaxis?.labels?.style,
              colors: "#1a1a1a",
              fontSize: "16px",
              fontWeight: 600,
            },
          },
        },
        grid: {
          ...options.grid,
          borderColor: "#bbbbbb",
        },
      };

      let tempChart = null;
      try {
        // Crear gr√°fico temporal con las opciones de exportaci√≥n
        tempChart = new ApexCharts(tempContainer, {
          ...opcionesExport,
          series: chart.w.config.series, // Usar las series actuales
        });
        await tempChart.render();

        // Peque√±a pausa para asegurar que el gr√°fico se renderice
        await new Promise(resolve => setTimeout(resolve, 150));

        // Capturar imagen del gr√°fico temporal
        const result = await tempChart.dataURI({ scale: exportOptions.scale || 2 });

        return result;
      } catch (err) {
        console.warn("Error capturando gr√°fico para informe:", err);
        return { imgURI: null };
      } finally {
        // Limpiar: destruir gr√°fico temporal y remover contenedor
        if (tempChart) {
          try {
            tempChart.destroy();
          } catch {
            // Ignorar errores de destrucci√≥n
          }
        }
        if (tempContainer.parentNode) {
          tempContainer.parentNode.removeChild(tempContainer);
        }
      }
    }
  }), [options]);

  // Refs para valores iniciales (evita re-crear el chart cuando cambian)
  const initialOptionsRef = useRef(options);
  const initialSeriesRef = useRef(series);
  const initialTypeRef = useRef(type);
  const initialHeightRef = useRef(height);
  const initialWidthRef = useRef(width);

  // Efecto principal: crear/destruir el chart (solo al montar/desmontar)
  useEffect(() => {
    // Si no hay contenedor, salir
    if (!containerRef.current) return;

    // Limpiar cualquier chart anterior que pudiera existir
    if (chartInstanceRef.current) {
      try {
        chartInstanceRef.current.destroy();
      } catch {
        // Ignorar errores de destrucci√≥n
      }
      chartInstanceRef.current = null;
    }

    // Usar valores iniciales de los refs
    const opts = initialOptionsRef.current;
    const ser = initialSeriesRef.current;
    const t = initialTypeRef.current;
    const h = initialHeightRef.current;
    const w = initialWidthRef.current;

    // Crear configuraci√≥n completa del chart
    const chartConfig = {
      ...opts,
      chart: {
        ...opts.chart,
        type: t || opts.chart?.type || "line",
        height: h || opts.chart?.height || "100%",
        width: w || opts.chart?.width || "100%",
      },
      series: ser || [],
    };

    // Crear nueva instancia
    const chart = new ApexCharts(containerRef.current, chartConfig);
    chartInstanceRef.current = chart;

    // Renderizar el chart
    chart.render();

    // Cleanup: destruir chart cuando el componente se desmonte
    return () => {
      if (chartInstanceRef.current) {
        try {
          chartInstanceRef.current.destroy();
        } catch {
          // Ignorar errores durante cleanup
        }
        chartInstanceRef.current = null;
      }
    };
  }, []); // Solo al montar/desmontar - las actualizaciones se hacen en otros effects

  // Efecto para actualizar opciones cuando cambien
  useEffect(() => {
    if (!chartInstanceRef.current) return;

    try {
      chartInstanceRef.current.updateOptions(
        {
          ...options,
          chart: {
            ...options.chart,
            type: type || options.chart?.type || "line",
          },
        },
        false, // No redraw
        true   // Animate
      );
    } catch (e) {
      console.warn("Error actualizando opciones del chart:", e);
    }
  }, [options, type]);

  // Efecto para actualizar series cuando cambien
  useEffect(() => {
    if (!chartInstanceRef.current) return;

    try {
      chartInstanceRef.current.updateSeries(series || [], true);
    } catch (e) {
      console.warn("Error actualizando series del chart:", e);
    }
  }, [series]);

  return (
    <div
      ref={containerRef}
      style={{
        width: width || "100%",
        height: height || "100%",
        minHeight: "200px",
      }}
    />
  );
});

ApexChartWrapper.displayName = "ApexChartWrapper";

export default memo(ApexChartWrapper);

========== mi-app/src/componentes/comunes/SelectorFecha.jsx ==========
/**
 * Componente SelectorFecha - DatePicker modular reutilizable
 * Soporta selecci√≥n de d√≠a √∫nico o rango de fechas
 * Navegaci√≥n drill-down: d√≠as ‚Üí meses ‚Üí a√±os
 *
 * Modo rango:
 * - Primer click: selecciona "desde"
 * - Segundo click: selecciona "hasta" (si es despu√©s del desde) o nuevo "desde" (si es antes)
 * - Los d√≠as entre ambos se marcan con color de fondo
 */

import { useState, useRef, useEffect } from "react";
import "./SelectorFecha.css";

const SelectorFecha = ({
  value,
  onChange,
  minDate,
  maxDate,
  placeholder = "Seleccionar fecha",
  disabled = false,
  className = "",
  // Nuevas props para modo rango
  modoRango = false,
  valueHasta = null,
  onChangeRango = null, // (desde, hasta) => void
}) => {
  const [abierto, setAbierto] = useState(false);
  const [mesActual, setMesActual] = useState(() => {
    const fecha = value ? new Date(value) : new Date();
    return new Date(fecha.getFullYear(), fecha.getMonth(), 1);
  });
  // Vista actual: "dias" | "meses" | "anios"
  const [vistaActual, setVistaActual] = useState("dias");
  // Para modo rango: guardamos temporalmente el "desde" mientras se selecciona el "hasta"
  const [seleccionandoRango, setSeleccionandoRango] = useState(false);
  const contenedorRef = useRef(null);

  // Cerrar al hacer clic fuera
  useEffect(() => {
    const handleClickFuera = (e) => {
      if (contenedorRef.current && !contenedorRef.current.contains(e.target)) {
        setAbierto(false);
        setVistaActual("dias");
        // Si estaba seleccionando rango y cierra, mantener solo el desde
        if (seleccionandoRango && value && !valueHasta) {
          setSeleccionandoRango(false);
        }
      }
    };

    if (abierto) {
      document.addEventListener("mousedown", handleClickFuera);
    }

    return () => {
      document.removeEventListener("mousedown", handleClickFuera);
    };
  }, [abierto, seleccionandoRango, value, valueHasta]);

  // Actualizar mes cuando cambia el valor
  useEffect(() => {
    if (value) {
      const fecha = new Date(value);
      setMesActual(new Date(fecha.getFullYear(), fecha.getMonth(), 1));
    }
  }, [value]);

  // Reset vista cuando se abre
  useEffect(() => {
    if (abierto) {
      setVistaActual("dias");
    }
  }, [abierto]);

  const nombresMeses = [
    "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
    "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
  ];

  const nombresMesesCortos = [
    "Ene", "Feb", "Mar", "Abr", "May", "Jun",
    "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"
  ];

  const nombresDias = ["Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sa"];

  const obtenerDiasMes = (fecha) => {
    const year = fecha.getFullYear();
    const month = fecha.getMonth();
    const primerDia = new Date(year, month, 1);
    const ultimoDia = new Date(year, month + 1, 0);
    const diasEnMes = ultimoDia.getDate();
    const diaSemanaInicio = primerDia.getDay();

    const dias = [];

    // D√≠as del mes anterior
    const mesAnterior = new Date(year, month, 0);
    const diasMesAnterior = mesAnterior.getDate();
    for (let i = diaSemanaInicio - 1; i >= 0; i--) {
      dias.push({
        dia: diasMesAnterior - i,
        mesActual: false,
        fecha: new Date(year, month - 1, diasMesAnterior - i),
      });
    }

    // D√≠as del mes actual
    for (let i = 1; i <= diasEnMes; i++) {
      dias.push({
        dia: i,
        mesActual: true,
        fecha: new Date(year, month, i),
      });
    }

    // D√≠as del mes siguiente para completar la √∫ltima fila (solo si es necesario)
    const diasEnUltimaFila = dias.length % 7;
    if (diasEnUltimaFila > 0) {
      const diasRestantes = 7 - diasEnUltimaFila;
      for (let i = 1; i <= diasRestantes; i++) {
        dias.push({
          dia: i,
          mesActual: false,
          fecha: new Date(year, month + 1, i),
        });
      }
    }

    return dias;
  };

  // Obtener d√©cada actual (ej: 2020-2029)
  const obtenerDecada = (year) => {
    const inicio = Math.floor(year / 10) * 10;
    return { inicio, fin: inicio + 9 };
  };

  const irMesAnterior = () => {
    setMesActual(new Date(mesActual.getFullYear(), mesActual.getMonth() - 1, 1));
  };

  const irMesSiguiente = () => {
    setMesActual(new Date(mesActual.getFullYear(), mesActual.getMonth() + 1, 1));
  };

  const irAnioAnterior = () => {
    setMesActual(new Date(mesActual.getFullYear() - 1, mesActual.getMonth(), 1));
  };

  const irAnioSiguiente = () => {
    setMesActual(new Date(mesActual.getFullYear() + 1, mesActual.getMonth(), 1));
  };

  const irDecadaAnterior = () => {
    setMesActual(new Date(mesActual.getFullYear() - 10, mesActual.getMonth(), 1));
  };

  const irDecadaSiguiente = () => {
    setMesActual(new Date(mesActual.getFullYear() + 10, mesActual.getMonth(), 1));
  };

  const seleccionarMes = (mesIndex) => {
    setMesActual(new Date(mesActual.getFullYear(), mesIndex, 1));
    setVistaActual("dias");
  };

  const seleccionarAnio = (year) => {
    setMesActual(new Date(year, mesActual.getMonth(), 1));
    setVistaActual("meses");
  };

  const normalizarFecha = (fecha) => {
    const d = new Date(fecha);
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  };

  const compararFechas = (fecha1, fecha2) => {
    const d1 = normalizarFecha(fecha1);
    const d2 = normalizarFecha(fecha2);
    return d1.getTime() - d2.getTime();
  };

  const seleccionarDia = (dia) => {
    if (disabled) return;

    const fechaSeleccionada = dia.fecha;

    // Validar min/max
    if (minDate && fechaSeleccionada < new Date(minDate)) return;
    if (maxDate && fechaSeleccionada > new Date(maxDate)) return;

    if (modoRango && onChangeRango) {
      // Modo rango
      if (!value || (value && valueHasta)) {
        // No hay desde, o ya hay rango completo: empezar nuevo rango
        onChangeRango(fechaSeleccionada, null);
        setSeleccionandoRango(true);
      } else if (value && !valueHasta) {
        // Ya hay desde, seleccionar hasta
        const desde = new Date(value);
        if (compararFechas(fechaSeleccionada, desde) < 0) {
          // Click en fecha anterior al desde: usar como nuevo desde
          onChangeRango(fechaSeleccionada, null);
          setSeleccionandoRango(true);
        } else if (compararFechas(fechaSeleccionada, desde) === 0) {
          // Mismo d√≠a: selecci√≥n de d√≠a √∫nico
          onChangeRango(fechaSeleccionada, fechaSeleccionada);
          setSeleccionandoRango(false);
          setAbierto(false);
        } else {
          // Fecha posterior: completar rango
          onChangeRango(desde, fechaSeleccionada);
          setSeleccionandoRango(false);
          setAbierto(false);
        }
      }
    } else {
      // Modo d√≠a √∫nico
      onChange(fechaSeleccionada);
      setAbierto(false);
    }
  };

  const esDiaSeleccionado = (dia) => {
    if (!value) return false;
    return compararFechas(dia.fecha, value) === 0;
  };

  const esDiaHasta = (dia) => {
    if (!valueHasta) return false;
    return compararFechas(dia.fecha, valueHasta) === 0;
  };

  const esDiaEnRango = (dia) => {
    if (!modoRango || !value || !valueHasta) return false;
    const fechaDia = normalizarFecha(dia.fecha);
    const desde = normalizarFecha(value);
    const hasta = normalizarFecha(valueHasta);
    return fechaDia > desde && fechaDia < hasta;
  };

  const esHoy = (dia) => {
    const hoy = new Date();
    return (
      dia.fecha.getDate() === hoy.getDate() &&
      dia.fecha.getMonth() === hoy.getMonth() &&
      dia.fecha.getFullYear() === hoy.getFullYear()
    );
  };

  const esDiaDeshabilitado = (dia) => {
    if (minDate && dia.fecha < new Date(minDate)) return true;
    if (maxDate && dia.fecha > new Date(maxDate)) return true;
    return false;
  };

  const esMesActual = (mesIndex) => {
    const hoy = new Date();
    return mesIndex === hoy.getMonth() && mesActual.getFullYear() === hoy.getFullYear();
  };

  const esAnioActual = (year) => {
    return year === new Date().getFullYear();
  };

  const formatearFechaDisplay = (fecha) => {
    if (!fecha) return "";
    const d = new Date(fecha);
    const dia = d.getDate().toString().padStart(2, "0");
    const mes = (d.getMonth() + 1).toString().padStart(2, "0");
    const anio = d.getFullYear().toString().slice(-2);
    return `${dia}/${mes}/${anio}`;
  };

  const obtenerTextoBoton = () => {
    if (modoRango) {
      if (value && valueHasta) {
        if (compararFechas(value, valueHasta) === 0) {
          return formatearFechaDisplay(value);
        }
        return `${formatearFechaDisplay(value)} - ${formatearFechaDisplay(valueHasta)}`;
      }
      if (value && !valueHasta) {
        return `${formatearFechaDisplay(value)} - ...`;
      }
    } else if (value) {
      return formatearFechaDisplay(value);
    }
    return placeholder;
  };

  const limpiarSeleccion = () => {
    if (modoRango && onChangeRango) {
      onChangeRango(null, null);
    } else {
      onChange(null);
    }
    setSeleccionandoRango(false);
    setAbierto(false);
  };

  const tieneSeleccion = modoRango ? (value || valueHasta) : value;

  const dias = obtenerDiasMes(mesActual);
  const decada = obtenerDecada(mesActual.getFullYear());

  // Renderizar header seg√∫n vista
  const renderHeader = () => {
    if (vistaActual === "dias") {
      return (
        <div className="selector-fecha-header">
          <button type="button" className="selector-fecha-nav" onClick={irMesAnterior}>
            ‚óÄ
          </button>
          <button
            type="button"
            className="selector-fecha-titulo"
            onClick={() => setVistaActual("meses")}
          >
            {nombresMeses[mesActual.getMonth()]} {mesActual.getFullYear()}
          </button>
          <button type="button" className="selector-fecha-nav" onClick={irMesSiguiente}>
            ‚ñ∂
          </button>
        </div>
      );
    }

    if (vistaActual === "meses") {
      return (
        <div className="selector-fecha-header">
          <button type="button" className="selector-fecha-nav" onClick={irAnioAnterior}>
            ‚óÄ
          </button>
          <button
            type="button"
            className="selector-fecha-titulo"
            onClick={() => setVistaActual("anios")}
          >
            {mesActual.getFullYear()}
          </button>
          <button type="button" className="selector-fecha-nav" onClick={irAnioSiguiente}>
            ‚ñ∂
          </button>
        </div>
      );
    }

    // Vista a√±os
    return (
      <div className="selector-fecha-header">
        <button type="button" className="selector-fecha-nav" onClick={irDecadaAnterior}>
          ‚óÄ
        </button>
        <span className="selector-fecha-titulo selector-fecha-titulo--no-click">
          {decada.inicio} - {decada.fin}
        </span>
        <button type="button" className="selector-fecha-nav" onClick={irDecadaSiguiente}>
          ‚ñ∂
        </button>
      </div>
    );
  };

  // Renderizar contenido seg√∫n vista
  const renderContenido = () => {
    if (vistaActual === "dias") {
      return (
        <>
          <div className="selector-fecha-dias-semana">
            {nombresDias.map((nombre) => (
              <span key={nombre} className="selector-fecha-dia-semana">
                {nombre}
              </span>
            ))}
          </div>
          <div className="selector-fecha-grilla">
            {dias.map((dia, index) => (
              <button
                key={index}
                type="button"
                className={`selector-fecha-dia ${
                  !dia.mesActual ? "selector-fecha-dia--otro-mes" : ""
                } ${esDiaSeleccionado(dia) ? "selector-fecha-dia--desde" : ""} ${
                  esDiaHasta(dia) ? "selector-fecha-dia--hasta" : ""
                } ${esDiaEnRango(dia) ? "selector-fecha-dia--en-rango" : ""} ${
                  esHoy(dia) ? "selector-fecha-dia--hoy" : ""
                } ${esDiaDeshabilitado(dia) ? "selector-fecha-dia--deshabilitado" : ""}`}
                onClick={() => seleccionarDia(dia)}
                disabled={esDiaDeshabilitado(dia)}
              >
                {dia.dia}
              </button>
            ))}
          </div>
        </>
      );
    }

    if (vistaActual === "meses") {
      return (
        <div className="selector-fecha-grilla-meses">
          {nombresMesesCortos.map((nombre, index) => (
            <button
              key={index}
              type="button"
              className={`selector-fecha-mes-item ${
                esMesActual(index) ? "selector-fecha-mes-item--actual" : ""
              } ${
                mesActual.getMonth() === index ? "selector-fecha-mes-item--seleccionado" : ""
              }`}
              onClick={() => seleccionarMes(index)}
            >
              {nombre}
            </button>
          ))}
        </div>
      );
    }

    // Vista a√±os
    const anios = [];
    for (let i = decada.inicio; i <= decada.fin; i++) {
      anios.push(i);
    }

    return (
      <div className="selector-fecha-grilla-anios">
        {anios.map((year) => (
          <button
            key={year}
            type="button"
            className={`selector-fecha-anio-item ${
              esAnioActual(year) ? "selector-fecha-anio-item--actual" : ""
            } ${
              mesActual.getFullYear() === year ? "selector-fecha-anio-item--seleccionado" : ""
            }`}
            onClick={() => seleccionarAnio(year)}
          >
            {year}
          </button>
        ))}
      </div>
    );
  };

  return (
    <div className={`selector-fecha ${className}`} ref={contenedorRef}>
      <button
        type="button"
        className={`selector-fecha-btn ${abierto ? "selector-fecha-btn--activo" : ""} ${disabled ? "selector-fecha-btn--disabled" : ""} ${tieneSeleccion ? "selector-fecha-btn--con-valor" : ""}`}
        onClick={() => !disabled && setAbierto(!abierto)}
        disabled={disabled}
        title={obtenerTextoBoton()}
      >
        <span className="selector-fecha-icono">üìÖ</span>
      </button>

      {abierto && (
        <div className="selector-fecha-dropdown">
          {/* Indicador de modo rango */}
          {modoRango && (
            <div className="selector-fecha-modo">
              <div className="selector-fecha-modo-contenido">
                {!value ? (
                  <span className="selector-fecha-instruccion">Selecciona fecha inicial</span>
                ) : !valueHasta ? (
                  <span className="selector-fecha-instruccion selector-fecha-instruccion--activo">
                    <span className="selector-fecha-desde-badge">{formatearFechaDisplay(value)}</span>
                    ‚Üí Selecciona fecha final
                  </span>
                ) : (
                  <span className="selector-fecha-instruccion selector-fecha-instruccion--completo">
                    <span className="selector-fecha-desde-badge">{formatearFechaDisplay(value)}</span>
                    ‚Üí
                    <span className="selector-fecha-hasta-badge">{formatearFechaDisplay(valueHasta)}</span>
                  </span>
                )}
              </div>
              {tieneSeleccion && (
                <button
                  type="button"
                  className="selector-fecha-limpiar-mini"
                  onClick={limpiarSeleccion}
                  title="Limpiar selecci√≥n"
                >
                  Limpiar
                </button>
              )}
            </div>
          )}

          {renderHeader()}
          {renderContenido()}

          {/* Footer solo para modo simple (no rango) */}
          {!modoRango && tieneSeleccion && vistaActual === "dias" && (
            <div className="selector-fecha-footer">
              <button
                type="button"
                className="selector-fecha-limpiar"
                onClick={limpiarSeleccion}
              >
                Limpiar
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default SelectorFecha;

========== mi-app/src/contextos/AuthContext.jsx ==========
// src/contextos/AuthContext.jsx
// Contexto de autenticaci√≥n para toda la aplicaci√≥n

import React, { createContext, useContext, useState, useEffect } from 'react';
import {
  iniciarSesion,
  cerrarSesion,
  obtenerSesion,
  obtenerUsuarioActual,
  registrarUsuario,
  recuperarContrasena,
  suscribirseACambiosAuth,
} from '../servicios/authService';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [usuario, setUsuario] = useState(null);
  const [cargando, setCargando] = useState(true);
  const [error, setError] = useState(null);

  // Cargar sesi√≥n al iniciar
  useEffect(() => {
    const cargarSesion = async () => {
      try {
        const { session } = await obtenerSesion();
        if (session) {
          const { usuario: datosUsuario } = await obtenerUsuarioActual();
          setUsuario(datosUsuario);
        }
      } catch (err) {
        console.error('Error al cargar sesi√≥n:', err);
      } finally {
        setCargando(false);
      }
    };

    cargarSesion();

    // Suscribirse a cambios de auth
    const desuscribir = suscribirseACambiosAuth(async (event, session) => {
      if (event === 'SIGNED_IN' && session) {
        const { usuario: datosUsuario } = await obtenerUsuarioActual();
        setUsuario(datosUsuario);
      } else if (event === 'SIGNED_OUT') {
        setUsuario(null);
      }
    });

    return () => desuscribir();
  }, []);

  // Funci√≥n de login
  const login = async (email, password) => {
    setError(null);
    const { user, error: loginError } = await iniciarSesion(email, password);

    if (loginError) {
      setError(loginError);
      return { exito: false, error: loginError };
    }

    if (user) {
      const { usuario: datosUsuario } = await obtenerUsuarioActual();
      setUsuario(datosUsuario);
    }

    return { exito: true, error: null };
  };

  // Funci√≥n de registro
  const registro = async (email, password, nombre) => {
    setError(null);
    const { user, error: registroError } = await registrarUsuario(email, password, nombre);

    if (registroError) {
      setError(registroError);
      return { exito: false, error: registroError };
    }

    return { exito: true, error: null, requiereConfirmacion: true };
  };

  // Funci√≥n de logout
  const logout = async () => {
    const { error: logoutError } = await cerrarSesion();
    if (!logoutError) {
      setUsuario(null);
    }
    return { error: logoutError };
  };

  // Funci√≥n para recuperar contrase√±a
  const recuperar = async (email) => {
    setError(null);
    const { error: recuperarError } = await recuperarContrasena(email);

    if (recuperarError) {
      setError(recuperarError);
      return { exito: false, error: recuperarError };
    }

    return { exito: true, error: null };
  };

  const valor = {
    usuario,
    cargando,
    error,
    estaAutenticado: !!usuario,
    login,
    logout,
    registro,
    recuperar,
  };

  return (
    <AuthContext.Provider value={valor}>
      {children}
    </AuthContext.Provider>
  );
}

// Hook personalizado para usar el contexto
export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth debe usarse dentro de un AuthProvider');
  }
  return context;
}

========== mi-app/src/hooks/useErrorHandler.js ==========
/**
 * Hook para manejo consistente de errores en la aplicaci√≥n
 * Proporciona funciones para capturar, mostrar y reportar errores
 */

import { useState, useCallback, useRef } from "react";

/**
 * Niveles de severidad de errores
 */
export const ERROR_LEVELS = {
  INFO: "info",
  WARNING: "warning",
  ERROR: "error",
  CRITICAL: "critical",
};

/**
 * C√≥digos de error predefinidos
 */
export const ERROR_CODES = {
  NETWORK: "NETWORK_ERROR",
  DATABASE: "DATABASE_ERROR",
  VALIDATION: "VALIDATION_ERROR",
  AUTH: "AUTH_ERROR",
  MODBUS: "MODBUS_ERROR",
  UNKNOWN: "UNKNOWN_ERROR",
};

/**
 * Hook para manejar errores de forma consistente
 * @param {Object} options - Opciones de configuraci√≥n
 * @param {boolean} options.logToConsole - Si debe loggear a consola (default: true en dev)
 * @param {number} options.maxErrors - M√°ximo de errores a mantener en historial (default: 50)
 * @param {number} options.autoCleanupMs - Tiempo en ms para limpiar errores viejos (default: 300000 = 5 min)
 * @returns {Object} - Funciones y estado del manejador de errores
 */
const useErrorHandler = (options = {}) => {
  const {
    logToConsole = import.meta.env.DEV,
    maxErrors = 50,
    autoCleanupMs = 5 * 60 * 1000,
  } = options;

  // Estado de errores actuales
  const [errors, setErrors] = useState([]);
  const [lastError, setLastError] = useState(null);

  // Ref para el timer de auto-cleanup
  const cleanupTimerRef = useRef(null);

  /**
   * Genera un ID √∫nico para cada error
   */
  const generateErrorId = useCallback(() => {
    return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }, []);

  /**
   * Formatea un error para almacenamiento consistente
   */
  const formatError = useCallback((error, context = {}) => {
    const errorObj = {
      id: generateErrorId(),
      timestamp: new Date().toISOString(),
      message: "",
      code: ERROR_CODES.UNKNOWN,
      level: ERROR_LEVELS.ERROR,
      stack: null,
      context: {},
      originalError: null,
    };

    // Si es un Error nativo
    if (error instanceof Error) {
      errorObj.message = error.message;
      errorObj.stack = error.stack;
      errorObj.originalError = error;

      // Detectar tipo de error por mensaje
      if (error.message.includes("fetch") || error.message.includes("network")) {
        errorObj.code = ERROR_CODES.NETWORK;
      } else if (error.message.includes("IndexedDB") || error.message.includes("database")) {
        errorObj.code = ERROR_CODES.DATABASE;
      } else if (error.message.includes("Modbus") || error.message.includes("modbus")) {
        errorObj.code = ERROR_CODES.MODBUS;
      }
    }
    // Si es un string
    else if (typeof error === "string") {
      errorObj.message = error;
    }
    // Si es un objeto con propiedades de error
    else if (typeof error === "object" && error !== null) {
      errorObj.message = error.message || JSON.stringify(error);
      errorObj.code = error.code || ERROR_CODES.UNKNOWN;
      errorObj.level = error.level || ERROR_LEVELS.ERROR;
    }

    // Merge con contexto proporcionado
    errorObj.context = {
      ...context,
      userAgent: typeof navigator !== "undefined" ? navigator.userAgent : "unknown",
      url: typeof window !== "undefined" ? window.location.href : "unknown",
    };

    // Override con valores del contexto si existen
    if (context.code) errorObj.code = context.code;
    if (context.level) errorObj.level = context.level;

    return errorObj;
  }, [generateErrorId]);

  /**
   * Captura y registra un error
   * @param {Error|string|Object} error - El error a capturar
   * @param {Object} context - Contexto adicional (c√≥digo, nivel, metadata)
   * @returns {Object} - El error formateado
   */
  const captureError = useCallback((error, context = {}) => {
    const formattedError = formatError(error, context);

    // Log a consola si est√° habilitado
    if (logToConsole) {
      const logMethod = formattedError.level === ERROR_LEVELS.WARNING ? console.warn : console.error;
      logMethod(`[${formattedError.code}] ${formattedError.message}`, {
        context: formattedError.context,
        stack: formattedError.stack,
      });
    }

    // Agregar al estado
    setErrors((prev) => {
      const updated = [formattedError, ...prev];
      // Limitar tama√±o del historial
      return updated.slice(0, maxErrors);
    });

    setLastError(formattedError);

    // Programar auto-limpieza
    if (cleanupTimerRef.current) {
      clearTimeout(cleanupTimerRef.current);
    }
    cleanupTimerRef.current = setTimeout(() => {
      setErrors((prev) => {
        const cutoffTime = Date.now() - autoCleanupMs;
        return prev.filter((err) => new Date(err.timestamp).getTime() > cutoffTime);
      });
    }, autoCleanupMs);

    return formattedError;
  }, [formatError, logToConsole, maxErrors, autoCleanupMs]);

  /**
   * Captura un error de nivel warning
   */
  const captureWarning = useCallback((message, context = {}) => {
    return captureError(message, { ...context, level: ERROR_LEVELS.WARNING });
  }, [captureError]);

  /**
   * Captura un error de nivel info
   */
  const captureInfo = useCallback((message, context = {}) => {
    return captureError(message, { ...context, level: ERROR_LEVELS.INFO });
  }, [captureError]);

  /**
   * Limpia un error espec√≠fico por ID
   */
  const dismissError = useCallback((errorId) => {
    setErrors((prev) => prev.filter((err) => err.id !== errorId));
    setLastError((prev) => (prev?.id === errorId ? null : prev));
  }, []);

  /**
   * Limpia todos los errores
   */
  const clearAllErrors = useCallback(() => {
    setErrors([]);
    setLastError(null);
    if (cleanupTimerRef.current) {
      clearTimeout(cleanupTimerRef.current);
    }
  }, []);

  /**
   * Obtiene errores filtrados por nivel
   */
  const getErrorsByLevel = useCallback((level) => {
    return errors.filter((err) => err.level === level);
  }, [errors]);

  /**
   * Obtiene errores filtrados por c√≥digo
   */
  const getErrorsByCode = useCallback((code) => {
    return errors.filter((err) => err.code === code);
  }, [errors]);

  /**
   * Wrapper para funciones async que captura errores autom√°ticamente
   * @param {Function} asyncFn - Funci√≥n async a ejecutar
   * @param {Object} context - Contexto para el error si ocurre
   * @returns {Promise<[result, error]>} - Tupla [resultado, error]
   */
  const withErrorCapture = useCallback((asyncFn, context = {}) => {
    return async (...args) => {
      try {
        const result = await asyncFn(...args);
        return [result, null];
      } catch (error) {
        const captured = captureError(error, context);
        return [null, captured];
      }
    };
  }, [captureError]);

  /**
   * Ejecuta una funci√≥n y captura errores autom√°ticamente
   * @param {Function} fn - Funci√≥n a ejecutar
   * @param {Object} context - Contexto para el error si ocurre
   * @returns {Promise<[result, error]>} - Tupla [resultado, error]
   */
  const tryCatch = useCallback(async (fn, context = {}) => {
    try {
      const result = await fn();
      return [result, null];
    } catch (error) {
      const captured = captureError(error, context);
      return [null, captured];
    }
  }, [captureError]);

  return {
    // Estado
    errors,
    lastError,
    hasErrors: errors.length > 0,
    errorCount: errors.length,

    // Funciones de captura
    captureError,
    captureWarning,
    captureInfo,

    // Funciones de limpieza
    dismissError,
    clearAllErrors,

    // Funciones de filtrado
    getErrorsByLevel,
    getErrorsByCode,

    // Utilidades
    withErrorCapture,
    tryCatch,

    // Constantes exportadas
    ERROR_LEVELS,
    ERROR_CODES,
  };
};

export default useErrorHandler;

========== mi-app/src/hooks/usePushNotifications.js ==========
// src/hooks/usePushNotifications.js
// Hook para gestionar push notifications en la app

import { useEffect, useRef, useCallback } from 'react';
import {
  esPlataformaNativa,
  registrarPushNotifications,
  desregistrarPushNotifications,
} from '../servicios/pushNotifications';
import { registrarTokenDispositivo } from '../servicios/apiService';

/**
 * Hook para inicializar y gestionar push notifications.
 * Solo funciona en plataformas nativas (Android/iOS).
 *
 * @param {Object} opciones - Opciones del hook
 * @param {boolean} opciones.habilitado - Si las notificaciones est√°n habilitadas (default: true)
 * @param {Function} opciones.onNotificacion - Callback cuando llega una notificaci√≥n en primer plano
 * @param {Function} opciones.onNotificacionTocada - Callback cuando el usuario toca la notificaci√≥n
 * @returns {Object} { esNativo, tokenRegistrado }
 */
export function usePushNotifications({
  habilitado = true,
  onNotificacion = null,
  onNotificacionTocada = null,
} = {}) {
  const tokenRegistradoRef = useRef(false);
  const esNativo = esPlataformaNativa();

  // Callback para cuando se recibe el token FCM
  const handleTokenRecibido = useCallback(async (token) => {
    if (tokenRegistradoRef.current) {
      console.log('[Push Hook] Token ya registrado, ignorando');
      return;
    }

    try {
      console.log('[Push Hook] Registrando token en backend...');
      await registrarTokenDispositivo(token, 'android');
      tokenRegistradoRef.current = true;
      console.log('[Push Hook] Token registrado exitosamente');
    } catch (error) {
      console.error('[Push Hook] Error registrando token:', error);
    }
  }, []);

  // Callback para notificaciones en primer plano
  const handleNotificacion = useCallback((notificacion) => {
    console.log('[Push Hook] Notificaci√≥n recibida:', notificacion);
    if (onNotificacion) {
      onNotificacion(notificacion);
    }
  }, [onNotificacion]);

  // Callback para cuando el usuario toca la notificaci√≥n
  const handleNotificacionTocada = useCallback((datos) => {
    console.log('[Push Hook] Notificaci√≥n tocada:', datos);
    if (onNotificacionTocada) {
      onNotificacionTocada(datos);
    }
  }, [onNotificacionTocada]);

  useEffect(() => {
    if (!esNativo || !habilitado) {
      console.log('[Push Hook] Saltando inicializaci√≥n (nativo:', esNativo, ', habilitado:', habilitado, ')');
      return;
    }

    console.log('[Push Hook] Inicializando push notifications...');

    // Inicializar push notifications
    registrarPushNotifications(
      handleTokenRecibido,
      handleNotificacion,
      handleNotificacionTocada
    );

    // Cleanup al desmontar
    return () => {
      console.log('[Push Hook] Limpiando listeners...');
      desregistrarPushNotifications();
    };
  }, [esNativo, habilitado, handleTokenRecibido, handleNotificacion, handleNotificacionTocada]);

  return {
    esNativo,
    tokenRegistrado: tokenRegistradoRef.current,
  };
}

export default usePushNotifications;

========== mi-app/src/lib/supabase.js ==========
// src/lib/supabase.js
// Cliente de Supabase para el frontend

import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Faltan las variables de entorno de Supabase (VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY)');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);

========== mi-app/src/main.jsx ==========
// src/main.jsx
import React from "react";                         // librer√≠a principal de React para componentes
import ReactDOM from "react-dom/client";           // API moderna de renderizado en el navegador
import { BrowserRouter } from "react-router-dom";  // enrutador basado en historial del navegador
import { AuthProvider } from "./contextos/AuthContext"; // contexto de autenticaci√≥n con Supabase
import App from "./App.jsx";                       // componente ra√≠z de la aplicaci√≥n (define las rutas)
import "./index.css";                              // estilos globales (tailwind + tema general)
import "./fuentes.css";                            // fuentes locales desde public/fonts/
import { Capacitor } from "@capacitor/core";       // para detectar plataforma nativa

// Configurar plataforma nativa (Android/iOS)
if (Capacitor.isNativePlatform()) {
   // Agregar clase a html y body para estilos espec√≠ficos de app nativa
   document.documentElement.classList.add('capacitor-native');
   document.body.classList.add('capacitor-native');
   // Los insets se manejan desde MainActivity.java con ViewCompat.setOnApplyWindowInsetsListener
}

ReactDOM.createRoot(document.getElementById("root")).render(   // crea la ra√≠z de React sobre el div#root
   <React.StrictMode>                   {/* modo estricto: ayuda a detectar problemas en desarrollo */}
      <BrowserRouter>                   {/* provee contexto de rutas a toda la app */}
         <AuthProvider>                 {/* provee contexto de autenticaci√≥n a toda la app */}
            <App />                     {/* componente principal que contiene las p√°ginas/rutas */}
         </AuthProvider>
      </BrowserRouter>
   </React.StrictMode>
);

// ---------------------------------------------------------------------------
// NOTA PERSONAL SOBRE ESTE ARCHIVO (main.jsx)
// - Este es el punto de entrada de la app React que usa Vite.
// - ReactDOM.createRoot() toma el <div id="root"> del index.html y ah√≠ monta todo.
// - StrictMode solo afecta al modo desarrollo: vuelve a montar componentes para
//   avisar de problemas potenciales, pero en producci√≥n no impacta.
// - BrowserRouter envuelve a <App /> para que dentro pueda usar rutas
//   (Link, Route, useNavigate, etc.) basadas en la URL del navegador.
// - En resumen: ac√° se conecta el HTML base con mi √°rbol de componentes y el
//   sistema de rutas de React Router.

========== mi-app/src/paginas/PaginaAlimentadores/componentes/historial/BarraControlesHistorial.jsx ==========
/**
 * Barra de controles para la ventana de historial
 * Incluye: toggle panel, tabs de zona, selector de rango, tipo de grafico, selector alimentador, cache
 */

import PropTypes from "prop-types";
import { RANGOS_TIEMPO, TIPOS_GRAFICO } from "../../constantes/historialConfig";
import SelectorFecha from "../../../../componentes/comunes/SelectorFecha";

/**
 * @param {Object} props
 * @param {boolean} props.panelDatosAbierto - Si el panel de datos est√° visible
 * @param {Function} props.onTogglePanel - Callback para toggle del panel
 * @param {string} props.zonaSeleccionada - "superior" o "inferior"
 * @param {Function} props.onZonaChange - Callback al cambiar zona
 * @param {Function} props.zonaDisponible - Funci√≥n que verifica si una zona est√° disponible
 * @param {string} props.tituloSuperior - T√≠tulo de la zona superior
 * @param {string} props.tituloInferior - T√≠tulo de la zona inferior
 * @param {string} props.rangoSeleccionado - ID del rango seleccionado
 * @param {Function} props.onRangoChange - Callback al cambiar rango
 * @param {Date|null} props.fechaRangoDesde - Fecha desde (rango personalizado)
 * @param {Date|null} props.fechaRangoHasta - Fecha hasta (rango personalizado)
 * @param {Function} props.onFechaRangoChange - Callback al cambiar fechas
 * @param {string} props.tipoGrafico - Tipo de gr√°fico seleccionado
 * @param {Function} props.onTipoGraficoChange - Callback al cambiar tipo
 * @param {string} props.alimentadorId - ID del alimentador actual
 * @param {Array} props.alimentadores - Lista de alimentadores disponibles
 * @param {Function} props.onAlimentadorChange - Callback al cambiar alimentador
 * @param {number} props.precargaProgreso - Progreso de precarga (0-100)
 * @param {boolean} props.precargaCompleta - Si la precarga termin√≥
 * @param {boolean} props.precargando - Si est√° precargando
 * @param {string|null} props.fuenteDatos - Fuente de datos actual
 * @param {Function} props.onLimpiarCache - Callback para limpiar cache
 */
const BarraControlesHistorial = ({
  panelDatosAbierto,
  onTogglePanel,
  zonaSeleccionada,
  onZonaChange,
  zonaDisponible,
  tituloSuperior,
  tituloInferior,
  rangoSeleccionado,
  onRangoChange,
  fechaRangoDesde,
  fechaRangoHasta,
  onFechaRangoChange,
  tipoGrafico,
  onTipoGraficoChange,
  alimentadorId,
  alimentadores,
  onAlimentadorChange,
  precargaProgreso,
  precargaCompleta,
  precargando,
  fuenteDatos,
  onLimpiarCache,
  graficoVisible,
  onToggleGrafico,
}) => {
  return (
    <div className="ventana-controles">
      {/* Boton toggle para panel de datos */}
      <button
        type="button"
        className={`ventana-toggle-datos ${panelDatosAbierto ? "ventana-toggle-datos--activo" : ""}`}
        onClick={onTogglePanel}
        title={panelDatosAbierto ? "Ocultar datos" : "Ver datos"}
      >
        <span className="ventana-toggle-icono">‚ñ≤</span>
      </button>

      {/* Tabs de zona */}
      <div className="ventana-tabs">
        <button
          type="button"
          className={`ventana-tab ${zonaSeleccionada === "superior" ? "ventana-tab--activo" : ""}`}
          onClick={() => onZonaChange("superior")}
          disabled={!zonaDisponible("superior")}
        >
          {tituloSuperior}
        </button>
        <button
          type="button"
          className={`ventana-tab ${zonaSeleccionada === "inferior" ? "ventana-tab--activo" : ""}`}
          onClick={() => onZonaChange("inferior")}
          disabled={!zonaDisponible("inferior")}
        >
          {tituloInferior}
        </button>
      </div>

      {/* Selector de rango */}
      <div className="ventana-rango">
        {RANGOS_TIEMPO.filter((r) => r.id !== "custom").map((r) => (
          <button
            key={r.id}
            type="button"
            className={`ventana-rango-btn ${rangoSeleccionado === r.id && !fechaRangoDesde ? "ventana-rango-btn--activo" : ""}`}
            onClick={() => onRangoChange(r.id)}
          >
            {r.label}
          </button>
        ))}
      </div>

      {/* Grupo: Selector de fechas + Tipo de gr√°fico */}
      <div className="ventana-grupo-graficos">
        {/* Selector de rango de fechas */}
        <div className="ventana-selector-dia">
          <SelectorFecha
            value={fechaRangoDesde}
            valueHasta={fechaRangoHasta}
            modoRango={true}
            onChangeRango={onFechaRangoChange}
            maxDate={new Date()}
            placeholder="Seleccionar fechas"
          />
          {fechaRangoDesde && fechaRangoHasta && (
            <span className="ventana-dia-seleccionado">
              {new Date(fechaRangoDesde).toLocaleDateString("es-AR", {
                day: "2-digit",
                month: "2-digit",
                year: "2-digit",
              })}
              {fechaRangoDesde.getTime() !== fechaRangoHasta.getTime() && (
                <>
                  {" "}
                  -{" "}
                  {new Date(fechaRangoHasta).toLocaleDateString("es-AR", {
                    day: "2-digit",
                    month: "2-digit",
                    year: "2-digit",
                  })}
                </>
              )}
            </span>
          )}
        </div>

        {/* Selector de tipo de grafico */}
        <div className="ventana-tipo-grafico">
          {TIPOS_GRAFICO.map((tipo) => (
            <button
              key={tipo.id}
              type="button"
              className={`ventana-tipo-btn ${tipoGrafico === tipo.id ? "ventana-tipo-btn--activo" : ""}`}
              onClick={() => onTipoGraficoChange(tipo.id)}
              title={tipo.label}
            >
              {tipo.icon}
            </button>
          ))}
        </div>
      </div>

      {/* Selector de alimentador */}
      {alimentadores && alimentadores.length > 1 && (
        <div className="ventana-selector-alimentador-container">
          <select
            className="ventana-selector-alimentador"
            value={alimentadorId}
            onChange={(e) => onAlimentadorChange(e.target.value)}
            title="Cambiar alimentador"
          >
            {alimentadores.map((alim) => (
              <option key={alim.id} value={alim.id}>
                {alim.nombre}
              </option>
            ))}
          </select>
        </div>
      )}

      {/* Cache + Fuente */}
      <div className="ventana-cache">
        {/* Bot√≥n toggle gr√°fico - solo visible en m√≥vil portrait */}
        <button
          type="button"
          className={`ventana-toggle-grafico ${graficoVisible ? "" : "ventana-toggle-grafico--cerrado"}`}
          onClick={onToggleGrafico}
          title={graficoVisible ? "Ocultar gr√°fico" : "Mostrar gr√°fico"}
        >
          <span className="ventana-toggle-grafico-icono">‚ñº</span>
        </button>
        <div className="ventana-cache-barra">
          <div
            className={`ventana-cache-progreso ${precargaCompleta ? "ventana-cache-progreso--completo" : ""}`}
            style={{ width: `${precargaProgreso}%` }}
          />
        </div>
        <span className="ventana-cache-texto">
          {precargaCompleta ? "‚úì" : `${precargaProgreso}%`}
        </span>
        {fuenteDatos && (
          <span className={`ventana-fuente ventana-fuente--${fuenteDatos}`}>
            {fuenteDatos === "local" ? "Local" : fuenteDatos === "remoto" ? "BD" : "Mixto"}
          </span>
        )}
        <button
          type="button"
          className="ventana-btn-limpiar"
          onClick={onLimpiarCache}
          disabled={precargando}
          title="Limpiar cache"
        >
          üóë
        </button>
      </div>
    </div>
  );
};

BarraControlesHistorial.propTypes = {
  panelDatosAbierto: PropTypes.bool.isRequired,
  onTogglePanel: PropTypes.func.isRequired,
  zonaSeleccionada: PropTypes.oneOf(["superior", "inferior"]).isRequired,
  onZonaChange: PropTypes.func.isRequired,
  zonaDisponible: PropTypes.func.isRequired,
  tituloSuperior: PropTypes.string,
  tituloInferior: PropTypes.string,
  rangoSeleccionado: PropTypes.string.isRequired,
  onRangoChange: PropTypes.func.isRequired,
  fechaRangoDesde: PropTypes.instanceOf(Date),
  fechaRangoHasta: PropTypes.instanceOf(Date),
  onFechaRangoChange: PropTypes.func.isRequired,
  tipoGrafico: PropTypes.oneOf(["line", "area", "bar"]).isRequired,
  onTipoGraficoChange: PropTypes.func.isRequired,
  alimentadorId: PropTypes.string,
  alimentadores: PropTypes.array,
  onAlimentadorChange: PropTypes.func,
  precargaProgreso: PropTypes.number,
  precargaCompleta: PropTypes.bool,
  precargando: PropTypes.bool,
  fuenteDatos: PropTypes.oneOf(["local", "remoto", "mixto", null]),
  onLimpiarCache: PropTypes.func.isRequired,
  graficoVisible: PropTypes.bool,
  onToggleGrafico: PropTypes.func,
};

BarraControlesHistorial.defaultProps = {
  tituloSuperior: "Superior",
  tituloInferior: "Inferior",
  fechaRangoDesde: null,
  fechaRangoHasta: null,
  alimentadorId: "",
  alimentadores: [],
  onAlimentadorChange: () => {},
  precargaProgreso: 0,
  precargaCompleta: false,
  precargando: false,
  fuenteDatos: null,
  graficoVisible: true,
  onToggleGrafico: () => {},
};

export default BarraControlesHistorial;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/historial/BarraTituloVentana.jsx ==========
/**
 * Barra de titulo arrastrable para ventanas flotantes de historial
 * Incluye titulo, botones de minimizar/maximizar/cerrar
 * En m√≥vil solo muestra el bot√≥n de cerrar
 */

import { forwardRef } from "react";
import PropTypes from "prop-types";

/**
 * @param {Object} props
 * @param {string} props.nombre - Nombre del alimentador
 * @param {boolean} props.maximizada - Si la ventana esta maximizada
 * @param {Function} props.onMinimizar - Callback para minimizar
 * @param {Function} props.onMaximizar - Callback para maximizar/restaurar
 * @param {Function} props.onCerrar - Callback para cerrar
 * @param {Function} props.onMouseDown - Callback para iniciar arrastre
 * @param {React.Ref} ref - Ref para el header
 */
const BarraTituloVentana = forwardRef(({
  nombre,
  maximizada,
  onMinimizar,
  onMaximizar,
  onCerrar,
  onMouseDown,
}, ref) => {
  return (
    <header
      ref={ref}
      className="ventana-historial-header"
      onMouseDown={onMouseDown}
    >
      <div className="ventana-historial-titulo">
        <span className="ventana-historial-icono">üìä</span>
        <span className="ventana-historial-nombre">{nombre}</span>
      </div>
      <div className="ventana-historial-controles">
        {/* Botones minimizar/maximizar ocultos en m√≥vil via CSS */}
        <button
          type="button"
          className="ventana-btn ventana-btn--minimizar ventana-btn--desktop-only"
          onClick={onMinimizar}
          title="Minimizar"
        >
          <span>‚îÄ</span>
        </button>
        <button
          type="button"
          className="ventana-btn ventana-btn--maximizar ventana-btn--desktop-only"
          onClick={onMaximizar}
          title={maximizada ? "Restaurar" : "Maximizar"}
        >
          <span>{maximizada ? "‚ùê" : "‚ñ°"}</span>
        </button>
        <button
          type="button"
          className="ventana-btn ventana-btn--cerrar"
          onClick={onCerrar}
          title="Cerrar"
        >
          <span>√ó</span>
        </button>
      </div>
    </header>
  );
});

BarraTituloVentana.displayName = "BarraTituloVentana";

BarraTituloVentana.propTypes = {
  nombre: PropTypes.string,
  maximizada: PropTypes.bool,
  onMinimizar: PropTypes.func.isRequired,
  onMaximizar: PropTypes.func.isRequired,
  onCerrar: PropTypes.func.isRequired,
  onMouseDown: PropTypes.func.isRequired,
};

BarraTituloVentana.defaultProps = {
  nombre: "Ventana",
  maximizada: false,
};

export default BarraTituloVentana;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/historial/PanelDatosHistorial.jsx ==========
/**
 * Panel lateral que muestra la tabla de datos del historial
 * Recibe los datos ya filtrados desde VentanaHistorial
 */

import { useMemo } from "react";
import PropTypes from "prop-types";

/**
 * @param {Object} props
 * @param {boolean} props.abierto - Si el panel est√° visible
 * @param {string} props.tituloPeriodo - T√≠tulo mostrando el per√≠odo de fechas
 * @param {number} props.intervaloFiltro - Intervalo de filtrado actual (0, 15, 30, 60 minutos)
 * @param {Function} props.onIntervaloChange - Callback al cambiar intervalo
 * @param {Array} props.datosFiltrados - Datos ya filtrados [{x, y}]
 * @param {string} props.tipoGrafico - Tipo de gr√°fico actual (line, area, bar)
 */
const PanelDatosHistorial = ({
  abierto,
  tituloPeriodo,
  intervaloFiltro,
  onIntervaloChange,
  datosFiltrados,
  tipoGrafico,
}) => {
  // El gr√°fico de barras no soporta "Todos (1/min)" por rendimiento
  const todosDeshabilitado = tipoGrafico === "bar";

  // Formatear datos para la tabla
  const datosTabla = useMemo(() => {
    return datosFiltrados.map((punto) => {
      const fecha = new Date(punto.x);
      return {
        fecha: fecha.toLocaleDateString("es-AR", { day: "2-digit", month: "2-digit", year: "2-digit" }),
        hora: fecha.toLocaleTimeString("es-AR", { hour: "2-digit", minute: "2-digit", second: "2-digit" }),
        medicion: Math.ceil(punto.y * 100) / 100,
      };
    });
  }, [datosFiltrados]);

  if (!abierto) return null;

  return (
    <div className="ventana-panel-datos">
      <div className="ventana-panel-header">
        <span>{tituloPeriodo}</span>
        <select
          className="ventana-panel-intervalo"
          value={intervaloFiltro}
          onChange={(e) => onIntervaloChange(Number(e.target.value))}
        >
          <option value={0} disabled={todosDeshabilitado}>
            {todosDeshabilitado ? "Todos (no disp.)" : "Todos"}
          </option>
          <option value={15}>cada 15m</option>
          <option value={30}>cada 30m</option>
          <option value={60}>cada 60m</option>
        </select>
      </div>
      <div className="ventana-panel-tabla-container">
        <table className="ventana-panel-tabla">
          <thead>
            <tr>
              <th>Fecha</th>
              <th>Hora</th>
              <th>Medicion</th>
            </tr>
          </thead>
          <tbody>
            {datosTabla.map((fila, idx) => (
              <tr key={idx}>
                <td>{fila.fecha}</td>
                <td>{fila.hora}</td>
                <td>{fila.medicion.toFixed(2)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

PanelDatosHistorial.propTypes = {
  abierto: PropTypes.bool.isRequired,
  tituloPeriodo: PropTypes.string,
  intervaloFiltro: PropTypes.number,
  onIntervaloChange: PropTypes.func.isRequired,
  datosFiltrados: PropTypes.arrayOf(
    PropTypes.shape({
      x: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.number]),
      y: PropTypes.number,
    })
  ),
  tipoGrafico: PropTypes.oneOf(["line", "area", "bar"]),
};

PanelDatosHistorial.defaultProps = {
  tituloPeriodo: "Sin datos",
  intervaloFiltro: 60,
  datosFiltrados: [],
  tipoGrafico: "line",
};

export default PanelDatosHistorial;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/layout/VistaAlimentadores.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/layout/VistaAlimentadores.jsx

import React, { useEffect, useState, useRef, useCallback, useMemo } from "react";
import ReactDOM from "react-dom";                                    // para portal del overlay
import { useNavigate } from "react-router-dom";                     // navegaci√≥n entre rutas
import { useAuth } from "../../../../contextos/AuthContext";        // contexto de autenticaci√≥n
import "./VistaAlimentadores.css";                                  // estilos espec√≠ficos del layout de alimentadores
import "../navegacion/BotonGuardarCambios.css";                     // estilos del overlay de guardando

import BarraNavegacion from "../navegacion/BarraNavegacion.jsx";    // barra superior (t√≠tulo + botones de puestos)
import MenuLateral from "../navegacion/MenuLateral.jsx";            // men√∫ lateral en modo compacto (mobile)
import GrillaTarjetas from "../tarjetas/GrillaTarjetas.jsx";        // grilla de tarjetas de alimentadores
import SkeletonCard from "../tarjetas/SkeletonCard.jsx";            // skeleton de tarjeta (loading state)
import ModalNuevoPuesto from "../modales/ModalNuevoPuesto.jsx";     // modal para crear puestos
import ModalEditarPuestos from "../modales/ModalEditarPuestos.jsx"; // modal para editar/renombrar/eliminar puestos
import ModalConfiguracionAlimentador from "../modales/ModalConfiguracionAlimentador.jsx"; // modal de config de registrador
import ModalConfiguracionPuesto from "../modales/ModalConfiguracionPuesto.jsx";           // modal de configuraci√≥n global del puesto
import ModalConfigurarAgente from "../modales/ModalConfigurarAgente.jsx";                 // modal de configuraci√≥n del agente
import ModalGestionarAccesos from "../modales/ModalGestionarAccesos.jsx";                 // modal de gesti√≥n de accesos al workspace
import ModalPanelPermisos from "../modales/ModalPanelPermisos.jsx";                       // modal de panel de permisos (solo superadmin)
import ContenedorVentanasHistorial from "../modales/ContenedorVentanasHistorial.jsx";     // contenedor de ventanas flotantes de historial
import { useVentanasHistorial } from "../../hooks/useVentanasHistorial";               // hook para gestionar ventanas de historial
import { useVentanaConfigAgente } from "../../hooks/useVentanaConfigAgente";           // hook para gestionar ventana de configuraci√≥n de agentes

import { COLORES_SISTEMA } from "../../constantes/colores";         // paleta de colores para botones/puestos
import { useArrastrarSoltar } from "../../hooks/useArrastrarSoltar"; // hook de drag & drop de tarjetas
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase"; // contexto con datos y acciones (Supabase)
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion"; // contexto de workspaces
import { useGestorModales } from "../../hooks/useGestorModales";    // hook para abrir/cerrar modales por clave
import { obtenerUltimasLecturasPorRegistrador, listarAgentesWorkspace, listarRegistradoresAgente } from "../../../../servicios/apiService"; // API para polling de lecturas
import { useHistorialLocal } from "../../hooks/useHistorialLocal"; // Hook para guardar historial en IndexedDB
import { usePushNotifications } from "../../../../hooks/usePushNotifications"; // Hook para push notifications (Android)

const VistaAlimentadores = () => {
	const navigate = useNavigate();                                  // para salir al login
	const { logout } = useAuth();                                    // funci√≥n de logout del contexto de auth
	const {
		configuracionSeleccionada,
		perfil,
		rolGlobal,
		// Estilos globales de tarjetas
		estilosGlobales,
		guardarEstilosGlobales,
	} = usarContextoConfiguracion(); // workspace activo + perfil usuario + rol + estilos globales

	const {
   puestos,                               // lista completa de puestos configurados en el sistema
   puestoSeleccionado,                    // puesto actualmente activo/visible en la vista
   agregarPuesto,                         // agrega un nuevo puesto (se usa desde el modal de nuevo puesto)
   eliminarPuesto,                        // elimina un puesto de la BD
   seleccionarPuesto,                     // cambia el puesto activo cuando el usuario hace clic en otro
   actualizarPuestos,                     // guarda la lista de puestos editada (nombres/colores, orden, etc.)
   agregarAlimentador,                    // agrega un alimentador al puesto seleccionado
   actualizarAlimentador,                 // actualiza los datos de un alimentador existente
   eliminarAlimentador,                   // elimina un alimentador de un puesto
   reordenarAlimentadores,                // guarda el nuevo orden de alimentadores tras el drag & drop
   lecturasTarjetas,                      // lecturas ya procesadas listas para mostrar en las tarjetas
   estaMidiendo,                          // indica si un alimentador/equipo est√° midiendo (true/false)
   obtenerTimestampInicio,                // devuelve el timestamp de la √∫ltima lectura (para animaciones/tiempos)
   obtenerContadorLecturas,               // cu√°ntas lecturas se hicieron desde que arranc√≥ la medici√≥n
   detenerMedicion,                       // detiene expl√≠citamente la medici√≥n de un alimentador/equipo
   actualizarRegistros,                   // actualiza registros manualmente (para polling de lecturas)
   cargando,                              // estado de carga (Supabase)
   error,                                 // error si hubo problema cargando datos
   // Preferencias UI (gaps) - vienen del contexto para consistencia
   obtenerGap,                            // obtiene gap horizontal de un alimentador (localStorage > BD > default)
   establecerGap,                         // establece gap horizontal de un alimentador
   obtenerRowGap,                         // obtiene gap vertical de una fila (localStorage > BD > default)
   establecerRowGap,                      // establece gap vertical de una fila
   GAP_DEFAULT,                           // valor por defecto para gaps horizontales
   // Escala de tarjetas
   escalaGlobal,                          // escala global para todas las tarjetas
   establecerEscalaGlobal,                // establece escala global
   obtenerEscalaEfectiva,                 // obtiene escala efectiva (individual > puesto > global > default)
   establecerEscalaTarjeta,               // establece escala individual de un alimentador
   resetearEscalaTarjeta,                 // resetea escala individual de un alimentador
   obtenerEscalaPuesto,                   // obtiene escala de un puesto espec√≠fico
   establecerEscalaPuesto,                // establece escala de un puesto
   ESCALA_MIN,                            // escala m√≠nima permitida
   ESCALA_MAX,                            // escala m√°xima permitida
   // Limpieza al salir
   limpiarPreferenciasUI,                 // limpia localStorage de gaps al salir
   // Estado de sincronizaci√≥n
   sincronizando,                         // true mientras se guardan cambios en BD
   // Getters de colores (para soporte de preferencias de invitados)
   obtenerBgColorPuesto,                  // obtiene bgColor del puesto (con preferencias de invitado)
   obtenerColorPuesto,                    // obtiene color del puesto (con preferencias de invitado)
   // Info del rol del usuario en el workspace
   esCreador,                             // true si el usuario es creador del workspace
   // Preferencias visuales (para invitados)
   preferenciasVisuales,                  // objeto con funciones para obtener preferencias personales
} = usarContextoAlimentadores();          // hook que conecta esta vista con el contexto global de alimentadores


const {
   elementoArrastrandoId,                 // id del alimentador que se est√° arrastrando actualmente (o null)
   alIniciarArrastre,                     // handler para onDragStart: marca qu√© tarjeta empez√≥ a moverse
   alTerminarArrastre,                    // handler para onDragEnd: limpia el estado de arrastre
   alPasarPorEncima,                      // handler para onDragOver: habilita que se pueda soltar en ese destino
   reordenarLista,                        // calcula una nueva lista con un elemento movido a la posici√≥n de otro
   moverAlFinal,                          // calcula una nueva lista moviendo un elemento al final
} = useArrastrarSoltar();                // hook que encapsula el estado y la l√≥gica de drag & drop de tarjetas


	const { abrirModal, cerrarModal, obtenerEstado } = useGestorModales(); // gestor centralizado de modales
	const { guardarLecturaLocal } = useHistorialLocal(); // Hook para guardar lecturas en IndexedDB

	// Inicializar push notifications para app Android (solo se activa en plataforma nativa)
	usePushNotifications({
		habilitado: true,
		onNotificacion: (notif) => {
			console.log('[VistaAlimentadores] Notificaci√≥n en primer plano:', notif);
			// TODO: Mostrar toast o notificaci√≥n in-app
		},
		onNotificacionTocada: (datos) => {
			console.log('[VistaAlimentadores] Usuario toc√≥ notificaci√≥n:', datos);
			// TODO: Navegar a alimentador espec√≠fico si viene en datos
		},
	});

	// Sistema de ventanas flotantes de historial
	const {
		listaVentanas,
		ventanasMinimizadas,
		abrirVentana,
		cerrarVentana,
		toggleMinimizar,
		toggleMaximizar,
		enfocarVentana,
		moverVentana,
	} = useVentanasHistorial();

	const [menuAbierto, setMenuAbierto] = useState(false);           // estado del drawer lateral en mobile
	const [esCompacto, setEsCompacto] = useState(false);             // flag: layout compacto (pantalla angosta)
	const [guardandoAlimentador, setGuardandoAlimentador] = useState(false); // flag: guardando alimentador (muestra skeleton)
	const [guardandoPuestos, setGuardandoPuestos] = useState(false); // flag: guardando/eliminando puestos
	// Hook para ventana flotante de configuraci√≥n de agentes
	const {
		ventana: ventanaConfigAgente,
		abrirVentana: abrirVentanaConfigAgente,
		cerrarVentana: cerrarVentanaConfigAgente,
		toggleMinimizar: toggleMinimizarConfigAgente,
		toggleMaximizar: toggleMaximizarConfigAgente,
		enfocarVentana: enfocarVentanaConfigAgente,
		moverVentana: moverVentanaConfigAgente,
	} = useVentanaConfigAgente();
	const [modalAccesosAbierto, setModalAccesosAbierto] = useState(false); // estado del modal de gesti√≥n de accesos
	const [modalPanelPermisosAbierto, setModalPanelPermisosAbierto] = useState(false); // estado del modal de panel de permisos
	const [alimentadoresPolling, setAlimentadoresPolling] = useState({}); // { [alimId]: true/false } para tracking de polling
	const [lecturasPolling, setLecturasPolling] = useState({}); // { [alimId]: { valores, timestamp, ... } } - √∫ltimas lecturas obtenidas
	const [contadoresPolling, setContadoresPolling] = useState({}); // { [alimId]: number } - contador de lecturas para animaci√≥n
	const pollingIntervalsRef = useRef({}); // { [alimId]: intervalId } - para limpiar intervalos
	const contadorIntervalsRef = useRef({}); // { [alimId]: intervalId } - intervalos separados para incrementar contador (1 por ciclo)
	const [registradores, setRegistradores] = useState([]); // Lista de registradores del workspace
	// Errores de lectura: el agente no pudo leer del equipo Modbus (exito === false)
	const [contadoresErrorLectura, setContadoresErrorLectura] = useState({}); // { [alimId_zona]: number }
	// Errores de red: el frontend no pudo comunicarse con el backend (fetch fall√≥)
	const [contadoresErrorRed, setContadoresErrorRed] = useState({}); // { [alimId_zona]: number }
	// Estado global de conexi√≥n con el backend
	const [hayProblemaConexion, setHayProblemaConexion] = useState(false);

	// ===== PUESTOS CON PREFERENCIAS (PARA MODAL DE EDICI√ìN) =====
	// Para invitados: aplicamos las preferencias personales sobre los puestos base
	// Esto asegura que el modal de edici√≥n muestre los colores correctos
	const puestosConPreferencias = useMemo(() => {
		if (esCreador || !preferenciasVisuales) {
			return puestos;
		}

		// Aplicar preferencias personales sobre los puestos base
		return puestos.map(puesto => {
			const configPuesto = preferenciasVisuales.obtenerConfigPuesto?.(puesto.id);

			return {
				...puesto,
				color: configPuesto?.color || puesto.color,
				bgColor: configPuesto?.bg_color || puesto.bgColor || puesto.bg_color,
				// Los alimentadores tambi√©n pueden tener preferencias
				alimentadores: (puesto.alimentadores || []).map(alim => {
					const configAlim = preferenciasVisuales.obtenerConfigAlimentador?.(alim.id, puesto.id);
					return {
						...alim,
						color: configAlim?.color || alim.color,
					};
				}),
			};
		});
	}, [esCreador, puestos, preferenciasVisuales]);

	// ===== ALIMENTADORES DEL PUESTO SELECCIONADO CON PREFERENCIAS =====
	// Los alimentadores del puesto seleccionado con las preferencias aplicadas
	// (color, intervalo_consulta_ms, oculto de zonas para operadores)
	const alimentadoresConPreferencias = useMemo(() => {
		if (!puestoSeleccionado?.alimentadores) return [];
		if (esCreador || !preferenciasVisuales) {
			return puestoSeleccionado.alimentadores;
		}

		// Aplicar preferencias personales sobre los alimentadores base
		return puestoSeleccionado.alimentadores.map(alim => {
			const configAlim = preferenciasVisuales.obtenerConfigAlimentador?.(alim.id, puestoSeleccionado.id);

			// Construir el alimentador con preferencias aplicadas
			const alimConPrefs = {
				...alim,
				color: configAlim?.color || alim.color,
			};

			// Aplicar intervalo personalizado si existe
			if (configAlim?.intervalo_consulta_ms !== undefined) {
				alimConPrefs.intervalo_consulta_ms = configAlim.intervalo_consulta_ms;
			}

			// Aplicar estados "oculto" personalizados a las zonas del card_design
			if (configAlim?.oculto_superior !== undefined || configAlim?.oculto_inferior !== undefined) {
				alimConPrefs.card_design = {
					...alim.card_design,
					superior: {
						...alim.card_design?.superior,
						...(configAlim?.oculto_superior !== undefined && { oculto: configAlim.oculto_superior }),
					},
					inferior: {
						...alim.card_design?.inferior,
						...(configAlim?.oculto_inferior !== undefined && { oculto: configAlim.oculto_inferior }),
					},
				};
			}

			return alimConPrefs;
		});
	}, [esCreador, puestoSeleccionado, preferenciasVisuales]);

	// Responsive: detectar modo compacto seg√∫n el ancho de la ventana
	useEffect(() => {
		const actualizarModo = () => setEsCompacto(window.innerWidth < 900);
		actualizarModo();                                            // eval√∫a una vez al montar
		window.addEventListener("resize", actualizarModo);
		return () => window.removeEventListener("resize", actualizarModo);
	}, []);

	// En modo compacto (m√≥vil), forzar escala global a 1 para visualizaci√≥n
	// Esto es solo visual, NO se persiste en BD ni en preferencias de usuario
	const escalaGlobalEfectiva = esCompacto ? 1 : escalaGlobal;

	// Wrapper para obtenerEscalaEfectiva que considera el modo compacto
	// En m√≥vil, si no hay escala individual ni de puesto, usa 1 en vez de escalaGlobal
	const obtenerEscalaEfectivaConModoCompacto = useCallback((alimentadorId, puestoId) => {
		if (esCompacto) {
			// En modo compacto, forzar escala 1
			// No importa qu√© tenga configurado el usuario, en m√≥vil siempre es 1
			return 1;
		}
		return obtenerEscalaEfectiva(alimentadorId, puestoId);
	}, [esCompacto, obtenerEscalaEfectiva]);

	// Cargar registradores del workspace (a trav√©s de los agentes vinculados)
	useEffect(() => {
		if (!configuracionSeleccionada?.id) return;
		const cargarRegistradores = async () => {
			try {
				// Primero obtener los agentes vinculados al workspace
				const agentes = await listarAgentesWorkspace(configuracionSeleccionada.id);

				// Luego cargar los registradores de cada agente
				const todosRegistradores = [];
				for (const agente of agentes || []) {
					try {
						const regs = await listarRegistradoresAgente(agente.id);
						if (regs && regs.length > 0) {
							todosRegistradores.push(...regs);
						}
					} catch (err) {
						console.error(`Error cargando registradores del agente ${agente.id}:`, err);
					}
				}
				setRegistradores(todosRegistradores);
			} catch (err) {
				console.error("Error cargando registradores:", err);
			}
		};
		cargarRegistradores();
	}, [configuracionSeleccionada?.id]);

	const estadoModalNuevoPuesto = obtenerEstado("nuevoPuesto");     // { abierto, datos } para modal de nuevo puesto
	const estadoModalEditarPuestos = obtenerEstado("editarPuestos"); // idem para modal de edici√≥n de puestos
	const estadoModalAlimentador = obtenerEstado("alimentador");     // idem para modal de configuraci√≥n de alimentador
	const estadoModalConfigPuesto = obtenerEstado("configPuesto");   // idem para modal de configuraci√≥n global del puesto

	const buscarAlimentador = (alimId) =>
		alimentadoresConPreferencias.find((a) => a.id === alimId) || null; // helper para obtener el alimentador por id (con preferencias aplicadas)

	const buscarRegistrador = useCallback((regId) =>
		registradores.find((r) => r.id === regId) || null, [registradores]); // helper para obtener el registrador por id

	const alimentadorEnEdicion = estadoModalAlimentador.datos?.alimentadorId
		? buscarAlimentador(estadoModalAlimentador.datos.alimentadorId)
		: null;

	const modoAlimentador = estadoModalAlimentador.datos?.modo || "crear"; // "crear" o "editar" seg√∫n c√≥mo se abri√≥ el modal

	// Navegacion
	const handleSalir = async () => {
		// Limpiar localStorage de gaps antes de salir
		// As√≠ al volver a entrar se cargan los datos frescos de BD
		limpiarPreferenciasUI();
		// Cerrar sesi√≥n de Supabase y limpiar localStorage de configuraci√≥n
		// Esto evita que al loguearse otro usuario se intente acceder a workspaces del anterior
		await logout();
		navigate("/");                                                 // vuelve al login
	};

	// ===== MODALES PUESTOS =====
	const abrirModalNuevoPuesto = () => abrirModal("nuevoPuesto");    // abre modal para crear puesto
	const abrirModalEditarPuestos = () => abrirModal("editarPuestos");// abre modal para editar lista de puestos
	const abrirModalConfigPuesto = () => abrirModal("configPuesto");  // abre modal de configuraci√≥n global del puesto
	const abrirModalConfigurarAgente = () => abrirVentanaConfigAgente(configuracionSeleccionada?.id); // abre ventana de configuraci√≥n del agente
	const abrirModalGestionarAccesos = () => setModalAccesosAbierto(true); // abre modal de gesti√≥n de accesos
	const abrirModalPanelPermisos = () => setModalPanelPermisosAbierto(true); // abre modal de panel de permisos

	const handleCrearPuesto = (nombre, color) => {
		agregarPuesto(nombre, color);                                 // crea el puesto v√≠a contexto
		cerrarModal("nuevoPuesto");
	};

	const handleGuardarPuestos = async (puestosEditados) => {
		// Cerrar modal inmediatamente y mostrar overlay a nivel de p√°gina
		cerrarModal("editarPuestos");
		setGuardandoPuestos(true);

		try {
			// Detectar puestos eliminados (est√°n en puestos original pero no en puestosEditados)
			const idsEditados = new Set(puestosEditados.map(p => p.id));
			const puestosEliminados = puestos.filter(p => !idsEditados.has(p.id));

			// Primero eliminar los puestos que fueron removidos de la lista
			for (const puesto of puestosEliminados) {
				await eliminarPuesto(puesto.id);
			}

			// Luego actualizar los puestos restantes (nombres/colores)
			if (puestosEditados.length > 0) {
				await actualizarPuestos(puestosEditados);
			}
		} catch (error) {
			console.error('Error guardando puestos:', error);
		} finally {
			setGuardandoPuestos(false);
		}
	};

	// Handler para cambio de escala de puesto: establece la escala y limpia las escalas individuales
	const handleEscalaPuestoChange = useCallback((puestoId, escala) => {
		// Encontrar el puesto para obtener sus alimentadores
		const puesto = puestos.find(p => p.id === puestoId);
		if (puesto && puesto.alimentadores) {
			// Limpiar las escalas individuales de todos los alimentadores del puesto
			puesto.alimentadores.forEach(alim => {
				resetearEscalaTarjeta(alim.id);
			});
		}
		// Establecer la nueva escala del puesto
		establecerEscalaPuesto(puestoId, escala);
	}, [puestos, establecerEscalaPuesto, resetearEscalaTarjeta]);

	// ===== MODALES ALIMENTADORES =====
	const abrirModalNuevoAlim = () => abrirModal("alimentador", { modo: "crear" });

	const abrirModalEditarAlim = (_puestoId, alimentador) =>
		abrirModal("alimentador", { modo: "editar", alimentadorId: alimentador.id });

	const handleGuardarAlimentador = async (datos) => {
		if (!datos || !datos.nombre || !puestoSeleccionado) return;

		// Solo mostrar skeleton si estamos creando (no al editar)
		if (modoAlimentador === "crear") {
			setGuardandoAlimentador(true);                        // activar skeleton
			cerrarModal("alimentador");                           // cerrar modal INMEDIATAMENTE para ver el skeleton
		}

		try {
			if (modoAlimentador === "crear") {
				const nuevoAlimentador = await agregarAlimentador(datos); // alta de nuevo alimentador
				// Establecer gap horizontal inicial de 10px para el nuevo alimentador
				if (nuevoAlimentador?.id) {
					establecerGap(nuevoAlimentador.id, 10);
				}
			} else if (alimentadorEnEdicion) {
				if (esCreador) {
					// CREADOR: Guardar todo en BASE (BD)
					const gapActual = obtenerGap(alimentadorEnEdicion.id);
					await actualizarAlimentador(
						puestoSeleccionado.id,
						alimentadorEnEdicion.id,
						{
							...datos,
							gapHorizontal: gapActual, // mantener el gap actual
						}
					);
				} else {
					// INVITADO (operador/observador): Solo guardar el color en preferencias personales
					if (datos.color && preferenciasVisuales?.guardarPreferenciasAlimentador) {
						await preferenciasVisuales.guardarPreferenciasAlimentador(
							alimentadorEnEdicion.id,
							{ color: datos.color }
						);
					}
				}
				cerrarModal("alimentador");                           // en edici√≥n, cerrar despu√©s de guardar
			}
		} catch (error) {
			console.error("Error guardando alimentador:", error);
			setGuardandoAlimentador(false);                       // desactivar skeleton si hay error
			// Aqu√≠ podr√≠as mostrar un toast de error
		} finally {
			// Desactivar skeleton despu√©s de un peque√±o delay para que se vea la transici√≥n
			if (modoAlimentador === "crear") {
				setTimeout(() => {
					setGuardandoAlimentador(false);
				}, 300);
			}
		}
	};

	const handleEliminarAlimentador = () => {
		if (!puestoSeleccionado || !alimentadorEnEdicion) return;

		// por seguridad, detiene mediciones antes de eliminar
		detenerMedicion(alimentadorEnEdicion.id, "rele");
		detenerMedicion(alimentadorEnEdicion.id, "analizador");

		eliminarAlimentador(puestoSeleccionado.id, alimentadorEnEdicion.id);
		cerrarModal("alimentador");
	};

	// ===== POLLING DE LECTURAS =====
	// Verifica si un alimentador est√° haciendo polling
	const estaPolling = (alimId) => !!alimentadoresPolling[alimId];

	// Obtiene el contador de lecturas de polling para un alimentador
	const obtenerContadorPolling = (alimId) => contadoresPolling[alimId] || 0;

	// Obtiene el error de LECTURA de un alimentador por zona
	// (errores de red NO activan el overlay de tarjeta, solo el banner global)
	// Devuelve objeto con:
	//   - superior/inferior: boolean - true si hay AL MENOS 1 error (para mostrar "ERROR" en box)
	//   - superiorCritico/inferiorCritico: boolean - true si hay 3+ errores (para mostrar overlay)
	const obtenerErrorPolling = (alimId) => {
		// Solo usamos contadoresErrorLectura (NO contadoresErrorRed)
		// Los errores de red se muestran en el banner global, no en las tarjetas
		const contadorSuperior = contadoresErrorLectura[`${alimId}_superior`] || 0;
		const contadorInferior = contadoresErrorLectura[`${alimId}_inferior`] || 0;

		// Si no hay errores de lectura en ninguna zona, devolver null
		if (contadorSuperior === 0 && contadorInferior === 0) return null;

		return {
			// Para mostrar "ERROR" en los boxes (desde el primer error de lectura)
			superior: contadorSuperior >= 1,
			inferior: contadorInferior >= 1,
			// Para mostrar overlay de ATENCI√ìN (despu√©s de 3 errores de lectura consecutivos)
			superiorCritico: contadorSuperior >= 3,
			inferiorCritico: contadorInferior >= 3,
		};
	};

	// Funci√≥n para obtener lecturas de un registrador y actualizar el estado
	const fetchLecturasRegistrador = useCallback(async (alimId, registradorId, zona = null) => {
		// Clave para el contador de errores: usa zona si est√° especificada
		const claveError = zona ? `${alimId}_${zona}` : `${alimId}_superior`; // default a superior si no hay zona

		try {
			const lecturas = await obtenerUltimasLecturasPorRegistrador(registradorId, 1);

			// Si el fetch fue exitoso, resetear errores de red para esta zona
			// y actualizar estado global de conexi√≥n
			setContadoresErrorRed((prev) => {
				if (prev[claveError]) {
					const nuevo = { ...prev };
					delete nuevo[claveError];
					// Si ya no hay errores de red en ninguna zona, conexi√≥n OK
					if (Object.keys(nuevo).length === 0) {
						setHayProblemaConexion(false);
					}
					return nuevo;
				}
				return prev;
			});

			// Si no hay lecturas disponibles, simplemente no hacer nada (no es un error)
			if (!lecturas || lecturas.length === 0) {
				return;
			}

			const lectura = lecturas[0];

			// Guardar lectura por zona si se especifica, o global si no
			const clavePolling = zona ? `${alimId}_${zona}` : alimId;
			setLecturasPolling((prev) => ({
				...prev,
				[clavePolling]: lectura,
			}));

			// Verificar si la lectura tiene error (exito === false)
			// Esto indica que el AGENTE no pudo leer del equipo Modbus
			const tieneErrorLectura = lectura.exito === false;

			if (tieneErrorLectura) {
				// Incrementar contador de errores de LECTURA (agente no pudo leer del Modbus)
				setContadoresErrorLectura((prev) => ({
					...prev,
					[claveError]: (prev[claveError] || 0) + 1,
				}));
				// NOTA: No incrementamos contadorPolling aqu√≠ para evitar m√∫ltiples incrementos
				// cuando hay varias zonas. El contador se incrementa en iniciarPolling.
				return; // No actualizar valores si hay error de lectura
			}

			// Si llegamos aqu√≠, la lectura es exitosa - resetear contador de errores de lectura
			setContadoresErrorLectura((prev) => {
				if (prev[claveError]) {
					const nuevo = { ...prev };
					delete nuevo[claveError];
					return nuevo;
				}
				return prev;
			});

			// Transformar los valores al formato esperado por calcularValoresLadoTarjeta
			// La lectura tiene: { id, registrador_id, timestamp, valores: [...], indice_inicial, cantidad_registros, ... }
			// El formato esperado es: { rele: [{ index, address, value }, ...] }
			if (lectura.valores && Array.isArray(lectura.valores)) {
				const indiceInicial = lectura.indice_inicial ?? 0;

				const registrosTransformados = lectura.valores.map((valor, idx) => ({
					index: idx,
					address: indiceInicial + idx,
					value: valor,
				}));

				// Actualizar registrosEnVivo acumulando con registros existentes
				// Esto permite que m√∫ltiples registradores contribuyan datos a la misma card
				actualizarRegistros(alimId, (prevRegistros) => {
					const registrosAnteriores = prevRegistros?.rele || [];
					// Filtrar registros anteriores que no est√©n en el rango del nuevo registrador
					// para evitar duplicados, luego agregar los nuevos
					const rangoNuevo = new Set(registrosTransformados.map(r => r.address));
					const registrosFiltrados = registrosAnteriores.filter(r => !rangoNuevo.has(r.address));
					return {
						rele: [...registrosFiltrados, ...registrosTransformados]
					};
				});

				// Guardar lectura en IndexedDB para historial (solo lecturas exitosas)
				// Se guarda por zona para poder consultar el historial por zona despu√©s
				guardarLecturaLocal(alimId, registradorId, zona, {
					timestamp: lectura.timestamp ? new Date(lectura.timestamp).getTime() : Date.now(),
					valores: lectura.valores,
					indiceInicial: indiceInicial,
					exito: true,
				});

				// NOTA: No incrementamos contadorPolling aqu√≠ para evitar m√∫ltiples incrementos
				// cuando hay varias zonas. El contador se incrementa en iniciarPolling.
			}
		} catch (error) {
			// Error de RED: el frontend no pudo comunicarse con el backend
			// (usuario sin internet, backend ca√≠do, timeout, etc.)
			console.error(`[Polling] Error de red obteniendo lecturas para alimentador ${alimId}:`, error);
			setContadoresErrorRed((prev) => ({
				...prev,
				[claveError]: (prev[claveError] || 0) + 1,
			}));
			// Marcar que hay problema de conexi√≥n global
			setHayProblemaConexion(true);
		}
	}, [actualizarRegistros, guardarLecturaLocal]);

	// Extrae los registrador_id √∫nicos del card_design de un alimentador
	const obtenerRegistradoresDeAlim = useCallback((alim) => {
		const registradores = [];
		const card_design = alim.card_design;

		const regSuperior = card_design?.superior?.registrador_id;
		const regInferior = card_design?.inferior?.registrador_id;

		if (regSuperior && regInferior) {
			// Ambas zonas tienen registrador configurado
			if (regSuperior === regInferior) {
				// Mismo registrador para ambas zonas
				registradores.push({ zona: "superior", zonas: ["superior", "inferior"], id: regSuperior });
			} else {
				// Registradores diferentes para cada zona
				registradores.push({ zona: "superior", id: regSuperior });
				registradores.push({ zona: "inferior", id: regInferior });
			}
		} else if (regSuperior) {
			// Solo hay registrador en superior - asumimos que cubre ambas zonas de la tarjeta
			registradores.push({ zona: "superior", zonas: ["superior", "inferior"], id: regSuperior });
		} else if (regInferior) {
			// Solo hay registrador en inferior - asumimos que cubre ambas zonas de la tarjeta
			registradores.push({ zona: "inferior", zonas: ["superior", "inferior"], id: regInferior });
		}

		// Compatibilidad: si no hay registradores en zonas, usar el de la ra√≠z (formato antiguo)
		if (registradores.length === 0 && alim.registrador_id) {
			registradores.push({ zona: "legacy", zonas: ["superior", "inferior"], id: alim.registrador_id });
		}

		return registradores;
	}, []);

	// Inicia el polling para un alimentador
	const iniciarPolling = useCallback((alim) => {
		const registradores = obtenerRegistradoresDeAlim(alim);

		if (registradores.length === 0) {
			console.warn(`[Polling] Alimentador ${alim.id} no tiene registradores configurados`);
			return;
		}

		if (!alim.intervalo_consulta_ms) {
			console.warn(`[Polling] Alimentador ${alim.id} no tiene intervalo de consulta configurado`);
			return;
		}

		// Limpiar intervalos existentes si hay
		if (pollingIntervalsRef.current[alim.id]) {
			// Puede ser un array de intervalos si hay m√∫ltiples registradores
			const intervalos = pollingIntervalsRef.current[alim.id];
			if (Array.isArray(intervalos)) {
				intervalos.forEach(clearInterval);
			} else {
				clearInterval(intervalos);
			}
		}
		// Limpiar intervalo del contador si existe
		if (contadorIntervalsRef.current[alim.id]) {
			clearInterval(contadorIntervalsRef.current[alim.id]);
		}

		// Crear intervalos para cada registrador √∫nico
		const intervalos = [];

		registradores.forEach(({ zona, zonas, id: registradorId }) => {
			// Si el registrador cubre m√∫ltiples zonas, usar ese array; si no, usar la zona individual
			const zonasACubrir = zonas || [zona];

			// Hacer la primera lectura inmediatamente para cada zona que cubre este registrador
			zonasACubrir.forEach((z) => {
				fetchLecturasRegistrador(alim.id, registradorId, z);
			});

			// Configurar intervalo para lecturas peri√≥dicas
			const intervalId = setInterval(() => {
				zonasACubrir.forEach((z) => {
					fetchLecturasRegistrador(alim.id, registradorId, z);
				});
			}, alim.intervalo_consulta_ms);

			intervalos.push(intervalId);
		});

		pollingIntervalsRef.current[alim.id] = intervalos.length === 1 ? intervalos[0] : intervalos;

		// Incrementar contador inmediatamente para la primera lectura
		setContadoresPolling((prev) => ({
			...prev,
			[alim.id]: (prev[alim.id] || 0) + 1,
		}));

		// Crear un intervalo separado SOLO para incrementar el contador (1 vez por ciclo)
		// Esto evita m√∫ltiples incrementos cuando hay varios registradores/zonas
		const contadorIntervalId = setInterval(() => {
			setContadoresPolling((prev) => ({
				...prev,
				[alim.id]: (prev[alim.id] || 0) + 1,
			}));
		}, alim.intervalo_consulta_ms);

		contadorIntervalsRef.current[alim.id] = contadorIntervalId;
	}, [fetchLecturasRegistrador, obtenerRegistradoresDeAlim]);

	// Detiene el polling para un alimentador
	const detenerPolling = useCallback((alimId) => {
		if (pollingIntervalsRef.current[alimId]) {
			// Puede ser un array de intervalos si hay m√∫ltiples registradores
			const intervalos = pollingIntervalsRef.current[alimId];
			if (Array.isArray(intervalos)) {
				intervalos.forEach(clearInterval);
			} else {
				clearInterval(intervalos);
			}
			delete pollingIntervalsRef.current[alimId];
		}
		// Limpiar el intervalo del contador de animaci√≥n
		if (contadorIntervalsRef.current[alimId]) {
			clearInterval(contadorIntervalsRef.current[alimId]);
			delete contadorIntervalsRef.current[alimId];
		}
		// Limpiar las lecturas de polling para ese alimentador (incluyendo las de zonas)
		setLecturasPolling((prev) => {
			const nuevo = { ...prev };
			delete nuevo[alimId];
			delete nuevo[`${alimId}_superior`];
			delete nuevo[`${alimId}_inferior`];
			delete nuevo[`${alimId}_legacy`];
			return nuevo;
		});
		// Resetear el contador de lecturas para ese alimentador
		setContadoresPolling((prev) => {
			const nuevo = { ...prev };
			delete nuevo[alimId];
			return nuevo;
		});
		// Limpiar contadores de errores de lectura para ese alimentador (ambas zonas)
		setContadoresErrorLectura((prev) => {
			const claveSup = `${alimId}_superior`;
			const claveInf = `${alimId}_inferior`;
			if (prev[claveSup] || prev[claveInf]) {
				const nuevo = { ...prev };
				delete nuevo[claveSup];
				delete nuevo[claveInf];
				return nuevo;
			}
			return prev;
		});
		// Limpiar contadores de errores de red para ese alimentador (ambas zonas)
		setContadoresErrorRed((prev) => {
			const claveSup = `${alimId}_superior`;
			const claveInf = `${alimId}_inferior`;
			if (prev[claveSup] || prev[claveInf]) {
				const nuevo = { ...prev };
				delete nuevo[claveSup];
				delete nuevo[claveInf];
				// Si ya no hay errores de red, actualizar estado global
				if (Object.keys(nuevo).length === 0) {
					setHayProblemaConexion(false);
				}
				return nuevo;
			}
			return prev;
		});
	}, []);

	// Alterna el polling de un alimentador (play/stop)
	const handlePlayStopClick = useCallback((alimId) => {
		const alimentador = buscarAlimentador(alimId);
		if (!alimentador) return;

		const estaActivo = alimentadoresPolling[alimId];

		if (estaActivo) {
			// Detener polling
			detenerPolling(alimId);
		} else {
			// Iniciar polling
			iniciarPolling(alimentador);
		}

		// Actualizar estado visual
		setAlimentadoresPolling((prev) => ({
			...prev,
			[alimId]: !prev[alimId],
		}));
	}, [alimentadoresPolling, buscarAlimentador, detenerPolling, iniciarPolling]);

	// Helper para limpiar intervalos (puede ser un solo intervalo o un array)
	const limpiarIntervalos = (intervalos) => {
		if (Array.isArray(intervalos)) {
			intervalos.forEach(clearInterval);
		} else {
			clearInterval(intervalos);
		}
	};

	// Limpiar todos los intervalos al desmontar el componente
	useEffect(() => {
		return () => {
			Object.values(pollingIntervalsRef.current).forEach(limpiarIntervalos);
		};
	}, []);

	// ===== DRAG & DROP =====
	const handleDragStartAlim = (alimId) => {
		alIniciarArrastre(alimId);                                    // guarda qu√© tarjeta se est√° arrastrando
	};

	const handleDragEndAlim = () => {
		alTerminarArrastre();                                         // limpia estado de drag
	};

	const handleDropAlim = (targetAlimId) => {
		if (!puestoSeleccionado || !elementoArrastrandoId) return;

		const nuevaLista = reordenarLista(
			puestoSeleccionado.alimentadores,
			elementoArrastrandoId,
			targetAlimId
		);                                                             // calcula nuevo orden interno

		// Resetear el gap de la tarjeta movida al valor por defecto
		establecerGap(elementoArrastrandoId, GAP_DEFAULT);

		reordenarAlimentadores(puestoSeleccionado.id, nuevaLista);     // guarda el nuevo orden en el contexto
		alTerminarArrastre();
	};

	const handleDropAlimAlFinal = () => {
		if (!puestoSeleccionado || !elementoArrastrandoId) return;

		const nuevaLista = moverAlFinal(
			puestoSeleccionado.alimentadores,
			elementoArrastrandoId
		);                                                             // mueve la tarjeta arrastrada al final

		// Resetear el gap de la tarjeta movida al valor por defecto
		establecerGap(elementoArrastrandoId, GAP_DEFAULT);

		reordenarAlimentadores(puestoSeleccionado.id, nuevaLista);
		alTerminarArrastre();
	};

	// Estado de carga (solo mostrar si NO estamos sincronizando)
	// Durante la sincronizaci√≥n, el overlay de "Guardando cambios..." se encarga del feedback
	if (cargando && !sincronizando) {
		return (
			<div className="alim-page alim-page--cargando">
				<div className="alim-loading">
					<div className="alim-loading__spinner"></div>
					<p>Cargando configuraci√≥n...</p>
				</div>
			</div>
		);
	}

	// Estado de error
	if (error) {
		return (
			<div className="alim-page alim-page--error">
				<div className="alim-error">
					<p>Error: {error}</p>
					<button onClick={() => window.location.reload()}>Reintentar</button>
				</div>
			</div>
		);
	}

	return (
		<div className="alim-page">
			{/* Overlay de guardando puestos (portal a body) */}
			{guardandoPuestos && ReactDOM.createPortal(
				<div className="guardar-overlay">
					<div className="guardar-overlay__contenido">
						<div className="guardar-overlay__spinner" />
						<span className="guardar-overlay__texto">Guardando cambios...</span>
					</div>
				</div>,
				document.body
			)}


			{/* ===== NAV SUPERIOR ===== */}
			<BarraNavegacion
				esCompacto={esCompacto}
				puestos={puestos}
				puestoSeleccionado={puestoSeleccionado}
				onSeleccionarPuesto={seleccionarPuesto}
				onAbrirModalNuevoPuesto={abrirModalNuevoPuesto}
				onAbrirModalEditarPuestos={abrirModalEditarPuestos}
				onAbrirModalConfigPuesto={abrirModalConfigPuesto}
				onAbrirModalConfigurarAgente={abrirModalConfigurarAgente}
				onAbrirModalGestionarAccesos={abrirModalGestionarAccesos}
				onAbrirModalPanelPermisos={abrirModalPanelPermisos}
				onSalir={handleSalir}
				onAbrirMenu={() => setMenuAbierto(true)}
				coloresSistema={COLORES_SISTEMA}
				estaPolling={estaPolling}
				onPlayStopClick={handlePlayStopClick}
			/>

			{/* ===== MENU LATERAL (modo compacto) ===== */}
			{/* En modo compacto (m√≥vil), NO se muestra la secci√≥n de Escala Global */}
			{/* La escala se fuerza a 1 autom√°ticamente (ver escalaGlobalEfectiva) */}
			{esCompacto && (
				<MenuLateral
					abierto={menuAbierto}
					onCerrar={() => setMenuAbierto(false)}
					puestos={puestos}
					puestoSeleccionado={puestoSeleccionado}
					onSeleccionarPuesto={seleccionarPuesto}
					onAbrirModalNuevoPuesto={abrirModalNuevoPuesto}
					onAbrirModalEditarPuestos={abrirModalEditarPuestos}
					onAbrirModalConfigurarAgente={abrirModalConfigurarAgente}
					onAbrirModalGestionarAccesos={abrirModalGestionarAccesos}
					onAbrirModalPanelPermisos={abrirModalPanelPermisos}
					onSalir={handleSalir}
					coloresSistema={COLORES_SISTEMA}
				/>
			)}

			{/* ===== MAIN ===== */}
			<main
				className="alim-main"
				style={{ backgroundColor: puestoSeleccionado ? (obtenerBgColorPuesto(puestoSeleccionado.id) || "#e5e7eb") : "#e5e7eb" }} // usa bgColor del puesto (con preferencias de invitado)
			>
				{/* Overlay de problema de conexi√≥n (errores de red) */}
				{hayProblemaConexion && (
					<div className="alim-overlay-conexion">
						<div className="alim-overlay-conexion__contenido">
							<span className="alim-overlay-conexion__icono">‚ö†</span>
							<span className="alim-overlay-conexion__titulo">SIN CONEXI√ìN</span>
							<span className="alim-overlay-conexion__texto">
								No se pueden obtener lecturas del servidor
							</span>
						</div>
					</div>
				)}

				{/* Caso 1: Sin workspace asignado */}
				{!configuracionSeleccionada ? (
					<div className="alim-sin-workspace">
						<h2>Sin acceso a workspaces</h2>
						<p>No tienes ning√∫n workspace asignado.</p>
						<p>Contacta a un administrador para que te asigne acceso a un workspace.</p>
						<button onClick={handleSalir}>Volver al inicio</button>
					</div>
				) : !puestoSeleccionado ? (
					/* Caso 2: Tiene workspace pero sin puestos */
					<div className="alim-empty-state">
						<p>
							No hay puestos creados. Haz clic en el boton "+" para agregar
							uno.
						</p>
					</div>
				) : (
					/* Caso 3: Tiene workspace y puestos */
					<>
						<GrillaTarjetas
							alimentadores={alimentadoresConPreferencias}
							lecturas={lecturasTarjetas}
							puestoId={puestoSeleccionado.id}
							workspaceId={configuracionSeleccionada?.id}
							elementoArrastrandoId={elementoArrastrandoId}
							onAbrirConfiguracion={abrirModalEditarAlim}
							onAbrirHistorial={(puestoId, alim) => {
								abrirVentana(alim, alim.card_design);
							}}
							onDragStart={handleDragStartAlim}
							onDragOver={alPasarPorEncima}
							onDrop={handleDropAlim}
							onDragEnd={handleDragEndAlim}
							skeletonCard={guardandoAlimentador ? <SkeletonCard /> : null}
							onDropAlFinal={handleDropAlimAlFinal}
							onAgregarNuevo={abrirModalNuevoAlim}
							puedeAgregarNuevo={
								configuracionSeleccionada?.esCreador
									? (rolGlobal === 'superadmin' || rolGlobal === 'admin')
									: (configuracionSeleccionada?.rol === 'admin')
							}
							// Observador no puede ver estad√≠sticas (ni global ni en workspace)
							esObservador={rolGlobal === 'observador' || configuracionSeleccionada?.rol === 'observador'}
							estaMidiendo={estaMidiendo}
							obtenerTimestampInicio={obtenerTimestampInicio}
							obtenerContadorLecturas={obtenerContadorLecturas}
							obtenerGap={obtenerGap}
							onGapChange={establecerGap}
							obtenerRowGap={obtenerRowGap}
							onRowGapChange={establecerRowGap}
							// Polling de lecturas
							estaPolling={estaPolling}
							onPlayStopClick={handlePlayStopClick}
							obtenerContadorPolling={obtenerContadorPolling}
							obtenerErrorPolling={obtenerErrorPolling}
							// Escala de tarjetas (usa wrapper que fuerza 1 en modo compacto/m√≥vil)
							obtenerEscalaEfectiva={obtenerEscalaEfectivaConModoCompacto}
							onEscalaChange={establecerEscalaTarjeta}
							ESCALA_MIN={ESCALA_MIN}
							ESCALA_MAX={ESCALA_MAX}
						/>
					</>
				)}
			</main>

			{/* ===== MODALES ===== */}
			<ModalNuevoPuesto
				abierto={estadoModalNuevoPuesto.abierto}
				onCerrar={() => cerrarModal("nuevoPuesto")}
				onCrear={handleCrearPuesto}
				coloresSistema={COLORES_SISTEMA}
			/>

			<ModalEditarPuestos
				abierto={estadoModalEditarPuestos.abierto}
				puestos={puestosConPreferencias}
				onCerrar={() => cerrarModal("editarPuestos")}
				onGuardar={handleGuardarPuestos}
				esCreador={configuracionSeleccionada?.esCreador}
				rolEnWorkspace={configuracionSeleccionada?.rol}
				// En modo compacto (m√≥vil), no mostrar controles de escala de puesto
				obtenerEscalaPuesto={!esCompacto ? obtenerEscalaPuesto : undefined}
				onEscalaPuestoChange={!esCompacto ? handleEscalaPuestoChange : undefined}
				ESCALA_MIN={ESCALA_MIN}
				ESCALA_MAX={ESCALA_MAX}
				// Estilos globales de tarjetas (pesta√±a Apariencia)
				estilosGlobales={estilosGlobales}
				onGuardarEstilos={guardarEstilosGlobales}
			/>

			<ModalConfiguracionAlimentador
				abierto={estadoModalAlimentador.abierto}
				puestoNombre={puestoSeleccionado?.nombre || ""}
				workspaceId={configuracionSeleccionada?.id}
				modo={modoAlimentador}
				initialData={alimentadorEnEdicion}
				onCancelar={() => cerrarModal("alimentador")}
				onConfirmar={handleGuardarAlimentador}
				onEliminar={handleEliminarAlimentador}
				esCreador={configuracionSeleccionada?.esCreador}
				rolEnWorkspace={configuracionSeleccionada?.rol}
			/>

			<ModalConfiguracionPuesto
				abierto={estadoModalConfigPuesto.abierto}
				puesto={puestoSeleccionado}
				onCerrar={() => cerrarModal("configPuesto")}
				estaPolling={estaPolling}
				onPlayStopClick={handlePlayStopClick}
				buscarRegistrador={buscarRegistrador}
			/>

			<ModalConfigurarAgente
				abierto={ventanaConfigAgente.abierta}
				workspaceId={ventanaConfigAgente.workspaceId}
				onCerrar={cerrarVentanaConfigAgente}
				minimizada={ventanaConfigAgente.minimizada}
				maximizada={ventanaConfigAgente.maximizada}
				posicion={ventanaConfigAgente.posicion}
				zIndex={ventanaConfigAgente.zIndex}
				onMinimizar={toggleMinimizarConfigAgente}
				onMaximizar={toggleMaximizarConfigAgente}
				onEnfocar={enfocarVentanaConfigAgente}
				onMover={moverVentanaConfigAgente}
			/>

			<ModalGestionarAccesos
				abierto={modalAccesosAbierto}
				workspaceId={configuracionSeleccionada?.id}
				workspaceNombre={configuracionSeleccionada?.nombre}
				usuarioActualId={perfil?.id}
				onCerrar={() => setModalAccesosAbierto(false)}
			/>

			<ModalPanelPermisos
				abierto={modalPanelPermisosAbierto}
				onCerrar={() => setModalPanelPermisosAbierto(false)}
			/>

			{/* Sistema de ventanas flotantes de historial */}
			<ContenedorVentanasHistorial
				listaVentanas={listaVentanas}
				ventanasMinimizadas={ventanasMinimizadas}
				cerrarVentana={cerrarVentana}
				toggleMinimizar={toggleMinimizar}
				toggleMaximizar={toggleMaximizar}
				enfocarVentana={enfocarVentana}
				moverVentana={moverVentana}
			/>
		</div>
	);
};

export default VistaAlimentadores;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (VistaAlimentadores.jsx)

 - Es el "tablero de control" visual de los alimentadores: aqu√≠ se ensamblan
   la barra de navegaci√≥n, el men√∫ lateral, la grilla de tarjetas y todos los
   modales de creaci√≥n/edici√≥n/mapeo.

 - Lee todos los datos y acciones desde `usarContextoAlimentadores()` y los
   reparte a los distintos componentes (nav, tarjetas, modales) sin guardar
   l√≥gica de negocio ac√° adentro.

 - `useGestorModales` centraliza qu√© modal est√° abierto y con qu√© datos, lo que
   permite abrir/cerrar cada uno con una simple clave (`"nuevoPuesto"`,
   `"editarPuestos"`, `"alimentador"`, `"mapeo"`).

 - `usarArrastrarSoltar` se encarga del drag & drop de tarjetas; esta vista solo
   coordina cu√°ndo llamar a `reordenarAlimentadores` con la nueva lista.

 - A nivel mental:
   * ContextoAlimentadores = sala de m√°quinas (datos + l√≥gica).
   * VistaAlimentadores = tablero de control que el usuario ve y manipula.
---------------------------------------------------------------------------*/}

{/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (VistaAlimentadores.jsx)

0) Visi√≥n general del archivo

   `VistaAlimentadores` es el ‚Äútablero de control‚Äù que ve el usuario:

   - Muestra:
       ‚Ä¢ barra superior con puestos y bot√≥n de salir,
       ‚Ä¢ men√∫ lateral en pantallas chicas,
       ‚Ä¢ grilla de tarjetas de alimentadores,
       ‚Ä¢ modales para crear/editar puestos,
       ‚Ä¢ modales para configurar alimentadores y mapear mediciones.

   - No calcula negocios pesados por su cuenta:
       ‚Ä¢ lee datos y funciones del contexto (`usarContextoAlimentadores`),
       ‚Ä¢ usa hooks auxiliares (`useGestorModales`, `usarArrastrarSoltar`),
       ‚Ä¢ y simplemente coordina qui√©n ve qu√©, y cu√°ndo.


1) Imports principales

   import React, { useEffect, useState } from "react";
   import { useNavigate } from "react-router-dom";
   import "./VistaAlimentadores.css";

   - React + hooks para estado y efectos (`useState`, `useEffect`).
   - `useNavigate` sirve para volver al login cuando el usuario quiere salir.
   - El CSS define el layout (grid, espaciados, colores de fondo, etc.).

   Luego se importan componentes de UI:

   - `BarraNavegacion`, `MenuLateral`, `GrillaTarjetas`,
   - `ModalNuevoPuesto`, `ModalEditarPuestos`,
   - `ModalConfiguracionAlimentador`, `ModalMapeoMediciones`.

   Y hooks/constantes de apoyo:

   - `COLORES_SISTEMA`              ‚Üí define la paleta que se usa para los puestos.
   - `usarArrastrarSoltar`          ‚Üí l√≥gica de drag & drop.
   - `usarContextoAlimentadores`    ‚Üí acceso a datos y acciones del contexto.
   - `useGestorModales`             ‚Üí qui√©n est√° abierto, con qu√© datos, etc.


2) Inicio del componente y lectura de contexto

   const VistaAlimentadores = () => {
     const navigate = useNavigate();

     const {
       puestos,
       puestoSeleccionado,
       agregarPuesto,
       seleccionarPuesto,
       actualizarPuestos,
       agregarAlimentador,
       actualizarAlimentador,
       eliminarAlimentador,
       reordenarAlimentadores,
       lecturasTarjetas,
       estaMidiendo,
       obtenerRegistros,
       obtenerTimestampInicio,
       obtenerContadorLecturas,
       alternarMedicion,
       detenerMedicion,
     } = usarContextoAlimentadores();

   - `useNavigate()`:
       ‚Ä¢ da la funci√≥n `navigate`, usada para volver al login (`navigate("/")`).

   - `usarContextoAlimentadores()`:
       ‚Ä¢ trae todo lo que el contexto ofrece:
           - datos: lista de `puestos`, `puestoSeleccionado`, `lecturasTarjetas`,
           - acciones sobre puestos y alimentadores,
           - acciones y helpers de mediciones (`estaMidiendo`, `obtenerRegistros`, etc.).

   En resumen: ac√° ‚Äúenchuf√°s‚Äù la vista al motor de datos.


3) Hook de drag & drop

   const {
     elementoArrastrandoId,
     alIniciarArrastre,
     alTerminarArrastre,
     alPasarPorEncima,
     reordenarLista,
     moverAlFinal,
   } = usarArrastrarSoltar();

   - `usarArrastrarSoltar` encapsula:
       ‚Ä¢ qu√© tarjeta se est√° arrastrando,
       ‚Ä¢ c√≥mo reordenar una lista,
       ‚Ä¢ c√≥mo mover un √≠tem al final.

   - Esta vista no se preocupa por los detalles internos de drag & drop:
       ‚Ä¢ solo llama a estas funciones en los momentos correctos (onDragStart, onDragOver, onDrop, etc.).


4) Gestor de modales

   const { abrirModal, cerrarModal, obtenerEstado } = useGestorModales();

   - `useGestorModales` es un ‚Äúmini gestor de ventanas‚Äù:
       ‚Ä¢ cada modal se identifica con una clave string:
           - "nuevoPuesto",
           - "editarPuestos",
           - "alimentador",
           - "mapeo".
       ‚Ä¢ cada clave tiene un estado `{ abierto, datos }`.

   - `abrirModal(id, datos?)`     ‚Üí abre el modal y puede asociarle datos.
   - `cerrarModal(id)`            ‚Üí lo cierra.
   - `obtenerEstado(id)`          ‚Üí devuelve siempre `{ abierto, datos }` (aunque nunca se haya usado).


5) Estados locales de layout (menu y modo compacto)

   const [menuAbierto, setMenuAbierto] = useState(false);
   const [esCompacto, setEsCompacto] = useState(false);

   - `menuAbierto`:
       ‚Ä¢ controla si el men√∫ lateral (drawer) est√° desplegado en modo mobile.

   - `esCompacto`:
       ‚Ä¢ indica si la pantalla se considera ‚Äúangosta‚Äù (por ejemplo mobile o tablet)
         y activa la versi√≥n con men√∫ lateral.


6) useEffect para detectar modo compacto (responsive)

   useEffect(() => {
     const actualizarModo = () => setEsCompacto(window.innerWidth < 900);
     actualizarModo();
     window.addEventListener("resize", actualizarModo);
     return () => window.removeEventListener("resize", actualizarModo);
   }, []);

   - Al montar la vista:
       ‚Ä¢ ejecuta `actualizarModo()` una vez para decidir si es compacto o no,
       ‚Ä¢ agrega un listener a `resize` para que, si cambia el tama√±o de ventana,
         se actualice `esCompacto`.

   - Al desmontar:
       ‚Ä¢ remueve el listener para evitar fugas de memoria o comportamientos raros.

   - Regla:
       ‚Ä¢ si el ancho de ventana es menor a 900 px ‚Üí `esCompacto = true`,
       ‚Ä¢ si no ‚Üí `esCompacto = false`.


7) Estado de modales (le√≠do desde useGestorModales)

   const estadoModalNuevoPuesto = obtenerEstado("nuevoPuesto");
   const estadoModalEditarPuestos = obtenerEstado("editarPuestos");
   const estadoModalAlimentador = obtenerEstado("alimentador");
   const estadoModalMapeo = obtenerEstado("mapeo");

   - Cada uno devuelve un objeto de la forma:
       { abierto: boolean, datos: any }

   - As√≠ se sabe:
       ‚Ä¢ si el modal est√° visible (`abierto`),
       ‚Ä¢ y qu√© datos se pasaron al abrirlo (`datos`).


8) Helpers para obtener un alimentador y derivar datos para modales

   const buscarAlimentador = (alimId) =>
     puestoSeleccionado?.alimentadores.find((a) => a.id === alimId) || null;

   const alimentadorEnEdicion = estadoModalAlimentador.datos?.alimentadorId
     ? buscarAlimentador(estadoModalAlimentador.datos.alimentadorId)
     : null;

   const modoAlimentador = estadoModalAlimentador.datos?.modo || "crear";

   const alimentadorParaMapeo = estadoModalMapeo.datos?.alimentadorId
     ? buscarAlimentador(estadoModalMapeo.datos.alimentadorId)
     : null;

   - `buscarAlimentador(alimId)`:
       ‚Ä¢ busca dentro de `puestoSeleccionado.alimentadores` el que tiene ese id,
       ‚Ä¢ si no existe o no hay puesto seleccionado, devuelve null.

   - `alimentadorEnEdicion`:
       ‚Ä¢ si el modal `"alimentador"` fue abierto con `{ alimentadorId }`,
         se busca ese alimentador y se usa como base para el formulario.

   - `modoAlimentador`:
       ‚Ä¢ puede ser "crear" o "editar",
       ‚Ä¢ seg√∫n c√≥mo se haya abierto el modal.

   - `alimentadorParaMapeo`:
       ‚Ä¢ similar a `alimentadorEnEdicion`, pero exclusivo para el modal de `"mapeo"`.


9) Navegaci√≥n: salir al login

   const handleSalir = () => navigate("/");

   - Se pasa a la barra superior y al men√∫ lateral.
   - Cuando se invoca, redirige a la ruta ra√≠z (login).


10) L√≥gica de modales de puestos

   const abrirModalNuevoPuesto = () => abrirModal("nuevoPuesto");
   const abrirModalEditarPuestos = () => abrirModal("editarPuestos");

   const handleCrearPuesto = (nombre, color) => {
     agregarPuesto(nombre, color);
     cerrarModal("nuevoPuesto");
   };

   const handleGuardarPuestos = (puestosEditados) => {
     actualizarPuestos(puestosEditados);
     cerrarModal("editarPuestos");
   };

   - `abrirModalNuevoPuesto`:
       ‚Ä¢ abre el modal de alta de puesto.

   - `abrirModalEditarPuestos`:
       ‚Ä¢ abre el modal de edici√≥n masiva (nombres, colores, etc.).

   - `handleCrearPuesto`:
       ‚Ä¢ llama a `agregarPuesto` del contexto,
       ‚Ä¢ cierra el modal.

   - `handleGuardarPuestos`:
       ‚Ä¢ recibe la lista editada desde el modal,
       ‚Ä¢ llama a `actualizarPuestos` para guardarla,
       ‚Ä¢ cierra el modal.


11) L√≥gica de modales de alimentadores

   const abrirModalNuevoAlim = () => abrirModal("alimentador", { modo: "crear" });

   const abrirModalEditarAlim = (_puestoId, alimentador) =>
     abrirModal("alimentador", { modo: "editar", alimentadorId: alimentador.id });

   const abrirModalMapeo = (_puestoId, alimentador) =>
     abrirModal("mapeo", { alimentadorId: alimentador.id });

   const handleGuardarAlimentador = (datos) => {
     if (!datos || !datos.nombre || !puestoSeleccionado) return;

     if (modoAlimentador === "crear") {
       agregarAlimentador(datos);
     } else if (alimentadorEnEdicion) {
       actualizarAlimentador(
         puestoSeleccionado.id,
         alimentadorEnEdicion.id,
         datos
       );
     }

     cerrarModal("alimentador");
   };

   const handleEliminarAlimentador = () => {
     if (!puestoSeleccionado || !alimentadorEnEdicion) return;

     detenerMedicion(alimentadorEnEdicion.id, "rele");
     detenerMedicion(alimentadorEnEdicion.id, "analizador");

     eliminarAlimentador(puestoSeleccionado.id, alimentadorEnEdicion.id);
     cerrarModal("alimentador");
   };

   const handleGuardarMapeo = (nuevoMapeo) => {
     if (!puestoSeleccionado || !alimentadorParaMapeo) return;

     actualizarAlimentador(puestoSeleccionado.id, alimentadorParaMapeo.id, {
       mapeoMediciones: nuevoMapeo,
     });
     cerrarModal("mapeo");
   };

   - Aperturas:
       ‚Ä¢ nuevo alimentador ‚Üí modo "crear",
       ‚Ä¢ editar alimentador ‚Üí modo "editar" + id del alimentador,
       ‚Ä¢ mapeo ‚Üí solo id del alimentador.

   - Guardar alimentador:
       ‚Ä¢ si el modo es "crear"       ‚Üí alta nueva,
       ‚Ä¢ si el modo es "editar"      ‚Üí actualiza el alimentador existente.

   - Eliminar alimentador:
       ‚Ä¢ por seguridad, corta medici√≥n de rele y analizador,
       ‚Ä¢ luego lo elimina del puesto.

   - Guardar mapeo:
       ‚Ä¢ actualiza solo `mapeoMediciones` del alimentador,
       ‚Ä¢ el resto de datos queda intacto.


12) L√≥gica de mediciones (rele y analizador)

   const handleAlternarMedicionRele = (alimId, overrideConfig) => {
     const alim = buscarAlimentador(alimId);
     if (!alim) return;
     alternarMedicion(alim, "rele", overrideConfig);
   };

   const handleAlternarMedicionAnalizador = (alimId, overrideConfig) => {
     const alim = buscarAlimentador(alimId);
     if (!alim) return;
     alternarMedicion(alim, "analizador", overrideConfig);
   };

   - Estas funciones:
       ‚Ä¢ buscan el alimentador por id,
       ‚Ä¢ llaman al helper `alternarMedicion` del contexto,
       ‚Ä¢ pasan el `overrideConfig` si viene desde el modal (periodo, ip, etc.).

   - La vista no decide si iniciar o detener:
       ‚Ä¢ solo dice ‚Äúaltern√°‚Äù, el hook resuelve.


13) L√≥gica de drag & drop

   const handleDragStartAlim = (alimId) => {
     alIniciarArrastre(alimId);
   };

   const handleDragEndAlim = () => {
     alTerminarArrastre();
   };

   const handleDropAlim = (targetAlimId) => {
     if (!puestoSeleccionado || !elementoArrastrandoId) return;

     const nuevaLista = reordenarLista(
       puestoSeleccionado.alimentadores,
       elementoArrastrandoId,
       targetAlimId
     );

     reordenarAlimentadores(puestoSeleccionado.id, nuevaLista);
     alTerminarArrastre();
   };

   const handleDropAlimAlFinal = () => {
     if (!puestoSeleccionado || !elementoArrastrandoId) return;

     const nuevaLista = moverAlFinal(
       puestoSeleccionado.alimentadores,
       elementoArrastrandoId
     );

     reordenarAlimentadores(puestoSeleccionado.id, nuevaLista);
     alTerminarArrastre();
   };

   - `handleDragStartAlim`:
       ‚Ä¢ se engancha a `onDragStart` de cada tarjeta,
       ‚Ä¢ marca qu√© alimentador se est√° arrastrando.

   - `handleDragEndAlim`:
       ‚Ä¢ limpia el estado de drag cuando termina el arrastre.

   - `handleDropAlim(targetAlimId)`:
       ‚Ä¢ se llama al soltar sobre otra tarjeta,
       ‚Ä¢ calcula el nuevo orden de la lista usando `reordenarLista`,
       ‚Ä¢ guarda ese orden con `reordenarAlimentadores` (contexto),
       ‚Ä¢ resetea el estado de drag.

   - `handleDropAlimAlFinal`:
       ‚Ä¢ se activa en la zona de ‚Äúsoltar para mandar al final‚Äù,
       ‚Ä¢ calcula la lista con `moverAlFinal`,
       ‚Ä¢ guarda el nuevo orden,
       ‚Ä¢ limpia estado de drag.


14) Render principal (JSX)

   return (
     <div className="alim-page">

       // NAV SUPERIOR 
       <BarraNavegacion ... />

       // MENU LATERAL (solo si esCompacto) 
       {esCompacto && <MenuLateral ... />}

       // MAIN 
       <main className="alim-main" style={{ backgroundColor: ... }}>
         { !puestoSeleccionado ? (
           // estado vac√≠o sin puestos
         ) : (
           <>
             { puestoSeleccionado.alimentadores.length === 0 && (
               // mensaje ‚Äúno hay alimentadores‚Äù
             )}

             <GrillaTarjetas
               // lista de alimentadores
               // lecturas procesadas
               // handlers de drag, de configuraci√≥n, de mapeo, etc.
             />
           </>
         )}
       </main>

       // MODALES 
       <ModalNuevoPuesto ... />
       <ModalEditarPuestos ... />
       <ModalConfiguracionAlimentador ... />
       <ModalMapeoMediciones ... />
     </div>
   );

   - La estructura visual queda as√≠:
       ‚Ä¢ `BarraNavegacion` arriba,
       ‚Ä¢ `MenuLateral` solo en modo compacto,
       ‚Ä¢ `main` con fondo seg√∫n `bgColor` del puesto,
       ‚Ä¢ `GrillaTarjetas` para las cards,
       ‚Ä¢ todos los modales montados al final (solo se ven cuando `abierto = true`).

   - `GrillaTarjetas` recibe:
       ‚Ä¢ alimentadores,
       ‚Ä¢ lecturas ya procesadas (`lecturasTarjetas`),
       ‚Ä¢ callbacks para abrir modales,
       ‚Ä¢ callbacks para drag & drop,
       ‚Ä¢ helpers de estado de medici√≥n y contadores.


15) Export

   export default VistaAlimentadores;

   - Exporta el componente para usarlo en la ruta `/alimentadores` de la app.
   - Es la vista principal del panel de alimentadores.

---------------------------------------------------------------------------------------*/}

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ColorPickerSimple.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/modales/ColorPickerSimple.jsx
// Componente minimalista de selector de color con picker inline

import React, { useState, useRef, useEffect } from "react";
import { createPortal } from "react-dom";
import { HexColorPicker, HexColorInput } from "react-colorful";
import "./ColorPickerSimple.css";

const ColorPickerSimple = ({ color, onChange, label, posicionArriba = false }) => {
	const [mostrarPicker, setMostrarPicker] = useState(false);
	const [posicion, setPosicion] = useState({ top: 0, left: 0 });
	const [valorHex, setValorHex] = useState(color);
	const pickerRef = useRef(null);
	const buttonRef = useRef(null);

	// Calcular posici√≥n del picker al abrirlo/cerrarlo (toggle)
	const togglePicker = (e) => {
		e.stopPropagation();

		// Si ya est√° abierto, cerrarlo
		if (mostrarPicker) {
			setMostrarPicker(false);
			return;
		}

		if (buttonRef.current) {
			const rect = buttonRef.current.getBoundingClientRect();
			// Altura aproximada del popover (picker + input hex)
			const alturaPopover = 260;
			const anchoPopover = 240;

			// Calcular posici√≥n vertical
			let top;
			if (posicionArriba) {
				top = rect.top - alturaPopover - 8;
				// Si no cabe arriba, mostrar abajo
				if (top < 10) {
					top = rect.bottom + 8;
				}
			} else {
				top = rect.bottom + 8;
				// Si no cabe abajo, mostrar arriba
				if (top + alturaPopover > window.innerHeight - 10) {
					top = rect.top - alturaPopover - 8;
				}
			}

			// Calcular posici√≥n horizontal centrada
			let left = rect.left + rect.width / 2 - anchoPopover / 2;
			// Asegurar que no se salga por la izquierda
			if (left < 10) {
				left = 10;
			}
			// Asegurar que no se salga por la derecha
			if (left + anchoPopover > window.innerWidth - 10) {
				left = window.innerWidth - anchoPopover - 10;
			}

			setPosicion({ top, left });
			setMostrarPicker(true);
		}
	};

	// Actualizar valor hex cuando cambia el color desde el picker
	const handleColorChange = (nuevoColor) => {
		setValorHex(nuevoColor);
		onChange(nuevoColor);
	};

	// Manejar cambio en el input de texto
	const handleInputChange = (e) => {
		const valor = e.target.value;
		setValorHex(valor);

		// Validar que sea un color hex v√°lido antes de notificar al padre
		if (/^#[0-9A-Fa-f]{6}$/.test(valor)) {
			onChange(valor);
		}
	};

	// Copiar al portapapeles
	const copiarColor = () => {
		navigator.clipboard.writeText(valorHex);
	};

	// Cerrar el picker al hacer click fuera
	useEffect(() => {
		if (!mostrarPicker) return;

		const handleClickOutside = (event) => {
			if (
				pickerRef.current &&
				!pickerRef.current.contains(event.target) &&
				buttonRef.current &&
				!buttonRef.current.contains(event.target)
			) {
				setMostrarPicker(false);
			}
		};

		// Agregar listener despu√©s de un peque√±o delay para evitar que el mismo click que abre el picker lo cierre
		const timeoutId = setTimeout(() => {
			document.addEventListener("mousedown", handleClickOutside);
		}, 10);

		return () => {
			clearTimeout(timeoutId);
			document.removeEventListener("mousedown", handleClickOutside);
		};
	}, [mostrarPicker]);

	return (
		<div className="color-picker-simple">
			<span className="color-picker-simple-label">{label}</span>
			<div className="color-picker-simple-wrapper">
				<button
					ref={buttonRef}
					type="button"
					className="color-picker-simple-button"
					style={{ backgroundColor: color }}
					onClick={togglePicker}
				/>
				{mostrarPicker &&
					createPortal(
						<div
							ref={pickerRef}
							className="color-picker-simple-popover"
							style={{ top: `${posicion.top}px`, left: `${posicion.left}px` }}
							onClick={(e) => e.stopPropagation()}
							onMouseDown={(e) => e.stopPropagation()}
						>
							<HexColorPicker color={color} onChange={handleColorChange} />
							<div className="color-picker-hex-input-wrapper">
								<input
									type="text"
									value={valorHex}
									onChange={handleInputChange}
									className="color-picker-hex-input"
									placeholder="#000000"
									maxLength={7}
								/>
								<button
									type="button"
									className="color-picker-copy-btn"
									onClick={copiarColor}
									title="Copiar color"
								>
									üìã
								</button>
							</div>
						</div>,
						document.body
					)}
			</div>
		</div>
	);
};

export default ColorPickerSimple;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ConfiguracionRele.jsx ==========
import { useState, useEffect, useMemo, useRef, useCallback } from "react";
import { useModelosRele } from "../../hooks/useModelosRele";
import {
  SEVERIDADES,
  CONEXION_MODBUS_DEFAULT,
} from "../../constantes/datosBaseReles";
import { solicitarTestRegistrador, consultarTestRegistrador, solicitarTestCoils } from "../../../../servicios/apiService";
import ModalGestionModelosRele from "./ModalGestionModelosRele";
import "./ConfiguracionRele.css";

/**
 * Componente para configurar un registrador de tipo Rel√© de Protecci√≥n.
 * Permite seleccionar modelo, configuraci√≥n, par√°metros de conexi√≥n,
 * escala CT/VT y protecciones a monitorear.
 *
 * @param {Object} configuracionInicial - Configuraci√≥n inicial del rel√©
 * @param {Function} onChange - Callback al cambiar la configuraci√≥n
 * @param {string} agenteId - ID del agente que ejecutar√° los tests de conexi√≥n (opcional)
 */
const ConfiguracionRele = ({ configuracionInicial, onChange, agenteId }) => {
  const {
    getModelos,
    getConfiguracionesDeModelo,
    getProtecciones,
    getProteccionesAgrupadas,
    tieneCapacidad,
  } = useModelosRele();

  // Estado para modal de gesti√≥n de modelos
  const [modalGestionAbierto, setModalGestionAbierto] = useState(false);

  // Estado para test de conexi√≥n
  const [testEnProgreso, setTestEnProgreso] = useState(false);
  const [resultadoTest, setResultadoTest] = useState(null);

  // Estado para test de coils (lectura de bits)
  const [testCoilsEnProgreso, setTestCoilsEnProgreso] = useState(false);
  const [resultadoTestCoils, setResultadoTestCoils] = useState(null);
  const [coilsDireccion, setCoilsDireccion] = useState(2880); // PHLPTOC1 START por defecto
  const [coilsCantidad, setCoilsCantidad] = useState(32);

  // Ref para evitar bucle infinito en notificaci√≥n de cambios
  const configAnteriorRef = useRef(null);
  const inicializadoRef = useRef(false);

  // Estado del formulario
  const [config, setConfig] = useState({
    modeloId: "",
    configuracionId: "",
    conexion: {
      ip: "",
      puerto: "",
      unitId: "",
      timeout: CONEXION_MODBUS_DEFAULT.timeout,
    },
    registros: {
      corrientes: { IL1: "", IL2: "", IL3: "", Io: "" },
      tensiones: { VA: "", VB: "", VC: "", VAB: "", VBC: "", VCA: "" },
      estadoCB: { registro: "", bitCerrado: "", bitAbierto: "", bitError: "" },
    },
    proteccionesMonitoreadas: [],
    intervaloSegundos: "",
    ...configuracionInicial,
  });

  // Cargar configuraci√≥n inicial si existe (solo una vez al montar)
  useEffect(() => {
    if (configuracionInicial && !inicializadoRef.current) {
      inicializadoRef.current = true;
      setConfig((prev) => ({
        ...prev,
        ...configuracionInicial,
        conexion: {
          ...prev.conexion,
          ...configuracionInicial?.conexion,
        },
        registros: {
          ...prev.registros,
          ...configuracionInicial?.registros,
        },
      }));
      // Guardar referencia inicial para comparaci√≥n
      configAnteriorRef.current = JSON.stringify(configuracionInicial);
    }
  }, [configuracionInicial]);

  // Notificar cambios al padre - evitando bucle infinito
  useEffect(() => {
    if (!onChange) return;

    const configActualStr = JSON.stringify(config);

    // Solo notificar si hay un cambio real en los valores
    if (configAnteriorRef.current !== configActualStr) {
      configAnteriorRef.current = configActualStr;
      onChange(config);
    }
  }, [config, onChange]);

  // Modelos disponibles
  const modelos = useMemo(() => getModelos(), [getModelos]);

  // Configuraciones disponibles seg√∫n modelo seleccionado
  const configuracionesDisponibles = useMemo(() => {
    if (!config.modeloId) return [];
    return getConfiguracionesDeModelo(config.modeloId);
  }, [config.modeloId, getConfiguracionesDeModelo]);

  // Protecciones de la configuraci√≥n seleccionada
  const proteccionesDisponibles = useMemo(() => {
    if (!config.configuracionId) return [];
    return getProtecciones(config.configuracionId);
  }, [config.configuracionId, getProtecciones]);

  // Protecciones agrupadas por categor√≠a
  const proteccionesAgrupadas = useMemo(() => {
    if (!config.configuracionId) return {};
    return getProteccionesAgrupadas(config.configuracionId);
  }, [config.configuracionId, getProteccionesAgrupadas]);

  // ============================================================================
  // HANDLERS
  // ============================================================================

  const handleModeloChange = (e) => {
    const modeloId = e.target.value;
    setConfig((prev) => ({
      ...prev,
      modeloId,
      configuracionId: "", // Reset configuraci√≥n al cambiar modelo
      proteccionesMonitoreadas: [], // Reset protecciones
    }));
  };

  const handleConfiguracionChange = (e) => {
    const configuracionId = e.target.value;

    // Al cambiar configuraci√≥n, habilitar todas las protecciones por defecto
    const protecciones = getProtecciones(configuracionId);
    const proteccionesHabilitadas = protecciones.map((p) => ({
      codigo: p.codigo,
      habilitado: true,
      notificar: p.severidad === "critica" || p.severidad === "alta",
      etiquetaPersonalizada: null,
    }));

    setConfig((prev) => ({
      ...prev,
      configuracionId,
      proteccionesMonitoreadas: proteccionesHabilitadas,
    }));
  };

  const handleConexionChange = (campo, valor) => {
    setConfig((prev) => ({
      ...prev,
      conexion: {
        ...prev.conexion,
        [campo]: valor,
      },
    }));
  };

  const handleRegistroChange = (grupo, campo, valor) => {
    setConfig((prev) => ({
      ...prev,
      registros: {
        ...prev.registros,
        [grupo]: {
          ...prev.registros[grupo],
          [campo]: valor === "" ? "" : parseInt(valor),
        },
      },
    }));
  };

  const handleProteccionToggle = (codigoProteccion) => {
    setConfig((prev) => {
      const proteccionesActualizadas = prev.proteccionesMonitoreadas.map((p) =>
        p.codigo === codigoProteccion ? { ...p, habilitado: !p.habilitado } : p
      );
      return { ...prev, proteccionesMonitoreadas: proteccionesActualizadas };
    });
  };

  const handleNotificarToggle = (codigoProteccion) => {
    setConfig((prev) => {
      const proteccionesActualizadas = prev.proteccionesMonitoreadas.map((p) =>
        p.codigo === codigoProteccion ? { ...p, notificar: !p.notificar } : p
      );
      return { ...prev, proteccionesMonitoreadas: proteccionesActualizadas };
    });
  };

  const handleSeleccionarTodas = (categoria, seleccionar) => {
    const proteccionesCategoria = proteccionesAgrupadas[categoria]?.protecciones || [];
    const codigosCategoria = proteccionesCategoria.map((p) => p.codigo);

    setConfig((prev) => {
      const proteccionesActualizadas = prev.proteccionesMonitoreadas.map((p) =>
        codigosCategoria.includes(p.codigo) ? { ...p, habilitado: seleccionar } : p
      );
      return { ...prev, proteccionesMonitoreadas: proteccionesActualizadas };
    });
  };

  // Obtener estado de una protecci√≥n
  const getEstadoProteccion = (codigoProteccion) => {
    return (
      config.proteccionesMonitoreadas.find((p) => p.codigo === codigoProteccion) || {
        habilitado: false,
        notificar: false,
        etiquetaPersonalizada: null,
      }
    );
  };

  // Cuando se crea un modelo desde el modal
  const handleModeloCreado = (modeloId, configId) => {
    setConfig((prev) => ({
      ...prev,
      modeloId,
      configuracionId: configId,
    }));
  };

  // ============================================================================
  // TEST DE CONEXI√ìN
  // ============================================================================

  /**
   * Interpreta un bit espec√≠fico de un valor de registro
   */
  const leerBit = (valor, bit) => {
    return ((valor >> bit) & 1) === 1;
  };

  /**
   * Analiza los registros obtenidos y genera las l√≠neas de resultado
   */
  const analizarRegistros = useCallback((registros, indiceInicial) => {
    const lineas = [];

    // Funci√≥n helper para obtener valor de un registro
    const getValor = (registro) => {
      const idx = registro - indiceInicial;
      if (idx >= 0 && idx < registros.length) {
        return registros[idx];
      }
      return null;
    };

    // === 1. LISTA COMPLETA DE REGISTROS ===
    lineas.push({ tipo: "titulo", texto: `üìä Registros ${indiceInicial} - ${indiceInicial + registros.length - 1} (${registros.length})` });

    // Mostrar todos los registros en formato tabla
    for (let i = 0; i < registros.length; i++) {
      const regNum = indiceInicial + i;
      const valor = registros[i];
      const esRelevante = valor !== 0;
      lineas.push({
        tipo: "registro-item",
        registro: regNum,
        valor: valor,
        relevante: esRelevante,
      });
    }

    // === 2. CORRIENTES ===
    if (tieneCapacidad(config.configuracionId, "medicionCorriente")) {
      lineas.push({ tipo: "titulo", texto: "‚ö° Corrientes" });
      const regIL1 = config.registros.corrientes.IL1;
      const regIL2 = config.registros.corrientes.IL2;
      const regIL3 = config.registros.corrientes.IL3;
      const regIo = config.registros.corrientes.Io;

      if (regIL1) {
        const val = getValor(parseInt(regIL1));
        lineas.push({ tipo: "dato", label: `IL1 [${regIL1}]`, valor: val !== null ? val : "N/A", unidad: "" });
      }
      if (regIL2) {
        const val = getValor(parseInt(regIL2));
        lineas.push({ tipo: "dato", label: `IL2 [${regIL2}]`, valor: val !== null ? val : "N/A", unidad: "" });
      }
      if (regIL3) {
        const val = getValor(parseInt(regIL3));
        lineas.push({ tipo: "dato", label: `IL3 [${regIL3}]`, valor: val !== null ? val : "N/A", unidad: "" });
      }
      if (regIo) {
        const val = getValor(parseInt(regIo));
        lineas.push({ tipo: "dato", label: `Io [${regIo}]`, valor: val !== null ? val : "N/A", unidad: "" });
      }
    }

    // === 3. TENSIONES ===
    if (tieneCapacidad(config.configuracionId, "medicionTension")) {
      lineas.push({ tipo: "titulo", texto: "üîå Tensiones" });
      const regVA = config.registros.tensiones.VA;
      const regVB = config.registros.tensiones.VB;
      const regVC = config.registros.tensiones.VC;

      if (regVA) {
        const val = getValor(parseInt(regVA));
        lineas.push({ tipo: "dato", label: `VA [${regVA}]`, valor: val !== null ? val : "N/A", unidad: "" });
      }
      if (regVB) {
        const val = getValor(parseInt(regVB));
        lineas.push({ tipo: "dato", label: `VB [${regVB}]`, valor: val !== null ? val : "N/A", unidad: "" });
      }
      if (regVC) {
        const val = getValor(parseInt(regVC));
        lineas.push({ tipo: "dato", label: `VC [${regVC}]`, valor: val !== null ? val : "N/A", unidad: "" });
      }
    }

    // === 4. ESTADO DEL INTERRUPTOR ===
    lineas.push({ tipo: "titulo", texto: "üî≤ Interruptor" });
    const regCB = config.registros.estadoCB.registro;
    if (regCB) {
      const valCB = getValor(parseInt(regCB));
      if (valCB !== null) {
        const bitCerrado = config.registros.estadoCB.bitCerrado;
        const bitAbierto = config.registros.estadoCB.bitAbierto;
        const bitError = config.registros.estadoCB.bitError;

        let estado = "Desconocido";
        if (bitCerrado !== "" && leerBit(valCB, parseInt(bitCerrado))) {
          estado = "üü¢ Cerrado";
        } else if (bitAbierto !== "" && leerBit(valCB, parseInt(bitAbierto))) {
          estado = "üî¥ Abierto";
        }
        if (bitError !== "" && leerBit(valCB, parseInt(bitError))) {
          estado += " ‚ö†Ô∏è Error";
        }

        lineas.push({ tipo: "dato", label: "Estado", valor: estado, unidad: "" });

        // Mostrar el valor del registro con desglose de bits activos
        const bitsActivos = [];
        for (let b = 0; b < 16; b++) {
          if (leerBit(valCB, b)) bitsActivos.push(b);
        }
        lineas.push({
          tipo: "dato",
          label: `Reg [${regCB}]`,
          valor: `0x${valCB.toString(16).padStart(4, "0")} (${valCB}) - bits: ${bitsActivos.join(",")}`,
          unidad: ""
        });
      } else {
        lineas.push({ tipo: "dato", label: "Estado", valor: "N/A (registro fuera de rango)", unidad: "" });
      }
    }

    // === 5. ALARMAS ACTIVAS (protecciones disparadas) ===
    const protecciones = proteccionesDisponibles;
    const alarmasActivas = [];
    const proteccionesNormales = [];

    if (protecciones.length > 0) {
      for (const prot of protecciones) {
        const regStart = prot.registroStart;
        const bitStart = prot.bitStart;
        const regOperate = prot.registroOperate;
        const bitOperate = prot.bitOperate;

        let estadoProt = [];
        let tieneAlarma = false;

        // Verificar Start
        if (regStart !== undefined && regStart !== "") {
          const valStart = getValor(parseInt(regStart));
          if (valStart !== null && bitStart !== undefined && bitStart !== "") {
            const activo = leerBit(valStart, parseInt(bitStart));
            if (activo) {
              estadoProt.push(`START [${regStart}.${bitStart}]`);
              tieneAlarma = true;
            }
          }
        }

        // Verificar Operate
        if (regOperate !== undefined && regOperate !== "") {
          const valOp = getValor(parseInt(regOperate));
          if (valOp !== null && bitOperate !== undefined && bitOperate !== "") {
            const activo = leerBit(valOp, parseInt(bitOperate));
            if (activo) {
              estadoProt.push(`OPERATE [${regOperate}.${bitOperate}]`);
              tieneAlarma = true;
            }
          }
        }

        if (tieneAlarma) {
          alarmasActivas.push({
            tipo: "alarma-activa",
            label: prot.nombreCorto || prot.codigo,
            valor: `üî¥ ${estadoProt.join(" + ")}`,
            severidad: prot.severidad,
          });
        } else {
          proteccionesNormales.push(prot.nombreCorto || prot.codigo);
        }
      }

      // Mostrar alarmas activas primero (resaltadas)
      if (alarmasActivas.length > 0) {
        lineas.push({ tipo: "titulo", texto: "üö® ALARMAS ACTIVAS" });
        for (const alarma of alarmasActivas) {
          lineas.push(alarma);
        }
      }

      // Mostrar protecciones normales agrupadas
      if (proteccionesNormales.length > 0) {
        lineas.push({ tipo: "titulo", texto: "üõ°Ô∏è Protecciones" });
        lineas.push({
          tipo: "protecciones-ok",
          texto: `‚úÖ ${proteccionesNormales.length} protecciones OK: ${proteccionesNormales.join(", ")}`
        });
      }
    }

    return lineas;
  }, [config.configuracionId, config.registros, proteccionesDisponibles, tieneCapacidad]);

  /**
   * Ejecuta el test de conexi√≥n Modbus y analiza los resultados
   * Usa el sistema de agentes para ejecutar el test real
   */
  const ejecutarTest = async () => {
    // Validar que tengamos los datos necesarios
    if (!config.conexion.ip || !config.conexion.puerto) {
      setResultadoTest({
        error: true,
        mensaje: "Falta configurar IP y Puerto",
        lineas: [],
      });
      return;
    }

    // Validar que tengamos un agenteId para ejecutar el test
    if (!agenteId) {
      setResultadoTest({
        error: true,
        mensaje: "No hay agente configurado para ejecutar el test",
        lineas: [],
      });
      return;
    }

    const indiceInicial = config.conexion.indiceInicial ?? 0;
    const cantidad = config.conexion.cantidad ?? 20;

    setTestEnProgreso(true);
    setResultadoTest(null);

    try {
      // Solicitar el test al agente
      const respuesta = await solicitarTestRegistrador(agenteId, {
        ip: config.conexion.ip,
        puerto: parseInt(config.conexion.puerto),
        unitId: config.conexion.unitId || 1,
        indiceInicial,
        cantidadRegistros: cantidad,
      });

      const testId = respuesta.testId;

      // Polling para obtener resultado (max 30 segundos)
      const maxIntentos = 15;
      const intervaloMs = 2000;
      let intentos = 0;
      let resultado = null;

      while (intentos < maxIntentos) {
        await new Promise((resolve) => setTimeout(resolve, intervaloMs));
        intentos++;

        resultado = await consultarTestRegistrador(agenteId, testId);

        if (resultado.estado === "completado") {
          // Test exitoso - analizar registros
          const registros = resultado.valores || [];
          const lineas = analizarRegistros(registros, indiceInicial);

          setResultadoTest({
            error: false,
            mensaje: `Conexi√≥n exitosa (${resultado.tiempo_respuesta_ms || 0}ms)`,
            lineas,
            tiempoMs: resultado.tiempo_respuesta_ms,
            registrosCrudos: registros,
            indiceInicial,
          });
          return;
        } else if (resultado.estado === "error" || resultado.estado === "timeout") {
          // Test fall√≥
          setResultadoTest({
            error: true,
            mensaje: resultado.error_mensaje || "Error de conexi√≥n",
            lineas: [],
          });
          return;
        }
        // Si est√° pendiente/enviado/ejecutando, seguir esperando
      }

      // Timeout del polling
      setResultadoTest({
        error: true,
        mensaje: "Timeout: El agente no respondi√≥ a tiempo",
        lineas: [],
      });
    } catch (error) {
      setResultadoTest({
        error: true,
        mensaje: error.message || "Error al ejecutar test",
        lineas: [],
      });
    } finally {
      setTestEnProgreso(false);
    }
  };

  /**
   * Exporta los registros del √∫ltimo test a un archivo CSV
   */
  const exportarRegistrosCSV = () => {
    if (!resultadoTest || resultadoTest.error || !resultadoTest.registrosCrudos) {
      return;
    }

    const { registrosCrudos, indiceInicial } = resultadoTest;
    const ip = config.conexion.ip || "unknown";
    const puerto = config.conexion.puerto || "502";
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);

    // Crear contenido CSV
    const cabecera = "Registro,Valor";
    const filas = registrosCrudos.map((valor, idx) => {
      const registro = indiceInicial + idx;
      return `${registro},${valor}`;
    });

    const contenidoCSV = [cabecera, ...filas].join("\n");

    // Crear y descargar archivo
    const blob = new Blob([contenidoCSV], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `registros_${ip}_${puerto}_${timestamp}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  /**
   * Ejecuta el test de lectura de coils (funci√≥n Modbus 01)
   * Para leer bits individuales de protecciones
   */
  const ejecutarTestCoils = async () => {
    // Validar que tengamos los datos necesarios
    if (!config.conexion.ip || !config.conexion.puerto) {
      setResultadoTestCoils({
        error: true,
        mensaje: "Falta configurar IP y Puerto",
        coils: [],
      });
      return;
    }

    if (!agenteId) {
      setResultadoTestCoils({
        error: true,
        mensaje: "No hay agente configurado para ejecutar el test",
        coils: [],
      });
      return;
    }

    setTestCoilsEnProgreso(true);
    setResultadoTestCoils(null);

    try {
      // Solicitar el test de coils al agente
      const respuesta = await solicitarTestCoils(agenteId, {
        ip: config.conexion.ip,
        puerto: parseInt(config.conexion.puerto),
        unitId: config.conexion.unitId || 1,
        direccionCoil: coilsDireccion,
        cantidadBits: coilsCantidad,
      });

      const testId = respuesta.testId;

      // Polling para obtener resultado (max 30 segundos)
      const maxIntentos = 15;
      const intervaloMs = 2000;
      let intentos = 0;
      let resultado = null;

      while (intentos < maxIntentos) {
        await new Promise((resolve) => setTimeout(resolve, intervaloMs));
        intentos++;

        // Reutilizamos consultarTestRegistrador ya que usa la misma tabla
        resultado = await consultarTestRegistrador(agenteId, testId);

        if (resultado.estado === "completado") {
          // Test exitoso - mostrar coils
          const coils = resultado.valores || [];
          const bitsActivos = coils
            .map((c, i) => (c === 1 || c === true) ? coilsDireccion + i : null)
            .filter(b => b !== null);

          setResultadoTestCoils({
            error: false,
            mensaje: `Lectura exitosa (${resultado.tiempo_respuesta_ms || 0}ms)`,
            coils: coils.map((v, i) => ({
              direccion: coilsDireccion + i,
              valor: v === 1 || v === true ? 1 : 0,
            })),
            bitsActivos,
            tiempoMs: resultado.tiempo_respuesta_ms,
          });
          return;
        } else if (resultado.estado === "error" || resultado.estado === "timeout") {
          setResultadoTestCoils({
            error: true,
            mensaje: resultado.error_mensaje || "Error de conexi√≥n",
            coils: [],
          });
          return;
        }
        // Si est√° pendiente/enviado/ejecutando, seguir esperando
      }

      // Timeout del polling
      setResultadoTestCoils({
        error: true,
        mensaje: "Timeout: El agente no respondi√≥ a tiempo",
        coils: [],
      });
    } catch (error) {
      setResultadoTestCoils({
        error: true,
        mensaje: error.message || "Error al ejecutar test",
        coils: [],
      });
    } finally {
      setTestCoilsEnProgreso(false);
    }
  };

  // ============================================================================
  // RENDER
  // ============================================================================

  return (
    <div className="config-rele">
      {/* Fila: Modelo y Configuraci√≥n */}
      <div className="config-rele-modelo-row">
        <div className="config-rele-campo">
          <label>Modelo</label>
          <div className="config-rele-select-con-btn">
            <select
              value={config.modeloId}
              onChange={handleModeloChange}
              className="config-rele-select"
            >
              <option value="">Seleccionar...</option>
              {modelos.map((modelo) => (
                <option key={modelo.id} value={modelo.id}>
                  {modelo.icono} {modelo.fabricante} {modelo.nombre}
                </option>
              ))}
            </select>
            <button
              type="button"
              className="config-rele-btn-editar"
              onClick={() => setModalGestionAbierto(true)}
              title="Gestionar modelos"
            >
              ‚öôÔ∏è
            </button>
          </div>
        </div>

        <div className="config-rele-campo">
          <label>Configuraci√≥n</label>
          <select
            value={config.configuracionId}
            onChange={handleConfiguracionChange}
            className="config-rele-select"
            disabled={!config.modeloId}
          >
            <option value="">Seleccionar...</option>
            {configuracionesDisponibles.map((cfg) => (
              <option key={cfg.id} value={cfg.id}>
                {cfg.nombre}
              </option>
            ))}
          </select>
        </div>
      </div>

      {/* Badges de capacidades */}
      {config.configuracionId && (
        <div className="config-rele-capacidades">
          {tieneCapacidad(config.configuracionId, "medicionCorriente") && (
            <span className="config-rele-badge">‚ö° Corriente</span>
          )}
          {tieneCapacidad(config.configuracionId, "medicionTension") && (
            <span className="config-rele-badge">üîå Tensi√≥n</span>
          )}
          {tieneCapacidad(config.configuracionId, "proteccionDireccional") && (
            <span className="config-rele-badge">‚û°Ô∏è Direccional</span>
          )}
          {tieneCapacidad(config.configuracionId, "autorecierre") && (
            <span className="config-rele-badge">üîÅ Recierre</span>
          )}
          {tieneCapacidad(config.configuracionId, "proteccionDiferencial") && (
            <span className="config-rele-badge">üîÑ Diferencial</span>
          )}
        </div>
      )}

      {/* Grid principal de 4 cuadrantes */}
      <div className="config-rele-grid-principal">
        {/* Columna izquierda */}
        <div className="config-rele-columna-izq">
          {/* Secci√≥n Conexi√≥n Modbus */}
          <div className="config-rele-seccion">
            <h6>üì° Conexi√≥n Modbus TCP</h6>
            <div className="config-rele-conexion-grid">
              <div className="config-rele-campo-inline">
                <label>IP</label>
                <input
                  type="text"
                  value={config.conexion.ip}
                  onChange={(e) => handleConexionChange("ip", e.target.value)}
                  placeholder="172.16.0.1"
                />
              </div>
              <div className="config-rele-campo-inline">
                <label>Puerto</label>
                <input
                  type="number"
                  value={config.conexion.puerto}
                  onChange={(e) => handleConexionChange("puerto", e.target.value === "" ? "" : parseInt(e.target.value))}
                  placeholder="502"
                />
              </div>
              <div className="config-rele-campo-inline">
                <label>Unit ID</label>
                <input
                  type="number"
                  value={config.conexion.unitId}
                  onChange={(e) => handleConexionChange("unitId", e.target.value === "" ? "" : parseInt(e.target.value))}
                  placeholder="1"
                />
              </div>
            </div>

            {/* √çndice, Cantidad e Intervalo - dentro de Conexi√≥n Modbus */}
            {config.configuracionId && (
              <div className="config-rele-indice-grid">
                <div className="config-rele-campo-inline">
                  <label>√çndice Inicial</label>
                  <input
                    type="number"
                    value={config.conexion.indiceInicial ?? ""}
                    onChange={(e) => handleConexionChange("indiceInicial", e.target.value === "" ? "" : parseInt(e.target.value))}
                    placeholder="0"
                    min={0}
                  />
                </div>
                <div className="config-rele-campo-inline">
                  <label>Cantidad</label>
                  <input
                    type="number"
                    value={config.conexion.cantidad ?? ""}
                    onChange={(e) => handleConexionChange("cantidad", e.target.value === "" ? "" : parseInt(e.target.value))}
                    placeholder="20"
                    min={1}
                  />
                </div>
                <div className="config-rele-campo-inline">
                  <label>Intervalo</label>
                  <div className="config-rele-input-sufijo">
                    <input
                      type="number"
                      value={config.intervaloSegundos}
                      onChange={(e) =>
                        setConfig((prev) => ({
                          ...prev,
                          intervaloSegundos: e.target.value === "" ? "" : parseInt(e.target.value),
                        }))
                      }
                      placeholder="60"
                      min={1}
                      step={1}
                    />
                    <span>s</span>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Secci√≥n Test de Conexi√≥n */}
          {config.configuracionId && (
            <div className="config-rele-seccion config-rele-seccion-test">
              <div className="config-rele-test-consola">
                {testEnProgreso ? (
                  <div className="test-consola-loading">
                    <span className="test-spinner"></span>
                    <span>Ejecutando test...</span>
                  </div>
                ) : resultadoTest ? (
                  <div className={`test-consola-resultado ${resultadoTest.error ? "error" : "exito"}`}>
                    <div className="test-consola-header">
                      {resultadoTest.error ? "‚ùå" : "‚úÖ"} {resultadoTest.mensaje}
                    </div>
                    {resultadoTest.lineas.map((linea, idx) => {
                      if (linea.tipo === "titulo") {
                        return (
                          <div key={idx} className="test-consola-titulo">
                            {linea.texto}
                          </div>
                        );
                      } else if (linea.tipo === "registro-item") {
                        return (
                          <div key={idx} className={`test-consola-registro-item ${linea.relevante ? "relevante" : ""}`}>
                            <span className="registro-num">{linea.registro}</span>
                            <span className="registro-valor">{linea.valor}</span>
                          </div>
                        );
                      } else if (linea.tipo === "alarma-activa") {
                        return (
                          <div key={idx} className="test-consola-linea test-consola-alarma">
                            <span className="test-label">{linea.label}:</span>
                            <span className="test-valor">{linea.valor}</span>
                          </div>
                        );
                      } else if (linea.tipo === "protecciones-ok") {
                        return (
                          <div key={idx} className="test-consola-protecciones-ok">
                            {linea.texto}
                          </div>
                        );
                      } else if (linea.tipo === "proteccion") {
                        return (
                          <div key={idx} className="test-consola-linea test-consola-proteccion">
                            <span className="test-label">{linea.label}:</span>
                            <span className="test-valor">{linea.valor}</span>
                          </div>
                        );
                      } else {
                        return (
                          <div key={idx} className="test-consola-linea">
                            <span className="test-label">{linea.label}:</span>
                            <span className="test-valor">{linea.valor}{linea.unidad}</span>
                          </div>
                        );
                      }
                    })}
                  </div>
                ) : (
                  <div className="test-consola-vacio">
                    {!agenteId ? (
                      <span>Requiere agente conectado para probar</span>
                    ) : (
                      <span>Presiona "Test" para probar la conexi√≥n</span>
                    )}
                  </div>
                )}
              </div>
              <div className="config-rele-test-acciones">
                <button
                  type="button"
                  className="config-rele-btn-test"
                  onClick={ejecutarTest}
                  disabled={testEnProgreso || !config.conexion.ip || !config.conexion.puerto || !agenteId}
                  title={!agenteId ? "Requiere agente conectado" : "Probar conexi√≥n Modbus"}
                >
                  {testEnProgreso ? "..." : "Test"}
                </button>
                <button
                  type="button"
                  className="config-rele-btn-exportar"
                  onClick={exportarRegistrosCSV}
                  disabled={!resultadoTest || resultadoTest.error || !resultadoTest.registrosCrudos}
                  title="Exportar registros a CSV"
                >
                  CSV
                </button>
              </div>
            </div>
          )}

          {/* Secci√≥n Test de Coils (Bits) - Experimental */}
          {config.configuracionId && (
            <div className="config-rele-seccion config-rele-seccion-test-coils">
              <h6>üîò Test Coils (Bits) - Experimental</h6>
              <div className="config-rele-coils-params">
                <div className="config-rele-campo-inline">
                  <label>Dir. Inicial</label>
                  <input
                    type="number"
                    value={coilsDireccion}
                    onChange={(e) => setCoilsDireccion(parseInt(e.target.value) || 0)}
                    placeholder="2880"
                    min={0}
                  />
                </div>
                <div className="config-rele-campo-inline">
                  <label>Cantidad</label>
                  <input
                    type="number"
                    value={coilsCantidad}
                    onChange={(e) => setCoilsCantidad(parseInt(e.target.value) || 16)}
                    placeholder="32"
                    min={1}
                    max={125}
                  />
                </div>
                <button
                  type="button"
                  className="config-rele-btn-test-coils"
                  onClick={ejecutarTestCoils}
                  disabled={testCoilsEnProgreso || !config.conexion.ip || !config.conexion.puerto || !agenteId}
                  title={!agenteId ? "Requiere agente conectado" : "Leer bits (Modbus FC01)"}
                >
                  {testCoilsEnProgreso ? "Leyendo..." : "Leer Coils"}
                </button>
              </div>

              <div className="config-rele-test-consola config-rele-coils-consola">
                {testCoilsEnProgreso ? (
                  <div className="test-consola-loading">
                    <span className="test-spinner"></span>
                    <span>Leyendo coils...</span>
                  </div>
                ) : resultadoTestCoils ? (
                  <div className={`test-consola-resultado ${resultadoTestCoils.error ? "error" : "exito"}`}>
                    <div className="test-consola-header">
                      {resultadoTestCoils.error ? "‚ùå" : "‚úÖ"} {resultadoTestCoils.mensaje}
                    </div>
                    {!resultadoTestCoils.error && resultadoTestCoils.bitsActivos && (
                      <div className="test-coils-activos">
                        <strong>Bits activos ({resultadoTestCoils.bitsActivos.length}):</strong>
                        {resultadoTestCoils.bitsActivos.length > 0 ? (
                          <span className="coils-lista-activos">
                            {resultadoTestCoils.bitsActivos.join(", ")}
                          </span>
                        ) : (
                          <span className="coils-ninguno">Ninguno</span>
                        )}
                      </div>
                    )}
                    {!resultadoTestCoils.error && resultadoTestCoils.coils && (
                      <div className="test-coils-grid">
                        {resultadoTestCoils.coils.map((coil) => (
                          <div
                            key={coil.direccion}
                            className={`test-coil-item ${coil.valor === 1 ? "activo" : "inactivo"}`}
                            title={`Dir: ${coil.direccion}`}
                          >
                            <span className="coil-dir">{coil.direccion}</span>
                            <span className="coil-val">{coil.valor}</span>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                ) : (
                  <div className="test-consola-vacio">
                    <span>Lee bits con Modbus funci√≥n 01 (Read Coils)</span>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        {/* Columna derecha */}
        <div className="config-rele-columna-der">

        {/* Secci√≥n Registros Modbus - Solo si hay configuraci√≥n seleccionada */}
        {config.configuracionId && (
          <div className="config-rele-seccion">
            <h6>üìã Registros Modbus</h6>
            <div className="config-rele-registros">
              <div className="config-rele-registros-wrapper">
              {/* Corrientes - Solo si tiene capacidad */}
              {tieneCapacidad(config.configuracionId, "medicionCorriente") && (
                <div className="config-rele-registro-grupo">
                  <span className="registro-grupo-label">‚ö° Corrientes:</span>
                  <div className="config-rele-registro-campos">
                    <div className="config-rele-campo-mini">
                      <label>IL1</label>
                      <input
                        type="number"
                        value={config.registros.corrientes.IL1}
                        onChange={(e) => handleRegistroChange("corrientes", "IL1", e.target.value)}
                        placeholder="138"
                      />
                    </div>
                    <div className="config-rele-campo-mini">
                      <label>IL2</label>
                      <input
                        type="number"
                        value={config.registros.corrientes.IL2}
                        onChange={(e) => handleRegistroChange("corrientes", "IL2", e.target.value)}
                        placeholder="139"
                      />
                    </div>
                    <div className="config-rele-campo-mini">
                      <label>IL3</label>
                      <input
                        type="number"
                        value={config.registros.corrientes.IL3}
                        onChange={(e) => handleRegistroChange("corrientes", "IL3", e.target.value)}
                        placeholder="140"
                      />
                    </div>
                    <div className="config-rele-campo-mini">
                      <label>Io</label>
                      <input
                        type="number"
                        value={config.registros.corrientes.Io}
                        onChange={(e) => handleRegistroChange("corrientes", "Io", e.target.value)}
                        placeholder="141"
                      />
                    </div>
                  </div>
                </div>
              )}

              {/* Tensiones - Solo si tiene capacidad */}
              {tieneCapacidad(config.configuracionId, "medicionTension") && (
                <div className="config-rele-registro-grupo">
                  <span className="registro-grupo-label">üîå Tensiones:</span>
                  <div className="config-rele-registro-campos config-rele-registro-campos--tres">
                    <div className="config-rele-campo-mini">
                      <label>VA</label>
                      <input
                        type="number"
                        value={config.registros.tensiones.VA}
                        onChange={(e) => handleRegistroChange("tensiones", "VA", e.target.value)}
                        placeholder="152"
                      />
                    </div>
                    <div className="config-rele-campo-mini">
                      <label>VB</label>
                      <input
                        type="number"
                        value={config.registros.tensiones.VB}
                        onChange={(e) => handleRegistroChange("tensiones", "VB", e.target.value)}
                        placeholder="153"
                      />
                    </div>
                    <div className="config-rele-campo-mini">
                      <label>VC</label>
                      <input
                        type="number"
                        value={config.registros.tensiones.VC}
                        onChange={(e) => handleRegistroChange("tensiones", "VC", e.target.value)}
                        placeholder="154"
                      />
                    </div>
                  </div>
                </div>
              )}

              {/* Estado del Interruptor - Siempre visible */}
              <div className="config-rele-registro-grupo">
                <span className="registro-grupo-label">üî≤ Interruptor:</span>
                <div className="config-rele-registro-campos">
                  <div className="config-rele-campo-mini">
                    <label>Reg</label>
                    <input
                      type="number"
                      value={config.registros.estadoCB.registro}
                      onChange={(e) => handleRegistroChange("estadoCB", "registro", e.target.value)}
                      placeholder="175"
                    />
                  </div>
                  <div className="config-rele-campo-mini">
                    <label>Cerrado</label>
                    <input
                      type="number"
                      min="0"
                      max="15"
                      value={config.registros.estadoCB.bitCerrado}
                      onChange={(e) => handleRegistroChange("estadoCB", "bitCerrado", e.target.value)}
                      placeholder="4"
                    />
                  </div>
                  <div className="config-rele-campo-mini">
                    <label>Abierto</label>
                    <input
                      type="number"
                      min="0"
                      max="15"
                      value={config.registros.estadoCB.bitAbierto}
                      onChange={(e) => handleRegistroChange("estadoCB", "bitAbierto", e.target.value)}
                      placeholder="5"
                    />
                  </div>
                  <div className="config-rele-campo-mini">
                    <label>Error</label>
                    <input
                      type="number"
                      min="0"
                      max="15"
                      value={config.registros.estadoCB.bitError}
                      onChange={(e) => handleRegistroChange("estadoCB", "bitError", e.target.value)}
                      placeholder="6"
                    />
                  </div>
                </div>
              </div>
              </div>
            </div>
          </div>
        )}

          {/* Secci√≥n: Protecciones a Monitorear */}
          {config.configuracionId && (
            <div className="config-rele-seccion config-rele-seccion-protecciones">
              <h6>
                üîî Protecciones a Monitorear
                <span className="config-rele-contador">
                  {config.proteccionesMonitoreadas.filter((p) => p.habilitado).length} / {proteccionesDisponibles.length}
                </span>
              </h6>

              <div className="config-rele-protecciones">
                {Object.entries(proteccionesAgrupadas).map(([categoriaId, categoria]) => (
                  <div key={categoriaId} className="config-rele-categoria">
                    <div className="config-rele-categoria-header">
                      <span className="categoria-icono">{categoria.icono}</span>
                      <span className="categoria-nombre">{categoria.nombre}</span>
                      <div className="categoria-acciones">
                        <button
                          type="button"
                          className="btn-categoria"
                          onClick={() => handleSeleccionarTodas(categoriaId, true)}
                          title="Seleccionar todas"
                        >
                          ‚úì
                        </button>
                        <button
                          type="button"
                          className="btn-categoria"
                          onClick={() => handleSeleccionarTodas(categoriaId, false)}
                          title="Deseleccionar todas"
                        >
                          ‚úï
                        </button>
                      </div>
                    </div>

                    <div className="config-rele-protecciones-grid">
                      {categoria.protecciones.map((proteccion) => {
                        const estado = getEstadoProteccion(proteccion.codigo);
                        const severidad = SEVERIDADES[proteccion.severidad];

                        return (
                          <div
                            key={proteccion.codigo}
                            className={`config-rele-proteccion ${estado.habilitado ? "activa" : "inactiva"}`}
                          >
                            <label className="proteccion-check">
                              <input
                                type="checkbox"
                                checked={estado.habilitado}
                                onChange={() => handleProteccionToggle(proteccion.codigo)}
                              />
                              <span
                                className="proteccion-indicador"
                                style={{ backgroundColor: severidad?.color }}
                              />
                              <span className="proteccion-codigo">{proteccion.nombreCorto}</span>
                            </label>
                            <label className="proteccion-notificar" title="Notificar al activarse">
                              <input
                                type="checkbox"
                                checked={estado.notificar}
                                onChange={() => handleNotificarToggle(proteccion.codigo)}
                                disabled={!estado.habilitado}
                              />
                              <span className="notificar-icono">üîî</span>
                            </label>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Modal de Gesti√≥n de Modelos */}
      <ModalGestionModelosRele
        abierto={modalGestionAbierto}
        onCerrar={() => setModalGestionAbierto(false)}
        onModeloCreado={handleModeloCreado}
      />
    </div>
  );
};

export default ConfiguracionRele;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ContenedorVentanasHistorial.jsx ==========
/**
 * Contenedor para m√∫ltiples ventanas de historial flotantes
 * Incluye barra de tareas para ventanas minimizadas
 */

import VentanaHistorial from "./VentanaHistorial";
import "./VentanaHistorial.css";

const ContenedorVentanasHistorial = ({
  listaVentanas,
  ventanasMinimizadas,
  cerrarVentana,
  toggleMinimizar,
  toggleMaximizar,
  enfocarVentana,
  moverVentana,
}) => {
  return (
    <>
      {/* Renderizar ventanas abiertas (no minimizadas) */}
      {listaVentanas
        .filter((v) => !v.minimizada)
        .map((ventana) => (
          <VentanaHistorial
            key={ventana.id}
            ventana={ventana}
            onCerrar={() => cerrarVentana(ventana.id)}
            onMinimizar={() => toggleMinimizar(ventana.id)}
            onMaximizar={() => toggleMaximizar(ventana.id)}
            onEnfocar={() => enfocarVentana(ventana.id)}
            onMover={(pos) => moverVentana(ventana.id, pos)}
          />
        ))}

      {/* Barra de tareas para ventanas minimizadas */}
      {ventanasMinimizadas.length > 0 && (
        <div className="ventanas-barra-tareas">
          {ventanasMinimizadas.map((ventana) => (
            <div
              key={ventana.id}
              className="ventana-tarea"
              onClick={() => toggleMinimizar(ventana.id)}
            >
              <span className="ventana-tarea-icono">üìä</span>
              <span className="ventana-tarea-nombre">
                {ventana.alimentador?.nombre}
              </span>
              <button
                type="button"
                className="ventana-tarea-cerrar"
                onClick={(e) => {
                  e.stopPropagation();
                  cerrarVentana(ventana.id);
                }}
              >
                √ó
              </button>
            </div>
          ))}
        </div>
      )}
    </>
  );
};

export default ContenedorVentanasHistorial;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigInforme.jsx ==========
/**
 * Modal de configuraci√≥n para generar informes Excel
 * Permite configurar: solicitante, intervalo de muestreo
 */

import { useState, useMemo, useEffect } from "react";
import PropTypes from "prop-types";
import { INTERVALOS_INFORME } from "../../constantes/historialConfig";
import { generarImagenGrafico } from "../../utilidades/generarGraficoInforme";
import "./ModalConfigInforme.css";

/**
 * Determina qu√© intervalos est√°n habilitados seg√∫n la duraci√≥n del per√≠odo
 * @param {number} duracionMs - Duraci√≥n en milisegundos
 * @returns {number[]} - Array de IDs de intervalos habilitados
 */
const obtenerIntervalosHabilitados = (duracionMs) => {
  const duracionHoras = duracionMs / (1000 * 60 * 60);

  if (duracionHoras <= 1) {
    // Hasta 1 hora: solo 15 min
    return [15];
  } else if (duracionHoras <= 2) {
    // M√°s de 1h hasta 2h: 15 min o 30 min
    return [15, 30];
  } else if (duracionHoras <= 6) {
    // M√°s de 2h hasta 6h: 15, 30 min o 1 hora
    return [15, 30, 60];
  } else if (duracionHoras <= 12) {
    // M√°s de 6h hasta 12h: 30 min o 1 hora
    return [30, 60];
  } else if (duracionHoras <= 24) {
    // M√°s de 12h hasta 24h: 30 min, 1 hora o 3 horas
    return [30, 60, 180];
  } else if (duracionHoras <= 48) {
    // M√°s de 24h hasta 48h: 3 horas o 6 horas
    return [180, 360];
  } else {
    // M√°s de 48h (7 d√≠as o m√°s): 3, 6 o 12 horas
    return [180, 360, 720];
  }
};

const ModalConfigInforme = ({
  visible,
  onCerrar,
  onGenerar,
  datos,
  nombreAlimentador,
  tituloMedicion,
  tipoGrafico = "line",
}) => {
  const [solicitadoPor, setSolicitadoPor] = useState("");
  const [intervaloSeleccionado, setIntervaloSeleccionado] = useState(null);
  const [generando, setGenerando] = useState(false);

  // Calcular duraci√≥n del per√≠odo de datos
  const { duracionMs, fechaInicio, fechaFin } = useMemo(() => {
    if (!datos || datos.length === 0) {
      return { duracionMs: 0, fechaInicio: null, fechaFin: null };
    }

    const timestamps = datos.map((d) => new Date(d.x).getTime());
    const min = Math.min(...timestamps);
    const max = Math.max(...timestamps);

    return {
      duracionMs: max - min,
      fechaInicio: new Date(min),
      fechaFin: new Date(max),
    };
  }, [datos]);

  // Intervalos habilitados seg√∫n la duraci√≥n
  const intervalosHabilitados = useMemo(() => {
    return obtenerIntervalosHabilitados(duracionMs);
  }, [duracionMs]);

  // Seleccionar autom√°ticamente el primer intervalo habilitado si no hay selecci√≥n v√°lida
  useEffect(() => {
    if (
      intervalosHabilitados.length > 0 &&
      (!intervaloSeleccionado || !intervalosHabilitados.includes(intervaloSeleccionado))
    ) {
      setIntervaloSeleccionado(intervalosHabilitados[0]);
    }
  }, [intervalosHabilitados, intervaloSeleccionado]);

  // Filtrar datos seg√∫n el intervalo seleccionado
  // Optimizado: usa muestreo por salto de √≠ndice para datasets grandes
  const datosFiltrados = useMemo(() => {
    if (!datos || datos.length === 0 || !intervaloSeleccionado) return [];

    const intervaloMs = intervaloSeleccionado * 60 * 1000;

    // Para datasets peque√±os (< 1000 puntos), usar filtrado tradicional
    if (datos.length < 1000) {
      let ultimoTimestamp = 0;
      return datos.filter((punto) => {
        const timestamp = new Date(punto.x).getTime();
        if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs) {
          ultimoTimestamp = timestamp;
          return true;
        }
        return false;
      });
    }

    // Para datasets grandes, calcular paso estimado y usar muestreo por √≠ndice
    // Esto reduce de O(n) a O(n/paso) iteraciones
    const primerTs = new Date(datos[0].x).getTime();
    const ultimoTs = new Date(datos[datos.length - 1].x).getTime();
    const duracionTotal = ultimoTs - primerTs;

    if (duracionTotal <= 0) return [datos[0]];

    // Estimar el intervalo promedio entre puntos
    const intervaloPromedio = duracionTotal / (datos.length - 1);
    // Calcular paso aproximado de √≠ndices
    const pasoEstimado = Math.max(1, Math.floor(intervaloMs / intervaloPromedio));

    const resultado = [];
    let ultimoTimestamp = 0;

    // Iterar con saltos, pero verificar timestamp real para precisi√≥n
    for (let i = 0; i < datos.length; i += pasoEstimado) {
      const punto = datos[i];
      const timestamp = new Date(punto.x).getTime();

      if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs * 0.9) {
        resultado.push(punto);
        ultimoTimestamp = timestamp;
      }
    }

    return resultado;
  }, [datos, intervaloSeleccionado]);

  const handleGenerar = async () => {
    setGenerando(true);

    try {
      // Generar imagen del gr√°fico con los datos filtrados del modal
      const imagenGrafico = await generarImagenGrafico(datosFiltrados, {
        tipo: tipoGrafico,
        titulo: "", // Sin t√≠tulo en el gr√°fico, ya est√° en el Excel
      });

      onGenerar({
        solicitadoPor: solicitadoPor.trim() || "No especificado",
        intervalo: intervaloSeleccionado,
        datosFiltrados,
        fechaInicio,
        fechaFin,
        imagenGrafico,
      });
      onCerrar();
    } catch (err) {
      console.error("Error generando informe:", err);
    } finally {
      setGenerando(false);
    }
  };

  if (!visible) return null;

  const formatearFecha = (fecha) => {
    if (!fecha) return "--";
    return fecha.toLocaleString("es-AR", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  const duracionTexto = () => {
    const horas = Math.floor(duracionMs / (1000 * 60 * 60));
    const minutos = Math.floor((duracionMs % (1000 * 60 * 60)) / (1000 * 60));

    if (horas >= 24) {
      const dias = Math.floor(horas / 24);
      const horasRestantes = horas % 24;
      return `${dias} d√≠a${dias > 1 ? "s" : ""} ${horasRestantes}h`;
    }
    return `${horas}h ${minutos}min`;
  };

  return (
    <div className="modal-config-informe-overlay" onClick={onCerrar}>
      <div className="modal-config-informe" onClick={(e) => e.stopPropagation()}>
        <header className="modal-config-header">
          <h3>Configurar Informe</h3>
          <button type="button" className="modal-config-cerrar" onClick={onCerrar}>
            √ó
          </button>
        </header>

        <div className="modal-config-contenido">
          {/* Info del informe */}
          <div className="modal-config-info">
            <p>
              <strong>Registros para:</strong> {nombreAlimentador}
            </p>
            <p>
              <strong>Medici√≥n:</strong> {tituloMedicion}
            </p>
            <p>
              <strong>Per√≠odo:</strong> {formatearFecha(fechaInicio)} - {formatearFecha(fechaFin)}
            </p>
            <p>
              <strong>Duraci√≥n:</strong> {duracionTexto()}
            </p>
          </div>

          {/* Solicitado por */}
          <div className="modal-config-campo">
            <label htmlFor="solicitadoPor">Solicitado por:</label>
            <input
              type="text"
              id="solicitadoPor"
              value={solicitadoPor}
              onChange={(e) => setSolicitadoPor(e.target.value)}
              placeholder="Nombre del solicitante"
              autoFocus
            />
          </div>

          {/* Intervalo de muestreo */}
          <div className="modal-config-campo">
            <label>Intervalo de muestreo:</label>
            <div className="modal-config-intervalos">
              {INTERVALOS_INFORME.map((intervalo) => {
                const habilitado = intervalosHabilitados.includes(intervalo.id);
                const seleccionado = intervaloSeleccionado === intervalo.id;

                return (
                  <button
                    key={intervalo.id}
                    type="button"
                    className={`modal-config-intervalo ${seleccionado ? "seleccionado" : ""}`}
                    disabled={!habilitado}
                    onClick={() => setIntervaloSeleccionado(intervalo.id)}
                  >
                    {intervalo.label}
                  </button>
                );
              })}
            </div>
          </div>

          {/* Preview de registros */}
          <div className="modal-config-preview">
            <span>
              Registros en el informe: <strong>{datosFiltrados.length}</strong>
            </span>
          </div>
        </div>

        <footer className="modal-config-footer">
          <button type="button" className="modal-config-btn cancelar" onClick={onCerrar}>
            Cancelar
          </button>
          <button
            type="button"
            className="modal-config-btn generar"
            onClick={handleGenerar}
            disabled={datosFiltrados.length === 0 || generando}
          >
            {generando ? "Generando..." : "Generar Informe"}
          </button>
        </footer>
      </div>
    </div>
  );
};

ModalConfigInforme.propTypes = {
  visible: PropTypes.bool.isRequired,
  onCerrar: PropTypes.func.isRequired,
  onGenerar: PropTypes.func.isRequired,
  datos: PropTypes.arrayOf(
    PropTypes.shape({
      x: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.number]),
      y: PropTypes.number,
    })
  ),
  nombreAlimentador: PropTypes.string,
  tituloMedicion: PropTypes.string,
  tipoGrafico: PropTypes.oneOf(["line", "area", "bar"]),
};

ModalConfigInforme.defaultProps = {
  datos: [],
  nombreAlimentador: "Alimentador",
  tituloMedicion: "Medici√≥n",
  tipoGrafico: "line",
};

export default ModalConfigInforme;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionAlimentador.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionAlimentador.jsx
// Modal unificado para configurar alimentador: nombre, color, registrador y dise√±o de card

import { useEffect, useState, useRef } from "react";
import { HexColorPicker } from "react-colorful";
import "./ModalConfiguracionAlimentador.css";
import "./ColorPickerSimple.css";
import { COLORES_SISTEMA } from "../../constantes/colores";
import {
	listarAgentesWorkspace,
	listarRegistradoresAgente,
} from "../../../../servicios/apiService";

// Opciones predefinidas para el t√≠tulo del bloque (magnitudes t√≠picas)
const OPCIONES_TITULO = [
	{ id: "tension_linea", label: "Tensi√≥n de l√≠nea (kV)" },
	{ id: "tension_entre_lineas", label: "Tensi√≥n entre l√≠neas (kV)" },
	{ id: "corriente_132", label: "Corriente de l√≠nea (A) (en 13,2 kV)" },
	{ id: "corriente_33", label: "Corriente de l√≠nea (A) (en 33 kV)" },
	{ id: "potencia_activa", label: "Potencia activa (kW)" },
	{ id: "potencia_reactiva", label: "Potencia reactiva (kVAr)" },
	{ id: "potencia_aparente", label: "Potencia aparente (kVA)" },
	{ id: "factor_potencia", label: "Factor de Potencia" },
	{ id: "frecuencia", label: "Frecuencia (Hz)" },
	{ id: "corriente_neutro", label: "Corriente de Neutro (A)" },
	{ id: "custom", label: "Otro (personalizado)..." },
];

// Placeholders sugeridos para las etiquetas de cada box
const PLACEHOLDERS_BOX = ["Ej: R o L1", "Ej: S o L2", "Ej: T o L3", "Ej: Total"];

// Dise√±o por defecto para un lado de la card
const crearSideDesignDefault = (tituloId = "corriente_132") => ({
	tituloId,
	tituloCustom: "",
	registrador_id: null, // cada zona tiene su propio registrador
	cantidad: 3,
	oculto: false, // si true, oculta t√≠tulo y boxes de esta zona en la tarjeta
	boxes: [
		{ enabled: false, label: "", indice: null, formula: "" },
		{ enabled: false, label: "", indice: null, formula: "" },
		{ enabled: false, label: "", indice: null, formula: "" },
		{ enabled: false, label: "", indice: null, formula: "" },
	],
});

// Dise√±o por defecto para toda la card
const crearCardDesignDefault = () => ({
	superior: crearSideDesignDefault("corriente_132"),
	inferior: crearSideDesignDefault("tension_linea"),
});

const ModalConfiguracionAlimentador = ({
	abierto,
	puestoNombre,
	workspaceId,
	modo = "crear",
	initialData,
	onCancelar,
	onConfirmar,
	onEliminar,
	// Props de permisos
	esCreador = false,           // si el usuario es creador del workspace
	rolEnWorkspace = null,       // rol del usuario en el workspace (admin, operador, observador)
}) => {
	// Determinar permisos seg√∫n rol
	const esAdmin = esCreador || rolEnWorkspace === 'admin';
	// Admin puede todo, operador y observador solo pueden cambiar el color
	const puedeEditarNombre = esAdmin;
	const puedeEditarDiseno = esAdmin;
	const puedeEliminar = esAdmin;
	const puedeEditarIntervalo = esAdmin;
	const puedeOcultarZonas = esAdmin;
	// === Estado b√°sico ===
	const [nombre, setNombre] = useState("");
	const [color, setColor] = useState(COLORES_SISTEMA[0]);
	const [mostrarPicker, setMostrarPicker] = useState(false);
	const [colorPersonalizado, setColorPersonalizado] = useState("#ff6b6b");
	const [valorHex, setValorHex] = useState("#ff6b6b");
	const pickerRef = useRef(null);
	const pickerBtnRef = useRef(null);

	// === Estado de registrador ===
	const [agentesVinculados, setAgentesVinculados] = useState([]);
	const [registradoresPorAgente, setRegistradoresPorAgente] = useState({});
	const [cargandoAgentes, setCargandoAgentes] = useState(false);

	// === Estado de configuraci√≥n ===
	const [intervaloConsultaSeg, setIntervaloConsultaSeg] = useState(60); // en segundos (default 60, m√≠nimo 5)
	const [cardDesign, setCardDesign] = useState(crearCardDesignDefault());

	// === Helpers ===
	const esColorPersonalizado = !COLORES_SISTEMA.includes(color);

	// === Detecci√≥n de √≠ndices duplicados ===
	const detectarIndicesDuplicados = () => {
		const indicesUsados = [];
		const duplicados = [];

		// Recolectar √≠ndices de parte superior
		const boxesSuperior = cardDesign.superior?.boxes || [];
		boxesSuperior.forEach((box, idx) => {
			if (box.indice !== null && box.indice !== undefined && box.indice !== "") {
				const clave = String(box.indice);
				const info = { zona: "superior", boxNum: idx + 1, indice: box.indice };

				const existente = indicesUsados.find((r) => r.clave === clave);
				if (existente) {
					duplicados.push({ ...info, duplicadoCon: existente.info });
				} else {
					indicesUsados.push({ clave, info });
				}
			}
		});

		// Recolectar √≠ndices de parte inferior
		const boxesInferior = cardDesign.inferior?.boxes || [];
		boxesInferior.forEach((box, idx) => {
			if (box.indice !== null && box.indice !== undefined && box.indice !== "") {
				const clave = String(box.indice);
				const info = { zona: "inferior", boxNum: idx + 1, indice: box.indice };

				const existente = indicesUsados.find((r) => r.clave === clave);
				if (existente) {
					duplicados.push({ ...info, duplicadoCon: existente.info });
				} else {
					indicesUsados.push({ clave, info });
				}
			}
		});

		return duplicados;
	};

	const indicesDuplicados = detectarIndicesDuplicados();

	// Crear set de claves duplicadas
	const clavesDuplicadas = new Set();
	indicesDuplicados.forEach((dup) => {
		clavesDuplicadas.add(`${dup.zona}-${dup.boxNum - 1}-${dup.indice}`);
		clavesDuplicadas.add(`${dup.duplicadoCon.zona}-${dup.duplicadoCon.boxNum - 1}-${dup.duplicadoCon.indice}`);
	});

	// Verificar si un √≠ndice espec√≠fico est√° duplicado
	const estaIndiceDuplicado = (zona, index, indice) => {
		if (indice === null || indice === undefined || indice === "") return false;
		const clave = `${zona}-${index}-${indice}`;
		return clavesDuplicadas.has(clave);
	};

	// Obtener mensaje de duplicado para tooltip
	const obtenerMensajeDuplicado = (zona, index, indice) => {
		if (indice === null || indice === undefined || indice === "") return "";
		const dup = indicesDuplicados.find(
			(d) => d.zona === zona && d.boxNum === index + 1 && d.indice === indice
		);
		if (dup) {
			return `Este √≠ndice ya est√° usado en ${dup.duplicadoCon.zona === "superior" ? "Parte superior" : "Parte inferior"} Box ${dup.duplicadoCon.boxNum}`;
		}
		// Tambi√©n puede ser el √≠ndice original que tiene duplicados
		const original = indicesDuplicados.find(
			(d) => d.duplicadoCon.zona === zona && d.duplicadoCon.boxNum === index + 1 && d.duplicadoCon.indice === indice
		);
		if (original) {
			return `Este √≠ndice tambi√©n se usa en ${original.zona === "superior" ? "Parte superior" : "Parte inferior"} Box ${original.boxNum}`;
		}
		return "";
	};

	// Agrupar todos los registradores para los selects
	const todosRegistradores = [];
	for (const agente of agentesVinculados) {
		const regs = registradoresPorAgente[agente.id] || [];
		for (const reg of regs) {
			todosRegistradores.push({ ...reg, agenteNombre: agente.nombre });
		}
	}

	// Buscar registrador por ID
	const buscarRegistrador = (regId) => {
		if (!regId) return null;
		return todosRegistradores.find((r) => r.id === regId) || null;
	};

	// Generar √≠ndices arrastrables para una zona espec√≠fica
	const obtenerIndicesZona = (zona) => {
		const regId = cardDesign[zona]?.registrador_id;
		const reg = buscarRegistrador(regId);
		if (!reg) return [];
		return Array.from(
			{ length: reg.cantidad_registros },
			(_, i) => reg.indice_inicial + i
		);
	};

	// === Cargar agentes vinculados ===
	useEffect(() => {
		if (!abierto || !workspaceId) return;

		const cargarAgentes = async () => {
			setCargandoAgentes(true);
			try {
				const agentes = await listarAgentesWorkspace(workspaceId);
				setAgentesVinculados(agentes || []);

				// Cargar registradores de cada agente
				const registradoresMap = {};
				for (const agente of agentes || []) {
					try {
						const regs = await listarRegistradoresAgente(agente.id);
						registradoresMap[agente.id] = regs || [];
					} catch (err) {
						console.error(`Error cargando registradores del agente ${agente.id}:`, err);
						registradoresMap[agente.id] = [];
					}
				}
				setRegistradoresPorAgente(registradoresMap);
			} catch (err) {
				console.error("Error cargando agentes:", err);
			} finally {
				setCargandoAgentes(false);
			}
		};

		cargarAgentes();
	}, [abierto, workspaceId]);

	// === Cargar datos iniciales ===
	useEffect(() => {
		if (!abierto) return;

		if (initialData) {
			setNombre(initialData.nombre || "");
			setColor(initialData.color || COLORES_SISTEMA[0]);
			// Convertir ms a segundos para la UI
			const intervaloMs = initialData.intervalo_consulta_ms || 60000;
			setIntervaloConsultaSeg(Math.max(5, Math.round(intervaloMs / 1000)));

			// Cargar card_design con compatibilidad hacia atr√°s
			let design = initialData.card_design || crearCardDesignDefault();

			// Migraci√≥n: si existe registrador_id en ra√≠z (formato antiguo), moverlo a las zonas
			if (initialData.registrador_id && !design.superior?.registrador_id && !design.inferior?.registrador_id) {
				design = {
					...design,
					superior: { ...design.superior, registrador_id: initialData.registrador_id },
					inferior: { ...design.inferior, registrador_id: initialData.registrador_id },
				};
			}

			setCardDesign(design);
		} else {
			setNombre("");
			setColor(COLORES_SISTEMA[0]);
			setIntervaloConsultaSeg(60); // default 60 segundos
			setCardDesign(crearCardDesignDefault());
		}
	}, [abierto, initialData]);

	// === Handlers color ===
	const handleHexInputChange = (e) => {
		const valor = e.target.value;
		setValorHex(valor);
		if (/^#[0-9A-Fa-f]{6}$/.test(valor)) {
			setColor(valor);
			setColorPersonalizado(valor);
		}
	};

	const copiarColor = () => {
		navigator.clipboard.writeText(color);
	};

	// Cerrar picker al hacer click fuera
	useEffect(() => {
		const handleClickOutside = (event) => {
			if (
				pickerRef.current &&
				!pickerRef.current.contains(event.target) &&
				pickerBtnRef.current &&
				!pickerBtnRef.current.contains(event.target)
			) {
				setMostrarPicker(false);
			}
		};

		if (mostrarPicker) {
			document.addEventListener("mousedown", handleClickOutside);
		}
		return () => document.removeEventListener("mousedown", handleClickOutside);
	}, [mostrarPicker]);

	// === Handler registrador por zona ===
	const handleSeleccionarRegistradorZona = (zona, regId) => {
		actualizarSide(zona, "registrador_id", regId || null);
	};

	// === Handlers card design ===
	const actualizarSide = (zona, campo, valor) => {
		setCardDesign((prev) => ({
			...prev,
			[zona]: {
				...prev[zona],
				[campo]: valor,
			},
		}));
	};

	const actualizarBox = (zona, index, campo, valor) => {
		setCardDesign((prev) => {
			const newBoxes = [...prev[zona].boxes];
			newBoxes[index] = { ...newBoxes[index], [campo]: valor };
			return {
				...prev,
				[zona]: {
					...prev[zona],
					boxes: newBoxes,
				},
			};
		});
	};

	// === Drag & Drop ===
	const handleDragStart = (e, indice) => {
		e.dataTransfer.setData("text/plain", String(indice));
		e.dataTransfer.effectAllowed = "copy";
	};

	const handleDragOver = (e) => {
		e.preventDefault();
		e.dataTransfer.dropEffect = "copy";
	};

	const handleDrop = (e, zona, boxIndex) => {
		e.preventDefault();
		const indice = parseInt(e.dataTransfer.getData("text/plain"), 10);
		if (!isNaN(indice)) {
			actualizarBox(zona, boxIndex, "indice", indice);
		}
	};

	// === Submit ===
	const handleSubmit = (e) => {
		e.preventDefault();
		const limpioNombre = nombre.trim();
		if (!limpioNombre) return;

		onConfirmar({
			nombre: limpioNombre,
			color,
			intervalo_consulta_ms: intervaloConsultaSeg * 1000, // convertir a ms para guardar
			card_design: cardDesign, // registrador_id est√° dentro de cada zona (superior/inferior)
		});
	};

	const handleEliminarClick = () => {
		if (!onEliminar) return;
		const seguro = window.confirm("¬øSeguro que quer√©s eliminar este alimentador?");
		if (seguro) {
			onEliminar();
		}
	};

	if (!abierto) return null;

	return (
		<div className="alim-modal-overlay">
			<div className="alim-modal alim-modal--grande">
				<h2>
					{modo === "editar" ? "Editar alimentador" : "Nuevo alimentador"}
					{puestoNombre && `: ${puestoNombre}`}
				</h2>

				<form onSubmit={handleSubmit}>
					<div className="alim-modal-content">
						{/* === SECCI√ìN: Nombre y Color === */}
						<div className="alim-modal-seccion">
							<div className="alim-modal-campo">
								<label>Nombre del Alimentador</label>
								<input
									id="nombre-alimentador"
									type="text"
									className="alim-modal-input"
									value={nombre}
									onChange={(e) => setNombre(e.target.value)}
									placeholder="Ej: ALIMENTADOR 1"
									required
									autoComplete="off"
									autoCorrect="off"
									spellCheck={false}
									autoFocus={puedeEditarNombre}
									disabled={!puedeEditarNombre}
								/>
							</div>

							<div className="alim-color-grid">
								{COLORES_SISTEMA.map((c) => (
									<button
										key={c}
										type="button"
										className={`alim-color-swatch ${
											color === c ? "alim-color-swatch-selected" : ""
										}`}
										style={{ backgroundColor: c }}
										onClick={() => {
											setColor(c);
											setMostrarPicker(false);
										}}
										aria-label={`Elegir color ${c}`}
									/>
								))}
								{/* Bot√≥n color personalizado */}
								<button
									ref={pickerBtnRef}
									type="button"
									className={`alim-color-swatch alim-color-custom ${
										esColorPersonalizado ? "alim-color-swatch-selected" : ""
									}`}
									onClick={() => {
										setMostrarPicker(!mostrarPicker);
										if (!mostrarPicker) {
											setValorHex(color);
										}
									}}
									aria-label="Color personalizado"
								/>
								{/* Preview del color seleccionado */}
								<div
									className="alim-color-preview"
									style={{ backgroundColor: color }}
									title={color}
								>
									<span className="alim-color-preview-text">COLOR</span>
								</div>
							</div>
							{/* Picker flotante */}
							{mostrarPicker && (
								<div
									ref={pickerRef}
									className="color-picker-simple-popover alim-color-picker-popover"
								>
									<HexColorPicker
										color={color}
										onChange={(nuevoColor) => {
											setColor(nuevoColor);
											setColorPersonalizado(nuevoColor);
											setValorHex(nuevoColor);
										}}
									/>
									<div className="color-picker-hex-input-wrapper">
										<input
											type="text"
											value={valorHex}
											onChange={handleHexInputChange}
											className="color-picker-hex-input"
											placeholder="#000000"
											maxLength={7}
										/>
										<button
											type="button"
											className="color-picker-copy-btn"
											onClick={copiarColor}
											title="Copiar color"
										>
											üìã
										</button>
									</div>
								</div>
							)}
						</div>

						{/* === SECCI√ìN: Dise√±o de Card (solo visible para admin/creador) === */}
						{puedeEditarDiseno && (
							<div className="alim-modal-seccion">
								<h3 className="alim-modal-seccion-titulo">Dise√±o de la tarjeta</h3>

								{cargandoAgentes ? (
									<p className="alim-modal-cargando">Cargando registradores...</p>
								) : agentesVinculados.length === 0 ? (
									<p className="alim-modal-aviso">
										No hay agentes vinculados a este workspace. Vincul√° un agente desde el
										panel de configuraci√≥n para poder asignar registradores.
									</p>
								) : (
									<>
										<p className="alim-modal-seccion-ayuda">
											Seleccion√° un registrador para cada zona y arrastr√° los √≠ndices a los campos.
										</p>

										{/* Parte Superior */}
										<SeccionCardDesign
											titulo="Parte superior"
											zona="superior"
											design={cardDesign.superior}
											registradores={todosRegistradores}
											registradorActual={buscarRegistrador(cardDesign.superior?.registrador_id)}
											indicesDisponibles={obtenerIndicesZona("superior")}
											onChangeRegistrador={(regId) => handleSeleccionarRegistradorZona("superior", regId)}
											onChangeTitulo={(val) => actualizarSide("superior", "tituloId", val)}
											onChangeTituloCustom={(val) =>
												actualizarSide("superior", "tituloCustom", val)
											}
											onChangeCantidad={(val) => actualizarSide("superior", "cantidad", val)}
											onChangeBox={(idx, campo, val) => actualizarBox("superior", idx, campo, val)}
											onDragOver={handleDragOver}
											onDrop={(e, idx) => handleDrop(e, "superior", idx)}
											onDragStart={handleDragStart}
											estaIndiceDuplicado={estaIndiceDuplicado}
											obtenerMensajeDuplicado={obtenerMensajeDuplicado}
										/>

										{/* Parte Inferior */}
										<SeccionCardDesign
											titulo="Parte inferior"
											zona="inferior"
											design={cardDesign.inferior}
											registradores={todosRegistradores}
											registradorActual={buscarRegistrador(cardDesign.inferior?.registrador_id)}
											indicesDisponibles={obtenerIndicesZona("inferior")}
											onChangeRegistrador={(regId) => handleSeleccionarRegistradorZona("inferior", regId)}
											onChangeTitulo={(val) => actualizarSide("inferior", "tituloId", val)}
											onChangeTituloCustom={(val) =>
												actualizarSide("inferior", "tituloCustom", val)
											}
											onChangeCantidad={(val) => actualizarSide("inferior", "cantidad", val)}
											onChangeBox={(idx, campo, val) => actualizarBox("inferior", idx, campo, val)}
											onDragOver={handleDragOver}
											onDrop={(e, idx) => handleDrop(e, "inferior", idx)}
											onDragStart={handleDragStart}
											estaIndiceDuplicado={estaIndiceDuplicado}
											obtenerMensajeDuplicado={obtenerMensajeDuplicado}
										/>
									</>
								)}
							</div>
						)}

						{/* === SECCI√ìN: Intervalo de consulta + Ocultar zonas (solo para admin u operador) === */}
						{(puedeEditarIntervalo || puedeOcultarZonas) && (
							<div className="alim-modal-seccion">
								<h3 className="alim-modal-seccion-titulo">Intervalo de consulta</h3>
								<div className="alim-modal-intervalo-wrapper">
									<div className="alim-modal-campo">
										<label>Segundos entre consultas a la Base de Datos</label>
										<input
											type="number"
											className="alim-modal-input-numero"
											value={intervaloConsultaSeg}
											onChange={(e) => {
												const valor = Number(e.target.value);
												setIntervaloConsultaSeg(Math.max(5, valor)); // m√≠nimo 5 segundos
											}}
											min={5}
											step={1}
											disabled={!puedeEditarIntervalo}
										/>
										<span className="alim-modal-campo-ayuda">
											Cada cu√°nto el frontend consulta la √∫ltima lectura (m√≠n. 5s)
										</span>
									</div>

									{/* Checkboxes para ocultar zonas */}
									<div className="alim-modal-ocultar-zonas">
										<span className="alim-modal-ocultar-zonas-titulo">Ocultar en tarjeta</span>
										<label className={`alim-modal-ocultar-zona-item ${!puedeOcultarZonas ? 'alim-modal-ocultar-zona-item--disabled' : ''}`}>
											<input
												type="checkbox"
												checked={cardDesign.superior?.oculto || false}
												onChange={(e) => actualizarSide("superior", "oculto", e.target.checked)}
												disabled={!puedeOcultarZonas}
											/>
											<span>Parte superior</span>
										</label>
										<label className={`alim-modal-ocultar-zona-item ${!puedeOcultarZonas ? 'alim-modal-ocultar-zona-item--disabled' : ''}`}>
											<input
												type="checkbox"
												checked={cardDesign.inferior?.oculto || false}
												onChange={(e) => actualizarSide("inferior", "oculto", e.target.checked)}
												disabled={!puedeOcultarZonas}
											/>
											<span>Parte inferior</span>
										</label>
									</div>
								</div>
							</div>
						)}
					</div>

					{/* Botones inferiores */}
					<div className="alim-modal-actions">
						{/* Bot√≥n eliminar a la izquierda (solo en modo edici√≥n y si tiene permisos) */}
						{modo === "editar" && puedeEliminar && (
							<button
								type="button"
								className="alim-modal-btn-eliminar"
								onClick={handleEliminarClick}
							>
								Eliminar
							</button>
						)}

						<div className="alim-modal-actions-right">
							<button
								type="button"
								className="alim-modal-btn alim-modal-btn-cancelar"
								onClick={onCancelar}
							>
								Cancelar
							</button>

							<button type="submit" className="alim-modal-btn alim-modal-btn-guardar">
								Guardar
							</button>
						</div>
					</div>
				</form>
			</div>
		</div>
	);
};

// === Subcomponente: Secci√≥n de dise√±o de card (superior/inferior) ===
const SeccionCardDesign = ({
	titulo,
	zona,
	design,
	registradores,
	registradorActual,
	indicesDisponibles,
	onChangeRegistrador,
	onChangeTitulo,
	onChangeTituloCustom,
	onChangeCantidad,
	onChangeBox,
	onDragOver,
	onDrop,
	onDragStart,
	estaIndiceDuplicado,
	obtenerMensajeDuplicado,
}) => {
	const [expandido, setExpandido] = useState(false);
	const [tooltipIdx, setTooltipIdx] = useState(null); // √≠ndice del box que muestra tooltip
	const cant = design.cantidad || 3;
	const estaOculto = design.oculto || false;

	return (
		<div className={`alim-modal-card-section ${expandido ? "alim-modal-card-section--expandido" : ""} ${estaOculto ? "alim-modal-card-section--oculto" : ""}`}>
			<button
				type="button"
				className="alim-modal-card-section-header"
				onClick={() => setExpandido(!expandido)}
			>
				<span className={`alim-modal-card-section-arrow ${expandido ? "alim-modal-card-section-arrow--expandido" : ""}`}>
					‚ñ∂
				</span>
				<span className="alim-modal-card-section-titulo">{titulo}</span>
				{registradorActual && !estaOculto && (
					<span className="alim-modal-card-section-registrador">
						{registradorActual.nombre}
					</span>
				)}
				{estaOculto && (
					<span className="alim-modal-card-section-oculto-badge">
						OCULTO
					</span>
				)}
			</button>

			{expandido && (
				<div className="alim-modal-card-section-content">
					{/* Selector de registrador para esta zona */}
					<div className="alim-modal-campo">
						<label>Registrador</label>
						<select
							className="alim-modal-select"
							value={design.registrador_id || ""}
							onChange={(e) => onChangeRegistrador(e.target.value)}
						>
							<option value="">-- Sin registrador --</option>
							{registradores.map((reg) => (
								<option key={reg.id} value={reg.id}>
									{reg.nombre} ({reg.agenteNombre}) - {reg.ip}:{reg.puerto} | Reg:{" "}
									{reg.indice_inicial}-{reg.indice_inicial + reg.cantidad_registros - 1}
								</option>
							))}
						</select>
					</div>

					{/* √çndices arrastrables del registrador seleccionado */}
					{registradorActual && indicesDisponibles.length > 0 && (
						<div className="alim-modal-indices">
							<span className="alim-modal-indices-label">
								√çndices arrastrables:
							</span>
							<div className="alim-modal-indices-chips">
								{indicesDisponibles.map((indice) => (
									<span
										key={indice}
										className="alim-modal-indice-chip"
										draggable
										onDragStart={(e) => onDragStart(e, indice)}
									>
										{indice}
									</span>
								))}
							</div>
						</div>
					)}

					<div className="alim-modal-card-header">
						<div className="alim-modal-campo">
							<label>T√≠tulo</label>
							<select
								className="alim-modal-select"
								value={design.tituloId || "corriente_132"}
								onChange={(e) => onChangeTitulo(e.target.value)}
							>
								{OPCIONES_TITULO.map((op) => (
									<option key={op.id} value={op.id}>
										{op.label}
									</option>
								))}
							</select>
						</div>

						{design.tituloId === "custom" && (
							<div className="alim-modal-campo">
								<label>T√≠tulo personalizado</label>
								<input
									type="text"
									className="alim-modal-input"
									placeholder="Ej: CONSUMO (A)"
									value={design.tituloCustom || ""}
									onChange={(e) => onChangeTituloCustom(e.target.value)}
								/>
							</div>
						)}

						<div className="alim-modal-campo alim-modal-campo--small">
							<label>Cantidad boxes</label>
							<select
								className="alim-modal-select"
								value={cant}
								onChange={(e) => onChangeCantidad(Number(e.target.value))}
							>
								{[1, 2, 3, 4].map((n) => (
									<option key={n} value={n}>
										{n}
									</option>
								))}
							</select>
						</div>
					</div>

					<div className="alim-modal-boxes">
						{Array.from({ length: cant }).map((_, idx) => {
							const box = design.boxes[idx] || {};
							return (
								<div key={`${zona}-box-${idx}`} className="alim-modal-box">
									<span className="alim-modal-box-titulo">Box {idx + 1}</span>
									<div className="alim-modal-box-row">
										<label className="alim-modal-box-check">
											<input
												type="checkbox"
												checked={!!box.enabled}
												onChange={(e) => onChangeBox(idx, "enabled", e.target.checked)}
											/>
										</label>

										<input
											type="text"
											className="alim-modal-input alim-modal-box-label"
											placeholder={PLACEHOLDERS_BOX[idx] || `Ej: R o L1`}
											value={box.label || ""}
											onChange={(e) => onChangeBox(idx, "label", e.target.value)}
										/>

										<div className="alim-modal-box-indice-wrapper">
										<input
											type="number"
											className={`alim-modal-input alim-modal-box-indice ${estaIndiceDuplicado(zona, idx, box.indice) ? "alim-modal-box-indice--duplicado" : ""}`}
											placeholder="√çndice"
											value={box.indice ?? ""}
											onChange={(e) =>
												onChangeBox(idx, "indice", e.target.value ? Number(e.target.value) : null)
											}
											onDragOver={onDragOver}
											onDrop={(e) => onDrop(e, idx)}
										/>
										{estaIndiceDuplicado(zona, idx, box.indice) && (
											<span
												className="alim-modal-box-warning"
												onMouseEnter={() => setTooltipIdx(idx)}
												onMouseLeave={() => setTooltipIdx(null)}
											>
												‚ö†Ô∏è
												{tooltipIdx === idx && (
													<div className="alim-modal-box-warning-tooltip">
														{obtenerMensajeDuplicado(zona, idx, box.indice)}
													</div>
												)}
											</span>
										)}
									</div>

										<input
											type="text"
											className="alim-modal-input alim-modal-box-formula"
											placeholder="F√≥rmula (ej: x*250/1000)"
											value={box.formula || ""}
											onChange={(e) => onChangeBox(idx, "formula", e.target.value)}
										/>
									</div>
								</div>
							);
						})}
					</div>
				</div>
			)}
		</div>
	);
};

export default ModalConfiguracionAlimentador;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionPuesto.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionPuesto.jsx

import React, { useEffect, useState, useRef } from "react";
import "./ModalConfiguracionPuesto.css";

/**
 * Modal de vista r√°pida del puesto.
 * Muestra el estado de cada alimentador con sus registradores asignados (solo lectura).
 * Permite controlar el polling de cada card y de todo el puesto.
 */
const ModalConfiguracionPuesto = ({
	abierto,
	puesto,
	onCerrar,
	// Polling
	estaPolling,              // (alimId) => boolean
	onPlayStopClick,          // (alimId) => void - alterna polling de un alimentador
	// Para obtener nombres de registradores
	buscarRegistrador,        // (regId) => registrador | null
}) => {
	// Estado para arrastrar el modal
	const [posicion, setPosicion] = useState({ x: 0, y: 0 });
	const [arrastrando, setArrastrando] = useState(false);
	const offsetRef = useRef({ x: 0, y: 0 });
	const modalRef = useRef(null);

	// Resetear posici√≥n al abrir el modal
	useEffect(() => {
		if (abierto) {
			setPosicion({ x: 0, y: 0 });
		}
	}, [abierto]);

	// Manejadores de arrastre
	const handleMouseDown = (e) => {
		if (e.target.closest('.puesto-modal__close') || e.target.closest('input') || e.target.closest('button')) {
			return;
		}
		setArrastrando(true);
		offsetRef.current = {
			x: e.clientX - posicion.x,
			y: e.clientY - posicion.y,
		};
	};

	const handleMouseMove = (e) => {
		if (!arrastrando) return;
		setPosicion({
			x: e.clientX - offsetRef.current.x,
			y: e.clientY - offsetRef.current.y,
		});
	};

	const handleMouseUp = () => {
		setArrastrando(false);
	};

	useEffect(() => {
		if (arrastrando) {
			window.addEventListener('mousemove', handleMouseMove);
			window.addEventListener('mouseup', handleMouseUp);
		}
		return () => {
			window.removeEventListener('mousemove', handleMouseMove);
			window.removeEventListener('mouseup', handleMouseUp);
		};
	}, [arrastrando]);

	// Helper para obtener registrador_id de una zona (con compatibilidad legacy)
	const obtenerRegistradorIdZona = (alim, zona) => {
		// Primero intentar obtener de card_design
		const regIdZona = alim.card_design?.[zona]?.registrador_id;
		if (regIdZona) return regIdZona;

		// Fallback: usar registrador_id de la ra√≠z (formato legacy)
		return alim.registrador_id || null;
	};

	if (!abierto || !puesto) return null;

	const alimentadores = puesto.alimentadores || [];

	// Helper para verificar si un alimentador puede hacer polling
	const puedeHacerPolling = (alim) => {
		if (!alim.intervalo_consulta_ms || alim.intervalo_consulta_ms <= 0) return false;

		const cardDesign = alim.card_design || {};
		const superior = cardDesign.superior || {};
		const inferior = cardDesign.inferior || {};

		const tieneRegistrador = !!superior.registrador_id || !!inferior.registrador_id || !!alim.registrador_id;
		if (!tieneRegistrador) return false;

		// Verificar que al menos un box est√© habilitado con √≠ndice v√°lido
		const boxesSuperior = superior.boxes || [];
		const boxesInferior = inferior.boxes || [];
		const todosLosBoxes = [...boxesSuperior, ...boxesInferior];

		const tieneBoxHabilitado = todosLosBoxes.some(
			(box) => box.enabled && box.indice !== null && box.indice !== undefined && box.indice !== ""
		);

		return tieneBoxHabilitado;
	};

	// Obtener nombre del registrador para mostrar
	const obtenerInfoRegistrador = (alim, zona) => {
		const regId = obtenerRegistradorIdZona(alim, zona);
		if (!regId || !buscarRegistrador) return "Sin asignar";
		const reg = buscarRegistrador(regId);
		if (!reg) return "Sin asignar";

		// Solo mostrar el nombre del registrador
		return reg.nombre;
	};

	// ===== BOT√ìN MAESTRO GLOBAL =====
	const alimentadoresConPolling = alimentadores.filter(puedeHacerPolling);
	const hayAlgunoPolling = alimentadoresConPolling.some((alim) => estaPolling?.(alim.id));
	const hayAlgunaCardDisponible = alimentadoresConPolling.length > 0;

	const handleMaestroGlobal = () => {
		if (!hayAlgunaCardDisponible) return;

		if (hayAlgunoPolling) {
			// Detener todos los que est√°n en polling
			alimentadoresConPolling.forEach((alim) => {
				if (estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		} else {
			// Iniciar todos los disponibles
			alimentadoresConPolling.forEach((alim) => {
				if (!estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		}
	};

	return (
		<div className="puesto-modal-overlay">
			<div
				ref={modalRef}
				className={`puesto-modal ${arrastrando ? 'puesto-modal--arrastrando' : ''}`}
				style={{
					transform: `translate(${posicion.x}px, ${posicion.y}px)`,
				}}
				onClick={(e) => e.stopPropagation()}
			>
				{/* Header */}
				<div
					className="puesto-modal__header"
					onMouseDown={handleMouseDown}
					style={{ cursor: 'move' }}
				>
					<h2 className="puesto-modal__title">
						Configuraci√≥n del Puesto: {puesto?.nombre || ""}
					</h2>
					<div className="puesto-modal__header-actions">
						{/* Bot√≥n maestro global */}
						<button
							type="button"
							className={`puesto-card__master-btn ${hayAlgunoPolling ? "puesto-card__master-btn--stop" : ""} ${!hayAlgunaCardDisponible ? "puesto-card__master-btn--disabled" : ""}`}
							onClick={handleMaestroGlobal}
							disabled={!hayAlgunaCardDisponible}
							title={!hayAlgunaCardDisponible ? "Sin alimentadores con configuraci√≥n v√°lida" : hayAlgunoPolling ? "Detener todas las lecturas" : "Iniciar todas las lecturas"}
						>
							{!hayAlgunaCardDisponible ? "‚äò" : hayAlgunoPolling ? "‚èπ" : "‚ñ∂"}
						</button>
						<button
							type="button"
							className="puesto-modal__close"
							onClick={onCerrar}
							aria-label="Cerrar"
						>
							√ó
						</button>
					</div>
				</div>

				{/* Contenido */}
				<div
					className="puesto-modal__content"
					style={{ backgroundColor: puesto?.bgColor || "#1e293b" }}
				>
					{alimentadores.length === 0 ? (
						<p className="puesto-modal__empty">
							No hay alimentadores en este puesto.
						</p>
					) : (
						<div className="puesto-cards">
							{alimentadores.map((alim) => {
								const periodoSeg = alim.intervalo_consulta_ms
									? Math.round(alim.intervalo_consulta_ms / 1000)
									: null;
								const puedePolling = puedeHacerPolling(alim);
								const polling = estaPolling?.(alim.id);

								return (
									<div
										key={alim.id}
										className="puesto-card"
										style={{
											borderLeftColor: alim.color || "#22c55e",
											borderBottomColor: alim.color || "#22c55e",
										}}
									>
										{/* Header de la card: Nombre + Play + Per√≠odo */}
										<div className="puesto-card__header">
											<span className="puesto-card__nombre">{alim.nombre}</span>
											<div className="puesto-card__header-right">
												<button
													type="button"
													className={`puesto-card__play-btn ${polling ? "puesto-card__play-btn--stop" : ""} ${!puedePolling ? "puesto-card__play-btn--disabled" : ""}`}
													onClick={() => puedePolling && onPlayStopClick?.(alim.id)}
													disabled={!puedePolling}
													title={!puedePolling ? "Configuraci√≥n incompleta" : polling ? "Detener lectura" : "Iniciar lectura"}
												>
													{!puedePolling ? "‚äò" : polling ? "‚èπ" : "‚ñ∂"}
												</button>
												<span className="puesto-card__periodo-badge">
													{periodoSeg ? `${periodoSeg}s` : "-"}
												</span>
											</div>
										</div>

										{/* Contenido: Superior e Inferior lado a lado */}
										<div className="puesto-card__body">
											<div className="puesto-card__zonas">
												{/* Zona Superior */}
												<div className="puesto-card__zona">
													<span className="puesto-card__tipo-badge puesto-card__tipo-badge--superior">
														Superior
													</span>
													<span className="puesto-card__registrador" title={obtenerInfoRegistrador(alim, "superior")}>
														{obtenerInfoRegistrador(alim, "superior")}
													</span>
												</div>

												{/* Zona Inferior */}
												<div className="puesto-card__zona">
													<span className="puesto-card__tipo-badge puesto-card__tipo-badge--inferior">
														Inferior
													</span>
													<span className="puesto-card__registrador" title={obtenerInfoRegistrador(alim, "inferior")}>
														{obtenerInfoRegistrador(alim, "inferior")}
													</span>
												</div>
											</div>
										</div>
									</div>
								);
							})}
						</div>
					)}
				</div>

				{/* Footer */}
				<div className="puesto-modal__footer">
					<button
						type="button"
						className="puesto-modal__btn puesto-modal__btn--cerrar"
						onClick={onCerrar}
					>
						Cerrar
					</button>
				</div>
			</div>
		</div>
	);
};

export default ModalConfiguracionPuesto;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigurarAgente.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigurarAgente.jsx
// Ventana flotante para configurar agentes con pesta√±as din√°micas seg√∫n rol
// Soporta: arrastrar, minimizar, maximizar, redimensionar, m√∫ltiples instancias

import React, { useState, useEffect, useCallback, useRef } from "react";
import {
  // Nueva arquitectura
  listarAgentesWorkspace,
  listarAgentesDisponibles,
  vincularAgenteWorkspace,
  desvincularAgenteWorkspace,
  listarTodosLosAgentes,
  crearAgente,
  eliminarAgente,
  rotarClaveAgentePorId,
  listarRegistradoresAgente,
  crearRegistradorAgente,
  actualizarRegistradorAgente,
  eliminarRegistradorAgente,
  toggleRegistradorAgente,
  solicitarTestRegistrador,
  consultarTestRegistrador,
} from "../../../../servicios/apiService";
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import ConfiguracionRele from "./ConfiguracionRele";
import "./ModalConfigurarAgente.css";

/**
 * Modal para configurar agentes con pesta√±as seg√∫n rol del usuario.
 *
 * Pesta√±as:
 * - "Agentes Vinculados": Todos los roles con acceso al workspace
 * - "Vincular Agente": Solo creador del workspace o superadmin
 * - "Panel SuperAdmin": Solo Superadmin (CRUD de agentes y registradores)
 *
 * NOTA: Un admin invitado puede ver los agentes vinculados pero NO puede
 * vincular ni desvincular agentes. Solo el creador del workspace o superadmin
 * tienen esa capacidad.
 */
const ModalConfigurarAgente = ({
  abierto,
  workspaceId,
  onCerrar,
  // Props para comportamiento de ventana flotante
  minimizada = false,
  maximizada = false,
  posicion = { x: 100, y: 50 },
  zIndex = 1000,
  onMinimizar,
  onMaximizar,
  onEnfocar,
  onMover,
}) => {
  const { rolGlobal, configuracionSeleccionada } = usarContextoConfiguracion();

  // Refs para drag y resize
  const ventanaRef = useRef(null);
  const headerRef = useRef(null);

  // Estados para drag
  const [arrastrando, setArrastrando] = useState(false);
  const [offsetArrastre, setOffsetArrastre] = useState({ x: 0, y: 0 });

  // Estados para resize
  const [redimensionando, setRedimensionando] = useState(false);
  const [dimensiones, setDimensiones] = useState({ width: 900, height: 600 });
  const [dimensionesIniciales, setDimensionesIniciales] = useState({ width: 0, height: 0 });
  const [posicionInicialResize, setPosicionInicialResize] = useState({ x: 0, y: 0 });

  // Determinar permisos seg√∫n rol
  // - rolGlobal: rol del usuario en el sistema
  // - configuracionSeleccionada?.rol: rol del usuario EN ESTE WORKSPACE
  const esSuperadmin = rolGlobal === 'superadmin';
  const rolEnWorkspace = configuracionSeleccionada?.rol;
  const esAdmin = esSuperadmin || rolEnWorkspace === 'admin';

  // Solo el creador del workspace o superadmin pueden vincular/desvincular agentes
  const esCreadorWorkspace = configuracionSeleccionada?.esCreador === true;
  const puedeVincularDesvincular = esSuperadmin || esCreadorWorkspace;

  // La pesta√±a "Vincular Agente" solo se muestra si puede vincular
  const puedeVincular = puedeVincularDesvincular;

  // Pesta√±as disponibles seg√∫n rol
  const pestanasDisponibles = [
    { id: 'vinculados', label: 'Agentes Vinculados', visible: true },
    { id: 'vincular', label: 'Vincular Agente', visible: puedeVincular },
    { id: 'admin', label: 'Panel SuperAdmin', visible: esSuperadmin },
  ].filter(p => p.visible);

  // Estado
  const [pestanaActiva, setPestanaActiva] = useState('vinculados');
  const [cargando, setCargando] = useState(false);
  const [error, setError] = useState(null);

  // Datos
  const [agentesVinculados, setAgentesVinculados] = useState([]);
  const [agentesDisponibles, setAgentesDisponibles] = useState([]);
  const [todosAgentes, setTodosAgentes] = useState([]);
  const [registradoresAgente, setRegistradoresAgente] = useState({});

  // Estado para crear agente
  const [mostrarFormCrear, setMostrarFormCrear] = useState(false);
  const [nuevoAgente, setNuevoAgente] = useState({ nombre: '', descripcion: '' });
  const [creando, setCreando] = useState(false);
  const [claveGenerada, setClaveGenerada] = useState(null);

  // Estado para expandir registradores
  const [agenteExpandido, setAgenteExpandido] = useState(null);

  // Estado para CRUD de registradores
  const [mostrarFormRegistrador, setMostrarFormRegistrador] = useState(null); // null | agenteId
  const [registradorEditando, setRegistradorEditando] = useState(null);
  const [nuevoRegistrador, setNuevoRegistrador] = useState({
    nombre: '',
    tipo: 'modbus',
    tipoDispositivo: 'analizador', // 'analizador' | 'rele'
    ip: '',
    puerto: '',
    unitId: '',
    indiceInicial: '',
    cantidadRegistros: '',
    intervaloSegundos: '',
    // Configuraci√≥n espec√≠fica para rel√©s de protecci√≥n
    configuracionRele: null,
  });
  const [guardandoRegistrador, setGuardandoRegistrador] = useState(false);
  const [registradorProcesando, setRegistradorProcesando] = useState(null); // ID del registrador que est√° procesando

  // Estado para test de registrador
  const [testEnCurso, setTestEnCurso] = useState(null); // { agenteId, registradorId, testId, estado, progreso }
  const [resultadoTest, setResultadoTest] = useState(null); // Resultado del test para mostrar en modal

  // Cargar datos al abrir
  useEffect(() => {
    if (abierto && workspaceId) {
      cargarDatos();
    }
  }, [abierto, workspaceId]);

  // Resetear estado al cerrar
  useEffect(() => {
    if (!abierto) {
      setPestanaActiva('vinculados');
      setError(null);
      setMostrarFormCrear(false);
      setClaveGenerada(null);
      setAgenteExpandido(null);
      setMostrarFormRegistrador(null);
      setRegistradorEditando(null);
      resetFormRegistrador();
      setTestEnCurso(null);
      setResultadoTest(null);
    }
  }, [abierto]);

  // Reset form de registrador
  const resetFormRegistrador = () => {
    setNuevoRegistrador({
      nombre: '',
      tipo: 'modbus',
      tipoDispositivo: 'analizador',
      ip: '',
      puerto: '',
      unitId: '',
      indiceInicial: '',
      cantidadRegistros: '',
      intervaloSegundos: '',
      configuracionRele: null,
    });
    setRegistradorEditando(null);
  };

  const cargarDatos = async () => {
    setCargando(true);
    setError(null);

    try {
      // Cargar agentes vinculados al workspace
      const vinculados = await listarAgentesWorkspace(workspaceId);
      setAgentesVinculados(vinculados || []);

      // Si puede vincular, cargar disponibles
      if (puedeVincular) {
        const disponibles = await listarAgentesDisponibles();
        // Filtrar los que ya est√°n vinculados
        const idsVinculados = new Set((vinculados || []).map(a => a.id));
        setAgentesDisponibles((disponibles || []).filter(a => !idsVinculados.has(a.id)));
      }

      // Si es superadmin, cargar todos
      if (esSuperadmin) {
        const todos = await listarTodosLosAgentes();
        setTodosAgentes(todos || []);
      }
    } catch (err) {
      console.error('Error cargando datos:', err);
      setError(err.message || 'Error cargando datos');
    } finally {
      setCargando(false);
    }
  };

  // Vincular agente al workspace
  const handleVincular = async (agenteId) => {
    try {
      setCargando(true);
      await vincularAgenteWorkspace(workspaceId, agenteId);
      await cargarDatos();
      setPestanaActiva('vinculados');
    } catch (err) {
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Desvincular agente del workspace
  const handleDesvincular = async (agenteId) => {
    if (!confirm('¬øDesvincular este agente del workspace?')) return;

    try {
      setCargando(true);
      await desvincularAgenteWorkspace(workspaceId, agenteId);
      await cargarDatos();
    } catch (err) {
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Crear nuevo agente (superadmin)
  const handleCrearAgente = async (e) => {
    e.preventDefault();
    if (!nuevoAgente.nombre.trim()) return;

    try {
      setCreando(true);
      setError(null);
      const resultado = await crearAgente(nuevoAgente.nombre, nuevoAgente.descripcion);
      setClaveGenerada(resultado.claveSecreta);
      setNuevoAgente({ nombre: '', descripcion: '' });
      await cargarDatos();
    } catch (err) {
      setError(err.message);
    } finally {
      setCreando(false);
    }
  };

  // Eliminar agente (superadmin)
  const handleEliminarAgente = async (agenteId, nombre) => {
    if (!confirm(`¬øEliminar el agente "${nombre}"? Esta acci√≥n no se puede deshacer.`)) return;

    try {
      setCargando(true);
      await eliminarAgente(agenteId);
      await cargarDatos();
    } catch (err) {
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Rotar clave de agente (superadmin)
  const handleRotarClave = async (agenteId) => {
    if (!confirm('¬øRotar la clave del agente? Deber√°s actualizar el agente con la nueva clave.')) return;

    try {
      setCargando(true);
      const resultado = await rotarClaveAgentePorId(agenteId);
      setClaveGenerada(resultado.nuevaClave);
    } catch (err) {
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Cargar registradores de un agente
  const toggleRegistradores = async (agenteId) => {
    if (agenteExpandido === agenteId) {
      setAgenteExpandido(null);
      setMostrarFormRegistrador(null);
      return;
    }

    try {
      if (!registradoresAgente[agenteId]) {
        const regs = await listarRegistradoresAgente(agenteId);
        setRegistradoresAgente(prev => ({ ...prev, [agenteId]: regs }));
      }
      setAgenteExpandido(agenteId);
    } catch (err) {
      console.error('Error cargando registradores:', err);
    }
  };

  // Recargar registradores de un agente
  const recargarRegistradores = async (agenteId) => {
    try {
      const regs = await listarRegistradoresAgente(agenteId);
      setRegistradoresAgente(prev => ({ ...prev, [agenteId]: regs }));
    } catch (err) {
      console.error('Error recargando registradores:', err);
    }
  };

  // Crear o editar registrador
  const handleGuardarRegistrador = async (e, agenteId) => {
    e.preventDefault();

    // Validaci√≥n b√°sica
    if (!nuevoRegistrador.nombre.trim()) return;

    // Para rel√©s, la validaci√≥n de conexi√≥n viene del componente ConfiguracionRele
    const esRele = nuevoRegistrador.tipoDispositivo === 'rele';

    if (esRele) {
      // Validar que tenga configuraci√≥n de rel√©
      if (!nuevoRegistrador.configuracionRele) {
        setError('Debes configurar el rel√© de protecci√≥n');
        return;
      }
    } else {
      // Para analizadores, validar campos tradicionales
      if (!nuevoRegistrador.ip.trim() || !nuevoRegistrador.puerto || !nuevoRegistrador.indiceInicial || !nuevoRegistrador.cantidadRegistros) return;
    }

    try {
      setGuardandoRegistrador(true);
      setError(null);

      // Preparar datos seg√∫n tipo de dispositivo
      let datos;

      if (esRele) {
        // Para rel√©s, usar la configuraci√≥n del componente ConfiguracionRele
        const configRele = nuevoRegistrador.configuracionRele;
        // Convertir intervaloPollingMs (en ms) a intervaloSegundos
        const intervaloSegundos = Math.round((configRele.intervaloPollingMs || 5000) / 1000);
        datos = {
          nombre: nuevoRegistrador.nombre,
          tipo: 'modbus',
          tipoDispositivo: 'rele',
          ip: configRele.conexion.ip,
          puerto: String(configRele.conexion.puerto),
          unitId: String(configRele.conexion.unitId),
          indiceInicial: '0', // Los rel√©s usan registros espec√≠ficos por configuraci√≥n
          cantidadRegistros: '200', // Rango amplio para cubrir todos los registros posibles
          intervaloSegundos: String(intervaloSegundos),
          configuracionRele: configRele,
        };
      } else {
        // Para analizadores, usar formato tradicional
        datos = {
          ...nuevoRegistrador,
          tipoDispositivo: 'analizador',
          unitId: nuevoRegistrador.unitId || '1',
          intervaloSegundos: nuevoRegistrador.intervaloSegundos || '60',
        };
      }

      if (registradorEditando) {
        // Editar
        await actualizarRegistradorAgente(agenteId, registradorEditando.id, datos);
      } else {
        // Crear
        await crearRegistradorAgente(agenteId, datos);
      }

      await recargarRegistradores(agenteId);
      setMostrarFormRegistrador(null);
      resetFormRegistrador();
    } catch (err) {
      setError(err.message);
    } finally {
      setGuardandoRegistrador(false);
    }
  };

  // Editar registrador
  const handleEditarRegistrador = (reg) => {
    setRegistradorEditando(reg);
    setNuevoRegistrador({
      nombre: reg.nombre || '',
      tipo: reg.tipo || 'modbus',
      tipoDispositivo: reg.tipo_dispositivo || 'analizador',
      ip: reg.ip || '',
      puerto: String(reg.puerto || '502'),
      unitId: String(reg.unit_id || '1'),
      indiceInicial: String(reg.indice_inicial || '0'),
      cantidadRegistros: String(reg.cantidad_registros || '10'),
      intervaloSegundos: String(reg.intervalo_segundos || '60'),
      configuracionRele: reg.configuracion_rele || null,
    });
    setMostrarFormRegistrador(reg.agente_id);
  };

  // Eliminar registrador
  const handleEliminarRegistrador = async (agenteId, registradorId, nombre) => {
    if (!confirm(`¬øEliminar el registrador "${nombre}"?`)) return;

    try {
      setCargando(true);
      await eliminarRegistradorAgente(agenteId, registradorId);
      await recargarRegistradores(agenteId);
    } catch (err) {
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Toggle activo registrador
  const handleToggleRegistrador = async (agenteId, registradorId) => {
    try {
      setRegistradorProcesando(registradorId);
      await toggleRegistradorAgente(agenteId, registradorId);
      await recargarRegistradores(agenteId);
    } catch (err) {
      setError(err.message);
    } finally {
      setRegistradorProcesando(null);
    }
  };

  // Iniciar o parar todos los registradores de un agente
  const handleToggleTodosRegistradores = async (agenteId, iniciar) => {
    const regs = registradoresAgente[agenteId] || [];
    const registrosAToggle = regs.filter(r => iniciar ? !r.activo : r.activo);

    if (registrosAToggle.length === 0) return;

    try {
      setRegistradorProcesando('todos');
      // Toggle cada registrador que necesite cambiar
      for (const reg of registrosAToggle) {
        await toggleRegistradorAgente(agenteId, reg.id);
      }
      await recargarRegistradores(agenteId);
    } catch (err) {
      setError(err.message);
    } finally {
      setRegistradorProcesando(null);
    }
  };

  // Test de conexi√≥n de registrador (usa datos del formulario)
  const handleTestRegistrador = async (agenteId) => {
    // Verificar si ya hay un test en curso
    if (testEnCurso) {
      return;
    }

    // Validar que los campos requeridos est√©n completos
    if (!nuevoRegistrador.ip.trim() || !nuevoRegistrador.puerto || !nuevoRegistrador.indiceInicial || !nuevoRegistrador.cantidadRegistros) {
      setError('Completa IP, Puerto, √çndice Inicial y Cantidad de Registros para hacer el test');
      return;
    }

// Crear objeto con datos del formulario (fuera del try para usar en catch)
    const datosTest = {
      nombre: nuevoRegistrador.nombre || 'Test',
      ip: nuevoRegistrador.ip,
      puerto: parseInt(nuevoRegistrador.puerto),
      unit_id: parseInt(nuevoRegistrador.unitId) || 1,
      indice_inicial: parseInt(nuevoRegistrador.indiceInicial),
      cantidad_registros: parseInt(nuevoRegistrador.cantidadRegistros),
    };

    try {
      setTestEnCurso({
        agenteId,
        registradorId: 'form',
        testId: null,
        estado: 'solicitando',
        progreso: 0,
      });
      setResultadoTest(null);
      setError(null);

      // Solicitar el test
      const respuesta = await solicitarTestRegistrador(agenteId, {
        ip: datosTest.ip,
        puerto: datosTest.puerto,
        unitId: datosTest.unit_id,
        indiceInicial: datosTest.indice_inicial,
        cantidadRegistros: datosTest.cantidad_registros,
      });

      const { testId, timeoutSegundos } = respuesta;

      setTestEnCurso(prev => ({
        ...prev,
        testId,
        estado: 'esperando',
        progreso: 0,
      }));

      // Polling del resultado
      const tiempoInicio = Date.now();
      const tiempoMaximo = (timeoutSegundos || 30) * 1000;
      const intervalo = 1000; // Consultar cada segundo

      const poll = async () => {
        const tiempoTranscurrido = Date.now() - tiempoInicio;

        if (tiempoTranscurrido > tiempoMaximo) {
          setTestEnCurso(null);
          setResultadoTest({
            exito: false,
            estado: 'timeout',
            error_mensaje: 'El agente no respondi√≥ a tiempo',
            registrador: datosTest,
          });
          return;
        }

        try {
          const resultado = await consultarTestRegistrador(agenteId, testId);

          // Actualizar progreso
          const progreso = Math.min((tiempoTranscurrido / tiempoMaximo) * 100, 95);
          setTestEnCurso(prev => prev ? { ...prev, progreso } : null);

          if (resultado.estado === 'completado' || resultado.estado === 'error' || resultado.estado === 'timeout') {
            // Primero llevar la barra a 100%
            setTestEnCurso(prev => prev ? { ...prev, progreso: 100 } : null);

            // Esperar un momento para que se vea la barra llena antes de mostrar el resultado
            setTimeout(() => {
              setTestEnCurso(null);
              setResultadoTest({
                ...resultado,
                exito: resultado.estado === 'completado',
                registrador: datosTest,
              });
            }, 400);
          } else {
            // Seguir esperando
            setTimeout(poll, intervalo);
          }
        } catch (err) {
          setTestEnCurso(null);
          setResultadoTest({
            exito: false,
            estado: 'error',
            error_mensaje: err.message,
            registrador: datosTest,
          });
        }
      };

      // Iniciar polling
      setTimeout(poll, intervalo);

    } catch (err) {
      setTestEnCurso(null);

      // Manejar error de cooldown
      if (err.message?.includes('esperar')) {
        setResultadoTest({
          exito: false,
          estado: 'cooldown',
          error_mensaje: err.message,
          registrador: datosTest,
        });
      } else {
        setError(err.message);
      }
    }
  };

  // Copiar al portapapeles
  const copiarAlPortapapeles = (texto) => {
    navigator.clipboard.writeText(texto);
  };

  // --- Drag & Drop ---
  const handleMouseDown = (e) => {
    if (maximizada) return;
    if (e.target.closest("button")) return;
    if (onEnfocar) onEnfocar();
    setArrastrando(true);
    const rect = ventanaRef.current.getBoundingClientRect();
    setOffsetArrastre({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    });
  };

  useEffect(() => {
    if (!arrastrando) return;

    const handleMouseMove = (e) => {
      const newX = Math.max(0, e.clientX - offsetArrastre.x);
      const newY = Math.max(0, e.clientY - offsetArrastre.y);
      if (onMover) {
        onMover({ x: newX, y: newY });
      }
    };

    const handleMouseUp = () => {
      setArrastrando(false);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [arrastrando, offsetArrastre, onMover]);

  // --- Resize ---
  const handleResizeMouseDown = (e) => {
    if (maximizada) return;
    e.preventDefault();
    e.stopPropagation();
    setRedimensionando(true);
    setPosicionInicialResize({ x: e.clientX, y: e.clientY });
    const rect = ventanaRef.current.getBoundingClientRect();
    setDimensionesIniciales({ width: rect.width, height: rect.height });
  };

  useEffect(() => {
    if (!redimensionando) return;

    const handleMouseMove = (e) => {
      const deltaX = e.clientX - posicionInicialResize.x;
      const deltaY = e.clientY - posicionInicialResize.y;
      const newWidth = Math.max(600, dimensionesIniciales.width + deltaX);
      const newHeight = Math.max(400, dimensionesIniciales.height + deltaY);
      setDimensiones({ width: newWidth, height: newHeight });
    };

    const handleMouseUp = () => {
      setRedimensionando(false);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [redimensionando, posicionInicialResize, dimensionesIniciales]);

  // Manejadores para minimizar/maximizar (con fallbacks internos si no se proveen)
  const handleMinimizar = useCallback(() => {
    if (onMinimizar) onMinimizar();
  }, [onMinimizar]);

  const handleMaximizar = useCallback(() => {
    if (onMaximizar) onMaximizar();
  }, [onMaximizar]);

  const handleEnfocar = useCallback(() => {
    if (onEnfocar) onEnfocar();
  }, [onEnfocar]);

  if (!abierto) return null;
  if (minimizada) return null;

  // Renderizar indicador de estado de conexi√≥n
  const renderEstadoConexion = (agente) => (
    <span className={`config-agente-estado ${agente.conectado ? 'config-agente-estado--conectado' : 'config-agente-estado--desconectado'}`}>
      <span className="config-agente-estado-punto"></span>
      {agente.conectado ? 'Conectado' : 'Desconectado'}
    </span>
  );

  // Renderizar lista de registradores (con acciones opcionales para superadmin)
  const renderRegistradores = (agenteId, conAcciones = false) => {
    const regs = registradoresAgente[agenteId] || [];
    const hayActivos = regs.some(r => r.activo);
    const hayInactivos = regs.some(r => !r.activo);

    return (
      <div className="config-agente-regs-contenedor">
        {/* Botones de acci√≥n (solo en panel superadmin) */}
        {conAcciones && (
          <div className="config-agente-regs-toolbar">
            <button
              className="config-agente-btn config-agente-btn--agregar-reg"
              onClick={() => {
                resetFormRegistrador();
                setMostrarFormRegistrador(agenteId);
              }}
            >
              + Agregar Registrador
            </button>
            {regs.length > 0 && (
              <div className="config-agente-regs-toolbar-acciones">
                {hayInactivos && (
                  <button
                    className="config-agente-btn config-agente-btn--iniciar-todos"
                    onClick={() => handleToggleTodosRegistradores(agenteId, true)}
                    disabled={registradorProcesando === 'todos'}
                    title="Iniciar todos los registradores pausados"
                  >
                    {registradorProcesando === 'todos' ? (
                      <span className="config-agente-spinner-mini"></span>
                    ) : '‚ñ∂'} Iniciar todos
                  </button>
                )}
                {hayActivos && (
                  <button
                    className="config-agente-btn config-agente-btn--parar-todos"
                    onClick={() => handleToggleTodosRegistradores(agenteId, false)}
                    disabled={registradorProcesando === 'todos'}
                    title="Pausar todos los registradores activos"
                  >
                    {registradorProcesando === 'todos' ? (
                      <span className="config-agente-spinner-mini"></span>
                    ) : '‚è∏'} Pausar todos
                  </button>
                )}
              </div>
            )}
          </div>
        )}

        {/* Formulario crear/editar registrador */}
        {conAcciones && mostrarFormRegistrador === agenteId && (
          <form className="config-agente-reg-form" onSubmit={(e) => handleGuardarRegistrador(e, agenteId)}>
            <h5>{registradorEditando ? 'Editar Registrador' : 'Nuevo Registrador'}</h5>

            {/* Selector de tipo de dispositivo */}
            <div className="config-agente-tipo-row">
              <label className="config-agente-tipo-label">Tipo de Dispositivo:</label>
              <select
                value={nuevoRegistrador.tipoDispositivo}
                onChange={e => setNuevoRegistrador(prev => ({
                  ...prev,
                  tipoDispositivo: e.target.value,
                  configuracionRele: e.target.value === 'analizador' ? null : prev.configuracionRele,
                }))}
                disabled={guardandoRegistrador}
                className="config-agente-select-tipo"
              >
                <option value="analizador">üìä Analizador de Redes</option>
                <option value="rele">üõ°Ô∏è Rel√© de Protecci√≥n</option>
              </select>
            </div>

            {/* Formulario para Analizador de Redes */}
            {nuevoRegistrador.tipoDispositivo === 'analizador' && (
              <div className="config-agente-analizador">
                {/* Nombre del registrador */}
                <div className="config-agente-analizador-nombre">
                  <label>Nombre del Registrador</label>
                  <input
                    type="text"
                    value={nuevoRegistrador.nombre}
                    onChange={e => setNuevoRegistrador(prev => ({ ...prev, nombre: e.target.value }))}
                    placeholder="Ej: Analizador Trafo 1"
                    disabled={guardandoRegistrador}
                  />
                </div>

                {/* Secciones en dos columnas */}
                <div className="config-agente-analizador-grid">
                  {/* Secci√≥n Conexi√≥n */}
                  <div className="config-agente-analizador-seccion">
                    <h6>üì° Conexi√≥n Modbus TCP</h6>
                    <div className="config-agente-analizador-campos">
                      <div className="config-agente-campo-inline">
                        <label>IP</label>
                        <input
                          type="text"
                          value={nuevoRegistrador.ip}
                          onChange={e => setNuevoRegistrador(prev => ({ ...prev, ip: e.target.value }))}
                          placeholder="192.168.1.100"
                          disabled={guardandoRegistrador}
                        />
                      </div>
                      <div className="config-agente-campo-inline">
                        <label>Puerto</label>
                        <input
                          type="number"
                          value={nuevoRegistrador.puerto}
                          onChange={e => setNuevoRegistrador(prev => ({ ...prev, puerto: e.target.value }))}
                          placeholder="502"
                          disabled={guardandoRegistrador}
                        />
                      </div>
                      <div className="config-agente-campo-inline">
                        <label>Unit ID</label>
                        <input
                          type="number"
                          value={nuevoRegistrador.unitId}
                          onChange={e => setNuevoRegistrador(prev => ({ ...prev, unitId: e.target.value }))}
                          placeholder="1"
                          disabled={guardandoRegistrador}
                        />
                      </div>
                    </div>
                  </div>

                  {/* Secci√≥n Registros */}
                  <div className="config-agente-analizador-seccion">
                    <h6>üìã Registros Modbus</h6>
                    <div className="config-agente-analizador-campos">
                      <div className="config-agente-campo-inline">
                        <label>√çndice Inicial</label>
                        <input
                          type="number"
                          value={nuevoRegistrador.indiceInicial}
                          onChange={e => setNuevoRegistrador(prev => ({ ...prev, indiceInicial: e.target.value }))}
                          placeholder="0"
                          disabled={guardandoRegistrador}
                        />
                      </div>
                      <div className="config-agente-campo-inline">
                        <label>Cantidad</label>
                        <input
                          type="number"
                          value={nuevoRegistrador.cantidadRegistros}
                          onChange={e => setNuevoRegistrador(prev => ({ ...prev, cantidadRegistros: e.target.value }))}
                          placeholder="20"
                          disabled={guardandoRegistrador}
                        />
                      </div>
                      <div className="config-agente-campo-inline">
                        <label>Intervalo</label>
                        <div className="config-agente-input-con-sufijo">
                          <input
                            type="number"
                            value={nuevoRegistrador.intervaloSegundos}
                            onChange={e => setNuevoRegistrador(prev => ({ ...prev, intervaloSegundos: e.target.value }))}
                            placeholder="60"
                            disabled={guardandoRegistrador}
                          />
                          <span>seg</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="config-agente-form-acciones">
                  <button
                    type="button"
                    className="config-agente-btn config-agente-btn--test"
                    onClick={() => handleTestRegistrador(agenteId)}
                    disabled={guardandoRegistrador || testEnCurso || !nuevoRegistrador.ip.trim() || !nuevoRegistrador.puerto || !nuevoRegistrador.indiceInicial || !nuevoRegistrador.cantidadRegistros}
                    title="Probar conexi√≥n antes de guardar"
                  >
                    {testEnCurso ? 'Probando...' : 'Test'}
                  </button>
                  <div className="config-agente-form-acciones-derecha">
                    <button
                      type="button"
                      className="config-agente-btn config-agente-btn--secundario"
                      onClick={() => {
                        setMostrarFormRegistrador(null);
                        resetFormRegistrador();
                      }}
                      disabled={guardandoRegistrador || testEnCurso}
                    >
                      Cancelar
                    </button>
                    <button
                      type="submit"
                      className="config-agente-btn config-agente-btn--primario"
                      disabled={guardandoRegistrador || testEnCurso || !nuevoRegistrador.nombre.trim() || !nuevoRegistrador.ip.trim() || !nuevoRegistrador.puerto || !nuevoRegistrador.indiceInicial || !nuevoRegistrador.cantidadRegistros}
                    >
                      {guardandoRegistrador ? 'Guardando...' : (registradorEditando ? 'Guardar' : 'Crear')}
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Formulario para Rel√© de Protecci√≥n */}
            {nuevoRegistrador.tipoDispositivo === 'rele' && (
              <>
                {/* Nombre del registrador (compartido con analizadores) */}
                <div className="config-agente-rele-nombre">
                  <label>Nombre del Registrador</label>
                  <input
                    type="text"
                    value={nuevoRegistrador.nombre}
                    onChange={e => setNuevoRegistrador(prev => ({ ...prev, nombre: e.target.value }))}
                    placeholder="Ej: Rel√© REF615 Bah√≠a 1"
                    disabled={guardandoRegistrador}
                  />
                </div>
                <ConfiguracionRele
                  configuracionInicial={nuevoRegistrador.configuracionRele}
                  onChange={(config) => setNuevoRegistrador(prev => ({
                    ...prev,
                    configuracionRele: config,
                  }))}
                  agenteId={agenteId}
                />
                <div className="config-agente-form-acciones">
                  <div className="config-agente-form-acciones-derecha">
                    <button
                      type="button"
                      className="config-agente-btn config-agente-btn--secundario"
                      onClick={() => {
                        setMostrarFormRegistrador(null);
                        resetFormRegistrador();
                      }}
                      disabled={guardandoRegistrador}
                    >
                      Cancelar
                    </button>
                    <button
                      type="submit"
                      className="config-agente-btn config-agente-btn--primario"
                      disabled={guardandoRegistrador || !nuevoRegistrador.nombre.trim() || !nuevoRegistrador.configuracionRele}
                    >
                      {guardandoRegistrador ? 'Guardando...' : (registradorEditando ? 'Guardar' : 'Crear')}
                    </button>
                  </div>
                </div>
              </>
            )}
          </form>
        )}

        {/* Lista de registradores */}
        {regs.length === 0 ? (
          <div className="config-agente-regs-vacio">Sin registradores configurados</div>
        ) : (
          <div className="config-agente-regs-lista">
            {regs.map(reg => {
              const esRele = reg.tipo_dispositivo === 'rele';
              const configRele = reg.configuracion_rele;

              return (
                <div key={reg.id} className={`config-agente-reg-item ${conAcciones ? 'config-agente-reg-item--admin' : ''} ${esRele ? 'config-agente-reg-item--rele' : ''}`}>
                  <div className="config-agente-reg-info">
                    <span
                      className={`config-agente-reg-estado ${reg.activo ? 'config-agente-reg-estado--activo' : ''}`}
                      title={reg.activo ? 'Activo' : 'Inactivo'}
                    ></span>
                    <span className="config-agente-reg-tipo" title={esRele ? 'Rel√© de Protecci√≥n' : 'Analizador de Redes'}>
                      {esRele ? 'üõ°Ô∏è' : 'üìä'}
                    </span>
                    <span className="config-agente-reg-nombre">{reg.nombre}</span>
                    {esRele && configRele ? (
                      <span className="config-agente-reg-detalle">
                        {reg.ip}:{reg.puerto} | {configRele.modeloId} - {configRele.configuracionId} | {reg.intervalo_segundos}s
                      </span>
                    ) : (
                      <span className="config-agente-reg-detalle">
                        {reg.ip}:{reg.puerto} | Reg: {reg.indice_inicial}-{reg.indice_inicial + reg.cantidad_registros - 1} | {reg.intervalo_segundos}s
                      </span>
                    )}
                  </div>
                  {conAcciones && (
                  <div className="config-agente-reg-acciones">
                    <button
                      className={`config-agente-btn-icon ${reg.activo ? 'config-agente-btn-icon--success' : ''}`}
                      onClick={() => handleToggleRegistrador(agenteId, reg.id)}
                      title={reg.activo ? 'Desactivar' : 'Activar'}
                      disabled={registradorProcesando === reg.id}
                    >
                      {registradorProcesando === reg.id ? (
                        <span className="config-agente-spinner-mini"></span>
                      ) : (
                        reg.activo ? '‚è∏' : '‚ñ∂'
                      )}
                    </button>
                    <button
                      className="config-agente-btn-icon"
                      onClick={() => handleEditarRegistrador({ ...reg, agente_id: agenteId })}
                      title="Editar"
                      disabled={registradorProcesando === reg.id}
                    >
                      ‚úèÔ∏è
                    </button>
                    <button
                      className="config-agente-btn-icon config-agente-btn-icon--danger"
                      onClick={() => handleEliminarRegistrador(agenteId, reg.id, reg.nombre)}
                      title="Eliminar"
                      disabled={registradorProcesando === reg.id}
                    >
                      üóë
                    </button>
                  </div>
                  )}
                </div>
              );
            })}
          </div>
        )}
      </div>
    );
  };

  // Estilo din√°mico de la ventana
  const estiloVentana = maximizada
    ? { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, width: "100%", height: "100%", zIndex }
    : {
        position: "fixed",
        top: posicion.y,
        left: posicion.x,
        width: dimensiones.width,
        height: dimensiones.height,
        zIndex,
      };

  return (
    <div
      ref={ventanaRef}
      className={`config-agente-ventana ${maximizada ? "config-agente-ventana--maximizada" : ""} ${arrastrando ? "config-agente-ventana--arrastrando" : ""} ${redimensionando ? "config-agente-ventana--redimensionando" : ""}`}
      style={estiloVentana}
      onMouseDown={handleEnfocar}
    >
      {/* Header arrastrable */}
      <header
        ref={headerRef}
        className="config-agente-header"
        onMouseDown={handleMouseDown}
      >
        <div className="config-agente-titulo">
          <span className="config-agente-icono">‚öôÔ∏è</span>
          <h2>Configuraci√≥n de Agentes</h2>
        </div>
        <div className="config-agente-controles-ventana">
          <button
            type="button"
            className="config-agente-btn-ventana config-agente-btn-ventana--minimizar"
            onClick={handleMinimizar}
            title="Minimizar"
          >
            <span>‚îÄ</span>
          </button>
          <button
            type="button"
            className="config-agente-btn-ventana config-agente-btn-ventana--maximizar"
            onClick={handleMaximizar}
            title={maximizada ? "Restaurar" : "Maximizar"}
          >
            <span>{maximizada ? "‚ùê" : "‚ñ°"}</span>
          </button>
          <button
            type="button"
            className="config-agente-btn-ventana config-agente-btn-ventana--cerrar"
            onClick={onCerrar}
            title="Cerrar"
          >
            <span>√ó</span>
          </button>
        </div>
      </header>

        {/* Pesta√±as */}
        <div className="config-agente-tabs">
          {pestanasDisponibles.map(p => (
            <button
              key={p.id}
              className={`config-agente-tab ${pestanaActiva === p.id ? 'config-agente-tab--activa' : ''}`}
              onClick={() => setPestanaActiva(p.id)}
            >
              {p.label}
            </button>
          ))}
        </div>

        {/* Contenido */}
        <div className="config-agente-contenido">
          {/* Alerta de clave generada */}
          {claveGenerada && (
            <div className="config-agente-alerta config-agente-alerta--exito">
              <div className="config-agente-alerta-header">
                <strong>Clave del Agente</strong>
                <button onClick={() => setClaveGenerada(null)}>√ó</button>
              </div>
              <p>Guarda esta clave, no se mostrar√° de nuevo:</p>
              <div className="config-agente-clave-box">
                <code>{claveGenerada}</code>
                <button onClick={() => copiarAlPortapapeles(claveGenerada)}>Copiar</button>
              </div>
            </div>
          )}

          {/* Error */}
          {error && (
            <div className="config-agente-alerta config-agente-alerta--error">
              {error}
              <button onClick={() => setError(null)}>√ó</button>
            </div>
          )}

          {/* Cargando */}
          {cargando && (
            <div className="config-agente-cargando">
              <span className="config-agente-spinner"></span>
              Cargando...
            </div>
          )}

          {/* ========== PESTA√ëA: AGENTES VINCULADOS ========== */}
          {pestanaActiva === 'vinculados' && !cargando && (
            <div className="config-agente-seccion">
              {agentesVinculados.length === 0 ? (
                <div className="config-agente-vacio">
                  <span className="config-agente-vacio-icono">üì°</span>
                  <p>No hay agentes vinculados a este workspace</p>
                  {puedeVincular && (
                    <button
                      className="config-agente-btn config-agente-btn--primario"
                      onClick={() => setPestanaActiva('vincular')}
                    >
                      Vincular un Agente
                    </button>
                  )}
                  {!puedeVincular && (
                    <p className="config-agente-hint">Contacta a un administrador para vincular agentes.</p>
                  )}
                </div>
              ) : (
                <div className="config-agente-lista">
                  {agentesVinculados.map(agente => (
                    <div key={agente.id} className="config-agente-card">
                      <div className="config-agente-card-header">
                        <div className="config-agente-card-info">
                          <h3>{agente.nombre}</h3>
                          {renderEstadoConexion(agente)}
                        </div>
                        <div className="config-agente-card-acciones">
                          <button
                            className="config-agente-btn-icon"
                            onClick={() => toggleRegistradores(agente.id)}
                            title="Ver registradores"
                          >
                            {agenteExpandido === agente.id ? '‚ñ≤' : '‚ñº'}
                          </button>
                          {/* El bot√≥n desvincular es visible para admins, pero solo funciona para creador/superadmin */}
                          {esAdmin && (
                            <button
                              className={`config-agente-btn-icon config-agente-btn-icon--danger ${!puedeVincularDesvincular ? 'config-agente-btn-icon--disabled' : ''}`}
                              onClick={() => {
                                if (puedeVincularDesvincular) {
                                  handleDesvincular(agente.id);
                                } else {
                                  alert('Solo el administrador que cre√≥ el workspace puede desvincular agentes.');
                                }
                              }}
                              title={puedeVincularDesvincular ? 'Desvincular' : 'Solo el creador del workspace puede desvincular'}
                            >
                              ‚úï
                            </button>
                          )}
                        </div>
                      </div>
                      {agente.descripcion && (
                        <p className="config-agente-card-desc">{agente.descripcion}</p>
                      )}
                      {agenteExpandido === agente.id && (
                        <div className="config-agente-card-regs">
                          <h4>Registradores</h4>
                          {renderRegistradores(agente.id)}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}

          {/* ========== PESTA√ëA: VINCULAR AGENTE ========== */}
          {pestanaActiva === 'vincular' && !cargando && (
            <div className="config-agente-seccion">
              <p className="config-agente-instruccion">
                Selecciona un agente disponible para vincularlo a este workspace.
              </p>
              {agentesDisponibles.length === 0 ? (
                <div className="config-agente-vacio">
                  <span className="config-agente-vacio-icono">üîç</span>
                  <p>No hay agentes disponibles para vincular</p>
                  {esSuperadmin && (
                    <button
                      className="config-agente-btn config-agente-btn--primario"
                      onClick={() => setPestanaActiva('admin')}
                    >
                      Crear nuevo Agente
                    </button>
                  )}
                </div>
              ) : (
                <div className="config-agente-lista">
                  {agentesDisponibles.map(agente => (
                    <div key={agente.id} className="config-agente-card config-agente-card--disponible">
                      <div className="config-agente-card-header">
                        <div className="config-agente-card-info">
                          <h3>{agente.nombre}</h3>
                          {renderEstadoConexion(agente)}
                        </div>
                        <button
                          className="config-agente-btn config-agente-btn--vincular"
                          onClick={() => handleVincular(agente.id)}
                        >
                          Vincular
                        </button>
                      </div>
                      {agente.descripcion && (
                        <p className="config-agente-card-desc">{agente.descripcion}</p>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}

          {/* ========== PESTA√ëA: PANEL ADMIN ========== */}
          {pestanaActiva === 'admin' && !cargando && (
            <div className="config-agente-seccion">
              {/* Formulario crear agente */}
              {!mostrarFormCrear ? (
                <button
                  className="config-agente-btn config-agente-btn--crear"
                  onClick={() => setMostrarFormCrear(true)}
                >
                  + Crear Nuevo Agente
                </button>
              ) : (
                <form className="config-agente-form" onSubmit={handleCrearAgente}>
                  <h4>Nuevo Agente</h4>
                  <div className="config-agente-form-grupo">
                    <label>Nombre *</label>
                    <input
                      type="text"
                      value={nuevoAgente.nombre}
                      onChange={e => setNuevoAgente(prev => ({ ...prev, nombre: e.target.value }))}
                      placeholder="Ej: Agente Subestaci√≥n Norte"
                      disabled={creando}
                    />
                  </div>
                  <div className="config-agente-form-grupo">
                    <label>Descripci√≥n</label>
                    <input
                      type="text"
                      value={nuevoAgente.descripcion}
                      onChange={e => setNuevoAgente(prev => ({ ...prev, descripcion: e.target.value }))}
                      placeholder="Descripci√≥n opcional"
                      disabled={creando}
                    />
                  </div>
                  <div className="config-agente-form-acciones">
                    <button
                      type="button"
                      className="config-agente-btn config-agente-btn--secundario"
                      onClick={() => setMostrarFormCrear(false)}
                      disabled={creando}
                    >
                      Cancelar
                    </button>
                    <button
                      type="submit"
                      className="config-agente-btn config-agente-btn--primario"
                      disabled={creando || !nuevoAgente.nombre.trim()}
                    >
                      {creando ? 'Creando...' : 'Crear Agente'}
                    </button>
                  </div>
                </form>
              )}

              {/* Lista de todos los agentes */}
              <div className="config-agente-admin-lista">
                <h4>Todos los Agentes del Sistema</h4>
                {todosAgentes.length === 0 ? (
                  <div className="config-agente-vacio">
                    <p>No hay agentes en el sistema</p>
                  </div>
                ) : (
                  <div className="config-agente-lista">
                    {todosAgentes.map(agente => (
                      <div key={agente.id} className="config-agente-card config-agente-card--admin">
                        <div className="config-agente-card-header">
                          <div className="config-agente-card-info">
                            <h3>{agente.nombre}</h3>
                            {renderEstadoConexion(agente)}
                            {!agente.activo && (
                              <span className="config-agente-badge config-agente-badge--inactivo">Inactivo</span>
                            )}
                          </div>
                          <div className="config-agente-card-acciones">
                            <button
                              className="config-agente-btn-icon"
                              onClick={() => toggleRegistradores(agente.id)}
                              title="Ver registradores"
                            >
                              {agenteExpandido === agente.id ? '‚ñ≤' : '‚ñº'}
                            </button>
                            <button
                              className="config-agente-btn-icon"
                              onClick={() => handleRotarClave(agente.id)}
                              title="Rotar clave"
                            >
                              üîë
                            </button>
                            <button
                              className="config-agente-btn-icon config-agente-btn-icon--danger"
                              onClick={() => handleEliminarAgente(agente.id, agente.nombre)}
                              title="Eliminar"
                            >
                              üóë
                            </button>
                          </div>
                        </div>
                        {agente.descripcion && (
                          <p className="config-agente-card-desc">{agente.descripcion}</p>
                        )}
                        {agenteExpandido === agente.id && (
                          <div className="config-agente-card-regs">
                            <h4>Registradores</h4>
                            {renderRegistradores(agente.id, true)}
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        {/* Modal de resultado del test */}
        {resultadoTest && (
          <div className="config-agente-test-overlay" onClick={() => setResultadoTest(null)}>
            <div className="config-agente-test-modal" onClick={e => e.stopPropagation()}>
              <div className="config-agente-test-header">
                <h3>Resultado del Test</h3>
                <button className="config-agente-cerrar" onClick={() => setResultadoTest(null)}>√ó</button>
              </div>
              <div className="config-agente-test-contenido">
                <div className="config-agente-test-info">
                  <strong>{resultadoTest.registrador?.nombre}</strong>
                  <span className="config-agente-test-detalle">
                    {resultadoTest.registrador?.ip}:{resultadoTest.registrador?.puerto}
                  </span>
                </div>

                {resultadoTest.exito ? (
                  <div className="config-agente-test-exito">
                    <div className="config-agente-test-icono">‚úì</div>
                    <h4>Conexi√≥n Exitosa</h4>
                    <p className="config-agente-test-tiempo">
                      Tiempo de respuesta: <strong>{resultadoTest.tiempo_respuesta_ms}ms</strong>
                    </p>
                    {resultadoTest.valores && resultadoTest.valores.length > 0 && (
                      <div className="config-agente-test-valores">
                        <h5>Valores le√≠dos ({resultadoTest.valores.length} registros):</h5>
                        <div className="config-agente-test-valores-grid">
                          {resultadoTest.valores.map((valor, idx) => (
                            <div key={idx} className="config-agente-test-valor">
                              <span className="config-agente-test-valor-idx">
                                [{resultadoTest.registrador?.indice_inicial + idx}]
                              </span>
                              <span className="config-agente-test-valor-num">{valor}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                ) : (
                  <div className="config-agente-test-error">
                    <div className="config-agente-test-icono config-agente-test-icono--error">‚úó</div>
                    <h4>
                      {resultadoTest.estado === 'timeout' && 'Tiempo Agotado'}
                      {resultadoTest.estado === 'cooldown' && 'Espera Requerida'}
                      {resultadoTest.estado === 'error' && 'Error de Conexi√≥n'}
                    </h4>
                    <p className="config-agente-test-mensaje">{resultadoTest.error_mensaje}</p>
                    {resultadoTest.tiempo_respuesta_ms && (
                      <p className="config-agente-test-tiempo">
                        Tiempo transcurrido: {resultadoTest.tiempo_respuesta_ms}ms
                      </p>
                    )}
                  </div>
                )}
              </div>
              <div className="config-agente-test-acciones">
                <button
                  className="config-agente-btn config-agente-btn--primario"
                  onClick={() => setResultadoTest(null)}
                >
                  Cerrar
                </button>
              </div>
            </div>
          </div>
        )}

      {/* Indicador de test en progreso */}
      {testEnCurso && (
        <div className="config-agente-test-progreso">
          <div className="config-agente-test-progreso-contenido">
            <span className="config-agente-spinner"></span>
            <span>Esperando respuesta del agente...</span>
            <div className="config-agente-test-progreso-barra">
              <div
                className="config-agente-test-progreso-fill"
                style={{ width: `${testEnCurso.progreso}%` }}
              ></div>
            </div>
          </div>
        </div>
      )}

      {/* Handle de resize en esquina inferior derecha */}
      {!maximizada && (
        <div
          className="config-agente-resize-handle"
          onMouseDown={handleResizeMouseDown}
          title="Arrastrar para redimensionar"
        />
      )}
    </div>
  );
};

export default ModalConfigurarAgente;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalConfirmacion.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfirmacion.jsx
// Modal de confirmaci√≥n reutilizable con estilo oscuro

import React from "react";
import "./ModalConfirmacion.css";

/**
 * Modal de confirmaci√≥n gen√©rico.
 * Muestra un mensaje y dos botones: Cancelar y Confirmar.
 */
const ModalConfirmacion = ({
  abierto,
  titulo = "Confirmar acci√≥n",
  mensaje,
  textoConfirmar = "Confirmar",
  textoCancelar = "Cancelar",
  onConfirmar,
  onCancelar,
  peligroso = false, // Si es true, el bot√≥n de confirmar ser√° rojo
}) => {
  if (!abierto) return null;

  return (
    <div className="confirmacion-fondo-oscuro">
      <div className="confirmacion-contenedor">
        <h2>{titulo}</h2>
        <p className="confirmacion-mensaje">{mensaje}</p>

        <div className="confirmacion-acciones">
          <button
            type="button"
            className="confirmacion-boton confirmacion-cancelar"
            onClick={onCancelar}
          >
            {textoCancelar}
          </button>
          <button
            type="button"
            className={`confirmacion-boton ${peligroso ? "confirmacion-peligro" : "confirmacion-confirmar"}`}
            onClick={onConfirmar}
          >
            {textoConfirmar}
          </button>
        </div>
      </div>
    </div>
  );
};

export default ModalConfirmacion;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalEditarPuestos.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/modales/ModalEditarPuestos.jsx

import React, { useState, useEffect } from "react";      // React + hooks para estado y efectos
import "./ModalEditarPuestos.css";                       // estilos espec√≠ficos de este modal
import ColorPickerSimple from "./ColorPickerSimple";     // selector de color minimalista
import TabApariencia from "./TabApariencia";             // pesta√±a de apariencia global

// Componente interno para el input de escala con estado local
const InputEscala = ({ valor, onChange, min, max }) => {
	const [valorLocal, setValorLocal] = useState(valor?.toString() ?? "1");

	// Sincronizar cuando cambia el valor externo
	useEffect(() => {
		setValorLocal(valor?.toString() ?? "1");
	}, [valor]);

	const aplicarCambio = () => {
		const valorNum = parseFloat(valorLocal);
		if (!isNaN(valorNum)) {
			const valorClamped = Math.max(min, Math.min(max, valorNum));
			onChange(valorClamped);
			setValorLocal(valorClamped.toString());
		} else {
			// Si no es v√°lido, restaurar al valor original
			setValorLocal(valor?.toString() ?? "1");
		}
	};

	const handleKeyDown = (e) => {
		if (e.key === "Enter") {
			aplicarCambio();
			e.target.blur();
		}
	};

	return (
		<input
			type="number"
			step="0.1"
			min={min}
			max={max}
			value={valorLocal}
			onChange={(e) => setValorLocal(e.target.value)}
			onBlur={aplicarCambio}
			onKeyDown={handleKeyDown}
			className="editar-escala-input"
		/>
	);
};

const ModalEditarPuestos = ({
	abierto,                                              // si es false, el modal no se renderiza
	puestos,                                              // lista original de puestos proveniente del contexto
	onCerrar,                                             // callback para cerrar sin guardar
	onGuardar,                                            // callback que recibe los puestos modificados
	esCreador,                                            // si el usuario es creador del workspace
	rolEnWorkspace,                                       // rol del usuario en el workspace (admin, operador, observador)
	// Props de escala por puesto
	obtenerEscalaPuesto,                                  // (puestoId) => number | undefined
	onEscalaPuestoChange,                                 // (puestoId, escala) => void
	ESCALA_MIN = 0.5,
	ESCALA_MAX = 2.0,
	// Props de estilos globales (para pesta√±a Apariencia)
	estilosGlobales,                                      // objeto con estilos actuales
	onGuardarEstilos,                                     // callback para guardar todos los estilos
}) => {
	const [puestosEditados, setPuestosEditados] = useState([]); // copia editable local
	const [tabActiva, setTabActiva] = useState("puestos");      // "puestos" o "apariencia"

	// Solo el creador o admin en el workspace pueden editar nombres y eliminar puestos
	// Operador y observador solo pueden cambiar colores y escala (son preferencias de usuario)
	const puedeEditarNombre = esCreador || rolEnWorkspace === 'admin';

	useEffect(() => {
		if (abierto) {
			// cuando se abre, clono el array de puestos para no mutar el original
			setPuestosEditados(puestos.map((p) => ({ ...p })));
		}
	}, [abierto, puestos]);

	const handleSubmit = () => {
		onGuardar(puestosEditados);                       // devuelvo al caller la versi√≥n editada
	};

	const cambiarNombre = (id, nombreNuevo) => {
		// recorro el array y s√≥lo modifico el puesto que coincide por id
		setPuestosEditados((prev) =>
			prev.map((p) => (p.id === id ? { ...p, nombre: nombreNuevo } : p))
		);
	};

	const cambiarColorBoton = (id, colorNuevo) => {
		setPuestosEditados((prev) =>
			prev.map((p) => (p.id === id ? { ...p, color: colorNuevo } : p))
		);
	};

	const cambiarColorFondo = (id, colorNuevo) => {
		setPuestosEditados((prev) =>
			prev.map((p) => (p.id === id ? { ...p, bgColor: colorNuevo } : p))
		);
	};

	const eliminar = (id) => {
		// filtro el puesto con ese id para "borrarlo" de la lista local
		setPuestosEditados((prev) => prev.filter((p) => p.id !== id));
	};

	if (!abierto) return null;                            // si no est√° abierto, no dibujo nada

	// Clase condicional para hacer el modal m√°s ancho en la pesta√±a de Apariencia
	const clasesContenedor = `editar-contenedor${tabActiva === "apariencia" ? " editar-contenedor--apariencia" : ""}`;

	return (
		<div className="editar-fondo-oscuro">
			<div className={clasesContenedor}>
				<h2>Configuraci√≥n</h2>

				{/* Sistema de tabs */}
				<div className="editar-tabs">
					<button
						type="button"
						className={`editar-tab ${tabActiva === "puestos" ? "editar-tab--activo" : ""}`}
						onClick={() => setTabActiva("puestos")}
					>
						Puestos
					</button>
					<button
						type="button"
						className={`editar-tab ${tabActiva === "apariencia" ? "editar-tab--activo" : ""}`}
						onClick={() => setTabActiva("apariencia")}
					>
						Apariencia
					</button>
				</div>

				{/* Contenido de la tab activa */}
				{tabActiva === "puestos" ? (
					<div className="editar-lista">
						{puestosEditados.map((p) => (
							<div key={p.id} className="editar-fila">
								<input
									type="text"
									className="editar-nombre"
									value={p.nombre}
									onChange={(e) => cambiarNombre(p.id, e.target.value)} // actualiza nombre en la copia local
									disabled={!puedeEditarNombre}                         // solo admin/superadmin pueden editar nombre
								/>

								<div className="editar-controles">
									<ColorPickerSimple
										color={p.color || "#22c55e"}
										onChange={(newColor) => cambiarColorBoton(p.id, newColor)}
										label="Bot√≥n"
									/>

									<ColorPickerSimple
										color={p.bgColor || "#e5e7eb"}
										onChange={(newColor) => cambiarColorFondo(p.id, newColor)}
										label="Fondo"
									/>

									{/* Control de escala por puesto */}
									{obtenerEscalaPuesto && onEscalaPuestoChange && (
										<div className="editar-escala">
											<label className="editar-escala-label">(0.5 - 2)</label>
											<InputEscala
												valor={obtenerEscalaPuesto(p.id) ?? 1.0}
												onChange={(nuevoValor) => onEscalaPuestoChange(p.id, nuevoValor)}
												min={ESCALA_MIN}
												max={ESCALA_MAX}
											/>
										</div>
									)}

									{/* Solo admin/superadmin pueden eliminar puestos */}
									{puedeEditarNombre && (
										<button
											type="button"
											className="editar-eliminar"
											onClick={() => eliminar(p.id)}             // elimina el puesto de la lista local
										>
											Eliminar
										</button>
									)}
								</div>
							</div>
						))}
					</div>
				) : (
					/* Pesta√±a de Apariencia - tiene su propio footer con botones */
					estilosGlobales && (
						<TabApariencia
							estilosIniciales={estilosGlobales}
							onGuardar={(nuevosEstilos) => {
								onGuardarEstilos(nuevosEstilos);
								onCerrar();
							}}
							onCancelar={onCerrar}
						/>
					)
				)}

				{/* Solo mostrar botones para la pesta√±a de Puestos */}
				{tabActiva === "puestos" && (
					<div className="editar-acciones">
						<button
							type="button"
							className="editar-boton editar-cancelar"
							onClick={onCerrar}
						>
							Cancelar
						</button>
						<button
							type="button"
							className="editar-boton editar-guardar"
							onClick={handleSubmit}
						>
							Guardar
						</button>
					</div>
				)}
			</div>
		</div>
	);
};

export default ModalEditarPuestos;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (ModalEditarPuestos.jsx)

 - Este modal funciona como un "panel de edici√≥n masiva" para todos los puestos:
   permite renombrarlos, cambiar el color del bot√≥n y el color de fondo, o
   directamente eliminarlos.

 - Al abrirse (`abierto === true`), clona el array `puestos` en `puestosEditados`
   para trabajar siempre sobre una copia local y no mutar el estado global
   del contexto hasta que realmente aprieto "Guardar".

 - Cada helper (`cambiarNombre`, `cambiarColorBoton`, `cambiarColorFondo`,
   `eliminar`) modifica s√≥lo el puesto indicado buscando por `id` y usando
   funciones de actualizaci√≥n inmutables (`map` / `filter`).

 - Al confirmar, `handleSubmit` llama a `onGuardar(puestosEditados)` y el
   componente padre decide c√≥mo persistir esos cambios (por ejemplo, usando
   `usarPuestos` y guardando en localStorage).

 - Si alguna vez quiero agregar m√°s propiedades editables (por ejemplo, un
   "orden" o una descripci√≥n), basta con extender el objeto `p` y agregar
   los campos en esta lista, manteniendo el mismo patr√≥n de edici√≥n local.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (ModalEditarPuestos.jsx)

0) Visi√≥n general del componente

   `ModalEditarPuestos` es un panel de edici√≥n masiva de puestos. Permite:

   - Cambiar el nombre de cada puesto.
   - Cambiar el color del bot√≥n del puesto (color principal).
   - Cambiar el color de fondo asociado a ese puesto.
   - Eliminar puestos completos de la lista.

   La gracia es que todo se hace sobre una copia local (`puestosEditados`) y
   reci√©n cuando el usuario pulsa ‚ÄúGuardar‚Äù se env√≠an los cambios al exterior.


1) Props del componente

   const ModalEditarPuestos = ({
     abierto,
     puestos,
     onCerrar,
     onGuardar,
   }) => { ... }

   - `abierto` (boolean):
       ‚Ä¢ Si es false    ‚Üí el modal no se renderiza (devuelve `null`).
       ‚Ä¢ Si es true     ‚Üí se dibuja overlay + contenido del modal.

   - `puestos` (array):
       ‚Ä¢ Lista de puestos que viene del contexto/global.
       ‚Ä¢ Cada elemento suele ser algo como:
         { id, nombre, color, bgColor, ... }.

   - `onCerrar()`:
       ‚Ä¢ Se llama al pulsar ‚ÄúCancelar‚Äù o cuando se quiera cerrar sin guardar.

   - `onGuardar(puestosEditados)`:
       ‚Ä¢ Recibe la versi√≥n editada de la lista de puestos,
       ‚Ä¢ El padre (VistaAlimentadores / usarPuestos) decide c√≥mo persistirla
         (estado global, localStorage, etc.).


2) Estado local y sincronizaci√≥n al abrir

   const [puestosEditados, setPuestosEditados] = useState([]);

   - `puestosEditados` es una copia editable de `puestos`:
       ‚Ä¢ Esto evita modificar directamente el array original del contexto.
       ‚Ä¢ Permite descartar cambios f√°cilmente si el usuario cancela.

   useEffect(() => {
     if (abierto) {
       setPuestosEditados(puestos.map((p) => ({ ...p })));
     }
   }, [abierto, puestos]);

   - Cuando el modal se abre (`abierto` pasa a true):

       1) Se recorre `puestos` y se crea un nuevo array con copias
          superficiales de cada puesto (`{ ...p }`).
       2) Se guarda en `puestosEditados`.

   - De esta forma:
       ‚Ä¢ el usuario siempre edita la versi√≥n m√°s actual de la lista,
       ‚Ä¢ y no hay riesgo de mutar accidentalmente el array original.


3) Handlers de actualizaci√≥n

   3.1) handleSubmit

   const handleSubmit = () => {
     onGuardar(puestosEditados);
   };

   - Se ejecuta al pulsar el bot√≥n ‚ÄúGuardar‚Äù.
   - Entrega la lista `puestosEditados` al exterior.
   - A partir de ah√≠, el componente padre decide:
       ‚Ä¢ actualizar el contexto (`actualizarPuestos`),
       ‚Ä¢ cerrar el modal,
       ‚Ä¢ y persistir si hace falta.

   3.2) cambiarNombre(id, nombreNuevo)

   - Busca el puesto con ese `id` y actualiza solo su `nombre`:

       setPuestosEditados((prev) =>
         prev.map((p) => p.id === id ? { ...p, nombre: nombreNuevo } : p)
       );

   - Se apoya en:
       ‚Ä¢ `map` ‚Üí devuelve un nuevo array,
       ‚Ä¢ spread `{ ...p, nombre: nombreNuevo }` ‚Üí respeta inmutabilidad.

   3.3) cambiarColorBoton(id, colorNuevo)

   - Mismo patr√≥n que `cambiarNombre`, pero actualizando `color`.

   3.4) cambiarColorFondo(id, colorNuevo)

   - Mismo patr√≥n, pero actualizando `bgColor`, que es el color de fondo
     del puesto (usado luego en el `<main>` de VistaAlimentadores).

   3.5) eliminar(id)

   - Elimina el puesto con ese `id` de la copia local:

       setPuestosEditados((prev) => prev.filter((p) => p.id !== id));

   - Solo afecta al listado interno del modal; el estado global no se toca
     hasta que se pulsa ‚ÄúGuardar‚Äù.


4) L√≥gica de renderizado condicional

   if (!abierto) return null;

   - Si el modal no est√° abierto, no se renderiza nada.
   - Esto ahorra trabajo de React y evita que el overlay interfiera con la UI.


5) Estructura JSX del modal

   5.1) Overlay y contenedor

   - `<div className="alim-modal-overlay">`:
       ‚Ä¢ fondo semitransparente que oscurece la pantalla.

   - `<div className="alim-modal">`:
       ‚Ä¢ caja blanca centrada donde vive el contenido del modal.

   5.2) Lista editable de puestos

   {puestosEditados.map((p) => (
     <div key={p.id} className="alim-edit-row">
       <input ... value={p.nombre} onChange={(e) => cambiarNombre(...)} />
       ...
       <input type="color" ... value={p.color} onChange={...} />
       <input type="color" ... value={p.bgColor || "#e5e7eb"} onChange={...} />
       <button onClick={() => eliminar(p.id)}>Eliminar</button>
     </div>
   ))}

   - Por cada puesto se dibuja una fila con:

       ‚Ä¢ Input de texto para el nombre:
           - enlazado a `p.nombre`,
           - cualquier cambio llama a `cambiarNombre`.

       ‚Ä¢ Dos ‚Äúpickers‚Äù de color:
           - uno para el color del bot√≥n (`p.color`),
           - otro para el color de fondo (`p.bgColor` o gris claro por defecto).
           - ambos actualizan la copia local por medio de sus handlers.

       ‚Ä¢ Bot√≥n ‚ÄúEliminar‚Äù:
           - quita el puesto de `puestosEditados`.
           - la eliminaci√≥n real se consolida solo si se pulsa ‚ÄúGuardar‚Äù.

   5.3) Botones de acci√≥n

   - Bot√≥n ‚ÄúCancelar‚Äù:
       ‚Ä¢ type="button",
       ‚Ä¢ llama a `onCerrar`,
       ‚Ä¢ descarta cualquier cambio hecho desde que se abri√≥ el modal.

   - Bot√≥n ‚ÄúGuardar‚Äù:
       ‚Ä¢ type="button",
       ‚Ä¢ llama a `handleSubmit`,
       ‚Ä¢ env√≠a `puestosEditados` al padre para que los persista.

---------------------------------------------------------------------------*/
========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalGestionarAccesos.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/modales/ModalGestionarAccesos.jsx
// Modal para gestionar usuarios con acceso a un workspace

import React, { useState, useEffect } from "react";
import "./ModalConfiguracionAlimentador.css"; // estilos base del modal
import "./ModalGestionarAccesos.css";         // estilos espec√≠ficos
import {
  obtenerPermisosWorkspace,
  agregarPermisoWorkspace,
  actualizarPermisoWorkspace,
  eliminarPermisoWorkspace,
} from "../../../../servicios/apiService";

/**
 * Modal para gestionar los accesos (permisos) de usuarios a un workspace.
 * Permite ver usuarios con acceso, invitar nuevos y cambiar/revocar roles.
 */
const ModalGestionarAccesos = ({
  abierto,
  onCerrar,
  workspaceId,
  workspaceNombre,
  usuarioActualId,
}) => {
  // Estado
  const [permisos, setPermisos] = useState([]);
  const [cargando, setCargando] = useState(false);
  const [error, setError] = useState(null);

  // Form de invitaci√≥n
  const [emailInvitar, setEmailInvitar] = useState("");
  const [rolInvitar, setRolInvitar] = useState("observador");
  const [invitando, setInvitando] = useState(false);
  const [errorInvitar, setErrorInvitar] = useState(null);
  const [exitoInvitar, setExitoInvitar] = useState(null);

  // Roles disponibles para asignar (no incluye superadmin)
  const rolesDisponibles = [
    { codigo: "observador", nombre: "Observador", descripcion: "Solo puede ver datos" },
    { codigo: "operador", nombre: "Operador", descripcion: "Puede operar mediciones" },
    { codigo: "admin", nombre: "Administrador", descripcion: "Puede gestionar el workspace" },
  ];

  // Cargar permisos al abrir
  useEffect(() => {
    if (abierto && workspaceId) {
      cargarPermisos();
    }
  }, [abierto, workspaceId]);

  // Limpiar estado al cerrar
  useEffect(() => {
    if (!abierto) {
      setEmailInvitar("");
      setRolInvitar("observador");
      setErrorInvitar(null);
      setExitoInvitar(null);
    }
  }, [abierto]);

  const cargarPermisos = async () => {
    try {
      setCargando(true);
      setError(null);
      const data = await obtenerPermisosWorkspace(workspaceId);
      setPermisos(data);
    } catch (err) {
      console.error("Error cargando permisos:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  const handleInvitar = async (e) => {
    e.preventDefault();
    const email = emailInvitar.trim().toLowerCase();

    if (!email) {
      setErrorInvitar("Ingresa un email");
      return;
    }

    try {
      setInvitando(true);
      setErrorInvitar(null);
      setExitoInvitar(null);

      const nuevoPermiso = await agregarPermisoWorkspace(workspaceId, email, rolInvitar);

      // Agregar a la lista o actualizar si ya exist√≠a
      setPermisos(prev => {
        const existe = prev.find(p => p.usuario_id === nuevoPermiso.usuario_id);
        if (existe) {
          return prev.map(p => p.usuario_id === nuevoPermiso.usuario_id ? nuevoPermiso : p);
        }
        return [...prev, nuevoPermiso];
      });

      setEmailInvitar("");
      setExitoInvitar(`Usuario ${email} agregado correctamente`);

      // Limpiar mensaje de √©xito despu√©s de 3s
      setTimeout(() => setExitoInvitar(null), 3000);
    } catch (err) {
      console.error("Error invitando usuario:", err);
      setErrorInvitar(err.message);
    } finally {
      setInvitando(false);
    }
  };

  const handleCambiarRol = async (permisoId, nuevoRol) => {
    try {
      const actualizado = await actualizarPermisoWorkspace(permisoId, nuevoRol);
      setPermisos(prev => prev.map(p => p.id === permisoId ? actualizado : p));
    } catch (err) {
      console.error("Error actualizando rol:", err);
      setError(err.message);
    }
  };

  const handleEliminarAcceso = async (permisoId, nombreUsuario) => {
    if (!confirm(`¬øEliminar el acceso de ${nombreUsuario} a este workspace?`)) {
      return;
    }

    try {
      await eliminarPermisoWorkspace(permisoId);
      setPermisos(prev => prev.filter(p => p.id !== permisoId));
    } catch (err) {
      console.error("Error eliminando acceso:", err);
      setError(err.message);
    }
  };

  if (!abierto) return null;

  return (
    <div className="alim-modal-overlay">
      <div className="alim-modal modal-accesos">
        {/* Header */}
        <div className="modal-accesos__header">
          <h2>Permisos para Workspace: {workspaceNombre}</h2>
        </div>

        {/* Contenido */}
        <div className="modal-accesos__contenido">
          {/* Secci√≥n: Invitar usuario */}
          <div className="modal-accesos__seccion">
            <h3>Invitar Usuario</h3>
            <form className="modal-accesos__form-invitar" onSubmit={handleInvitar}>
              <input
                type="email"
                className="alim-modal-input"
                placeholder="Ingrese el email del usuario a invitar"
                value={emailInvitar}
                onChange={(e) => setEmailInvitar(e.target.value)}
                disabled={invitando}
              />
              <select
                className="alim-modal-select"
                value={rolInvitar}
                onChange={(e) => setRolInvitar(e.target.value)}
                disabled={invitando}
              >
                {rolesDisponibles.map(r => (
                  <option key={r.codigo} value={r.codigo}>
                    {r.nombre}
                  </option>
                ))}
              </select>
              <button
                type="submit"
                className="modal-accesos__btn-invitar"
                disabled={invitando || !emailInvitar.trim()}
              >
                {invitando ? "Invitando..." : "Invitar"}
              </button>
            </form>

            {errorInvitar && (
              <div className="modal-accesos__mensaje modal-accesos__mensaje--error">
                {errorInvitar}
              </div>
            )}
            {exitoInvitar && (
              <div className="modal-accesos__mensaje modal-accesos__mensaje--exito">
                {exitoInvitar}
              </div>
            )}
          </div>

          {/* Secci√≥n: Lista de usuarios */}
          <div className="modal-accesos__seccion">
            <h3>Usuarios con acceso</h3>

            {cargando ? (
              <div className="modal-accesos__cargando">Cargando...</div>
            ) : error ? (
              <div className="modal-accesos__error">
                Error: {error}
                <button onClick={cargarPermisos}>Reintentar</button>
              </div>
            ) : permisos.filter(p => p.usuario_id !== usuarioActualId).length === 0 ? (
              <div className="modal-accesos__vacio">
                No hay otros usuarios con acceso a este workspace.
              </div>
            ) : (
              <ul className="modal-accesos__lista">
                {permisos.filter(p => p.usuario_id !== usuarioActualId).map(permiso => (
                  <li key={permiso.id} className="modal-accesos__usuario">
                    <div className="modal-accesos__usuario-info">
                      <span className="modal-accesos__usuario-icono">üë§</span>
                      <div className="modal-accesos__usuario-datos">
                        <span className="modal-accesos__usuario-nombre">
                          {permiso.usuarios?.nombre || "Sin nombre"}
                        </span>
                        <span className="modal-accesos__usuario-email">
                          {permiso.usuarios?.email}
                        </span>
                      </div>
                    </div>

                    <div className="modal-accesos__usuario-acciones">
                      <select
                        className="modal-accesos__select-rol"
                        value={permiso.rol}
                        onChange={(e) => handleCambiarRol(permiso.id, e.target.value)}
                      >
                        {rolesDisponibles.map(r => (
                          <option key={r.codigo} value={r.codigo}>
                            {r.nombre}
                          </option>
                        ))}
                      </select>
                      <button
                        type="button"
                        className="modal-accesos__btn-eliminar"
                        onClick={() => handleEliminarAcceso(
                          permiso.id,
                          permiso.usuarios?.nombre || permiso.usuarios?.email
                        )}
                        title="Eliminar acceso"
                      >
                        ‚úï
                      </button>
                    </div>
                  </li>
                ))}
              </ul>
            )}
          </div>
        </div>

        {/* Footer */}
        <div className="modal-accesos__footer">
          <button
            type="button"
            className="alim-modal-btn alim-modal-btn-secondary"
            onClick={onCerrar}
          >
            Cerrar
          </button>
        </div>
      </div>
    </div>
  );
};

export default ModalGestionarAccesos;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalGestionModelosRele.jsx ==========
/**
 * Modal para gestionar modelos de rel√© personalizados.
 * Permite crear, editar y eliminar modelos de diferentes fabricantes.
 */
import { useState, useEffect } from "react";
import { useModelosRele } from "../../hooks/useModelosRele";
import {
  CATEGORIAS_PROTECCION,
  SEVERIDADES,
} from "../../constantes/datosBaseReles";
import "./ModalGestionModelosRele.css";

const ModalGestionModelosRele = ({ abierto, onCerrar, onModeloCreado }) => {
  const {
    modelos,
    configuraciones,
    getModelos,
    getConfiguracionesDeModelo,
    agregarModelo,
    agregarConfiguracion,
    actualizarModelo,
    actualizarConfiguracion,
    eliminarModelo,
    eliminarConfiguracion,
  } = useModelosRele();

  // Estado de vista: 'lista' | 'crear' | 'editar'
  const [vista, setVista] = useState('lista');
  const [modeloEditandoId, setModeloEditandoId] = useState(null);
  const [configEditandoId, setConfigEditandoId] = useState(null);
  const [confirmandoEliminar, setConfirmandoEliminar] = useState(null); // { tipo: 'modelo'|'config', id: string }

  // Estado del wizard/formulario
  const [paso, setPaso] = useState(1); // 1: Info b√°sica, 2: Protecciones
  const [error, setError] = useState(null);

  // Estado del nuevo modelo
  const [nuevoModelo, setNuevoModelo] = useState({
    id: "",
    nombre: "",
    fabricante: "",
    familia: "",
    descripcion: "",
    icono: "‚ö°",
  });

  // Estado de la nueva configuraci√≥n
  const [nuevaConfig, setNuevaConfig] = useState({
    id: "",
    nombre: "",
    descripcion: "",
    // Capacidades
    medicionCorriente: true,
    medicionTension: false,
    proteccionDireccional: false,
    autorecierre: false,
    proteccionDiferencial: false,
    // Protecciones
    protecciones: [],
  });

  // Estado para agregar protecci√≥n
  const [nuevaProteccion, setNuevaProteccion] = useState({
    codigo: "",
    nombre: "",
    nombreCorto: "",
    ansi: "",
    registroStart: "",
    bitStart: "",
    registroOperate: "",
    bitOperate: "",
    severidad: "media",
    categoria: "sobrecorriente",
  });

  const [mostrarFormProteccion, setMostrarFormProteccion] = useState(false);

  // Reset al cerrar
  useEffect(() => {
    if (!abierto) {
      setVista('lista');
      setModeloEditandoId(null);
      setConfigEditandoId(null);
      setConfirmandoEliminar(null);
      setPaso(1);
      setError(null);
      setNuevoModelo({
        id: "",
        nombre: "",
        fabricante: "",
        familia: "",
        descripcion: "",
        icono: "‚ö°",
      });
      setNuevaConfig({
        id: "",
        nombre: "",
        descripcion: "",
        medicionCorriente: true,
        medicionTension: false,
        proteccionDireccional: false,
        autorecierre: false,
        proteccionDiferencial: false,
        protecciones: [],
      });
      setNuevaProteccion({
        codigo: "",
        nombre: "",
        nombreCorto: "",
        ansi: "",
        registroStart: "",
        bitStart: "",
        registroOperate: "",
        bitOperate: "",
        severidad: "media",
        categoria: "sobrecorriente",
      });
      setMostrarFormProteccion(false);
    }
  }, [abierto]);

  // Validar paso actual
  const validarPaso = (numPaso) => {
    setError(null);

    if (numPaso === 1) {
      if (!nuevoModelo.nombre.trim()) {
        setError("El nombre del modelo es requerido");
        return false;
      }
      if (!nuevoModelo.fabricante.trim()) {
        setError("El fabricante es requerido");
        return false;
      }
      if (!nuevaConfig.nombre.trim()) {
        setError("El nombre de la configuraci√≥n es requerido");
        return false;
      }
    }

    return true;
  };

  // Ir al siguiente paso
  const siguientePaso = () => {
    if (validarPaso(paso)) {
      setPaso(paso + 1);
    }
  };

  // Ir al paso anterior
  const pasoAnterior = () => {
    setPaso(paso - 1);
  };

  // Agregar protecci√≥n a la lista
  const handleAgregarProteccion = () => {
    if (!nuevaProteccion.codigo.trim() || !nuevaProteccion.nombre.trim()) {
      setError("C√≥digo y nombre de protecci√≥n son requeridos");
      return;
    }

    // Verificar que no exista
    if (nuevaConfig.protecciones.some(p => p.codigo === nuevaProteccion.codigo)) {
      setError("Ya existe una protecci√≥n con ese c√≥digo");
      return;
    }

    setNuevaConfig(prev => ({
      ...prev,
      protecciones: [...prev.protecciones, { ...nuevaProteccion }],
    }));

    // Reset form protecci√≥n
    setNuevaProteccion({
      codigo: "",
      nombre: "",
      nombreCorto: "",
      ansi: "",
      registroStart: "",
      bitStart: "",
      registroOperate: "",
      bitOperate: "",
      severidad: "media",
      categoria: "sobrecorriente",
    });
    setMostrarFormProteccion(false);
    setError(null);
  };

  // Eliminar protecci√≥n de la lista
  const handleEliminarProteccion = (codigo) => {
    setNuevaConfig(prev => ({
      ...prev,
      protecciones: prev.protecciones.filter(p => p.codigo !== codigo),
    }));
  };

  // Iniciar creaci√≥n de nuevo modelo
  const handleNuevoModelo = () => {
    setVista('crear');
    setPaso(1);
    setNuevoModelo({
      id: "",
      nombre: "",
      fabricante: "",
      familia: "",
      descripcion: "",
      icono: "‚ö°",
    });
    setNuevaConfig({
      id: "",
      nombre: "",
      descripcion: "",
      medicionCorriente: true,
      medicionTension: false,
      proteccionDireccional: false,
      autorecierre: false,
      proteccionDiferencial: false,
      protecciones: [],
    });
  };

  // Iniciar edici√≥n de modelo
  const handleEditarModelo = (modeloId) => {
    const modelo = modelos[modeloId];
    if (!modelo) return;

    setModeloEditandoId(modeloId);
    setVista('editar');
    setPaso(1);
    setNuevoModelo({
      id: modelo.id,
      nombre: modelo.nombre,
      fabricante: modelo.fabricante,
      familia: modelo.familia || "",
      descripcion: modelo.descripcion || "",
      icono: modelo.icono || "‚ö°",
    });

    // Cargar primera configuraci√≥n si existe
    const configsDelModelo = getConfiguracionesDeModelo(modeloId);
    if (configsDelModelo.length > 0) {
      const config = configsDelModelo[0];
      setConfigEditandoId(config.id);
      setNuevaConfig({
        id: config.id,
        nombre: config.nombre,
        descripcion: config.descripcion || "",
        medicionCorriente: config.capacidades?.medicionCorriente ?? true,
        medicionTension: config.capacidades?.medicionTension ?? false,
        proteccionDireccional: config.capacidades?.proteccionDireccional ?? false,
        autorecierre: config.capacidades?.autorecierre ?? false,
        proteccionDiferencial: config.capacidades?.proteccionDiferencial ?? false,
        protecciones: config.protecciones || [],
      });
    }
  };

  // Confirmar eliminaci√≥n
  const handleConfirmarEliminar = (tipo, id) => {
    setConfirmandoEliminar({ tipo, id });
  };

  // Cancelar eliminaci√≥n
  const handleCancelarEliminar = () => {
    setConfirmandoEliminar(null);
  };

  // Ejecutar eliminaci√≥n
  const handleEliminar = () => {
    if (!confirmandoEliminar) return;

    try {
      if (confirmandoEliminar.tipo === 'modelo') {
        eliminarModelo(confirmandoEliminar.id);
      } else if (confirmandoEliminar.tipo === 'config') {
        eliminarConfiguracion(confirmandoEliminar.id);
      }
      setConfirmandoEliminar(null);
    } catch (err) {
      setError(err.message);
    }
  };

  // Volver a la lista
  const handleVolverALista = () => {
    setVista('lista');
    setModeloEditandoId(null);
    setConfigEditandoId(null);
    setPaso(1);
    setError(null);
  };

  // Guardar modelo y configuraci√≥n
  const handleGuardar = () => {
    try {
      if (vista === 'editar') {
        // Actualizar modelo existente
        actualizarModelo(modeloEditandoId, {
          nombre: nuevoModelo.nombre,
          fabricante: nuevoModelo.fabricante,
          familia: nuevoModelo.familia || nuevoModelo.fabricante,
          descripcion: nuevoModelo.descripcion,
          icono: nuevoModelo.icono,
        });

        // Actualizar configuraci√≥n
        if (configEditandoId) {
          actualizarConfiguracion(configEditandoId, {
            nombre: nuevaConfig.nombre,
            descripcion: nuevaConfig.descripcion,
            capacidades: {
              medicionCorriente: nuevaConfig.medicionCorriente,
              medicionTension: nuevaConfig.medicionTension,
              proteccionDireccional: nuevaConfig.proteccionDireccional,
              autorecierre: nuevaConfig.autorecierre,
              proteccionDiferencial: nuevaConfig.proteccionDiferencial,
            },
            protecciones: nuevaConfig.protecciones,
          });
        }

        handleVolverALista();
      } else {
        // Crear ID √∫nico para modelo
        const modeloId = `${nuevoModelo.fabricante.toUpperCase()}_${nuevoModelo.nombre.replace(/\s+/g, "_").toUpperCase()}`;
        const configId = `${modeloId}_${nuevaConfig.nombre.replace(/\s+/g, "_").toUpperCase()}`;

        // Crear modelo
        const modeloData = {
          id: modeloId,
          nombre: nuevoModelo.nombre,
          fabricante: nuevoModelo.fabricante,
          familia: nuevoModelo.familia || nuevoModelo.fabricante,
          descripcion: nuevoModelo.descripcion,
          icono: nuevoModelo.icono,
          configuraciones: [configId],
        };

        // Crear configuraci√≥n con estructura correcta
        const configData = {
          id: configId,
          nombre: nuevaConfig.nombre,
          descripcion: nuevaConfig.descripcion,
          modeloId: modeloId,
          capacidades: {
            medicionCorriente: nuevaConfig.medicionCorriente,
            medicionTension: nuevaConfig.medicionTension,
            proteccionDireccional: nuevaConfig.proteccionDireccional,
            autorecierre: nuevaConfig.autorecierre,
            proteccionDiferencial: nuevaConfig.proteccionDiferencial,
          },
          protecciones: nuevaConfig.protecciones,
        };

        agregarModelo(modeloData);
        agregarConfiguracion(configData);

        if (onModeloCreado) {
          onModeloCreado(modeloId, configId);
        }

        onCerrar();
      }
    } catch (err) {
      setError(err.message);
    }
  };

  // Lista de modelos
  const listaModelos = getModelos();

  if (!abierto) return null;

  // T√≠tulo seg√∫n la vista
  const getTitulo = () => {
    if (vista === 'lista') return 'Gestionar Modelos de Rel√©';
    if (vista === 'editar') return 'Editar Modelo';
    return 'Crear Modelo de Rel√©';
  };

  return (
    <div className="gestion-modelo-overlay" onClick={onCerrar}>
      <div className="gestion-modelo-modal" onClick={(e) => e.stopPropagation()}>
        {/* Header */}
        <div className="gestion-modelo-header">
          <h2>{getTitulo()}</h2>
          <button className="gestion-modelo-cerrar" onClick={onCerrar}>√ó</button>
        </div>

        {/* Indicador de pasos - solo en crear/editar */}
        {vista !== 'lista' && (
          <div className="gestion-modelo-pasos">
            <div className={`gestion-modelo-paso ${paso >= 1 ? "activo" : ""} ${paso > 1 ? "completado" : ""}`}>
              <span className="paso-numero">1</span>
              <span className="paso-texto">Informaci√≥n</span>
            </div>
            <div className="paso-linea"></div>
            <div className={`gestion-modelo-paso ${paso >= 2 ? "activo" : ""}`}>
              <span className="paso-numero">2</span>
              <span className="paso-texto">Protecciones</span>
            </div>
          </div>
        )}

        {/* Contenido */}
        <div className="gestion-modelo-contenido">
          {error && (
            <div className="gestion-modelo-error">
              {error}
              <button onClick={() => setError(null)}>√ó</button>
            </div>
          )}

          {/* Modal de confirmaci√≥n de eliminaci√≥n */}
          {confirmandoEliminar && (
            <div className="gestion-modelo-confirmar-eliminar">
              <div className="confirmar-eliminar-contenido">
                <span className="confirmar-eliminar-icono">‚ö†Ô∏è</span>
                <p>
                  {confirmandoEliminar.tipo === 'modelo'
                    ? '¬øEliminar este modelo y todas sus configuraciones?'
                    : '¬øEliminar esta configuraci√≥n?'}
                </p>
                <div className="confirmar-eliminar-acciones">
                  <button className="btn-cancelar" onClick={handleCancelarEliminar}>
                    Cancelar
                  </button>
                  <button className="btn-eliminar" onClick={handleEliminar}>
                    Eliminar
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Vista Lista de Modelos */}
          {vista === 'lista' && (
            <div className="gestion-modelo-lista">
              {listaModelos.length === 0 ? (
                <div className="lista-modelos-vacia">
                  <span className="lista-vacia-icono">üì¶</span>
                  <p>No hay modelos personalizados</p>
                  <p className="lista-vacia-hint">Crea tu primer modelo de rel√© para comenzar</p>
                </div>
              ) : (
                <div className="lista-modelos">
                  {listaModelos.map((modelo) => {
                    const configsModelo = getConfiguracionesDeModelo(modelo.id);
                    const primeraConfig = configsModelo[0];
                    const totalProtecciones = primeraConfig?.protecciones?.length || 0;
                    return (
                      <div key={modelo.id} className="lista-modelo-item">
                        <div className="lista-modelo-info">
                          <span className="lista-modelo-icono">{modelo.icono || '‚ö°'}</span>
                          <div className="lista-modelo-detalles">
                            <span className="lista-modelo-nombre">{modelo.nombre}</span>
                            <span className="lista-modelo-fabricante">{modelo.fabricante}</span>
                          </div>
                          <div className="lista-modelo-config-info">
                            {primeraConfig && (
                              <>
                                <span className="lista-modelo-config-nombre">{primeraConfig.nombre}</span>
                                <span className="lista-modelo-protecciones">
                                  {totalProtecciones} se√±al{totalProtecciones !== 1 ? 'es' : ''}
                                </span>
                              </>
                            )}
                          </div>
                        </div>
                        <div className="lista-modelo-acciones">
                          <button
                            className="btn-lista-editar"
                            onClick={() => handleEditarModelo(modelo.id)}
                            title="Editar modelo"
                          >
                            ‚úèÔ∏è
                          </button>
                          <button
                            className="btn-lista-eliminar"
                            onClick={() => handleConfirmarEliminar('modelo', modelo.id)}
                            title="Eliminar modelo"
                          >
                            üóëÔ∏è
                          </button>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          )}

          {/* Paso 1: Informaci√≥n b√°sica */}
          {vista !== 'lista' && paso === 1 && (
            <div className="gestion-modelo-seccion">
              <h3>Informaci√≥n del Modelo</h3>
              <div className="gestion-modelo-grid">
                <div className="gestion-modelo-campo">
                  <label>Fabricante *</label>
                  <input
                    type="text"
                    value={nuevoModelo.fabricante}
                    onChange={(e) => setNuevoModelo(prev => ({ ...prev, fabricante: e.target.value }))}
                    placeholder="Ej: Siemens, Schneider, GE..."
                  />
                </div>
                <div className="gestion-modelo-campo">
                  <label>Modelo *</label>
                  <input
                    type="text"
                    value={nuevoModelo.nombre}
                    onChange={(e) => setNuevoModelo(prev => ({ ...prev, nombre: e.target.value }))}
                    placeholder="Ej: 7SJ82, Sepam 80..."
                  />
                </div>
                <div className="gestion-modelo-campo">
                  <label>Familia/Serie</label>
                  <input
                    type="text"
                    value={nuevoModelo.familia}
                    onChange={(e) => setNuevoModelo(prev => ({ ...prev, familia: e.target.value }))}
                    placeholder="Ej: SIPROTEC 5, Sepam..."
                  />
                </div>
                <div className="gestion-modelo-campo">
                  <label>Descripci√≥n</label>
                  <input
                    type="text"
                    value={nuevoModelo.descripcion}
                    onChange={(e) => setNuevoModelo(prev => ({ ...prev, descripcion: e.target.value }))}
                    placeholder="Descripci√≥n breve del modelo"
                  />
                </div>
              </div>

              <h3 style={{ marginTop: "1.5rem" }}>Configuraci√≥n</h3>
              <div className="gestion-modelo-grid">
                <div className="gestion-modelo-campo">
                  <label>Nombre de Configuraci√≥n *</label>
                  <input
                    type="text"
                    value={nuevaConfig.nombre}
                    onChange={(e) => setNuevaConfig(prev => ({ ...prev, nombre: e.target.value }))}
                    placeholder="Ej: Protecci√≥n Alimentador"
                  />
                </div>
                <div className="gestion-modelo-campo">
                  <label>Descripci√≥n</label>
                  <input
                    type="text"
                    value={nuevaConfig.descripcion}
                    onChange={(e) => setNuevaConfig(prev => ({ ...prev, descripcion: e.target.value }))}
                    placeholder="Descripci√≥n de la configuraci√≥n"
                  />
                </div>
              </div>

              <h4>Capacidades</h4>
              <div className="gestion-modelo-capacidades">
                <label className="capacidad-check">
                  <input
                    type="checkbox"
                    checked={nuevaConfig.medicionCorriente}
                    onChange={(e) => setNuevaConfig(prev => ({ ...prev, medicionCorriente: e.target.checked }))}
                  />
                  Medici√≥n de Corriente
                </label>
                <label className="capacidad-check">
                  <input
                    type="checkbox"
                    checked={nuevaConfig.medicionTension}
                    onChange={(e) => setNuevaConfig(prev => ({
                      ...prev,
                      medicionTension: e.target.checked,
                      registros: {
                        ...prev.registros,
                        tensiones: { ...prev.registros.tensiones, habilitado: e.target.checked }
                      }
                    }))}
                  />
                  Medici√≥n de Tensi√≥n
                </label>
                <label className="capacidad-check">
                  <input
                    type="checkbox"
                    checked={nuevaConfig.proteccionDireccional}
                    onChange={(e) => setNuevaConfig(prev => ({ ...prev, proteccionDireccional: e.target.checked }))}
                  />
                  Protecci√≥n Direccional
                </label>
                <label className="capacidad-check">
                  <input
                    type="checkbox"
                    checked={nuevaConfig.autorecierre}
                    onChange={(e) => setNuevaConfig(prev => ({ ...prev, autorecierre: e.target.checked }))}
                  />
                  Autorecierre
                </label>
                <label className="capacidad-check">
                  <input
                    type="checkbox"
                    checked={nuevaConfig.proteccionDiferencial}
                    onChange={(e) => setNuevaConfig(prev => ({ ...prev, proteccionDiferencial: e.target.checked }))}
                  />
                  Protecci√≥n Diferencial
                </label>
              </div>
            </div>
          )}

          {/* Paso 2: Protecciones */}
          {vista !== 'lista' && paso === 2 && (
            <div className="gestion-modelo-seccion">
              <h3>Protecciones / Fallas</h3>
              <p className="gestion-modelo-hint">
                Define las protecciones que el rel√© puede reportar, con sus registros y bits asociados.
              </p>

              {/* Lista de protecciones agregadas */}
              <div className="protecciones-lista">
                {nuevaConfig.protecciones.length === 0 ? (
                  <div className="protecciones-vacio">
                    No hay protecciones definidas. Agrega al menos una.
                  </div>
                ) : (
                  nuevaConfig.protecciones.map((prot) => (
                    <div key={prot.codigo} className="proteccion-item">
                      <div className="proteccion-item-info">
                        <span
                          className="proteccion-severidad"
                          style={{ backgroundColor: SEVERIDADES[prot.severidad]?.color }}
                        ></span>
                        <span className="proteccion-codigo">{prot.codigo}</span>
                        <span className="proteccion-nombre">{prot.nombre}</span>
                        <span className="proteccion-ansi">ANSI {prot.ansi}</span>
                      </div>
                      <div className="proteccion-item-registros">
                        <span>Start: R{prot.registroStart}:B{prot.bitStart}</span>
                        <span>Operate: R{prot.registroOperate}:B{prot.bitOperate}</span>
                      </div>
                      <button
                        className="proteccion-eliminar"
                        onClick={() => handleEliminarProteccion(prot.codigo)}
                        title="Eliminar"
                      >
                        √ó
                      </button>
                    </div>
                  ))
                )}
              </div>

              {/* Bot√≥n para agregar */}
              {!mostrarFormProteccion ? (
                <button
                  className="btn-agregar-proteccion"
                  onClick={() => setMostrarFormProteccion(true)}
                >
                  + Agregar Protecci√≥n
                </button>
              ) : (
                <div className="form-proteccion">
                  <h4>Nueva Protecci√≥n</h4>

                  {/* Fila 1: Identificaci√≥n */}
                  <div className="form-proteccion-row form-proteccion-row--identificacion">
                    <div className="registro-campo campo-codigo">
                      <label>C√≥digo *</label>
                      <input
                        type="text"
                        value={nuevaProteccion.codigo}
                        onChange={(e) => setNuevaProteccion(prev => ({ ...prev, codigo: e.target.value.toUpperCase() }))}
                        placeholder="PHLPTOC1"
                      />
                    </div>
                    <div className="registro-campo campo-nombre">
                      <label>Nombre *</label>
                      <input
                        type="text"
                        value={nuevaProteccion.nombre}
                        onChange={(e) => setNuevaProteccion(prev => ({ ...prev, nombre: e.target.value }))}
                        placeholder="Sobrecorriente Fase Baja"
                      />
                    </div>
                    <div className="registro-campo campo-nombre-corto">
                      <label>Nombre Corto</label>
                      <input
                        type="text"
                        value={nuevaProteccion.nombreCorto}
                        onChange={(e) => setNuevaProteccion(prev => ({ ...prev, nombreCorto: e.target.value }))}
                        placeholder="I> Fase"
                      />
                    </div>
                    <div className="registro-campo campo-ansi">
                      <label>ANSI</label>
                      <input
                        type="text"
                        value={nuevaProteccion.ansi}
                        onChange={(e) => setNuevaProteccion(prev => ({ ...prev, ansi: e.target.value }))}
                        placeholder="51P"
                      />
                    </div>
                  </div>

                  {/* Fila 2: Registros y Clasificaci√≥n */}
                  <div className="form-proteccion-row form-proteccion-row--registros">
                    <div className="registro-campo campo-registro">
                      <label>Reg. Start</label>
                      <input
                        type="number"
                        value={nuevaProteccion.registroStart}
                        onChange={(e) => setNuevaProteccion(prev => ({ ...prev, registroStart: e.target.value === "" ? "" : parseInt(e.target.value) || 0 }))}
                        placeholder="180"
                      />
                    </div>
                    <div className="registro-campo campo-bit">
                      <label>Bit Start</label>
                      <input
                        type="number"
                        min="0"
                        max="15"
                        value={nuevaProteccion.bitStart}
                        onChange={(e) => setNuevaProteccion(prev => ({ ...prev, bitStart: e.target.value === "" ? "" : parseInt(e.target.value) || 0 }))}
                        placeholder="0"
                      />
                    </div>
                    <div className="registro-campo campo-registro">
                      <label>Reg. Oper.</label>
                      <input
                        type="number"
                        value={nuevaProteccion.registroOperate}
                        onChange={(e) => setNuevaProteccion(prev => ({ ...prev, registroOperate: e.target.value === "" ? "" : parseInt(e.target.value) || 0 }))}
                        placeholder="180"
                      />
                    </div>
                    <div className="registro-campo campo-bit">
                      <label>Bit Operate</label>
                      <input
                        type="number"
                        min="0"
                        max="15"
                        value={nuevaProteccion.bitOperate}
                        onChange={(e) => setNuevaProteccion(prev => ({ ...prev, bitOperate: e.target.value === "" ? "" : parseInt(e.target.value) || 0 }))}
                        placeholder="8"
                      />
                    </div>
                    <div className="registro-campo campo-severidad">
                      <label>Severidad</label>
                      <select
                        value={nuevaProteccion.severidad}
                        onChange={(e) => setNuevaProteccion(prev => ({ ...prev, severidad: e.target.value }))}
                      >
                        {Object.entries(SEVERIDADES).map(([id, sev]) => (
                          <option key={id} value={id}>{sev.nombre}</option>
                        ))}
                      </select>
                    </div>
                    <div className="registro-campo campo-categoria">
                      <label>Categor√≠a</label>
                      <select
                        value={nuevaProteccion.categoria}
                        onChange={(e) => setNuevaProteccion(prev => ({ ...prev, categoria: e.target.value }))}
                      >
                        {Object.entries(CATEGORIAS_PROTECCION).map(([id, cat]) => (
                          <option key={id} value={id}>{cat.icono} {cat.nombre}</option>
                        ))}
                      </select>
                    </div>
                  </div>
                  <div className="form-proteccion-acciones">
                    <button
                      className="btn-cancelar"
                      onClick={() => setMostrarFormProteccion(false)}
                    >
                      Cancelar
                    </button>
                    <button
                      className="btn-agregar"
                      onClick={handleAgregarProteccion}
                    >
                      Agregar
                    </button>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Footer con navegaci√≥n */}
        <div className="gestion-modelo-footer">
          {vista === 'lista' ? (
            <>
              <div className="footer-espaciador"></div>
              <button className="btn-primario" onClick={handleNuevoModelo}>
                + Nuevo Modelo
              </button>
            </>
          ) : (
            <>
              {paso === 1 ? (
                <button className="btn-secundario" onClick={handleVolverALista}>
                  ‚Üê Volver
                </button>
              ) : (
                <button className="btn-secundario" onClick={pasoAnterior}>
                  ‚Üê Anterior
                </button>
              )}
              <div className="footer-espaciador"></div>
              {paso < 2 ? (
                <button className="btn-primario" onClick={siguientePaso}>
                  Siguiente ‚Üí
                </button>
              ) : (
                <button
                  className="btn-primario btn-guardar"
                  onClick={handleGuardar}
                  disabled={nuevaConfig.protecciones.length === 0}
                >
                  {vista === 'editar' ? 'Guardar Cambios' : 'Crear Modelo'}
                </button>
              )}
            </>
          )}
        </div>
      </div>
    </div>
  );
};

export default ModalGestionModelosRele;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalHistorial.jsx ==========
/**
 * Modal para visualizar el historial de lecturas con gr√°ficos
 * Muestra el PROMEDIO de los valores de cada zona (superior/inferior)
 * aplicando las f√≥rmulas configuradas en cada box
 */

import { useState, useEffect, useMemo, useCallback } from "react";
import Chart from "react-apexcharts";
import { useHistorialLocal } from "../../hooks/useHistorialLocal";
import { aplicarFormula } from "../../utilidades/calculosFormulas";
import { exportarCSV } from "../../utilidades/exportarCSV";
import { TITULOS_MEDICIONES } from "../../constantes/titulosMediciones";
import "./ModalHistorial.css";

// Opciones de rango predefinidas
const RANGOS_TIEMPO = [
  { id: "1h", label: "√öltima hora", ms: 60 * 60 * 1000 },
  { id: "2h", label: "√öltimas 2 horas", ms: 2 * 60 * 60 * 1000 },
  { id: "6h", label: "√öltimas 6 horas", ms: 6 * 60 * 60 * 1000 },
  { id: "12h", label: "√öltimas 12 horas", ms: 12 * 60 * 60 * 1000 },
  { id: "24h", label: "√öltimas 24 horas", ms: 24 * 60 * 60 * 1000 },
  { id: "48h", label: "√öltimas 48 horas", ms: 48 * 60 * 60 * 1000 },
  { id: "7d", label: "√öltimos 7 d√≠as", ms: 7 * 24 * 60 * 60 * 1000 },
  { id: "custom", label: "Personalizado", ms: null },
];

/**
 * Obtiene el t√≠tulo de una zona del cardDesign
 */
const obtenerTituloZona = (cardDesign, zona) => {
  const config = cardDesign?.[zona];
  if (!config) return zona === "superior" ? "Parte Superior" : "Parte Inferior";

  // Si tiene t√≠tulo custom
  if (config.tituloCustom && config.tituloCustom.trim()) {
    return config.tituloCustom;
  }

  // Si tiene tituloId, buscar en las constantes
  if (config.tituloId && TITULOS_MEDICIONES[config.tituloId]) {
    return TITULOS_MEDICIONES[config.tituloId];
  }

  return zona === "superior" ? "Parte Superior" : "Parte Inferior";
};

/**
 * Calcula el promedio de los valores de una zona, aplicando f√≥rmulas
 * Descarta valores que resulten en 0 despu√©s de aplicar la f√≥rmula
 */
const calcularPromedioZona = (lectura, zonaConfig) => {
  if (!lectura?.valores || !Array.isArray(lectura.valores)) return null;
  if (!zonaConfig?.boxes) return null;

  const indiceInicial = lectura.indiceInicial ?? lectura.indice_inicial ?? 0;
  const valoresCalculados = [];

  zonaConfig.boxes.forEach((box) => {
    if (!box.enabled) return;

    const registro = box.registro ?? box.indice;
    if (registro === null || registro === undefined) return;

    const indiceEnArray = registro - indiceInicial;
    if (indiceEnArray < 0 || indiceEnArray >= lectura.valores.length) return;

    const valorCrudo = lectura.valores[indiceEnArray];
    if (valorCrudo === null || valorCrudo === undefined) return;

    // Aplicar f√≥rmula
    const valorCalculado = aplicarFormula(box.formula || "x", valorCrudo);

    // Descartar valores nulos, NaN o 0
    if (valorCalculado !== null && !Number.isNaN(valorCalculado) && valorCalculado !== 0) {
      valoresCalculados.push(valorCalculado);
    }
  });

  if (valoresCalculados.length === 0) return null;

  // Calcular promedio
  const suma = valoresCalculados.reduce((a, b) => a + b, 0);
  return suma / valoresCalculados.length;
};

const ModalHistorial = ({ abierto, onCerrar, alimentador, cardDesign }) => {
  // Hook DEBE estar antes de cualquier return condicional (React Rules of Hooks)
  const {
    obtenerDatosGrafico,
    cargando,
    error,
    // Precarga 48h
    precargar48h,
    resetearPrecarga,
    precargaProgreso,
    precargaCompleta,
    precargando,
    // Limpiar cache
    limpiarCacheCompleto,
    estadisticas,
  } = useHistorialLocal();

  // Estado del selector
  const [rangoSeleccionado, setRangoSeleccionado] = useState("1h");
  const [fechaDesde, setFechaDesde] = useState("");
  const [fechaHasta, setFechaHasta] = useState("");
  const [zonaSeleccionada, setZonaSeleccionada] = useState("superior");

  // Datos del gr√°fico
  const [datosGrafico, setDatosGrafico] = useState([]);
  const [fuenteDatos, setFuenteDatos] = useState(null);

  // Obtener t√≠tulos de las zonas
  const tituloSuperior = useMemo(
    () => obtenerTituloZona(cardDesign, "superior"),
    [cardDesign]
  );
  const tituloInferior = useMemo(
    () => obtenerTituloZona(cardDesign, "inferior"),
    [cardDesign]
  );

  // T√≠tulo de la zona seleccionada (para el gr√°fico)
  const tituloZonaActual = zonaSeleccionada === "superior" ? tituloSuperior : tituloInferior;

  // Verificar si hay zona configurada
  const zonaDisponible = useCallback((zona) => {
    const config = cardDesign?.[zona];
    return config?.boxes?.some((b) => b.enabled);
  }, [cardDesign]);

  // Obtener registrador_id de la zona (con fallback al registrador del alimentador)
  const obtenerRegistradorZona = useCallback((zona) => {
    // Primero buscar en la zona espec√≠fica del cardDesign
    const regIdZona = cardDesign?.[zona]?.registrador_id;
    if (regIdZona) return regIdZona;

    // Fallback: usar registrador_id del alimentador (formato legacy o √∫nico registrador)
    return alimentador?.registrador_id || null;
  }, [cardDesign, alimentador]);

  // Cargar datos cuando cambia la selecci√≥n
  const cargarDatos = useCallback(async () => {
    if (!alimentador?.id) return;

    const registradorId = obtenerRegistradorZona(zonaSeleccionada);

    if (!registradorId) {
      setDatosGrafico([]);
      setFuenteDatos(null);
      return;
    }

    const ahora = Date.now();
    const rango = RANGOS_TIEMPO.find((r) => r.id === rangoSeleccionado);

    let desde, hasta;
    if (rangoSeleccionado === "custom" && fechaDesde && fechaHasta) {
      desde = new Date(fechaDesde).getTime();
      hasta = new Date(fechaHasta).getTime();
    } else if (rango?.ms) {
      desde = ahora - rango.ms;
      hasta = ahora;
    } else {
      return;
    }

    // Si la precarga de 48h est√° completa, forzar solo datos locales
    const forzarSoloLocal = precargaCompleta;

    const { datos, fuente } = await obtenerDatosGrafico(
      alimentador.id,
      registradorId,
      zonaSeleccionada,
      desde,
      hasta,
      forzarSoloLocal
    );

    // Transformar datos calculando el promedio de la zona
    const zonaConfig = cardDesign?.[zonaSeleccionada];

    const datosTransformados = datos
      .map((lectura) => {
        const promedio = calcularPromedioZona(lectura, zonaConfig);

        if (promedio === null) return null;

        return {
          x: new Date(lectura.timestamp),
          y: promedio,
        };
      })
      .filter((d) => d !== null);

    setDatosGrafico(datosTransformados);
    setFuenteDatos(fuente);
  }, [
    alimentador,
    cardDesign,
    rangoSeleccionado,
    fechaDesde,
    fechaHasta,
    zonaSeleccionada,
    obtenerDatosGrafico,
    obtenerRegistradorZona,
    precargaCompleta,
  ]);

  // Resetear a 1h y resetear precarga cuando se abre/cierra el modal
  useEffect(() => {
    if (abierto) {
      setRangoSeleccionado("1h");
    } else {
      // Al cerrar, resetear estado de precarga
      resetearPrecarga();
    }
  }, [abierto, resetearPrecarga]);

  // Iniciar precarga de 48h autom√°ticamente al abrir el modal
  useEffect(() => {
    if (!abierto || !alimentador?.id) return;

    // Obtener registradores de ambas zonas
    const registradorSuperior = obtenerRegistradorZona("superior");
    const registradorInferior = obtenerRegistradorZona("inferior");

    // Iniciar precarga
    precargar48h(alimentador.id, registradorSuperior, registradorInferior);
  }, [abierto, alimentador?.id, obtenerRegistradorZona, precargar48h]);

  // Cargar datos al abrir o cambiar selecci√≥n
  useEffect(() => {
    if (abierto) {
      cargarDatos();
    }
  }, [abierto, cargarDatos]);

  // Configuraci√≥n de ApexCharts
  const opcionesGrafico = useMemo(
    () => ({
      chart: {
        id: "historial-lecturas",
        type: "line",
        height: 350,
        zoom: {
          enabled: true,
          type: "x",
          autoScaleYaxis: true,
        },
        toolbar: {
          show: true,
          tools: {
            download: true,
            selection: true,
            zoom: true,
            zoomin: true,
            zoomout: true,
            pan: true,
            reset: true,
          },
          autoSelected: "zoom",
        },
        background: "#0f172a",
        foreColor: "#e2e8f0",
        animations: {
          enabled: true,
          speed: 500,
        },
      },
      stroke: {
        curve: "smooth",
        width: 2,
      },
      colors: ["#0ea5e9"],
      xaxis: {
        type: "datetime",
        labels: {
          style: { colors: "#94a3b8" },
          datetimeUTC: false,
          datetimeFormatter: {
            year: "yyyy",
            month: "MMM 'yy",
            day: "dd MMM",
            hour: "HH:mm",
          },
        },
        axisBorder: { color: "#334155" },
        axisTicks: { color: "#334155" },
      },
      yaxis: {
        labels: {
          style: { colors: "#94a3b8" },
          formatter: (val) => (val != null ? val.toFixed(2) : "--"),
        },
      },
      grid: {
        borderColor: "#334155",
        strokeDashArray: 3,
      },
      tooltip: {
        theme: "dark",
        x: { format: "dd/MM/yyyy HH:mm:ss" },
        y: {
          formatter: (val) => (val != null ? val.toFixed(4) : "--"),
        },
      },
      dataLabels: {
        enabled: false,
      },
      markers: {
        size: 0,
        hover: { size: 5 },
      },
      noData: {
        text: "No hay datos disponibles",
        style: {
          color: "#94a3b8",
          fontSize: "14px",
        },
      },
    }),
    []
  );

  const seriesGrafico = useMemo(
    () => [
      {
        name: `Promedio ${tituloZonaActual}`,
        data: datosGrafico,
      },
    ],
    [datosGrafico, tituloZonaActual]
  );

  // Calcular estad√≠sticas del gr√°fico
  const estadisticasGrafico = useMemo(() => {
    if (datosGrafico.length === 0) return null;

    const valores = datosGrafico.map((d) => d.y);
    const min = Math.min(...valores);
    const max = Math.max(...valores);
    const suma = valores.reduce((a, b) => a + b, 0);
    const promedio = suma / valores.length;

    return {
      puntos: datosGrafico.length,
      min: min.toFixed(2),
      max: max.toFixed(2),
      promedio: promedio.toFixed(2),
    };
  }, [datosGrafico]);

  // Handler exportar CSV
  const handleExportarCSV = () => {
    if (datosGrafico.length === 0) return;

    const nombreArchivo = `historial_${alimentador?.nombre || "alimentador"}_${
      zonaSeleccionada
    }_${Date.now()}`;

    exportarCSV(datosGrafico, nombreArchivo, {
      columnas: ["timestamp", "valor"],
      etiquetas: {
        timestamp: "Fecha/Hora",
        valor: `Promedio ${tituloZonaActual}`,
      },
    });
  };

  // Early return DESPU√âS de todos los hooks (React Rules of Hooks)
  if (!abierto) return null;

  return (
    <div className="historial-modal-overlay">
      <div className="historial-modal">
        <header className="historial-modal-header">
          <div className="historial-modal-titulo">
            <h2>Historial de Lecturas</h2>
            <span className="historial-modal-subtitulo">
              {alimentador?.nombre}
            </span>
          </div>
          <button
            type="button"
            className="historial-modal-cerrar"
            onClick={onCerrar}
          >
            &times;
          </button>
        </header>

        <div className="historial-modal-content">
          {/* Selectores */}
          <div className="historial-selectores">
            {/* Selector de zona con t√≠tulos */}
            <div className="historial-selector-grupo historial-selector-zona">
              <label>Medici√≥n</label>
              <div className="historial-tabs">
                <button
                  type="button"
                  className={`historial-tab ${
                    zonaSeleccionada === "superior" ? "historial-tab--activo" : ""
                  }`}
                  onClick={() => setZonaSeleccionada("superior")}
                  disabled={!zonaDisponible("superior")}
                  title={tituloSuperior}
                >
                  {tituloSuperior}
                </button>
                <button
                  type="button"
                  className={`historial-tab ${
                    zonaSeleccionada === "inferior" ? "historial-tab--activo" : ""
                  }`}
                  onClick={() => setZonaSeleccionada("inferior")}
                  disabled={!zonaDisponible("inferior")}
                  title={tituloInferior}
                >
                  {tituloInferior}
                </button>
              </div>
            </div>

            {/* Selector de rango de tiempo */}
            <div className="historial-selector-grupo">
              <label>Rango de tiempo</label>
              <select
                className="historial-select"
                value={rangoSeleccionado}
                onChange={(e) => setRangoSeleccionado(e.target.value)}
              >
                {RANGOS_TIEMPO.map((r) => (
                  <option key={r.id} value={r.id}>
                    {r.label}
                  </option>
                ))}
              </select>
            </div>

            {/* Fechas personalizadas */}
            {rangoSeleccionado === "custom" && (
              <div className="historial-fechas-custom">
                <div className="historial-selector-grupo">
                  <label>Desde</label>
                  <input
                    type="datetime-local"
                    className="historial-input"
                    value={fechaDesde}
                    onChange={(e) => setFechaDesde(e.target.value)}
                  />
                </div>
                <div className="historial-selector-grupo">
                  <label>Hasta</label>
                  <input
                    type="datetime-local"
                    className="historial-input"
                    value={fechaHasta}
                    onChange={(e) => setFechaHasta(e.target.value)}
                  />
                </div>
                <button
                  type="button"
                  className="historial-btn-buscar"
                  onClick={cargarDatos}
                  disabled={!fechaDesde || !fechaHasta}
                >
                  Buscar
                </button>
              </div>
            )}

            {/* Barra de progreso de precarga de 48h */}
            <div className="historial-precarga">
              <div className="historial-precarga-header">
                <span className="historial-precarga-label">
                  Cache local (48h){estadisticas?.totalLecturas ? ` - ${estadisticas.totalLecturas} registros` : ""}:
                </span>
                <div className="historial-precarga-acciones">
                  {precargaCompleta ? (
                    <span className="historial-precarga-ok">
                      <svg
                        className="historial-precarga-check"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="3"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <polyline points="20 6 9 17 4 12"></polyline>
                      </svg>
                      Completo
                    </span>
                  ) : precargando ? (
                    <span className="historial-precarga-porcentaje">
                      {precargaProgreso}%
                    </span>
                  ) : (
                    <span className="historial-precarga-pendiente">Pendiente</span>
                  )}
                  <button
                    type="button"
                    className="historial-btn-limpiar"
                    onClick={async () => {
                      if (window.confirm("¬øLimpiar todo el cache local? Se volver√°n a descargar los datos.")) {
                        await limpiarCacheCompleto();
                        // Reiniciar precarga
                        const registradorSuperior = obtenerRegistradorZona("superior");
                        const registradorInferior = obtenerRegistradorZona("inferior");
                        precargar48h(alimentador.id, registradorSuperior, registradorInferior);
                      }
                    }}
                    disabled={precargando}
                    title="Limpiar cache local"
                  >
                    Limpiar
                  </button>
                </div>
              </div>
              <div className="historial-precarga-barra">
                <div
                  className={`historial-precarga-progreso ${
                    precargaCompleta ? "historial-precarga-progreso--completo" : ""
                  }`}
                  style={{ width: `${precargaProgreso}%` }}
                ></div>
              </div>
            </div>
          </div>

          {/* Indicador de fuente de datos */}
          {fuenteDatos && (
            <div className={`historial-fuente historial-fuente--${fuenteDatos}`}>
              {fuenteDatos === "local" && precargaCompleta && "Datos de cache local (precarga completa)"}
              {fuenteDatos === "local" && !precargaCompleta && "Datos de cache local (tiempo real)"}
              {fuenteDatos === "remoto" && "Datos de base de datos"}
              {fuenteDatos === "mixto" && "Datos combinados (local + BD)"}
              {fuenteDatos === "error" && "Error cargando datos"}
            </div>
          )}

          {/* Gr√°fico */}
          <div className="historial-grafico-container">
            {cargando ? (
              <div className="historial-estado">
                <div className="historial-spinner"></div>
                <span>Cargando datos...</span>
              </div>
            ) : error ? (
              <div className="historial-estado historial-estado--error">
                <span>Error: {error}</span>
                <button onClick={cargarDatos}>Reintentar</button>
              </div>
            ) : datosGrafico.length === 0 ? (
              <div className="historial-estado">
                <span>No hay datos para el rango seleccionado</span>
              </div>
            ) : (
              <Chart
                options={opcionesGrafico}
                series={seriesGrafico}
                type="line"
                height={350}
              />
            )}
          </div>

          {/* Estad√≠sticas */}
          {estadisticasGrafico && (
            <div className="historial-stats">
              <div className="historial-stat">
                <span className="historial-stat-label">Puntos</span>
                <span className="historial-stat-valor">{estadisticasGrafico.puntos}</span>
              </div>
              <div className="historial-stat">
                <span className="historial-stat-label">M√≠n</span>
                <span className="historial-stat-valor">{estadisticasGrafico.min}</span>
              </div>
              <div className="historial-stat">
                <span className="historial-stat-label">M√°x</span>
                <span className="historial-stat-valor">{estadisticasGrafico.max}</span>
              </div>
              <div className="historial-stat">
                <span className="historial-stat-label">Promedio</span>
                <span className="historial-stat-valor">{estadisticasGrafico.promedio}</span>
              </div>
            </div>
          )}
        </div>

        {/* Acciones */}
        <div className="historial-modal-acciones">
          <button
            type="button"
            className="historial-btn historial-btn--secundario"
            onClick={cargarDatos}
            disabled={cargando}
          >
            Actualizar
          </button>
          <button
            type="button"
            className="historial-btn historial-btn--secundario"
            onClick={onCerrar}
          >
            Cerrar
          </button>
          <button
            type="button"
            className="historial-btn historial-btn--primario"
            onClick={handleExportarCSV}
            disabled={datosGrafico.length === 0}
          >
            Exportar CSV
          </button>
        </div>
      </div>
    </div>
  );
};

export default ModalHistorial;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalNuevoPuesto.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/modales/ModalNuevoPuesto.jsx

import React, { useState } from "react";
import "./ModalConfiguracionAlimentador.css"; // estilos base del modal (overlay, fondo, input, etc.)
import "./ModalNuevoPuesto.css";              // estilos espec√≠ficos del modal nuevo puesto
import ColorPickerSimple from "./ColorPickerSimple"; // componente reutilizable del picker

/**
 * Modal para crear un nuevo puesto.
 * Permite ingresar nombre y seleccionar color.
 */
const ModalNuevoPuesto = ({
	abierto,                                   // boolean: controla si el modal se muestra
	onCerrar,                                  // callback para cerrar sin crear
	onCrear,                                   // callback que recibe (nombre, color)
	coloresSistema,                            // array de colores disponibles
}) => {
	const [nombrePuesto, setNombrePuesto] = useState("");
	const [colorPuesto, setColorPuesto] = useState(coloresSistema[0]);

	const handleSubmit = (e) => {
		e.preventDefault();
		const nombre = nombrePuesto.trim();
		if (!nombre) return;

		onCrear(nombre, colorPuesto);

		// Limpiar (el cierre lo maneja el padre)
		setNombrePuesto("");
		setColorPuesto(coloresSistema[0]);
	};

	const handleCerrar = () => {
		setNombrePuesto("");
		setColorPuesto(coloresSistema[0]);
		onCerrar();
	};

	if (!abierto) return null;

	return (
		<div className="alim-modal-overlay">
			<div className="alim-modal alim-modal-sm">
				<h2>Nuevo Puesto</h2>
				<form onSubmit={handleSubmit}>
					<div className="nuevo-puesto-contenedor">
						<label className="alim-modal-label">
							Nombre del Puesto
							<input
								type="text"
								className="alim-modal-input"
								value={nombrePuesto}
								onChange={(e) => setNombrePuesto(e.target.value)}
								placeholder="Ej: PUESTO 1"
								autoFocus
							/>
						</label>

						<div className="nuevo-puesto-color-section">
							{/* Grid de colores predefinidos */}
							<div className="nuevo-puesto-color-grid">
								{coloresSistema.slice(0, 8).map((c) => (
									<button
										key={c}
										type="button"
										className={`nuevo-puesto-color-swatch ${
											colorPuesto === c ? "nuevo-puesto-color-swatch--selected" : ""
										}`}
										style={{ backgroundColor: c }}
										onClick={() => setColorPuesto(c)}
										aria-label={`Elegir color ${c}`}
									/>
								))}
								{/* Picker personalizado (c√≠rculo multicolor) */}
								<ColorPickerSimple
									color={colorPuesto}
									onChange={setColorPuesto}
									label=""
								/>
							</div>

							{/* Preview del color seleccionado */}
							<div
								className="nuevo-puesto-color-preview"
								style={{ backgroundColor: colorPuesto }}
								title={colorPuesto}
							>
								<span className="nuevo-puesto-color-preview-text">COLOR</span>
							</div>
						</div>
					</div>

					<div className="alim-modal-actions">
						<button
							type="button"
							className="alim-modal-btn alim-modal-btn-cancelar"
							onClick={handleCerrar}
						>
							Cancelar
						</button>
						<button
							type="submit"
							className="alim-modal-btn alim-modal-btn-guardar"
						>
							Crear
						</button>
					</div>
				</form>
			</div>
		</div>
	);
};

export default ModalNuevoPuesto;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/ModalPanelPermisos.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/modales/ModalPanelPermisos.jsx
// Modal para gestionar permisos de usuarios y acceso a agentes (solo superadmin)
// Dise√±o master-detail: Lista de usuarios + Panel de detalles

import React, { useState, useEffect, useMemo, useRef, useCallback } from "react";
import "./ModalPanelPermisos.css";
import {
  listarUsuariosAdmin,
  cambiarRolUsuarioAdmin,
  actualizarAgentesUsuarioAdmin,
  listarAgentesParaPermisos,
  obtenerDetallesUsuarioAdmin,
} from "../../../../servicios/apiService";

/**
 * Modal para gestionar los permisos de usuarios y su acceso a agentes.
 * Solo visible para superadmins.
 * Dise√±o: Master-detail (lista usuarios izquierda + detalles derecha)
 * Caracter√≠sticas: Arrastrable, redimensionable, no se cierra al hacer clic fuera
 */
const ModalPanelPermisos = ({ abierto, onCerrar }) => {
  // Estado principal
  const [usuarios, setUsuarios] = useState([]);
  const [agentesDisponibles, setAgentesDisponibles] = useState([]);
  const [cargando, setCargando] = useState(false);
  const [error, setError] = useState(null);

  // Estado de ventana (minimizado/maximizado)
  const [estadoVentana, setEstadoVentana] = useState("normal");

  // Estado para arrastrar
  const [posicion, setPosicion] = useState({ x: null, y: null });
  const [arrastrando, setArrastrando] = useState(false);
  const modalRef = useRef(null);
  const dragOffset = useRef({ x: 0, y: 0 });

  // B√∫squeda y filtrado
  const [busqueda, setBusqueda] = useState("");
  const [filtroRol, setFiltroRol] = useState("todos");

  // Usuario seleccionado para ver detalles
  const [usuarioSeleccionado, setUsuarioSeleccionado] = useState(null);
  const [detallesUsuario, setDetallesUsuario] = useState(null);
  const [cargandoDetalles, setCargandoDetalles] = useState(false);
  const [errorDetalles, setErrorDetalles] = useState(null);

  // Estado de edici√≥n
  const [modoEdicion, setModoEdicion] = useState(false);
  const [cambiosPendientes, setCambiosPendientes] = useState({});
  const [guardando, setGuardando] = useState(false);

  // Roles disponibles para asignar (no incluye superadmin)
  const rolesDisponibles = [
    { codigo: "admin", nombre: "Administrador" },
    { codigo: "operador", nombre: "Operador" },
    { codigo: "observador", nombre: "Observador" },
  ];

  // Usuarios filtrados
  const usuariosFiltrados = useMemo(() => {
    return usuarios.filter((u) => {
      const coincideBusqueda =
        busqueda === "" ||
        u.nombre?.toLowerCase().includes(busqueda.toLowerCase()) ||
        u.email?.toLowerCase().includes(busqueda.toLowerCase());
      const coincideRol = filtroRol === "todos" || u.rolGlobal === filtroRol;
      return coincideBusqueda && coincideRol;
    });
  }, [usuarios, busqueda, filtroRol]);

  // Cargar datos al abrir
  useEffect(() => {
    if (abierto) {
      cargarDatos();
    }
  }, [abierto]);

  // Limpiar estado al cerrar
  useEffect(() => {
    if (!abierto) {
      setUsuarioSeleccionado(null);
      setDetallesUsuario(null);
      setCambiosPendientes({});
      setModoEdicion(false);
      setError(null);
      setBusqueda("");
      setFiltroRol("todos");
      setEstadoVentana("normal");
      setErrorDetalles(null);
      setPosicion({ x: null, y: null });
    }
  }, [abierto]);

  // ============================================
  // L√ìGICA DE ARRASTRAR (DRAG)
  // ============================================
  const handleMouseDownDrag = useCallback((e) => {
    if (e.button !== 0 || estadoVentana === "maximizado") return;
    if (e.target.closest('.permisos-controles')) return;

    const modal = modalRef.current;
    if (!modal) return;

    const rect = modal.getBoundingClientRect();
    dragOffset.current = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    };

    if (posicion.x === null) {
      setPosicion({ x: rect.left, y: rect.top });
    }

    setArrastrando(true);
    e.preventDefault();
  }, [estadoVentana, posicion.x]);

  const handleMouseMoveDrag = useCallback((e) => {
    if (!arrastrando) return;

    const newX = e.clientX - dragOffset.current.x;
    const newY = e.clientY - dragOffset.current.y;

    const modal = modalRef.current;
    if (modal) {
      const maxX = window.innerWidth - modal.offsetWidth;
      const maxY = window.innerHeight - modal.offsetHeight;
      setPosicion({
        x: Math.max(0, Math.min(newX, maxX)),
        y: Math.max(0, Math.min(newY, maxY)),
      });
    }
  }, [arrastrando]);

  const handleMouseUpDrag = useCallback(() => {
    setArrastrando(false);
  }, []);

  useEffect(() => {
    if (arrastrando) {
      window.addEventListener('mousemove', handleMouseMoveDrag);
      window.addEventListener('mouseup', handleMouseUpDrag);
      return () => {
        window.removeEventListener('mousemove', handleMouseMoveDrag);
        window.removeEventListener('mouseup', handleMouseUpDrag);
      };
    }
  }, [arrastrando, handleMouseMoveDrag, handleMouseUpDrag]);

  const handleMinimizar = () => {
    setEstadoVentana(estadoVentana === "minimizado" ? "normal" : "minimizado");
  };

  const handleMaximizar = () => {
    if (estadoVentana === "maximizado") {
      setEstadoVentana("normal");
    } else {
      setEstadoVentana("maximizado");
      setPosicion({ x: null, y: null });
    }
  };

  const cargarDatos = async () => {
    try {
      setCargando(true);
      setError(null);

      const [usuariosData, agentesData] = await Promise.all([
        listarUsuariosAdmin(),
        listarAgentesParaPermisos(),
      ]);

      setUsuarios(usuariosData);
      setAgentesDisponibles(agentesData);
    } catch (err) {
      console.error("Error cargando datos:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  // Seleccionar usuario y cargar sus detalles
  const seleccionarUsuario = async (usuario) => {
    if (usuarioSeleccionado?.id === usuario.id) return;

    setUsuarioSeleccionado(usuario);
    setModoEdicion(false);
    setCambiosPendientes({});
    setCargandoDetalles(true);
    setErrorDetalles(null);
    setDetallesUsuario(null);

    try {
      const detalles = await obtenerDetallesUsuarioAdmin(usuario.id);
      setDetallesUsuario(detalles);
    } catch (err) {
      console.error("Error cargando detalles:", err);
      setErrorDetalles(err.message || "Error al cargar detalles");
    } finally {
      setCargandoDetalles(false);
    }
  };

  // Iniciar modo edici√≥n
  const iniciarEdicion = () => {
    if (!usuarioSeleccionado) return;
    setModoEdicion(true);
    setCambiosPendientes({
      rolGlobal: usuarioSeleccionado.rolGlobal,
      accesoTotal: usuarioSeleccionado.permisoAgentes?.accesoTotal || false,
      agentesIds: usuarioSeleccionado.permisoAgentes?.agentes?.map((a) => a.id) || [],
    });
  };

  const handleCambioRol = (nuevoRol) => {
    setCambiosPendientes((prev) => ({ ...prev, rolGlobal: nuevoRol }));
  };

  const handleToggleAccesoTotal = () => {
    setCambiosPendientes((prev) => ({
      ...prev,
      accesoTotal: !prev.accesoTotal,
      agentesIds: !prev.accesoTotal ? [] : prev.agentesIds,
    }));
  };

  const handleToggleAgente = (agenteId) => {
    setCambiosPendientes((prev) => {
      const yaIncluido = prev.agentesIds.includes(agenteId);
      return {
        ...prev,
        agentesIds: yaIncluido
          ? prev.agentesIds.filter((id) => id !== agenteId)
          : [...prev.agentesIds, agenteId],
      };
    });
  };

  const tieneModificaciones = () => {
    if (!usuarioSeleccionado || !cambiosPendientes.rolGlobal) return false;

    const rolCambio = usuarioSeleccionado.rolGlobal !== cambiosPendientes.rolGlobal;
    const accesoTotalCambio =
      (usuarioSeleccionado.permisoAgentes?.accesoTotal || false) !== cambiosPendientes.accesoTotal;
    const agentesOriginales =
      usuarioSeleccionado.permisoAgentes?.agentes?.map((a) => a.id).sort() || [];
    const agentesNuevos = [...cambiosPendientes.agentesIds].sort();
    const agentesCambio = JSON.stringify(agentesOriginales) !== JSON.stringify(agentesNuevos);

    return rolCambio || accesoTotalCambio || agentesCambio;
  };

  const handleGuardarUsuario = async () => {
    if (!usuarioSeleccionado) return;

    try {
      setGuardando(true);
      setError(null);

      if (usuarioSeleccionado.rolGlobal !== cambiosPendientes.rolGlobal) {
        await cambiarRolUsuarioAdmin(usuarioSeleccionado.id, cambiosPendientes.rolGlobal);
      }

      await actualizarAgentesUsuarioAdmin(
        usuarioSeleccionado.id,
        cambiosPendientes.accesoTotal,
        cambiosPendientes.agentesIds
      );

      await cargarDatos();
      // Recargar detalles del usuario
      const detalles = await obtenerDetallesUsuarioAdmin(usuarioSeleccionado.id);
      setDetallesUsuario(detalles);
      // Actualizar usuario seleccionado con nuevos datos
      const usuarioActualizado = (await listarUsuariosAdmin()).find(u => u.id === usuarioSeleccionado.id);
      if (usuarioActualizado) setUsuarioSeleccionado(usuarioActualizado);

      setModoEdicion(false);
      setCambiosPendientes({});
    } catch (err) {
      console.error("Error guardando usuario:", err);
      setError(err.message || err.detalles || "Error al guardar permisos");
    } finally {
      setGuardando(false);
    }
  };

  const handleCancelarEdicion = () => {
    setModoEdicion(false);
    setCambiosPendientes({});
  };

  const getAccesoTexto = (usuario) => {
    if (usuario.permisoAgentes?.accesoTotal) return "Todos";
    const count = usuario.permisoAgentes?.agentes?.length || 0;
    if (count === 0) return "Sin acceso a agentes";
    return `${count} agente${count > 1 ? "s" : ""}`;
  };

  // Agrupar invitados por rol
  const agruparInvitadosPorRol = (invitados) => {
    const grupos = {};
    invitados.forEach((inv) => {
      const rol = inv.rol || "observador";
      if (!grupos[rol]) grupos[rol] = [];
      grupos[rol].push(inv);
    });
    return grupos;
  };

  // Renderizar panel de detalles
  const renderPanelDetalles = () => {
    if (!usuarioSeleccionado) {
      return (
        <div className="permisos-detalle-vacio">
          <span className="permisos-detalle-vacio-icono">üë§</span>
          <span>Selecciona un usuario para ver sus detalles</span>
        </div>
      );
    }

    if (cargandoDetalles) {
      return (
        <div className="permisos-detalle-cargando">
          <div className="permisos-spinner"></div>
          <span>Cargando detalles...</span>
        </div>
      );
    }

    if (errorDetalles) {
      return (
        <div className="permisos-detalle-error">
          <span>Error: {errorDetalles}</span>
        </div>
      );
    }

    const { workspacesPropios = [], workspacesComoInvitado = [], resumen = {} } = detallesUsuario || {};

    return (
      <div className="permisos-detalle">
        {/* Header del usuario */}
        <div className="permisos-detalle-header">
          <div className="permisos-detalle-usuario">
            <span className="permisos-detalle-nombre">
              {usuarioSeleccionado.nombre || "Sin nombre"}
            </span>
            <span className="permisos-detalle-email">{usuarioSeleccionado.email}</span>
          </div>
          <div className="permisos-detalle-badges">
            <span className={`permisos-badge permisos-badge--${usuarioSeleccionado.rolGlobal}`}>
              {usuarioSeleccionado.rolNombre}
            </span>
            <span className="permisos-detalle-acceso">
              {getAccesoTexto(usuarioSeleccionado)}
            </span>
          </div>
          {!modoEdicion && (
            <button
              type="button"
              className="permisos-btn-editar"
              onClick={iniciarEdicion}
            >
              Editar permisos
            </button>
          )}
        </div>

        {/* Modo edici√≥n */}
        {modoEdicion && (
          <div className="permisos-detalle-edicion">
            <h4>Editar Permisos</h4>

            <div className="permisos-campo">
              <label className="permisos-label">Rol Global</label>
              <select
                className="permisos-select"
                value={cambiosPendientes.rolGlobal || ""}
                onChange={(e) => handleCambioRol(e.target.value)}
                disabled={guardando}
              >
                {rolesDisponibles.map((rol) => (
                  <option key={rol.codigo} value={rol.codigo}>
                    {rol.nombre}
                  </option>
                ))}
              </select>
            </div>

            <div className="permisos-campo">
              <label className="permisos-label">Acceso a Agentes</label>
              <label className="permisos-checkbox permisos-checkbox--destacado">
                <input
                  type="checkbox"
                  checked={cambiosPendientes.accesoTotal}
                  onChange={handleToggleAccesoTotal}
                  disabled={guardando}
                />
                <span>Acceso a todos los agentes</span>
              </label>

              {!cambiosPendientes.accesoTotal && (
                <div className="permisos-agentes-lista">
                  {agentesDisponibles.length === 0 ? (
                    <span className="permisos-agentes-vacio">No hay agentes disponibles</span>
                  ) : (
                    agentesDisponibles.map((agente) => (
                      <label key={agente.id} className="permisos-checkbox">
                        <input
                          type="checkbox"
                          checked={cambiosPendientes.agentesIds.includes(agente.id)}
                          onChange={() => handleToggleAgente(agente.id)}
                          disabled={guardando}
                        />
                        <span>{agente.nombre}</span>
                        {!agente.activo && <span className="permisos-agente-inactivo">(inactivo)</span>}
                      </label>
                    ))
                  )}
                </div>
              )}
            </div>

            <div className="permisos-edicion-acciones">
              <button
                type="button"
                className="permisos-btn permisos-btn--cancelar"
                onClick={handleCancelarEdicion}
                disabled={guardando}
              >
                Cancelar
              </button>
              <button
                type="button"
                className="permisos-btn permisos-btn--guardar"
                onClick={handleGuardarUsuario}
                disabled={guardando || !tieneModificaciones()}
              >
                {guardando ? "Guardando..." : "Guardar"}
              </button>
            </div>
          </div>
        )}

        {/* Resumen de estad√≠sticas */}
        {!modoEdicion && detallesUsuario && (
          <>
            <div className="permisos-detalle-stats">
              <div className="permisos-stat-item">
                <span className="permisos-stat-numero">{resumen.totalWorkspacesPropios ?? workspacesPropios.length}</span>
                <span className="permisos-stat-label">Workspaces propios</span>
              </div>
              <div className="permisos-stat-item">
                <span className="permisos-stat-numero">{resumen.totalPuestos ?? 0}</span>
                <span className="permisos-stat-label">Puestos totales</span>
              </div>
              <div className="permisos-stat-item">
                <span className="permisos-stat-numero">{resumen.totalWorkspacesInvitado ?? workspacesComoInvitado.length}</span>
                <span className="permisos-stat-label">Como invitado</span>
              </div>
            </div>

            {/* Contenido de workspaces */}
            <div className="permisos-detalle-contenido">
              {/* Workspaces propios */}
              {workspacesPropios.length > 0 && (
                <div className="permisos-seccion">
                  <h4 className="permisos-seccion-titulo">Workspaces Propios</h4>
                  <div className="permisos-workspaces-grid">
                    {workspacesPropios.map((ws) => {
                      const invitadosAgrupados = agruparInvitadosPorRol(ws.invitados || []);
                      return (
                        <div key={ws.id} className="permisos-workspace-card">
                          <div className="permisos-workspace-header">
                            <span className="permisos-workspace-nombre">{ws.nombre}</span>
                            <span className="permisos-workspace-puestos">
                              {ws.cantidadPuestos} puesto{ws.cantidadPuestos !== 1 ? "s" : ""}
                            </span>
                          </div>

                          {/* Agentes */}
                          <div className="permisos-workspace-row">
                            <span className="permisos-workspace-label">Agentes:</span>
                            {ws.agentes.length === 0 ? (
                              <span className="permisos-workspace-vacio">Sin agente</span>
                            ) : (
                              <div className="permisos-workspace-chips">
                                {ws.agentes.map((a) => (
                                  <span
                                    key={a.id}
                                    className={`permisos-chip ${!a.activo ? "permisos-chip--inactivo" : ""}`}
                                  >
                                    {a.nombre}
                                  </span>
                                ))}
                              </div>
                            )}
                          </div>

                          {/* Invitados agrupados por rol */}
                          <div className="permisos-workspace-row">
                            <span className="permisos-workspace-label">Invitados:</span>
                            {ws.invitados.length === 0 ? (
                              <span className="permisos-workspace-vacio">Sin invitados</span>
                            ) : (
                              <div className="permisos-invitados-grupos">
                                {Object.entries(invitadosAgrupados).map(([rol, invs]) => (
                                  <div key={rol} className="permisos-invitados-grupo">
                                    <span className={`permisos-rol-badge permisos-rol-badge--${rol}`}>
                                      {rol.toUpperCase()} ({invs.length})
                                    </span>
                                    <span className="permisos-invitados-nombres">
                                      {invs.map((inv) => inv.nombre || inv.email).join(", ")}
                                    </span>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}

              {/* Workspaces como invitado */}
              {workspacesComoInvitado.length > 0 && (
                <div className="permisos-seccion">
                  <h4 className="permisos-seccion-titulo">Acceso como Invitado</h4>
                  <div className="permisos-workspaces-grid">
                    {workspacesComoInvitado.map((ws) => (
                      <div key={ws.id} className="permisos-workspace-card permisos-workspace-card--invitado">
                        <div className="permisos-workspace-header">
                          <span className="permisos-workspace-nombre">{ws.nombre}</span>
                          <span className={`permisos-rol-badge permisos-rol-badge--${ws.rol}`}>
                            {ws.rol?.toUpperCase()}
                          </span>
                        </div>
                        <div className="permisos-workspace-row">
                          <span className="permisos-workspace-label">Propietario:</span>
                          <span className="permisos-workspace-propietario">
                            {ws.propietario?.nombre || ws.propietario?.email || "Desconocido"}
                          </span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Sin datos */}
              {workspacesPropios.length === 0 && workspacesComoInvitado.length === 0 && (
                <div className="permisos-detalle-sin-datos">
                  Este usuario no tiene workspaces propios ni acceso como invitado.
                </div>
              )}
            </div>
          </>
        )}
      </div>
    );
  };

  if (!abierto) return null;

  const getModalClase = () => {
    let clase = "permisos-modal";
    if (estadoVentana === "minimizado") clase += " permisos-modal--minimizado";
    if (estadoVentana === "maximizado") clase += " permisos-modal--maximizado";
    if (arrastrando) clase += " permisos-modal--arrastrando";
    return clase;
  };

  const getModalEstilo = () => {
    if (estadoVentana === "maximizado") {
      return { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, width: "100%", height: "100%" };
    }
    if (estadoVentana === "minimizado") {
      return { position: "fixed", bottom: "1rem", left: "1rem" };
    }
    if (posicion.x !== null && posicion.y !== null) {
      return { position: "fixed", top: posicion.y, left: posicion.x };
    }
    return {};
  };

  const getOverlayClase = () => {
    let clase = "permisos-overlay";
    if (estadoVentana === "minimizado") clase += " permisos-overlay--minimizado";
    if (estadoVentana === "maximizado") clase += " permisos-overlay--maximizado";
    return clase;
  };

  return (
    <div className={getOverlayClase()}>
      <div
        ref={modalRef}
        className={getModalClase()}
        style={getModalEstilo()}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div
          className="permisos-header"
          onMouseDown={handleMouseDownDrag}
          onDoubleClick={handleMaximizar}
          style={{ cursor: estadoVentana === "maximizado" ? "default" : "move" }}
        >
          <div className="permisos-titulo">
            <span className="permisos-icono">üîê</span>
            <span className="permisos-nombre">Panel de Permisos</span>
          </div>
          <div className="permisos-controles">
            <button
              type="button"
              className="permisos-btn-control"
              onClick={handleMinimizar}
              title={estadoVentana === "minimizado" ? "Restaurar" : "Minimizar"}
            >
              {estadoVentana === "minimizado" ? "üóó" : "‚Äî"}
            </button>
            <button
              type="button"
              className="permisos-btn-control"
              onClick={handleMaximizar}
              title={estadoVentana === "maximizado" ? "Restaurar" : "Maximizar"}
            >
              {estadoVentana === "maximizado" ? "üóó" : "‚òê"}
            </button>
            <button
              type="button"
              className="permisos-btn-cerrar"
              onClick={onCerrar}
              title="Cerrar"
            >
              ‚úï
            </button>
          </div>
        </div>

        {/* Contenido principal - Master Detail */}
        <div className="permisos-content">
          {/* Panel izquierdo - Lista de usuarios */}
          <div className="permisos-master">
            {/* B√∫squeda y filtros */}
            <div className="permisos-master-toolbar">
              <input
                type="text"
                placeholder="Buscar usuario..."
                value={busqueda}
                onChange={(e) => setBusqueda(e.target.value)}
                className="permisos-input-busqueda"
              />
              <select
                value={filtroRol}
                onChange={(e) => setFiltroRol(e.target.value)}
                className="permisos-select-filtro"
              >
                <option value="todos">Todos</option>
                <option value="admin">Admin</option>
                <option value="operador">Operador</option>
                <option value="observador">Observador</option>
              </select>
            </div>

            {/* Lista de usuarios */}
            <div className="permisos-usuarios-lista">
              {cargando ? (
                <div className="permisos-estado">
                  <div className="permisos-spinner"></div>
                  <span>Cargando...</span>
                </div>
              ) : error ? (
                <div className="permisos-estado permisos-estado--error">
                  <span>{error}</span>
                  <button onClick={cargarDatos}>Reintentar</button>
                </div>
              ) : usuariosFiltrados.length === 0 ? (
                <div className="permisos-estado">
                  <span>No hay usuarios</span>
                </div>
              ) : (
                usuariosFiltrados.map((usuario) => (
                  <div
                    key={usuario.id}
                    className={`permisos-usuario-item ${
                      usuarioSeleccionado?.id === usuario.id ? "permisos-usuario-item--activo" : ""
                    }`}
                    onClick={() => seleccionarUsuario(usuario)}
                  >
                    <div className="permisos-usuario-info">
                      <span className="permisos-usuario-nombre">
                        {usuario.nombre || "Sin nombre"}
                      </span>
                      <span className="permisos-usuario-email">{usuario.email}</span>
                    </div>
                    <span className={`permisos-badge-small permisos-badge-small--${usuario.rolGlobal}`}>
                      {usuario.rolGlobal?.substring(0, 3).toUpperCase()}
                    </span>
                  </div>
                ))
              )}
            </div>

            {/* Contador */}
            <div className="permisos-master-footer">
              {usuariosFiltrados.length} de {usuarios.length} usuarios
            </div>
          </div>

          {/* Panel derecho - Detalles */}
          <div className="permisos-detail">
            {renderPanelDetalles()}
          </div>
        </div>
      </div>
    </div>
  );
};

export default ModalPanelPermisos;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/TabApariencia.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/modales/TabApariencia.jsx
// Pesta√±a de configuraci√≥n de apariencia global de las tarjetas

import React, { useState, useCallback, useEffect, useRef } from "react";
import { createPortal } from "react-dom";
import {
  FUENTES_DISPONIBLES,
  FUENTES_DIGITALES,
  LIMITES_TAMA√ëO,
  COLORES_VALOR_PREDEFINIDOS,
  OPCIONES_DECIMALES,
  ESTILOS_GLOBALES_DEFAULT,
} from "../../constantes/estilosGlobalesTarjeta";
import { HexColorPicker } from "react-colorful";
import "./TabApariencia.css";

// Versi√≥n del formato de archivo para compatibilidad futura
const FORMATO_VERSION = 1;

/**
 * Genera un valor aleatorio con formato de medici√≥n
 * @param {number} decimales - Cantidad de decimales a mostrar (0, 1 o 2)
 */
const generarValorAleatorio = (decimales = 2) => {
  const valor = (Math.random() * 500).toFixed(decimales);
  return valor.replace(".", ",");
};

/**
 * Formatea un valor seg√∫n la cantidad de decimales configurada
 * @param {string} valor - Valor original (puede ser "--,--" o n√∫mero con coma)
 * @param {number} decimales - Cantidad de decimales a mostrar
 */
const formatearValorConDecimales = (valor, decimales) => {
  if (valor === "--,--" || valor === "--" || valor === "--,-") {
    if (decimales === 0) return "--";
    if (decimales === 1) return "--,-";
    return "--,--";
  }

  // Convertir coma a punto para parsear
  const numStr = valor.replace(",", ".");
  const num = parseFloat(numStr);
  if (isNaN(num)) return valor;

  return num.toFixed(decimales).replace(".", ",");
};

/**
 * Redondea un n√∫mero para evitar errores de punto flotante
 * @param {number} valor - Valor a redondear
 * @param {number} decimales - Cantidad de decimales
 */
const redondear = (valor, decimales = 2) => {
  const factor = Math.pow(10, decimales);
  return Math.round(valor * factor) / factor;
};

/**
 * Selector de fuentes personalizado que muestra cada opci√≥n con su propia tipograf√≠a
 * - Auto-scroll a la fuente seleccionada al abrir
 * - Navegaci√≥n con flechas arriba/abajo con preview en vivo
 * - Enter para confirmar, Escape para cancelar
 */
const SelectorFuente = ({ value, onChange, fuentes }) => {
  const [abierto, setAbierto] = useState(false);
  const [indiceResaltado, setIndiceResaltado] = useState(-1);
  const [valorOriginal, setValorOriginal] = useState(value);
  const contenedorRef = useRef(null);
  const dropdownRef = useRef(null);
  const opcionesRefs = useRef([]);

  // √çndice de la fuente actualmente seleccionada
  const indiceSeleccionado = fuentes.findIndex((f) => f.id === value);

  // Al abrir el dropdown: guardar valor original, scroll a la opci√≥n seleccionada
  useEffect(() => {
    if (abierto) {
      setValorOriginal(value);
      setIndiceResaltado(indiceSeleccionado);

      // Scroll a la opci√≥n seleccionada despu√©s de que el DOM se actualice
      requestAnimationFrame(() => {
        const opcionActiva = opcionesRefs.current[indiceSeleccionado];
        if (opcionActiva && dropdownRef.current) {
          opcionActiva.scrollIntoView({ block: "center", behavior: "instant" });
        }
      });
    }
  }, [abierto, indiceSeleccionado, value]);

  // Cerrar dropdown al hacer clic fuera
  useEffect(() => {
    const handleClickFuera = (e) => {
      if (contenedorRef.current && !contenedorRef.current.contains(e.target)) {
        // Restaurar valor original si se cierra sin confirmar
        onChange(valorOriginal);
        setAbierto(false);
      }
    };
    if (abierto) {
      document.addEventListener("mousedown", handleClickFuera);
    }
    return () => document.removeEventListener("mousedown", handleClickFuera);
  }, [abierto, valorOriginal, onChange]);

  // Manejo de teclado
  useEffect(() => {
    if (!abierto) return;

    const handleKeyDown = (e) => {
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          setIndiceResaltado((prev) => {
            const nuevoIndice = prev < fuentes.length - 1 ? prev + 1 : 0;
            // Aplicar preview de la fuente
            onChange(fuentes[nuevoIndice].id);
            // Scroll a la opci√≥n
            requestAnimationFrame(() => {
              opcionesRefs.current[nuevoIndice]?.scrollIntoView({ block: "nearest", behavior: "smooth" });
            });
            return nuevoIndice;
          });
          break;
        case "ArrowUp":
          e.preventDefault();
          setIndiceResaltado((prev) => {
            const nuevoIndice = prev > 0 ? prev - 1 : fuentes.length - 1;
            // Aplicar preview de la fuente
            onChange(fuentes[nuevoIndice].id);
            // Scroll a la opci√≥n
            requestAnimationFrame(() => {
              opcionesRefs.current[nuevoIndice]?.scrollIntoView({ block: "nearest", behavior: "smooth" });
            });
            return nuevoIndice;
          });
          break;
        case "Enter":
          e.preventDefault();
          // Confirmar selecci√≥n actual
          setAbierto(false);
          break;
        case "Escape":
          e.preventDefault();
          // Restaurar valor original y cerrar
          onChange(valorOriginal);
          setAbierto(false);
          break;
        default:
          break;
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [abierto, fuentes, onChange, valorOriginal]);

  // Encontrar la fuente seleccionada para mostrar en el bot√≥n
  const fuenteSeleccionada = fuentes.find((f) => f.id === value) || fuentes[0];

  return (
    <div className="selector-fuente" ref={contenedorRef}>
      <button
        type="button"
        className="selector-fuente-btn"
        onClick={() => setAbierto(!abierto)}
        style={{ fontFamily: fuenteSeleccionada.id !== "inherit" ? fuenteSeleccionada.id : undefined }}
      >
        <span className="selector-fuente-texto">{fuenteSeleccionada.label}</span>
        <span className="selector-fuente-flecha">{abierto ? "‚ñ≤" : "‚ñº"}</span>
      </button>
      {abierto && (
        <div className="selector-fuente-dropdown" ref={dropdownRef}>
          {fuentes.map((f, idx) => (
            <div
              key={f.id}
              ref={(el) => (opcionesRefs.current[idx] = el)}
              className={`selector-fuente-opcion ${f.id === value ? "selector-fuente-opcion--activa" : ""} ${idx === indiceResaltado ? "selector-fuente-opcion--resaltada" : ""}`}
              style={{ fontFamily: f.id !== "inherit" ? f.id : undefined }}
              onClick={() => {
                onChange(f.id);
                setAbierto(false);
              }}
              onMouseEnter={() => {
                // Solo resaltar visualmente, sin aplicar preview ni scroll
                setIndiceResaltado(idx);
              }}
            >
              {f.label}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

/**
 * Componente Slider con flechitas para incrementar/decrementar
 */
const SliderConFlechas = ({ value, onChange, min, max, step, valorDisplay }) => {
  // Calcular decimales del step para redondear correctamente
  const decimalesStep = step < 1 ? String(step).split('.')[1]?.length || 0 : 0;

  const incrementar = () => {
    const nuevoValor = redondear(Math.min(max, parseFloat(value) + step), decimalesStep);
    onChange(nuevoValor);
  };

  const decrementar = () => {
    const nuevoValor = redondear(Math.max(min, parseFloat(value) - step), decimalesStep);
    onChange(nuevoValor);
  };

  return (
    <div className="slider-con-flechas">
      <button
        type="button"
        className="slider-flecha slider-flecha--izq"
        onClick={decrementar}
        disabled={parseFloat(value) <= min}
      >
        ‚óÄ
      </button>
      <input
        type="range"
        min={min}
        max={max}
        step={step}
        value={value}
        onChange={(e) => onChange(parseFloat(e.target.value))}
      />
      <button
        type="button"
        className="slider-flecha slider-flecha--der"
        onClick={incrementar}
        disabled={parseFloat(value) >= max}
      >
        ‚ñ∂
      </button>
      <span className="apariencia-valor">{valorDisplay}</span>
    </div>
  );
};

/**
 * Bot√≥n de color con popover usando react-colorful
 */
const ColorPickerBoton = ({ color, onChange }) => {
  const [abierto, setAbierto] = useState(false);
  const [posicion, setPosicion] = useState({ top: 0, left: 0 });
  const [valorHex, setValorHex] = useState(color);
  const pickerRef = useRef(null);
  const buttonRef = useRef(null);

  // Sincronizar valor cuando cambia el color externo
  useEffect(() => {
    setValorHex(color);
  }, [color]);

  // Calcular posici√≥n del picker al abrirlo
  const togglePicker = (e) => {
    e.stopPropagation();
    if (abierto) {
      setAbierto(false);
      return;
    }

    if (buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect();
      const alturaPopover = 260;
      const anchoPopover = 240;

      // Calcular posici√≥n vertical (preferir abajo)
      let top = rect.bottom + 8;
      if (top + alturaPopover > window.innerHeight - 10) {
        top = rect.top - alturaPopover - 8;
      }

      // Calcular posici√≥n horizontal centrada
      let left = rect.left + rect.width / 2 - anchoPopover / 2;
      if (left < 10) left = 10;
      if (left + anchoPopover > window.innerWidth - 10) {
        left = window.innerWidth - anchoPopover - 10;
      }

      setPosicion({ top, left });
      setAbierto(true);
    }
  };

  // Cerrar al hacer clic fuera
  useEffect(() => {
    if (!abierto) return;
    const handleClickFuera = (e) => {
      if (
        pickerRef.current &&
        !pickerRef.current.contains(e.target) &&
        buttonRef.current &&
        !buttonRef.current.contains(e.target)
      ) {
        setAbierto(false);
      }
    };
    const timeoutId = setTimeout(() => {
      document.addEventListener("mousedown", handleClickFuera);
    }, 10);
    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener("mousedown", handleClickFuera);
    };
  }, [abierto]);

  const handleColorChange = (nuevoColor) => {
    setValorHex(nuevoColor);
    onChange(nuevoColor);
  };

  const handleInputChange = (e) => {
    const valor = e.target.value;
    setValorHex(valor);
    if (/^#[0-9A-Fa-f]{6}$/.test(valor)) {
      onChange(valor);
    }
  };

  return (
    <div className="apariencia-colorpicker-wrapper">
      <button
        ref={buttonRef}
        type="button"
        className="apariencia-color-picker-btn"
        style={{ backgroundColor: color }}
        onClick={togglePicker}
        title="Color personalizado"
      />
      {abierto &&
        createPortal(
          <div
            ref={pickerRef}
            className="apariencia-colorpicker-popover"
            style={{ top: `${posicion.top}px`, left: `${posicion.left}px` }}
            onClick={(e) => e.stopPropagation()}
            onMouseDown={(e) => e.stopPropagation()}
          >
            <HexColorPicker color={color} onChange={handleColorChange} />
            <div className="apariencia-colorpicker-input-row">
              <input
                type="text"
                value={valorHex}
                onChange={handleInputChange}
                className="apariencia-colorpicker-hex-input"
                placeholder="#000000"
                maxLength={7}
              />
              <button
                type="button"
                className="apariencia-colorpicker-copy-btn"
                onClick={() => navigator.clipboard.writeText(valorHex)}
                title="Copiar color"
              >
                üìã
              </button>
            </div>
          </div>,
          document.body
        )}
    </div>
  );
};

/**
 * Componente de preview que muestra c√≥mo quedan los estilos aplicados
 */
const PreviewTarjeta = ({ estilos, valores, onRandomizar, onResetearValores }) => {
  const decimales = estilos.valorBox.decimales ?? 2;

  return (
    <div className="preview-tarjeta">
      <div className="preview-header">
        <div className="preview-header-icons">
          <span className="preview-icon">‚ñ≤</span>
        </div>
        <span
          className="preview-titulo"
          style={{
            fontFamily: estilos.header.fontFamily,
            fontSize: estilos.header.fontSize,
            fontWeight: estilos.header.fontWeight,
          }}
        >
          TRAFO 1
        </span>
      </div>

      <div className="preview-body">
        {/* Secci√≥n superior */}
        <div className="preview-seccion">
          <div
            className="preview-zona-titulo"
            style={{
              fontFamily: estilos.tituloZona.fontFamily,
              fontSize: estilos.tituloZona.fontSize,
            }}
          >
            CORRIENTE DE L√çNEA (A) (EN 33 KV)
          </div>
          <div className="preview-boxes" style={{ gap: estilos.box.gap }}>
            {["R", "S", "T"].map((fase, idx) => (
              <div
                key={fase}
                className="preview-box"
                style={{ width: estilos.box.width, flex: `0 0 ${estilos.box.width}` }}
              >
                <span
                  className="preview-box-titulo"
                  style={{
                    fontFamily: estilos.tituloBox.fontFamily,
                    fontSize: estilos.tituloBox.fontSize,
                  }}
                >
                  {fase}
                </span>
                <span
                  className="preview-box-valor"
                  style={{
                    fontFamily: estilos.valorBox.fontFamily,
                    fontSize: estilos.valorBox.fontSize,
                    color: estilos.valorBox.color,
                    width: "100%",
                    height: estilos.box.height !== "auto" ? estilos.box.height : undefined,
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                  }}
                >
                  {formatearValorConDecimales(valores[idx], decimales)}
                </span>
              </div>
            ))}
          </div>
        </div>

        {/* Secci√≥n inferior */}
        <div className="preview-seccion">
          <div
            className="preview-zona-titulo"
            style={{
              fontFamily: estilos.tituloZona.fontFamily,
              fontSize: estilos.tituloZona.fontSize,
            }}
          >
            CORRIENTE DE L√çNEA (A) (EN 13,2 KV)
          </div>
          <div className="preview-boxes" style={{ gap: estilos.box.gap }}>
            {["R", "S", "T"].map((fase, idx) => (
              <div
                key={`inf-${fase}`}
                className="preview-box"
                style={{ width: estilos.box.width, flex: `0 0 ${estilos.box.width}` }}
              >
                <span
                  className="preview-box-titulo"
                  style={{
                    fontFamily: estilos.tituloBox.fontFamily,
                    fontSize: estilos.tituloBox.fontSize,
                  }}
                >
                  {fase}
                </span>
                <span
                  className="preview-box-valor"
                  style={{
                    fontFamily: estilos.valorBox.fontFamily,
                    fontSize: estilos.valorBox.fontSize,
                    color: estilos.valorBox.color,
                    width: "100%",
                    height: estilos.box.height !== "auto" ? estilos.box.height : undefined,
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                  }}
                >
                  {formatearValorConDecimales(valores[idx], decimales)}
                </span>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Botones para controlar los valores del preview */}
      <div className="preview-acciones">
        <button
          type="button"
          className="preview-btn"
          onClick={onRandomizar}
          title="Poner valores aleatorios"
        >
          üé≤
        </button>
        <button
          type="button"
          className="preview-btn"
          onClick={onResetearValores}
          title="Volver a --,--"
        >
          ‚ü≤
        </button>
      </div>
    </div>
  );
};

// Valores por defecto para el preview
const VALORES_DEFAULT = ["--,--", "--,--", "--,--"];

/**
 * Nombres de los slides del carrusel para m√≥vil
 */
const SLIDES_CARRUSEL = [
  { id: "header", label: "Header" },
  { id: "zona", label: "Zona" },
  { id: "fases", label: "Fases" },
  { id: "valores1", label: "Valores 1/2" },
  { id: "valores2", label: "Valores 2/2" },
  { id: "dimensiones", label: "Dimensiones" },
];

/**
 * Componente para configurar la apariencia global de las tarjetas
 */
const TabApariencia = ({
  estilosIniciales,
  onGuardar,
  onCancelar,
}) => {
  // Ref para guardar los estilos iniciales y solo sincronizar una vez
  const estilosInicialesRef = useRef(null);

  // Estado para el carrusel en m√≥vil
  const [slideActual, setSlideActual] = useState(0);

  // Estado local para los estilos (copia editable)
  const [estilos, setEstilos] = useState(() => ({
    header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...estilosIniciales?.header },
    tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...estilosIniciales?.tituloZona },
    tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...estilosIniciales?.tituloBox },
    valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...estilosIniciales?.valorBox },
    box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...estilosIniciales?.box },
  }));

  // Estado para los valores del preview
  const [valoresPreview, setValoresPreview] = useState(VALORES_DEFAULT);

  // Reiniciar estado local solo cuando cambian los estilos iniciales realmente (al abrir el modal)
  useEffect(() => {
    // Solo actualizar si es la primera vez o si los estilos iniciales cambiaron de verdad
    const estilosStr = JSON.stringify(estilosIniciales);
    if (estilosIniciales && estilosInicialesRef.current !== estilosStr) {
      estilosInicialesRef.current = estilosStr;
      setEstilos({
        header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...estilosIniciales.header },
        tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...estilosIniciales.tituloZona },
        tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...estilosIniciales.tituloBox },
        valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...estilosIniciales.valorBox },
        box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...estilosIniciales.box },
      });
    }
  }, [estilosIniciales]);

  // Funciones para actualizar cada secci√≥n
  const actualizarHeader = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      header: { ...prev.header, ...cambios },
    }));
  }, []);

  const actualizarTituloZona = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      tituloZona: { ...prev.tituloZona, ...cambios },
    }));
  }, []);

  const actualizarTituloBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      tituloBox: { ...prev.tituloBox, ...cambios },
    }));
  }, []);

  const actualizarValorBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      valorBox: { ...prev.valorBox, ...cambios },
    }));
  }, []);

  const actualizarBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      box: { ...prev.box, ...cambios },
    }));
  }, []);

  // Restaurar valores por defecto
  const restaurarDefecto = useCallback(() => {
    setEstilos(ESTILOS_GLOBALES_DEFAULT);
  }, []);

  // Funciones auxiliares
  const remANumero = (remStr) => {
    if (typeof remStr === "number") return remStr;
    return parseFloat(remStr) || 1;
  };

  const pxANumero = (pxStr) => {
    if (typeof pxStr === "number") return pxStr;
    return parseInt(pxStr) || 80;
  };

  const randomizarValores = useCallback(() => {
    const decimales = estilos.valorBox.decimales ?? 2;
    setValoresPreview([
      generarValorAleatorio(decimales),
      generarValorAleatorio(decimales),
      generarValorAleatorio(decimales),
    ]);
  }, [estilos.valorBox.decimales]);

  const resetearValoresPreview = useCallback(() => {
    setValoresPreview(VALORES_DEFAULT);
  }, []);

  // Navegaci√≥n del carrusel
  const irAlSlideAnterior = useCallback(() => {
    setSlideActual((prev) => (prev > 0 ? prev - 1 : SLIDES_CARRUSEL.length - 1));
  }, []);

  const irAlSlideSiguiente = useCallback(() => {
    setSlideActual((prev) => (prev < SLIDES_CARRUSEL.length - 1 ? prev + 1 : 0));
  }, []);

  // Guardar cambios
  const handleGuardar = () => {
    onGuardar(estilos);
  };

  // Referencia para el input de archivo oculto
  const inputArchivoRef = useRef(null);

  // Exportar configuraci√≥n a archivo JSON
  const exportarConfiguracion = useCallback(async () => {
    const configuracion = {
      version: FORMATO_VERSION,
      fechaExportacion: new Date().toISOString(),
      estilos: estilos,
    };

    const contenidoJSON = JSON.stringify(configuracion, null, 2);
    const nombreArchivo = `apariencia-tarjetas-${new Date().toISOString().slice(0, 10)}.json`;

    // Intentar usar File System Access API (Chrome, Edge)
    if ("showSaveFilePicker" in window) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: nombreArchivo,
          types: [
            {
              description: "Archivo JSON",
              accept: { "application/json": [".json"] },
            },
          ],
        });
        const writable = await handle.createWritable();
        await writable.write(contenidoJSON);
        await writable.close();
        return; // √âxito con File System Access API
      } catch (err) {
        // Si el usuario cancela, no hacer nada
        if (err.name === "AbortError") return;
        // Si hay otro error, usar el fallback
        console.warn("File System Access API fall√≥, usando fallback:", err);
      }
    }

    // Fallback para navegadores sin soporte (Firefox, Safari, etc.)
    const blob = new Blob([contenidoJSON], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = nombreArchivo;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [estilos]);

  // Importar configuraci√≥n desde archivo JSON
  const importarConfiguracion = (evento) => {
    const archivo = evento.target.files?.[0];
    if (!archivo) return;

    const lector = new FileReader();
    lector.onload = (e) => {
      try {
        const contenido = JSON.parse(e.target.result);

        // Validar que tenga la estructura esperada
        if (!contenido.estilos) {
          alert("El archivo no tiene el formato correcto de configuraci√≥n.");
          return;
        }

        // Aplicar los estilos importados
        setEstilos({
          header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...contenido.estilos.header },
          tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...contenido.estilos.tituloZona },
          tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...contenido.estilos.tituloBox },
          valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...contenido.estilos.valorBox },
          box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...contenido.estilos.box },
        });
      } catch {
        alert("Error al leer el archivo. Aseg√∫rate de que sea un archivo JSON v√°lido.");
      }
    };
    lector.readAsText(archivo);

    // Limpiar el input para permitir reimportar el mismo archivo
    evento.target.value = "";
  };

  return (
    <div className="tab-apariencia">
      <div className="apariencia-layout">
        {/* Columna de controles - todo en un contenedor con separadores */}
        <div className="apariencia-controles-columna">
          {/* Versi√≥n Desktop: contenedor con scroll */}
          <div className="apariencia-controles-unificado apariencia-controles-desktop">
            {/* Header */}
            <div className="apariencia-grupo">
              <span className="apariencia-grupo-label">Header</span>
              <SelectorFuente
                value={estilos.header.fontFamily}
                onChange={(fontFamily) => actualizarHeader({ fontFamily })}
                fuentes={FUENTES_DISPONIBLES}
              />
              <SliderConFlechas
                value={remANumero(estilos.header.fontSize)}
                onChange={(val) => actualizarHeader({ fontSize: `${val}rem` })}
                min={LIMITES_TAMA√ëO.header.min}
                max={LIMITES_TAMA√ëO.header.max}
                step={LIMITES_TAMA√ëO.header.step}
                valorDisplay={estilos.header.fontSize}
              />
            </div>

            <div className="apariencia-separador" />

            {/* T√≠tulos zona */}
            <div className="apariencia-grupo">
              <span className="apariencia-grupo-label">Zona</span>
              <SelectorFuente
                value={estilos.tituloZona.fontFamily}
                onChange={(fontFamily) => actualizarTituloZona({ fontFamily })}
                fuentes={FUENTES_DISPONIBLES}
              />
              <SliderConFlechas
                value={remANumero(estilos.tituloZona.fontSize)}
                onChange={(val) => actualizarTituloZona({ fontSize: `${val}rem` })}
                min={LIMITES_TAMA√ëO.tituloZona.min}
                max={LIMITES_TAMA√ëO.tituloZona.max}
                step={LIMITES_TAMA√ëO.tituloZona.step}
                valorDisplay={estilos.tituloZona.fontSize}
              />
            </div>

            <div className="apariencia-separador" />

            {/* Fases */}
            <div className="apariencia-grupo">
              <span className="apariencia-grupo-label">Fases</span>
              <SelectorFuente
                value={estilos.tituloBox.fontFamily}
                onChange={(fontFamily) => actualizarTituloBox({ fontFamily })}
                fuentes={FUENTES_DISPONIBLES}
              />
              <SliderConFlechas
                value={remANumero(estilos.tituloBox.fontSize)}
                onChange={(val) => actualizarTituloBox({ fontSize: `${val}rem` })}
                min={LIMITES_TAMA√ëO.tituloBox.min}
                max={LIMITES_TAMA√ëO.tituloBox.max}
                step={LIMITES_TAMA√ëO.tituloBox.step}
                valorDisplay={estilos.tituloBox.fontSize}
              />
            </div>

            <div className="apariencia-separador" />

            {/* Valores */}
            <div className="apariencia-grupo">
              <span className="apariencia-grupo-label">Valores</span>
              <SelectorFuente
                value={estilos.valorBox.fontFamily}
                onChange={(fontFamily) => actualizarValorBox({ fontFamily })}
                fuentes={FUENTES_DISPONIBLES}
              />
              <SliderConFlechas
                value={remANumero(estilos.valorBox.fontSize)}
                onChange={(val) => actualizarValorBox({ fontSize: `${val}rem` })}
                min={LIMITES_TAMA√ëO.valorBox.min}
                max={LIMITES_TAMA√ëO.valorBox.max}
                step={LIMITES_TAMA√ëO.valorBox.step}
                valorDisplay={estilos.valorBox.fontSize}
              />
            </div>

            {/* Colores y Decimales en una fila */}
            <div className="apariencia-colores-decimales">
              {/* Colores a la izquierda */}
              <div className="apariencia-colores-grupo">
                <span className="apariencia-mini-label">Color:</span>
                <div className="apariencia-colores-inline">
                  {COLORES_VALOR_PREDEFINIDOS.map((color) => (
                    <button
                      key={color}
                      type="button"
                      className={`apariencia-color-btn ${estilos.valorBox.color === color ? "apariencia-color-btn--activo" : ""}`}
                      style={{ backgroundColor: color }}
                      onClick={() => actualizarValorBox({ color })}
                      title={color}
                    />
                  ))}
                  <ColorPickerBoton
                    color={estilos.valorBox.color}
                    onChange={(color) => actualizarValorBox({ color })}
                  />
                </div>
              </div>

              {/* Decimales a la derecha */}
              <div className="apariencia-decimales-grupo">
                <span className="apariencia-mini-label">Decimales:</span>
                <div className="apariencia-decimales-inline">
                  {OPCIONES_DECIMALES.map((opcion) => (
                    <button
                      key={opcion.valor}
                      type="button"
                      className={`apariencia-decimal-btn ${(estilos.valorBox.decimales ?? 2) === opcion.valor ? "apariencia-decimal-btn--activo" : ""}`}
                      onClick={() => actualizarValorBox({ decimales: opcion.valor })}
                    >
                      {opcion.valor}
                    </button>
                  ))}
                </div>
              </div>
            </div>

            <div className="apariencia-separador" />

            {/* Dimensiones - grid 2x2 */}
            <div className="apariencia-grupo apariencia-grupo--dimensiones">
              <span className="apariencia-grupo-label">Dimensiones</span>
              <div className="apariencia-dimensiones-fila">
                <div className="apariencia-dimension-item">
                  <label>Ancho</label>
                  <SliderConFlechas
                    value={pxANumero(estilos.box.width)}
                    onChange={(val) => actualizarBox({ width: `${val}px` })}
                    min={LIMITES_TAMA√ëO.boxWidth.min}
                    max={LIMITES_TAMA√ëO.boxWidth.max}
                    step={LIMITES_TAMA√ëO.boxWidth.step}
                    valorDisplay={estilos.box.width}
                  />
                </div>
                <div className="apariencia-dimension-item">
                  <label>Espacio</label>
                  <SliderConFlechas
                    value={pxANumero(estilos.box.gap)}
                    onChange={(val) => actualizarBox({ gap: `${val}px` })}
                    min={LIMITES_TAMA√ëO.gap.min}
                    max={LIMITES_TAMA√ëO.gap.max}
                    step={LIMITES_TAMA√ëO.gap.step}
                    valorDisplay={estilos.box.gap}
                  />
                </div>
                <div className="apariencia-dimension-item">
                  <label>Alto</label>
                  <SliderConFlechas
                    value={estilos.box.height === "auto" ? LIMITES_TAMA√ëO.boxHeight.min : pxANumero(estilos.box.height)}
                    onChange={(val) => actualizarBox({ height: `${val}px` })}
                    min={LIMITES_TAMA√ëO.boxHeight.min}
                    max={LIMITES_TAMA√ëO.boxHeight.max}
                    step={LIMITES_TAMA√ëO.boxHeight.step}
                    valorDisplay={estilos.box.height}
                  />
                </div>
              </div>
            </div>
          </div>

          {/* Versi√≥n M√≥vil: Carrusel con flechas */}
          <div className="apariencia-carrusel">
            {/* Navegaci√≥n del carrusel con t√≠tulo en el centro */}
            <div className="carrusel-navegacion">
              <button
                type="button"
                className="carrusel-flecha carrusel-flecha--izq"
                onClick={irAlSlideAnterior}
                aria-label="Slide anterior"
              >
                ‚óÄ
              </button>

              <span className="carrusel-titulo-central">
                {SLIDES_CARRUSEL[slideActual].label}
              </span>

              <button
                type="button"
                className="carrusel-flecha carrusel-flecha--der"
                onClick={irAlSlideSiguiente}
                aria-label="Slide siguiente"
              >
                ‚ñ∂
              </button>
            </div>

            {/* Contenedor de slides */}
            <div className="carrusel-contenedor">
              {/* Slide 0: Header */}
              <div className={`carrusel-slide ${slideActual === 0 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Fuente:</span>
                  <SelectorFuente
                    value={estilos.header.fontFamily}
                    onChange={(fontFamily) => actualizarHeader({ fontFamily })}
                    fuentes={FUENTES_DISPONIBLES}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Tama√±o:</span>
                  <SliderConFlechas
                    value={remANumero(estilos.header.fontSize)}
                    onChange={(val) => actualizarHeader({ fontSize: `${val}rem` })}
                    min={LIMITES_TAMA√ëO.header.min}
                    max={LIMITES_TAMA√ëO.header.max}
                    step={LIMITES_TAMA√ëO.header.step}
                    valorDisplay={estilos.header.fontSize}
                  />
                </div>
              </div>

              {/* Slide 1: Zona */}
              <div className={`carrusel-slide ${slideActual === 1 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Fuente:</span>
                  <SelectorFuente
                    value={estilos.tituloZona.fontFamily}
                    onChange={(fontFamily) => actualizarTituloZona({ fontFamily })}
                    fuentes={FUENTES_DISPONIBLES}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Tama√±o:</span>
                  <SliderConFlechas
                    value={remANumero(estilos.tituloZona.fontSize)}
                    onChange={(val) => actualizarTituloZona({ fontSize: `${val}rem` })}
                    min={LIMITES_TAMA√ëO.tituloZona.min}
                    max={LIMITES_TAMA√ëO.tituloZona.max}
                    step={LIMITES_TAMA√ëO.tituloZona.step}
                    valorDisplay={estilos.tituloZona.fontSize}
                  />
                </div>
              </div>

              {/* Slide 2: Fases */}
              <div className={`carrusel-slide ${slideActual === 2 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Fuente:</span>
                  <SelectorFuente
                    value={estilos.tituloBox.fontFamily}
                    onChange={(fontFamily) => actualizarTituloBox({ fontFamily })}
                    fuentes={FUENTES_DISPONIBLES}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Tama√±o:</span>
                  <SliderConFlechas
                    value={remANumero(estilos.tituloBox.fontSize)}
                    onChange={(val) => actualizarTituloBox({ fontSize: `${val}rem` })}
                    min={LIMITES_TAMA√ëO.tituloBox.min}
                    max={LIMITES_TAMA√ëO.tituloBox.max}
                    step={LIMITES_TAMA√ëO.tituloBox.step}
                    valorDisplay={estilos.tituloBox.fontSize}
                  />
                </div>
              </div>

              {/* Slide 3: Valores 1/2 (Fuente y Tama√±o) */}
              <div className={`carrusel-slide ${slideActual === 3 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Fuente:</span>
                  <SelectorFuente
                    value={estilos.valorBox.fontFamily}
                    onChange={(fontFamily) => actualizarValorBox({ fontFamily })}
                    fuentes={FUENTES_DISPONIBLES}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Tama√±o:</span>
                  <SliderConFlechas
                    value={remANumero(estilos.valorBox.fontSize)}
                    onChange={(val) => actualizarValorBox({ fontSize: `${val}rem` })}
                    min={LIMITES_TAMA√ëO.valorBox.min}
                    max={LIMITES_TAMA√ëO.valorBox.max}
                    step={LIMITES_TAMA√ëO.valorBox.step}
                    valorDisplay={estilos.valorBox.fontSize}
                  />
                </div>
              </div>

              {/* Slide 4: Valores 2/2 (Color y Decimales) */}
              <div className={`carrusel-slide ${slideActual === 4 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila carrusel-fila--colores">
                  <span className="carrusel-label">Color:</span>
                  <div className="apariencia-colores-inline">
                    {COLORES_VALOR_PREDEFINIDOS.map((color) => (
                      <button
                        key={color}
                        type="button"
                        className={`apariencia-color-btn ${estilos.valorBox.color === color ? "apariencia-color-btn--activo" : ""}`}
                        style={{ backgroundColor: color }}
                        onClick={() => actualizarValorBox({ color })}
                        title={color}
                      />
                    ))}
                    <ColorPickerBoton
                      color={estilos.valorBox.color}
                      onChange={(color) => actualizarValorBox({ color })}
                    />
                  </div>
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Decimales:</span>
                  <div className="apariencia-decimales-inline">
                    {OPCIONES_DECIMALES.map((opcion) => (
                      <button
                        key={opcion.valor}
                        type="button"
                        className={`apariencia-decimal-btn ${(estilos.valorBox.decimales ?? 2) === opcion.valor ? "apariencia-decimal-btn--activo" : ""}`}
                        onClick={() => actualizarValorBox({ decimales: opcion.valor })}
                      >
                        {opcion.valor}
                      </button>
                    ))}
                  </div>
                </div>
              </div>

              {/* Slide 5: Dimensiones */}
              <div className={`carrusel-slide ${slideActual === 5 ? "carrusel-slide--activo" : ""}`}>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Ancho:</span>
                  <SliderConFlechas
                    value={pxANumero(estilos.box.width)}
                    onChange={(val) => actualizarBox({ width: `${val}px` })}
                    min={LIMITES_TAMA√ëO.boxWidth.min}
                    max={LIMITES_TAMA√ëO.boxWidth.max}
                    step={LIMITES_TAMA√ëO.boxWidth.step}
                    valorDisplay={estilos.box.width}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Alto:</span>
                  <SliderConFlechas
                    value={estilos.box.height === "auto" ? LIMITES_TAMA√ëO.boxHeight.min : pxANumero(estilos.box.height)}
                    onChange={(val) => actualizarBox({ height: `${val}px` })}
                    min={LIMITES_TAMA√ëO.boxHeight.min}
                    max={LIMITES_TAMA√ëO.boxHeight.max}
                    step={LIMITES_TAMA√ëO.boxHeight.step}
                    valorDisplay={estilos.box.height}
                  />
                </div>
                <div className="carrusel-fila">
                  <span className="carrusel-label">Espacio:</span>
                  <SliderConFlechas
                    value={pxANumero(estilos.box.gap)}
                    onChange={(val) => actualizarBox({ gap: `${val}px` })}
                    min={LIMITES_TAMA√ëO.gap.min}
                    max={LIMITES_TAMA√ëO.gap.max}
                    step={LIMITES_TAMA√ëO.gap.step}
                    valorDisplay={estilos.box.gap}
                  />
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Columna de preview */}
        <div className="apariencia-preview-columna">
          <div className="apariencia-preview-label">Vista previa</div>
          <PreviewTarjeta
            estilos={estilos}
            valores={valoresPreview}
            onRandomizar={randomizarValores}
            onResetearValores={resetearValoresPreview}
          />
        </div>
      </div>

      {/* Footer con botones */}
      <div className="apariencia-footer">
        <div className="apariencia-footer-izquierda">
          <button
            type="button"
            className="apariencia-btn apariencia-btn--reset"
            onClick={restaurarDefecto}
          >
            Restaurar por defecto
          </button>
          <button
            type="button"
            className="apariencia-btn apariencia-btn--importar"
            onClick={() => inputArchivoRef.current?.click()}
            title="Importar configuraci√≥n desde archivo"
          >
            Importar
          </button>
          <button
            type="button"
            className="apariencia-btn apariencia-btn--exportar"
            onClick={exportarConfiguracion}
            title="Exportar configuraci√≥n a archivo"
          >
            Exportar
          </button>
          {/* Input oculto para importar archivo */}
          <input
            ref={inputArchivoRef}
            type="file"
            accept=".json"
            onChange={importarConfiguracion}
            style={{ display: "none" }}
          />
        </div>
        <div className="apariencia-footer-derecha">
          <button
            type="button"
            className="apariencia-btn apariencia-btn--cancelar"
            onClick={onCancelar}
          >
            Cancelar
          </button>
          <button
            type="button"
            className="apariencia-btn apariencia-btn--guardar"
            onClick={handleGuardar}
          >
            Guardar
          </button>
        </div>
      </div>
    </div>
  );
};

export default TabApariencia;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/modales/VentanaHistorial.jsx ==========
/**
 * Ventana flotante para visualizar el historial de lecturas con gr√°ficos
 * Soporta: arrastrar, minimizar, maximizar, m√∫ltiples instancias
 */

import { useState, useEffect, useMemo, useCallback, useRef } from "react";
import ApexChartWrapper from "../../../../componentes/comunes/ApexChartWrapper";
import { useHistorialLocal } from "../../hooks/useHistorialLocal";
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase";
import { aplicarFormula } from "../../utilidades/calculosFormulas";
import { exportarCSV } from "../../utilidades/exportarCSV";
import { generarInformePDF } from "../../utilidades/exportarInformePDF";
import { TITULOS_MEDICIONES } from "../../constantes/titulosMediciones";
import {
  RANGOS_TIEMPO,
  TIPOS_GRAFICO,
  COLORES_GRADIENTE,
} from "../../constantes/historialConfig";
import ModalConfigInforme from "./ModalConfigInforme";
import PanelDatosHistorial from "../historial/PanelDatosHistorial";
import BarraTituloVentana from "../historial/BarraTituloVentana";
import BarraControlesHistorial from "../historial/BarraControlesHistorial";
import "./VentanaHistorial.css";

/**
 * Interpola color de verde a rojo basado en porcentaje (0-1)
 * 0 = verde, 0.5 = amarillo, 1 = rojo
 */
const interpolarColorVerdeRojo = (porcentaje) => {
  const p = Math.max(0, Math.min(1, porcentaje));
  const { verde, amarillo, rojo } = COLORES_GRADIENTE;

  let r, g, b;

  if (p <= 0.5) {
    // Verde a Amarillo (0 a 0.5)
    const t = p * 2;
    r = Math.round(verde.r + (amarillo.r - verde.r) * t);
    g = Math.round(verde.g + (amarillo.g - verde.g) * t);
    b = Math.round(verde.b + (amarillo.b - verde.b) * t);
  } else {
    // Amarillo a Rojo (0.5 a 1)
    const t = (p - 0.5) * 2;
    r = Math.round(amarillo.r + (rojo.r - amarillo.r) * t);
    g = Math.round(amarillo.g + (rojo.g - amarillo.g) * t);
    b = Math.round(amarillo.b + (rojo.b - amarillo.b) * t);
  }

  return `rgb(${r}, ${g}, ${b})`;
};

const obtenerTituloZona = (cardDesign, zona) => {
  const config = cardDesign?.[zona];
  if (!config) return zona === "superior" ? "Superior" : "Inferior";
  if (config.tituloCustom?.trim()) return config.tituloCustom;
  if (config.tituloId && TITULOS_MEDICIONES[config.tituloId]) {
    return TITULOS_MEDICIONES[config.tituloId];
  }
  return zona === "superior" ? "Superior" : "Inferior";
};

const calcularPromedioZona = (lectura, zonaConfig) => {
  if (!lectura?.valores || !Array.isArray(lectura.valores)) return null;
  if (!zonaConfig?.boxes) return null;

  const indiceInicial = lectura.indiceInicial ?? lectura.indice_inicial ?? 0;
  const valoresCalculados = [];

  zonaConfig.boxes.forEach((box) => {
    if (!box.enabled) return;
    const registro = box.registro ?? box.indice;
    if (registro === null || registro === undefined) return;
    const indiceEnArray = registro - indiceInicial;
    if (indiceEnArray < 0 || indiceEnArray >= lectura.valores.length) return;
    const valorCrudo = lectura.valores[indiceEnArray];
    if (valorCrudo === null || valorCrudo === undefined) return;
    const valorCalculado = aplicarFormula(box.formula || "x", valorCrudo);
    if (valorCalculado !== null && !Number.isNaN(valorCalculado) && valorCalculado !== 0) {
      valoresCalculados.push(valorCalculado);
    }
  });

  if (valoresCalculados.length === 0) return null;
  const suma = valoresCalculados.reduce((a, b) => a + b, 0);
  return suma / valoresCalculados.length;
};

const VentanaHistorial = ({
  ventana,
  onCerrar,
  onMinimizar,
  onMaximizar,
  onEnfocar,
  onMover,
}) => {
  const { alimentador: alimentadorInicial, cardDesign: cardDesignInicial, minimizada, maximizada, posicion, zIndex } = ventana;

  // Obtener alimentadores del puesto desde el contexto
  const { puestoSeleccionado } = usarContextoAlimentadores();
  const alimentadoresPuesto = puestoSeleccionado?.alimentadores || [];

  // Estado local para permitir cambiar de alimentador sin cerrar el modal
  const [alimentadorActual, setAlimentadorActual] = useState(alimentadorInicial);
  const [cardDesignActual, setCardDesignActual] = useState(cardDesignInicial);

  // Alias para mantener compatibilidad con el resto del c√≥digo
  const alimentador = alimentadorActual;
  const cardDesign = cardDesignActual;

  const ventanaRef = useRef(null);
  const headerRef = useRef(null);
  const chartRef = useRef(null);
  const [arrastrando, setArrastrando] = useState(false);
  const [offsetArrastre, setOffsetArrastre] = useState({ x: 0, y: 0 });

  // Hook de historial
  const {
    obtenerDatosGrafico,
    cargando,
    error,
    precargarPuesto,
    resetearPrecarga,
    precargaProgreso,
    precargaCompleta,
    precargando,
    datosDeBD,
    limpiarCacheCompleto,
    estadisticas,
    dbLista,
  } = useHistorialLocal();

  // Estados del selector
  const [rangoSeleccionado, setRangoSeleccionado] = useState("24h");
  const [fechaRangoDesde, setFechaRangoDesde] = useState(null);
  const [fechaRangoHasta, setFechaRangoHasta] = useState(null);
  const [zonaSeleccionada, setZonaSeleccionada] = useState("superior");
  const [datosGrafico, setDatosGrafico] = useState([]);
  const [fuenteDatos, setFuenteDatos] = useState(null);
  const [panelDatosAbierto, setPanelDatosAbierto] = useState(true);
  const [intervaloFiltro, setIntervaloFiltro] = useState(60); // 0 = todos, 15, 30, 60 minutos
  const [tipoGrafico, setTipoGrafico] = useState("line"); // line, area, bar
  const [modalInformeVisible, setModalInformeVisible] = useState(false);
  const [escalaYMax, setEscalaYMax] = useState(null); // null = auto, valor = m√°ximo personalizado
  const [graficoVisible, setGraficoVisible] = useState(true); // Toggle para mostrar/ocultar gr√°fico en m√≥vil
  const [editandoEscalaY, setEditandoEscalaY] = useState(false); // Para edici√≥n manual del valor

  // T√≠tulos de zonas
  const tituloSuperior = useMemo(() => obtenerTituloZona(cardDesign, "superior"), [cardDesign]);
  const tituloInferior = useMemo(() => obtenerTituloZona(cardDesign, "inferior"), [cardDesign]);
  const tituloZonaActual = zonaSeleccionada === "superior" ? tituloSuperior : tituloInferior;

  const zonaDisponible = useCallback((zona) => {
    const config = cardDesign?.[zona];
    return config?.boxes?.some((b) => b.enabled);
  }, [cardDesign]);

  const obtenerRegistradorZona = useCallback((zona) => {
    const regIdZona = cardDesign?.[zona]?.registrador_id;
    if (regIdZona) return regIdZona;
    return alimentador?.registrador_id || null;
  }, [cardDesign, alimentador]);

  // Cargar datos
  const cargarDatos = useCallback(async () => {
    if (!alimentador?.id) return;
    const registradorId = obtenerRegistradorZona(zonaSeleccionada);
    if (!registradorId) {
      setDatosGrafico([]);
      setFuenteDatos(null);
      return;
    }

    const ahora = Date.now();
    const rango = RANGOS_TIEMPO.find((r) => r.id === rangoSeleccionado);
    let desde, hasta;

    // Si hay un rango de fechas seleccionado desde el calendario
    if (fechaRangoDesde && fechaRangoHasta) {
      const fDesde = new Date(fechaRangoDesde);
      const fHasta = new Date(fechaRangoHasta);
      desde = new Date(fDesde.getFullYear(), fDesde.getMonth(), fDesde.getDate(), 0, 0, 0, 0).getTime();
      hasta = new Date(fHasta.getFullYear(), fHasta.getMonth(), fHasta.getDate(), 23, 59, 59, 999).getTime();
    } else if (rango?.ms) {
      desde = ahora - rango.ms;
      hasta = ahora;
    } else {
      return;
    }

    // Solo forzar local si:
    // 1. La precarga est√° completa Y
    // 2. Estamos usando un rango predefinido (no fechas personalizadas del calendario)
    // Los rangos personalizados pueden estar fuera de las 48h precargadas
    const usandoRangoPredefinido = !fechaRangoDesde && !fechaRangoHasta;
    const forzarSoloLocal = precargaCompleta && usandoRangoPredefinido;
    const { datos, fuente } = await obtenerDatosGrafico(
      alimentador.id,
      registradorId,
      zonaSeleccionada,
      desde,
      hasta,
      forzarSoloLocal
    );

    const zonaConfig = cardDesign?.[zonaSeleccionada];
    const datosTransformados = datos
      .map((lectura) => {
        const promedio = calcularPromedioZona(lectura, zonaConfig);
        if (promedio === null) return null;
        return { x: new Date(lectura.timestamp), y: promedio };
      })
      .filter((d) => d !== null);

    setDatosGrafico(datosTransformados);
    setFuenteDatos(fuente);
  }, [alimentador, cardDesign, rangoSeleccionado, fechaRangoDesde, fechaRangoHasta, zonaSeleccionada, obtenerDatosGrafico, obtenerRegistradorZona, precargaCompleta]);

  // Iniciar precarga de todo el puesto al montar (esperar a que IndexedDB est√© lista)
  // Esto beneficia a todas las cards del puesto, no solo a la actual
  useEffect(() => {
    if (!alimentador?.id || !dbLista || alimentadoresPuesto.length === 0) return;
    precargarPuesto(alimentadoresPuesto);
    return () => resetearPrecarga();
  }, [alimentador?.id, dbLista, alimentadoresPuesto, precargarPuesto, resetearPrecarga]);

  // Cargar datos cuando cambia selecci√≥n
  // IMPORTANTE: Esperar a que la precarga termine (precargaCompleta=true) antes de cargar
  // para evitar consultas innecesarias a la BD cuando ya hay datos en cache
  useEffect(() => {
    // Solo cargar cuando:
    // 1. No est√° minimizada
    // 2. La precarga termin√≥ (precargaCompleta es true, lo que significa que verific√≥ cache o carg√≥ datos)
    if (!minimizada && precargaCompleta) {
      cargarDatos();
    }
  }, [cargarDatos, minimizada, precargaCompleta]);

  // --- Drag & Drop ---
  const handleMouseDown = (e) => {
    if (maximizada) return;
    if (e.target.closest("button")) return;
    onEnfocar();
    setArrastrando(true);
    const rect = ventanaRef.current.getBoundingClientRect();
    setOffsetArrastre({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    });
  };

  useEffect(() => {
    if (!arrastrando) return;

    const handleMouseMove = (e) => {
      const newX = Math.max(0, e.clientX - offsetArrastre.x);
      const newY = Math.max(0, e.clientY - offsetArrastre.y);
      onMover({ x: newX, y: newY });
    };

    const handleMouseUp = () => {
      setArrastrando(false);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [arrastrando, offsetArrastre, onMover]);

  // Datos filtrados por intervalo (se usa tanto para el gr√°fico como para la tabla)
  // Esto evita renderizar miles de puntos y mejora el rendimiento
  // Siempre incluye la √∫ltima lectura del rango para mejor visualizaci√≥n
  const datosFiltrados = useMemo(() => {
    if (intervaloFiltro === 0 || datosGrafico.length === 0) {
      return datosGrafico;
    }

    if (datosGrafico.length === 1) {
      return datosGrafico;
    }

    const intervaloMs = intervaloFiltro * 60 * 1000;
    const resultado = [];
    let ultimoTimestamp = 0;

    // Filtrar por intervalo
    for (const punto of datosGrafico) {
      const timestamp = new Date(punto.x).getTime();
      if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs) {
        resultado.push(punto);
        ultimoTimestamp = timestamp;
      }
    }

    // Siempre incluir la √∫ltima lectura si no est√° ya incluida
    const ultimaLectura = datosGrafico[datosGrafico.length - 1];
    const ultimaEnResultado = resultado[resultado.length - 1];
    if (ultimaLectura !== ultimaEnResultado) {
      resultado.push(ultimaLectura);
    }

    return resultado;
  }, [datosGrafico, intervaloFiltro]);

  // Calcular l√≠mites para el slider de escala Y
  // min = valor m√°ximo de los datos (para que no se corte la l√≠nea)
  // max = doble del valor m√°ximo de los datos
  const limitesEscalaY = useMemo(() => {
    if (datosFiltrados.length === 0) return { min: 10, max: 100, valorMaxDatos: 0 };
    const valores = datosFiltrados.map((d) => d.y);
    const valorMaxDatos = Math.max(...valores);
    // Redondear hacia arriba para valores m√°s limpios
    const minRedondeado = Math.ceil(valorMaxDatos);
    const maxRedondeado = Math.ceil(valorMaxDatos * 2);
    return {
      min: Math.max(minRedondeado, 1), // M√≠nimo de 1 para evitar 0
      max: Math.max(maxRedondeado, minRedondeado + 10), // Asegurar que max > min
      valorMaxDatos,
    };
  }, [datosFiltrados]);

  // Manejador para edici√≥n manual del valor de escala Y
  const handleEscalaYManual = (valorInput) => {
    const valor = parseFloat(valorInput);
    if (isNaN(valor)) {
      setEditandoEscalaY(false);
      return;
    }
    // Validar l√≠mites: si excede max, usar max; si es menor a min, usar min
    const valorValidado = Math.min(Math.max(valor, limitesEscalaY.min), limitesEscalaY.max);
    setEscalaYMax(valorValidado);
    setEditandoEscalaY(false);
  };

  // Colores para gr√°fico de barras (verde a rojo con normalizaci√≥n min-max)
  // Usa el rango completo de colores: el valor m√≠nimo es verde, el m√°ximo es rojo
  const coloresBarras = useMemo(() => {
    if (datosFiltrados.length === 0) return [];
    const valores = datosFiltrados.map((d) => d.y);
    const minVal = Math.min(...valores);
    const maxVal = Math.max(...valores);
    const rango = maxVal - minVal;
    // Normalizaci√≥n min-max para maximizar el contraste visual
    return valores.map((val) => {
      const porcentaje = rango > 0 ? (val - minVal) / rango : 0;
      return interpolarColorVerdeRojo(porcentaje);
    });
  }, [datosFiltrados]);

  // Configuraci√≥n ApexCharts (din√°mica seg√∫n tipo de gr√°fico y colores)
  const opcionesGrafico = useMemo(() => {
    const opcionesBase = {
      chart: {
        id: `historial-${alimentador?.id}-${tipoGrafico}`,
        type: tipoGrafico,
        height: "100%",
        zoom: { enabled: true, type: "x", autoScaleYaxis: true },
        toolbar: {
          show: true,
          tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true },
          autoSelected: "zoom",
        },
        background: "#0f172a",
        foreColor: "#e2e8f0",
        animations: { enabled: true, speed: 500 },
      },
      colors: ["#0ea5e9"],
      xaxis: {
        type: "datetime",
        labels: {
          style: { colors: "#94a3b8" },
          datetimeUTC: false,
          datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm" },
        },
        axisBorder: { color: "#334155" },
        axisTicks: { color: "#334155" },
      },
      yaxis: {
        min: 0,
        max: escalaYMax || undefined, // undefined = auto, valor = m√°ximo personalizado
        labels: {
          style: { colors: "#94a3b8" },
          formatter: (val) => (val != null ? val.toFixed(2) : "--"),
        },
      },
      grid: { borderColor: "#334155", strokeDashArray: 3 },
      tooltip: { theme: "dark", x: { format: "dd/MM/yyyy HH:mm:ss" }, y: { formatter: (val) => (val != null ? val.toFixed(4) : "--") } },
      dataLabels: { enabled: false },
      noData: { text: "No hay datos", style: { color: "#94a3b8", fontSize: "14px" } },
    };

    // Opciones espec√≠ficas por tipo de gr√°fico
    if (tipoGrafico === "line") {
      opcionesBase.stroke = {
        curve: "smooth",
        width: 2,
        lineCap: "round",
      };
      // Gradiente en la l√≠nea (verde abajo, rojo arriba)
      opcionesBase.fill = {
        type: "gradient",
        gradient: {
          type: "vertical",
          colorStops: [
            { offset: 0, color: "#ef4444", opacity: 1 },   // Rojo arriba
            { offset: 50, color: "#eab308", opacity: 1 },  // Amarillo medio
            { offset: 100, color: "#22c55e", opacity: 1 }, // Verde abajo
          ],
        },
      };
      opcionesBase.markers = { size: 0, hover: { size: 5 } };
    } else if (tipoGrafico === "area") {
      opcionesBase.stroke = { curve: "smooth", width: 2, colors: ["#ef4444"] };
      opcionesBase.fill = {
        type: "gradient",
        gradient: {
          shade: "light",
          type: "vertical",
          shadeIntensity: 0.1,
          opacityFrom: 0.9,
          opacityTo: 0.9,
          colorStops: [
            { offset: 0, color: "#ef4444", opacity: 0.9 },   // Rojo arriba
            { offset: 50, color: "#eab308", opacity: 0.9 },  // Amarillo medio
            { offset: 100, color: "#22c55e", opacity: 0.9 }, // Verde abajo
          ],
        },
      };
      opcionesBase.markers = { size: 0, hover: { size: 5 } };
    } else if (tipoGrafico === "bar") {
      opcionesBase.plotOptions = {
        bar: {
          columnWidth: "95%",
          borderRadius: 0,
          distributed: true, // Permite colores individuales por barra
        },
      };
      opcionesBase.legend = { show: false }; // Ocultar leyenda cuando distributed
      opcionesBase.fill = { type: "solid" }; // Color s√≥lido por barra
      opcionesBase.stroke = { show: false }; // Sin borde en las barras
      // Asignar colores seg√∫n valor relativo al m√°ximo
      if (coloresBarras.length > 0) {
        opcionesBase.colors = coloresBarras;
      }
    }

    return opcionesBase;
  }, [alimentador?.id, tipoGrafico, coloresBarras, escalaYMax]);

  // Series para el gr√°fico (usa datos filtrados)
  const seriesGrafico = useMemo(() => [{ name: `Promedio ${tituloZonaActual}`, data: datosFiltrados }], [datosFiltrados, tituloZonaActual]);

  // Fuente de datos efectiva: considera si los datos vinieron de la BD aunque est√©n en cache local
  // Si fuenteDatos es "local" pero datosDeBD es true, mostrar "remoto" (BD)
  const fuenteDatosEfectiva = useMemo(() => {
    if (fuenteDatos === "local" && datosDeBD) {
      return "remoto"; // Los datos fueron descargados de la BD
    }
    return fuenteDatos;
  }, [fuenteDatos, datosDeBD]);

  // T√≠tulo del panel: per√≠odo de fechas o fecha √∫nica si es el mismo d√≠a
  const tituloPanelDatos = useMemo(() => {
    if (datosGrafico.length === 0) return "Sin datos";
    const primeraFecha = new Date(datosGrafico[0].x);
    const ultimaFecha = new Date(datosGrafico[datosGrafico.length - 1].x);

    const formatoFecha = { day: "2-digit", month: "2-digit", year: "2-digit" };
    const primeraStr = primeraFecha.toLocaleDateString("es-AR", formatoFecha);
    const ultimaStr = ultimaFecha.toLocaleDateString("es-AR", formatoFecha);

    // Si es el mismo d√≠a, mostrar solo una fecha
    if (primeraStr === ultimaStr) {
      return primeraStr;
    }
    // Si son d√≠as diferentes, mostrar rango
    return `${primeraStr} - ${ultimaStr}`;
  }, [datosGrafico]);

  const estadisticasGrafico = useMemo(() => {
    if (datosGrafico.length === 0) return null;
    const valores = datosGrafico.map((d) => d.y);
    const minVal = Math.min(...valores);
    const maxVal = Math.max(...valores);
    const promedio = valores.reduce((a, b) => a + b, 0) / valores.length;

    // Encontrar los puntos con min y max para obtener sus timestamps
    const puntoMin = datosGrafico.find((d) => d.y === minVal);
    const puntoMax = datosGrafico.find((d) => d.y === maxVal);

    // Formatear fecha/hora compacta con a√±o
    const formatearFecha = (date) => {
      if (!date) return "";
      const d = new Date(date);
      const dia = d.getDate().toString().padStart(2, "0");
      const mes = (d.getMonth() + 1).toString().padStart(2, "0");
      const anio = d.getFullYear().toString().slice(-2);
      const hora = d.getHours().toString().padStart(2, "0");
      const min = d.getMinutes().toString().padStart(2, "0");
      return `${dia}/${mes}/${anio} - ${hora}:${min} hs.`;
    };

    return {
      puntos: datosGrafico.length,
      min: minVal.toFixed(2),
      minFecha: formatearFecha(puntoMin?.x),
      max: maxVal.toFixed(2),
      maxFecha: formatearFecha(puntoMax?.x),
      promedio: promedio.toFixed(2)
    };
  }, [datosGrafico]);

  const handleExportarCSV = () => {
    if (datosGrafico.length === 0) return;
    exportarCSV(datosGrafico, `historial_${alimentador?.nombre}_${zonaSeleccionada}_${Date.now()}`, {
      columnas: ["timestamp", "valor"],
      etiquetas: { timestamp: "Fecha/Hora", valor: `Promedio ${tituloZonaActual}` },
    });
  };

  const handleAbrirModalInforme = () => {
    if (datosGrafico.length === 0) return;
    setModalInformeVisible(true);
  };

  // Handler para cambio de rango predefinido
  const handleRangoChange = useCallback((rangoId) => {
    setRangoSeleccionado(rangoId);
    setFechaRangoDesde(null);
    setFechaRangoHasta(null);
  }, []);

  // Handler para cambio de rango de fechas personalizado
  const handleFechaRangoChange = useCallback((desde, hasta) => {
    setFechaRangoDesde(desde);
    setFechaRangoHasta(hasta);
  }, []);

  // Handler para limpiar cache
  const handleLimpiarCache = useCallback(async () => {
    if (window.confirm("¬øLimpiar cache local?")) {
      await limpiarCacheCompleto();
      precargarPuesto(alimentadoresPuesto);
    }
  }, [limpiarCacheCompleto, precargarPuesto, alimentadoresPuesto]);

  // Handler para cambio de tipo de gr√°fico
  // Si cambia a barras y el intervalo es "Todos", primero cambia a 15min
  // para evitar renderizar miles de barras que tildan el navegador
  const handleTipoGraficoChange = useCallback((nuevoTipo) => {
    if (nuevoTipo === "bar" && intervaloFiltro === 0) {
      // Cambiar intervalo ANTES de cambiar el tipo para evitar render con todos los datos
      setIntervaloFiltro(15);
    }
    setTipoGrafico(nuevoTipo);
  }, [intervaloFiltro]);

  // Handler para cambio de alimentador desde el selector
  const handleAlimentadorChange = useCallback((nuevoAlimentadorId) => {
    const nuevoAlimentador = alimentadoresPuesto.find(a => a.id === nuevoAlimentadorId);
    if (nuevoAlimentador) {
      setAlimentadorActual(nuevoAlimentador);
      setCardDesignActual(nuevoAlimentador.card_design || {});
      // Resetear zona a superior al cambiar de alimentador
      setZonaSeleccionada("superior");
      // Limpiar datos del gr√°fico para que se recarguen
      setDatosGrafico([]);
    }
  }, [alimentadoresPuesto]);

  const handleGenerarInforme = async (configInforme) => {
    // La imagen del gr√°fico ahora se genera en el modal con los datos filtrados,
    // as√≠ siempre corresponde a los datos de la tabla del informe
    const { solicitadoPor, datosFiltrados, fechaInicio, fechaFin, intervalo, imagenGrafico } = configInforme;

    await generarInformePDF({
      nombreAlimentador: alimentador?.nombre || "Alimentador",
      tituloMedicion: tituloZonaActual,
      datos: datosFiltrados,
      fechaInicio,
      fechaFin,
      solicitadoPor,
      imagenGrafico,
      intervalo,
    });
  };

  // No renderizar si est√° minimizada
  if (minimizada) return null;

  const estiloVentana = maximizada
    ? { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, width: "100%", height: "100%", zIndex }
    : { position: "fixed", top: posicion.y, left: posicion.x, zIndex };

  return (
    <div
      ref={ventanaRef}
      className={`ventana-historial ${maximizada ? "ventana-historial--maximizada" : ""} ${arrastrando ? "ventana-historial--arrastrando" : ""}`}
      style={estiloVentana}
      onMouseDown={() => onEnfocar()}
    >
      {/* Header arrastrable */}
      <BarraTituloVentana
        ref={headerRef}
        nombre={alimentador?.nombre}
        maximizada={maximizada}
        onMinimizar={onMinimizar}
        onMaximizar={onMaximizar}
        onCerrar={onCerrar}
        onMouseDown={handleMouseDown}
      />

      {/* Contenido */}
      <div className="ventana-historial-content">
        {/* Barra de controles compacta */}
        <BarraControlesHistorial
          panelDatosAbierto={panelDatosAbierto}
          onTogglePanel={() => setPanelDatosAbierto(!panelDatosAbierto)}
          zonaSeleccionada={zonaSeleccionada}
          onZonaChange={setZonaSeleccionada}
          zonaDisponible={zonaDisponible}
          tituloSuperior={tituloSuperior}
          tituloInferior={tituloInferior}
          rangoSeleccionado={rangoSeleccionado}
          onRangoChange={handleRangoChange}
          fechaRangoDesde={fechaRangoDesde}
          fechaRangoHasta={fechaRangoHasta}
          onFechaRangoChange={handleFechaRangoChange}
          tipoGrafico={tipoGrafico}
          onTipoGraficoChange={handleTipoGraficoChange}
          alimentadorId={alimentador?.id}
          alimentadores={alimentadoresPuesto}
          onAlimentadorChange={handleAlimentadorChange}
          precargaProgreso={precargaProgreso}
          precargaCompleta={precargaCompleta}
          precargando={precargando}
          fuenteDatos={fuenteDatosEfectiva}
          onLimpiarCache={handleLimpiarCache}
          graficoVisible={graficoVisible}
          onToggleGrafico={() => setGraficoVisible(!graficoVisible)}
        />

        {/* Contenedor del gr√°fico y panel de datos */}
        <div className={`ventana-grafico-container ${!graficoVisible ? "ventana-grafico-container--oculto" : ""}`}>
          {/* Panel lateral de datos */}
          <PanelDatosHistorial
            abierto={panelDatosAbierto}
            tituloPeriodo={tituloPanelDatos}
            intervaloFiltro={intervaloFiltro}
            onIntervaloChange={setIntervaloFiltro}
            datosFiltrados={datosFiltrados}
            tipoGrafico={tipoGrafico}
          />

          {/* Slider vertical para escala Y (elemento separado) */}
          {datosGrafico.length > 0 && !cargando && !error && (
            <div className="ventana-escala-y">
              {/* Bot√≥n subir escala (solo visible en landscape m√≥vil via CSS) */}
              <button
                type="button"
                className="ventana-escala-y-btn ventana-escala-y-btn--arriba"
                onClick={() => {
                  const valorActual = escalaYMax ?? limitesEscalaY.min;
                  const redondeado = Math.ceil(valorActual / 10) * 10;
                  const nuevoValor = redondeado === valorActual ? valorActual + 10 : redondeado;
                  setEscalaYMax(Math.min(nuevoValor, limitesEscalaY.max));
                }}
                title="Aumentar escala +10"
              >
                ‚ñ≤
              </button>
              {editandoEscalaY ? (
                <input
                  type="number"
                  className="ventana-escala-y-input"
                  defaultValue={escalaYMax ?? limitesEscalaY.min}
                  autoFocus
                  onBlur={(e) => handleEscalaYManual(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === "Enter") handleEscalaYManual(e.target.value);
                    if (e.key === "Escape") setEditandoEscalaY(false);
                  }}
                />
              ) : (
                <span
                  className="ventana-escala-y-label ventana-escala-y-label--editable"
                  onDoubleClick={() => setEditandoEscalaY(true)}
                  title="Doble click para editar"
                >
                  {escalaYMax ?? limitesEscalaY.min}
                </span>
              )}
              <input
                type="range"
                className="ventana-escala-y-slider"
                min={limitesEscalaY.min}
                max={limitesEscalaY.max}
                step={0.5}
                value={escalaYMax ?? limitesEscalaY.min}
                onChange={(e) => setEscalaYMax(Number(e.target.value))}
                title={`Escala Y: 0 - ${escalaYMax ?? limitesEscalaY.min}`}
              />
              <span className="ventana-escala-y-label">0</span>
              {/* Bot√≥n bajar escala (solo visible en landscape m√≥vil via CSS) */}
              <button
                type="button"
                className="ventana-escala-y-btn ventana-escala-y-btn--abajo"
                onClick={() => {
                  const valorActual = escalaYMax ?? limitesEscalaY.min;
                  const redondeado = Math.floor(valorActual / 10) * 10;
                  const nuevoValor = redondeado === valorActual ? valorActual - 10 : redondeado;
                  setEscalaYMax(Math.max(nuevoValor, limitesEscalaY.min));
                }}
                title="Disminuir escala -10"
              >
                ‚ñº
              </button>
              <button
                type="button"
                className="ventana-escala-y-reset"
                onClick={() => setEscalaYMax(null)}
                title="Restaurar escala autom√°tica"
                disabled={!escalaYMax}
              >
                Auto
              </button>
            </div>
          )}

          {/* Gr√°fico */}
          <div className="ventana-grafico">
              {cargando ? (
                <div className="ventana-estado">
                  <div className="ventana-spinner" />
                  <span>Cargando...</span>
                </div>
              ) : error ? (
                <div className="ventana-estado ventana-estado--error">
                  <span>Error: {error}</span>
                  <button onClick={cargarDatos}>Reintentar</button>
                </div>
              ) : precargando && datosGrafico.length === 0 ? (
                <div className="ventana-estado">
                  <div className="ventana-spinner" />
                  <span>Descargando datos de la base de datos...</span>
                </div>
              ) : datosGrafico.length === 0 ? (
                <div className="ventana-estado">
                  <span>No hay datos en el per√≠odo seleccionado</span>
                </div>
              ) : (
                <ApexChartWrapper key={`chart-${tipoGrafico}-${escalaYMax}`} ref={chartRef} options={opcionesGrafico} series={seriesGrafico} type={tipoGrafico} height="100%" />
              )}
          </div>
        </div>

        {/* Estad√≠sticas */}
        {estadisticasGrafico && (
          <div className="ventana-stats">
            <span className="ventana-stat">
              <b>Puntos:</b>
              <input type="text" className="ventana-stat-input" value={estadisticasGrafico.puntos} size={String(estadisticasGrafico.puntos).length || 1} readOnly />
            </span>
            <span className="ventana-stat">
              <b>M√≠n:</b>
              <input type="text" className="ventana-stat-input" value={estadisticasGrafico.min} size={estadisticasGrafico.min.length || 1} readOnly />
              {estadisticasGrafico.minFecha && (
                <span className="ventana-stat-fecha">({estadisticasGrafico.minFecha})</span>
              )}
            </span>
            <span className="ventana-stat">
              <b>M√°x:</b>
              <input type="text" className="ventana-stat-input" value={estadisticasGrafico.max} size={estadisticasGrafico.max.length || 1} readOnly />
              {estadisticasGrafico.maxFecha && (
                <span className="ventana-stat-fecha">({estadisticasGrafico.maxFecha})</span>
              )}
            </span>
            <span className="ventana-stat">
              <b>Prom:</b>
              <input type="text" className="ventana-stat-input" value={estadisticasGrafico.promedio} size={estadisticasGrafico.promedio.length || 1} readOnly />
            </span>
            <button type="button" className="ventana-btn-exportar ventana-btn--desktop-only" onClick={handleExportarCSV} disabled={datosGrafico.length === 0}>
              CSV
            </button>
            <button type="button" className="ventana-btn-exportar ventana-btn-informe ventana-btn--desktop-only" onClick={handleAbrirModalInforme} disabled={datosGrafico.length === 0}>
              Informe
            </button>
          </div>
        )}
      </div>

      {/* Modal de configuraci√≥n de informe */}
      <ModalConfigInforme
        visible={modalInformeVisible}
        onCerrar={() => setModalInformeVisible(false)}
        onGenerar={handleGenerarInforme}
        datos={datosGrafico}
        nombreAlimentador={alimentador?.nombre || "Alimentador"}
        tituloMedicion={tituloZonaActual}
        tipoGrafico={tipoGrafico}
      />
    </div>
  );
};

export default VentanaHistorial;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/navegacion/BarraNavegacion.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/navegacion/BarraNavegacion.jsx

import React, { useState } from "react";
import "./BarraNavegacion.css";            // estilos espec√≠ficos de la barra superior
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase";
import SelectorConfiguracion from "./SelectorConfiguracion.jsx";
import BotonGuardarCambios from "./BotonGuardarCambios.jsx";

/**
 * Barra de navegaci√≥n superior.
 * Muestra t√≠tulo, botones de selecci√≥n de puesto y controles globales.
 */
const BarraNavegacion = ({
	esCompacto,                             // true en pantallas angostas (modo compacto)
	puestos,                                // lista de puestos disponibles
	puestoSeleccionado,                     // puesto actualmente activo
	onSeleccionarPuesto,                    // callback al hacer clic en un bot√≥n de puesto
	onAbrirModalNuevoPuesto,                // callback para abrir modal "Nuevo puesto"
	onAbrirModalEditarPuestos,              // callback para abrir modal "Editar puestos"
	onAbrirModalConfigPuesto,               // callback para abrir modal de configuraci√≥n del puesto
	onAbrirModalConfigurarAgente,           // callback para abrir modal de configuraci√≥n del agente
	onAbrirModalGestionarAccesos,           // callback para abrir modal de gesti√≥n de accesos
	onAbrirModalPanelPermisos,              // callback para abrir modal de panel de permisos (solo superadmin)
	onSalir,                                // callback para cerrar sesi√≥n / volver al inicio
	onAbrirMenu,                            // callback para abrir el men√∫ lateral en modo compacto
	coloresSistema,                         // paleta de colores para botones de puesto
	estaPolling,                            // (alimId) => boolean - verifica si un alimentador est√° en polling
	onPlayStopClick,                        // (alimId) => void - alterna polling de un alimentador
}) => {
	const {
		hayCambiosPendientes,
		sincronizando,
		sincronizarCambios,
		descartarCambios,
		obtenerColorPuesto,
	} = usarContextoAlimentadores();

	// Estado para el di√°logo de confirmaci√≥n
	const [mostrarConfirmacion, setMostrarConfirmacion] = useState(false);

	// ===== L√ìGICA DEL BOT√ìN MAESTRO GLOBAL =====
	// Helper para verificar si un alimentador puede hacer polling (misma l√≥gica que ModalConfiguracionPuesto)
	const puedeHacerPolling = (alim) => {
		if (!alim.intervalo_consulta_ms || alim.intervalo_consulta_ms <= 0) return false;

		const cardDesign = alim.card_design || {};
		const superior = cardDesign.superior || {};
		const inferior = cardDesign.inferior || {};

		const tieneRegistrador = !!superior.registrador_id || !!inferior.registrador_id || !!alim.registrador_id;
		if (!tieneRegistrador) return false;

		// Verificar que al menos un box est√© habilitado con √≠ndice v√°lido
		const boxesSuperior = superior.boxes || [];
		const boxesInferior = inferior.boxes || [];
		const todosLosBoxes = [...boxesSuperior, ...boxesInferior];

		const tieneBoxHabilitado = todosLosBoxes.some(
			(box) => box.enabled && box.indice !== null && box.indice !== undefined && box.indice !== ""
		);

		return tieneBoxHabilitado;
	};

	const calcularEstadoGlobal = () => {
		if (!puestoSeleccionado) {
			return { alimentadoresConPolling: [], hayAlgunaCardDisponible: false, algunaCardMidiendo: false };
		}

		const alimentadores = puestoSeleccionado.alimentadores || [];

		// Filtrar solo los alimentadores que pueden hacer polling
		const alimentadoresConPolling = alimentadores.filter(puedeHacerPolling);

		const hayAlgunaCardDisponible = alimentadoresConPolling.length > 0;
		// Verificar si alg√∫n alimentador est√° actualmente en polling
		const algunaCardMidiendo = alimentadoresConPolling.some((alim) => estaPolling?.(alim.id));

		return { alimentadoresConPolling, hayAlgunaCardDisponible, algunaCardMidiendo };
	};

	const { alimentadoresConPolling, hayAlgunaCardDisponible, algunaCardMidiendo } = calcularEstadoGlobal();

	// Abre el di√°logo de confirmaci√≥n
	const handleClickMaestro = () => {
		if (!hayAlgunaCardDisponible) return;
		setMostrarConfirmacion(true);
	};

	// Ejecuta la acci√≥n despu√©s de confirmar - inicia o detiene el polling de todos los alimentadores
	const ejecutarMaestroGlobal = () => {
		setMostrarConfirmacion(false);

		if (algunaCardMidiendo) {
			// Detener todos los que est√°n en polling
			alimentadoresConPolling.forEach((alim) => {
				if (estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		} else {
			// Iniciar todos los disponibles
			alimentadoresConPolling.forEach((alim) => {
				if (!estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		}
	};

	return (
		<>
		<nav
			className={
				"alim-navbar" + (esCompacto ? " alim-navbar-compact" : "")
			}                                  // aplica clase extra cuando est√° en modo compacto
		>
			{esCompacto ? (
				<>
					{/* Bot√≥n men√∫ (solo en modo compacto / mobile) */}
					<button
						type="button"
						className="alim-navbar-menu-btn"
						onClick={onAbrirMenu}
						aria-label="Abrir men√∫"
					>
						‚ò∞
					</button>

					{/* Centro: nombre del puesto o texto gen√©rico */}
					{puestoSeleccionado ? (
						<button
							type="button"
							className="alim-current-puesto-btn"
							onClick={onAbrirModalConfigPuesto}
							title="Configurar puesto"
						>
							{puestoSeleccionado.nombre}
						</button>
					) : (
						<div className="alim-navbar-compact-title">
							Panel de Alimentadores
						</div>
					)}

					{/* Bot√≥n maestro a la derecha (solo si hay puesto seleccionado) */}
					{puestoSeleccionado && (
						<button
							type="button"
							className={`alim-maestro-btn ${algunaCardMidiendo ? "alim-maestro-btn--stop" : ""} ${!hayAlgunaCardDisponible ? "alim-maestro-btn--disabled" : ""}`}
							onClick={handleClickMaestro}
							disabled={!hayAlgunaCardDisponible}
							title={!hayAlgunaCardDisponible ? "Sin registradores con configuraci√≥n v√°lida" : algunaCardMidiendo ? "Detener todas las mediciones" : "Iniciar todas las mediciones"}
						>
							{!hayAlgunaCardDisponible ? "‚äò" : algunaCardMidiendo ? "‚èπ" : "‚ñ∂"}
						</button>
					)}
				</>
			) : (
				<>
					{/* Lado izquierdo: t√≠tulo grande y nombre del puesto actual */}
					<div className="alim-navbar-left">
						<h1 className="alim-title">Panel de Alimentadores</h1>

						{puestoSeleccionado && (
							<div className="alim-puesto-row">
								<button
									type="button"
									className="alim-puesto-nombre-btn"
									onClick={onAbrirModalConfigPuesto}
									title="Configurar puesto"
								>
									{puestoSeleccionado.nombre}
								</button>
								<button
									type="button"
									className={`alim-maestro-btn-texto ${algunaCardMidiendo ? "alim-maestro-btn-texto--stop" : ""} ${!hayAlgunaCardDisponible ? "alim-maestro-btn-texto--disabled" : ""}`}
									onClick={handleClickMaestro}
									disabled={!hayAlgunaCardDisponible}
									title={!hayAlgunaCardDisponible ? "Sin registradores con configuraci√≥n v√°lida" : algunaCardMidiendo ? "Detener todas las mediciones" : "Iniciar todas las mediciones"}
								>
									{!hayAlgunaCardDisponible ? "‚äò" : algunaCardMidiendo ? "PARAR MEDICIONES" : "INICIAR MEDICIONES"}
								</button>
							</div>
						)}
					</div>

					{/* Lado derecho: botones de puestos + controles */}
					<div className="alim-nav-buttons">
						{/* Bloque 2: botones de puestos (uno por cada puesto creado) */}
						<div className="alim-nav-bloque-puestos">
							{puestos.map((p) => (
								<button
									key={p.id}
									className={
										"alim-btn" +
										(puestoSeleccionado &&
										puestoSeleccionado.id === p.id
											? " alim-btn-active"
											: "")
									}
									onClick={() => onSeleccionarPuesto(p.id)}
									style={{
										backgroundColor:
											obtenerColorPuesto(p.id) || coloresSistema[0],
									}}                           // usa el color configurado (con soporte para preferencias de invitado)
								>
									{p.nombre}
								</button>
							))}
						</div>

						{/* Bloque 1: botones de control fijo (nuevo, editar, config, salir) */}
						<div className="alim-nav-bloque-controles">
							<BotonGuardarCambios
								hayCambios={hayCambiosPendientes}
								sincronizando={sincronizando}
								onGuardar={sincronizarCambios}
								onDescartar={descartarCambios}
							/>

							<SelectorConfiguracion
								onAbrirModalNuevoPuesto={onAbrirModalNuevoPuesto}
								onAbrirModalEditarPuestos={onAbrirModalEditarPuestos}
								onAbrirModalConfigurarAgente={onAbrirModalConfigurarAgente}
								onAbrirModalGestionarAccesos={onAbrirModalGestionarAccesos}
								onAbrirModalPanelPermisos={onAbrirModalPanelPermisos}
								puestosLength={puestos.length}
							/>

							<button
								type="button"
								className="alim-btn-exit"
								onClick={onSalir}
							>
								Salir
							</button>
						</div>
					</div>
				</>
			)}
		</nav>

		{/* Di√°logo de confirmaci√≥n para el bot√≥n maestro */}
		{mostrarConfirmacion && (
			<div className="alim-confirmacion-overlay">
				<div className="alim-confirmacion">
					<div className="alim-confirmacion__icono">
						{algunaCardMidiendo ? "‚èπÔ∏è" : "‚ñ∂Ô∏è"}
					</div>
					<h3 className="alim-confirmacion__titulo">
						{algunaCardMidiendo ? "¬øDetener todas las mediciones?" : "¬øIniciar todas las mediciones?"}
					</h3>
					<p className="alim-confirmacion__mensaje">
						{algunaCardMidiendo
							? "Se detendr√°n las mediciones de todos los registradores activos en este puesto."
							: "Se iniciar√°n las mediciones de todos los registradores con configuraci√≥n v√°lida en este puesto."}
					</p>
					<div className="alim-confirmacion__botones">
						<button
							type="button"
							className="alim-confirmacion__btn alim-confirmacion__btn--cancelar"
							onClick={() => setMostrarConfirmacion(false)}
						>
							Cancelar
						</button>
						<button
							type="button"
							className={`alim-confirmacion__btn ${algunaCardMidiendo ? "alim-confirmacion__btn--detener" : "alim-confirmacion__btn--iniciar"}`}
							onClick={ejecutarMaestroGlobal}
						>
							{algunaCardMidiendo ? "Detener" : "Iniciar"}
						</button>
					</div>
				</div>
			</div>
		)}
		</>
	);
};

export default BarraNavegacion;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (BarraNavegacion.jsx)

 - Este componente es la barra superior fija del panel de alimentadores.
   En modo escritorio muestra el t√≠tulo, el puesto actual y todos los botones
   de puestos; en modo compacto solo muestra el bot√≥n de men√∫ y el t√≠tulo.

 - La prop `esCompacto` viene de `VistaAlimentadores` y decide si se muestra la
   versi√≥n completa (desktop) o la versi√≥n reducida (mobile).

 - El array `puestos` se recorre para dibujar un bot√≥n por puesto; el que est√°
   seleccionado recibe la clase `alim-btn-active` y el color que tenga
   configurado (`p.color`).

 - Los callbacks `onSeleccionarPuesto`, `onAbrirModalNuevoPuesto`,
   `onAbrirModalEditarPuestos` y `onSalir` se conectan directamente con la
   l√≥gica del contexto y la navegaci√≥n, pero este componente se limita a
   dispararlos cuando corresponde (no sabe la l√≥gica interna).
---------------------------------------------------------------------------*/}

{/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (BarraNavegacion.jsx)

0) Visi√≥n general del componente

   `BarraNavegacion` es la barra superior fija del panel de alimentadores.

   - En modo escritorio:
       ‚Ä¢ muestra el t√≠tulo grande ‚ÄúPanel de Alimentadores‚Äù,
       ‚Ä¢ debajo, el nombre del puesto actualmente seleccionado,
       ‚Ä¢ a la derecha, todos los botones de puestos,
       ‚Ä¢ y los controles globales: nuevo puesto, editar puestos, salir.

   - En modo compacto (pantallas angostas):
       ‚Ä¢ muestra solo:
           - un bot√≥n de men√∫ (‚ò∞) para abrir el panel lateral,
           - un t√≠tulo centrado (nombre del puesto actual o texto gen√©rico).


1) Props del componente

   const BarraNavegacion = ({
     esCompacto,
     puestos,
     puestoSeleccionado,
     onSeleccionarPuesto,
     onAbrirModalNuevoPuesto,
     onAbrirModalEditarPuestos,
     onSalir,
     onAbrirMenu,
     coloresSistema,
   }) => { ... }

   - `esCompacto` (boolean):
       ‚Ä¢ true  ‚Üí se usa el layout reducido (mobile),
       ‚Ä¢ false ‚Üí se usa el layout completo (desktop).

   - `puestos` (array):
       ‚Ä¢ lista de todos los puestos creados,
       ‚Ä¢ cada puesto suele tener `{ id, nombre, color, ... }`.

   - `puestoSeleccionado` (objeto o null):
       ‚Ä¢ el puesto actualmente activo,
       ‚Ä¢ si existe, se muestra su nombre y se marca su bot√≥n.

   - `onSeleccionarPuesto(idPuesto)`:
       ‚Ä¢ callback que se llama al hacer clic en el bot√≥n de un puesto.

   - `onAbrirModalNuevoPuesto()`:
       ‚Ä¢ se ejecuta al hacer clic en el bot√≥n "+".

   - `onAbrirModalEditarPuestos()`:
       ‚Ä¢ se ejecuta al hacer clic en el bot√≥n de edici√≥n (‚úé).

   - `onSalir()`:
       ‚Ä¢ se ejecuta al hacer clic en el bot√≥n ‚ÄúSalir‚Äù (volver al login).

   - `onAbrirMenu()`:
       ‚Ä¢ se usa solo en modo compacto para abrir el men√∫ lateral.

   - `coloresSistema` (array de colores):
       ‚Ä¢ paleta de fallback para botones de puestos,
       ‚Ä¢ si un puesto no tiene `color`, se usa `coloresSistema[0]`.


2) Contenedor principal <nav>

   return (
     <nav
       className={
         "alim-navbar" + (esCompacto ? " alim-navbar-compact" : "")
       }
     >
       {esCompacto ? ( ... ) : ( ... )}
     </nav>
   );

   - El `<nav>` usa siempre la clase base `"alim-navbar"`.

   - Si `esCompacto` es true, agrega tambi√©n `"alim-navbar-compact"`,
     que aplica estilos espec√≠ficos para el modo reducido (CSS).

   - Dentro del nav se hace un condicional:
       ‚Ä¢ si `esCompacto` es true ‚Üí renderiza la versi√≥n compacta,
       ‚Ä¢ si es false ‚Üí renderiza la versi√≥n completa.


3) Modo compacto (mobile)

   {esCompacto ? (
     <>
       <button ... onClick={onAbrirMenu}>‚ò∞</button>
       <div className="alim-navbar-compact-title">
         {puestoSeleccionado ? puestoSeleccionado.nombre : "Panel de Alimentadores"}
       </div>
     </>
   ) : ( ... )}

   - Bot√≥n de men√∫:
       ‚Ä¢ solo aparece en modo compacto,
       ‚Ä¢ tiene texto ‚Äú‚ò∞‚Äù (√≠cono tipo hamburguesa),
       ‚Ä¢ `onClick={onAbrirMenu}`: dispara la apertura del men√∫ lateral,
       ‚Ä¢ `aria-label="Abrir men√∫"`: mejora la accesibilidad.

   - T√≠tulo centrado:
       ‚Ä¢ si hay `puestoSeleccionado`, muestra su nombre,
       ‚Ä¢ si no, muestra el texto gen√©rico `"Panel de Alimentadores"`.

   - En este modo NO se muestran los botones de puestos ni los controles
     de nuevo/editar/salir; esas funciones se acceden desde el men√∫ lateral.


4) Modo escritorio (layout completo)

   : (
     <>
       // Lado izquierdo: t√≠tulo y puesto actual 
       <div className="alim-navbar-left">
         <h1 className="alim-title">Panel de Alimentadores</h1>

         {puestoSeleccionado && (
           <div className="alim-current-puesto">
             {puestoSeleccionado.nombre}
           </div>
         )}
       </div>

       // Lado derecho: botones de puestos + controles 
       <div className="alim-nav-buttons">
         // Bloque de puestos 
         <div className="alim-nav-bloque-puestos">
           {puestos.map((p) => (
             <button
               key={p.id}
               className={
                 "alim-btn" +
                 (puestoSeleccionado && puestoSeleccionado.id === p.id
                   ? " alim-btn-active"
                   : "")
               }
               onClick={() => onSeleccionarPuesto(p.id)}
               style={{
                 backgroundColor: p.color || coloresSistema[0],
               }}
             >
               {p.nombre}
             </button>
           ))}
         </div>

         // Bloque de controles
         <div className="alim-nav-bloque-controles">
           <button ... onClick={onAbrirModalNuevoPuesto}>+</button>
           <button ... onClick={onAbrirModalEditarPuestos} disabled={puestos.length === 0}>‚úé</button>
           <button ... onClick={onSalir}>Salir</button>
         </div>
       </div>
     </>
   )

   4.1) Lado izquierdo

   - `<h1 className="alim-title">Panel de Alimentadores</h1>`:
       ‚Ä¢ t√≠tulo fijo de la pantalla.

   - `puestoSeleccionado && <div className="alim-current-puesto">...`:
       ‚Ä¢ si hay puesto seleccionado, se muestra su nombre debajo del t√≠tulo,
       ‚Ä¢ si no hay, directamente no se renderiza ese div.


   4.2) Botones de puestos (lado derecho, bloque de puestos)

   {puestos.map((p) => (
     <button
       key={p.id}
       className={
         "alim-btn" +
         (puestoSeleccionado && puestoSeleccionado.id === p.id
           ? " alim-btn-active"
           : "")
       }
       onClick={() => onSeleccionarPuesto(p.id)}
       style={{ backgroundColor: p.color || coloresSistema[0] }}
     >
       {p.nombre}
     </button>
   ))}

   - Se recorre el array `puestos` y se dibuja un bot√≥n por cada puesto.

   - `key={p.id}`:
       ‚Ä¢ clave √∫nica para que React identifique cada bot√≥n.

   - `className`:
       ‚Ä¢ siempre tiene la clase base `"alim-btn"`,
       ‚Ä¢ si este puesto es el seleccionado (`puestoSeleccionado.id === p.id`),
         se agrega `"alim-btn-active"`, lo que aplica estilos de ‚Äúbot√≥n activo‚Äù.

   - `onClick={() => onSeleccionarPuesto(p.id)}`:
       ‚Ä¢ al hacer clic, se llama al callback con el id del puesto,
       ‚Ä¢ la l√≥gica de cambio de puesto vive afuera, en la vista/contexto.

   - `style={{ backgroundColor: p.color || coloresSistema[0] }}`:
       ‚Ä¢ usa el color configurado en el puesto (`p.color`),
       ‚Ä¢ si el puesto no tiene color, cae al primer color del sistema.


   4.3) Botones de control (lado derecho, bloque de controles)

   <div className="alim-nav-bloque-controles">
     <button
       type="button"
       className="alim-btn alim-btn-add"
       onClick={onAbrirModalNuevoPuesto}
     >
       <span className="alim-btn-add-icon">+</span>
     </button>

     <button
       type="button"
       className="alim-btn alim-btn-edit"
       onClick={onAbrirModalEditarPuestos}
       disabled={puestos.length === 0}
     >
       ‚úé
     </button>

     <button
       type="button"
       className="alim-btn-exit"
       onClick={onSalir}
     >
       Salir
     </button>
   </div>

   - Bot√≥n de ‚Äúnuevo puesto‚Äù:
       ‚Ä¢ muestra un ‚Äú+‚Äù,
       ‚Ä¢ dispara `onAbrirModalNuevoPuesto` ‚Üí abre modal de alta de puesto.

   - Bot√≥n de ‚Äúeditar puestos‚Äù:
       ‚Ä¢ muestra un √≠cono ‚úé,
       ‚Ä¢ dispara `onAbrirModalEditarPuestos`,
       ‚Ä¢ est√° `disabled` mientras `puestos.length === 0` (no hay nada que editar).

   - Bot√≥n ‚ÄúSalir‚Äù:
       ‚Ä¢ dispara `onSalir`,
       ‚Ä¢ normalmente vuelve al login o pantalla inicial.


5) Export

   export default BarraNavegacion;

   - Exporta el componente para ser usado en `VistaAlimentadores`.
	
   - Esa vista le pasa:
       ‚Ä¢ los datos (puestos, puesto actual, colores),
       ‚Ä¢ y los callbacks (seleccionar, nuevo, editar, salir, abrir men√∫).

---------------------------------------------------------------------------*/}



========== mi-app/src/paginas/PaginaAlimentadores/componentes/navegacion/BotonGuardarCambios.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/navegacion/BotonGuardarCambios.jsx

import React from "react";
import ReactDOM from "react-dom";
import "./BotonGuardarCambios.css";

/**
 * Overlay de guardado que se muestra sobre toda la pantalla
 */
const OverlayGuardando = () => {
  return ReactDOM.createPortal(
    <div className="guardar-overlay">
      <div className="guardar-overlay__contenido">
        <div className="guardar-overlay__spinner" />
        <span className="guardar-overlay__texto">Guardando cambios...</span>
      </div>
    </div>,
    document.body
  );
};

/**
 * Bot√≥n para guardar cambios pendientes en la base de datos.
 * Se activa solo cuando hay diferencias entre el estado local y la BD.
 *
 * @param {boolean} hayCambios - Si hay cambios pendientes por sincronizar
 * @param {boolean} sincronizando - Si est√° en proceso de sincronizaci√≥n
 * @param {Function} onGuardar - Callback para iniciar la sincronizaci√≥n
 * @param {Function} onDescartar - Callback para descartar cambios (opcional)
 */
const BotonGuardarCambios = ({
  hayCambios,
  sincronizando,
  onGuardar,
  onDescartar,
}) => {
  return (
    <>
      {/* Overlay de guardado */}
      {sincronizando && <OverlayGuardando />}

      <div className="guardar-cambios-container">
        <button
          type="button"
          className={`guardar-cambios-btn ${hayCambios ? "guardar-cambios-btn--activo" : ""} ${sincronizando ? "guardar-cambios-btn--sincronizando" : ""}`}
          onClick={onGuardar}
          disabled={!hayCambios || sincronizando}
          title={
            sincronizando
              ? "Guardando..."
              : hayCambios
                ? "Guardar cambios en la base de datos"
                : "No hay cambios pendientes"
          }
        >
          {sincronizando ? (
            <>
              <span className="guardar-cambios-spinner" />
              <span>Guardando...</span>
            </>
          ) : (
            <>
              <span className="guardar-cambios-icono">üíæ</span>
              <span>Guardar</span>
            </>
          )}
        </button>

        {hayCambios && onDescartar && !sincronizando && (
          <button
            type="button"
            className="guardar-cambios-btn-descartar"
            onClick={onDescartar}
            title="Descartar cambios y recargar desde la base de datos"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
              <path d="M3 3v5h5" />
            </svg>
          </button>
        )}
      </div>
    </>
  );
};

export default BotonGuardarCambios;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/navegacion/MenuLateral.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/navegacion/MenuLateral.jsx

import React, { useState } from "react";
import "./MenuLateral.css";             // estilos del drawer lateral
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase";

/**
 * Men√∫ lateral (drawer) para modo compacto.
 * Muestra puestos, workspaces y acciones en un panel deslizante.
 */
const MenuLateral = ({
	abierto,                            // boolean: controla si el drawer est√° visible
	onCerrar,                           // callback para cerrar el drawer
	puestos,                            // lista de puestos
	puestoSeleccionado,                 // puesto actualmente activo
	onSeleccionarPuesto,                // callback al elegir un puesto
	onAbrirModalNuevoPuesto,            // callback para abrir modal "Nuevo puesto"
	onAbrirModalEditarPuestos,          // callback para abrir modal "Editar puestos"
	onAbrirModalConfigurarAgente,       // callback para abrir modal "Configurar Agente"
	onAbrirModalGestionarAccesos,       // callback para abrir modal "Gestionar Accesos"
	onAbrirModalPanelPermisos,          // callback para abrir modal "Panel de Permisos" (solo superadmin)
	onSalir,                            // callback para salir al login
	coloresSistema,                     // paleta de colores para botones de puesto
	// Props de escala global
	escalaGlobal,                       // n√∫mero actual de escala global
	onEscalaGlobalChange,               // (escala) => void
	ESCALA_MIN = 0.5,
	ESCALA_MAX = 2.0,
}) => {
	const {
		configuraciones,
		configuracionSeleccionada,
		seleccionarConfiguracion,
		agregarConfiguracion,
		puedeCrearWorkspaces,
		rolGlobal,
		perfil,
		workspaceDefaultId,
		toggleWorkspaceDefault,
	} = usarContextoConfiguracion();

	const { obtenerColorPuesto } = usarContextoAlimentadores();

	const [submenuWorkspaceAbierto, setSubmenuWorkspaceAbierto] = useState(false);
	const [mostrarFormNuevoWorkspace, setMostrarFormNuevoWorkspace] = useState(false);
	const [nombreNuevoWorkspace, setNombreNuevoWorkspace] = useState("");
	const [creandoWorkspace, setCreandoWorkspace] = useState(false);

	const handleSeleccionarPuesto = (id) => {
		onSeleccionarPuesto(id);        // selecciona el puesto
		onCerrar();                     // cierra el men√∫ despu√©s de elegir
	};

	const handleAccion = (accion) => {
		if (!accion) return;
		onCerrar();                     // primero cierra el men√∫
		accion();                       // luego ejecuta la acci√≥n (nuevo, editar, salir)
	};

	const handleSeleccionarWorkspace = (id) => {
		seleccionarConfiguracion(id);
		setSubmenuWorkspaceAbierto(false);
	};

	const handleCrearWorkspace = async (e) => {
		e.preventDefault();
		if (!nombreNuevoWorkspace.trim()) return;

		try {
			setCreandoWorkspace(true);
			await agregarConfiguracion(nombreNuevoWorkspace.trim());
			setNombreNuevoWorkspace("");
			setMostrarFormNuevoWorkspace(false);
		} catch (err) {
			console.error("Error creando workspace:", err);
		} finally {
			setCreandoWorkspace(false);
		}
	};

	const handleToggleDefault = async (e, id) => {
		e.stopPropagation();
		try {
			await toggleWorkspaceDefault(id);
		} catch (err) {
			console.error("Error cambiando workspace default:", err);
		}
	};

	return (
		<div
			className={
				"alim-drawer-overlay" + (abierto ? " alim-drawer-open" : "")
			}                             // overlay oscuro + animaci√≥n de apertura
			onClick={onCerrar}            // clic fuera del panel cierra el drawer
		>
			<aside
				className="alim-drawer"
				onClick={(e) => e.stopPropagation()} // evita que el clic dentro cierre el drawer
			>
				<header className="alim-drawer-header">
					<h2 className="alim-drawer-title">Panel de Alimentadores</h2>
					{puestoSeleccionado && (
						<p className="alim-drawer-subtitle">
							Puesto actual:{" "}
							<strong>{puestoSeleccionado.nombre}</strong>
						</p>
					)}
				</header>

				{/* Info del usuario */}
				{perfil && (
					<div className="alim-drawer-usuario">
						<span className="alim-drawer-usuario-nombre">{perfil.nombre || perfil.email}</span>
						<span className="alim-drawer-usuario-rol">{perfil.roles?.nombre || rolGlobal}</span>
					</div>
				)}

				{/* Secci√≥n Workspace */}
				<section className="alim-drawer-section">
					<h3 className="alim-drawer-section-title">Workspace</h3>

					{/* Bot√≥n para expandir/colapsar lista de workspaces */}
					<button
						type="button"
						className="alim-drawer-workspace-trigger"
						onClick={() => setSubmenuWorkspaceAbierto(!submenuWorkspaceAbierto)}
					>
						<span className={`alim-drawer-workspace-flecha ${submenuWorkspaceAbierto ? 'alim-drawer-workspace-flecha--abierto' : ''}`}>‚ñ∂</span>
						<span>{configuracionSeleccionada?.nombre || "Sin workspace"}</span>
					</button>

					{/* Lista de workspaces (submen√∫) */}
					{submenuWorkspaceAbierto && (
						<div className="alim-drawer-workspace-lista">
							{configuraciones.map((config) => (
								<div key={config.id} className="alim-drawer-workspace-row">
									<button
										type="button"
										className="alim-drawer-workspace-default-btn"
										onClick={(e) => handleToggleDefault(e, config.id)}
										title={config.id === workspaceDefaultId ? "Quitar como default" : "Establecer como default"}
									>
										{config.id === workspaceDefaultId ? "‚òÖ" : "‚òÜ"}
									</button>
									<button
										type="button"
										className={`alim-drawer-workspace-item ${config.id === configuracionSeleccionada?.id ? 'alim-drawer-workspace-item--activo' : ''}`}
										onClick={() => handleSeleccionarWorkspace(config.id)}
									>
										{config.nombre}
										{!config.esCreador && <em className="alim-drawer-workspace-invitado">(invitado)</em>}
									</button>
								</div>
							))}
						</div>
					)}
				</section>

				<section className="alim-drawer-section">
					<h3 className="alim-drawer-section-title">Puestos</h3>
					<div className="alim-drawer-puestos">
						{puestos.map((p) => (
							<button
								key={p.id}
								className={
									"alim-btn alim-drawer-btn-puesto" +
									(puestoSeleccionado &&
									puestoSeleccionado.id === p.id
										? " alim-btn-active"
										: "")
								}
								style={{
									backgroundColor:
										obtenerColorPuesto(p.id) || coloresSistema[0],
								}}           // usa el color (con soporte para preferencias de invitado)
								onClick={() => handleSeleccionarPuesto(p.id)}
							>
								{p.nombre}
							</button>
						))}
					</div>
				</section>

				{/* Secci√≥n Escala Global */}
				{onEscalaGlobalChange && (
					<section className="alim-drawer-section">
						<h3 className="alim-drawer-section-title">Escala Global</h3>
						<div className="alim-drawer-escala">
							<input
								type="range"
								min={ESCALA_MIN}
								max={ESCALA_MAX}
								step="0.1"
								value={escalaGlobal ?? 1.0}
								onChange={(e) => onEscalaGlobalChange(parseFloat(e.target.value))}
								className="alim-drawer-escala-slider"
							/>
							<div className="alim-drawer-escala-valor">
								<input
									type="number"
									step="0.1"
									min={ESCALA_MIN}
									max={ESCALA_MAX}
									value={escalaGlobal ?? 1.0}
									onChange={(e) => {
										const valor = parseFloat(e.target.value);
										if (!isNaN(valor) && valor >= ESCALA_MIN && valor <= ESCALA_MAX) {
											onEscalaGlobalChange(valor);
										}
									}}
									className="alim-drawer-escala-input"
								/>
								<span className="alim-drawer-escala-x">x</span>
							</div>
							<button
								type="button"
								className="alim-drawer-escala-reset"
								onClick={() => onEscalaGlobalChange(1.0)}
								disabled={escalaGlobal === 1.0}
							>
								Reset
							</button>
						</div>
					</section>
				)}

				<section className="alim-drawer-section">
					<h3 className="alim-drawer-section-title">Acciones</h3>
					<div className="alim-drawer-actions">
						{/* Gestionar Accesos (SOLO el creador del workspace) */}
						{configuracionSeleccionada?.esCreador && (
							<button
								type="button"
								className="alim-drawer-btn-action alim-drawer-btn-accesos"
								onClick={() => handleAccion(onAbrirModalGestionarAccesos)}
							>
								<svg className="alim-drawer-btn-icon-svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
									<path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
								</svg>
								Gestionar Accesos
							</button>
						)}

						{/* Nuevo puesto (creador del workspace O invitado con rol admin en el workspace) */}
						{(configuracionSeleccionada?.esCreador || configuracionSeleccionada?.rol === 'admin') && (
							<button
								type="button"
								className="alim-drawer-btn-action alim-drawer-btn-add"
								onClick={() => handleAccion(onAbrirModalNuevoPuesto)}
							>
								<span className="alim-drawer-btn-icon">+</span>
								<span>Nuevo puesto</span>
							</button>
						)}

						<button
							type="button"
							className="alim-drawer-btn-action alim-drawer-btn-edit"
							onClick={() =>
								handleAccion(onAbrirModalEditarPuestos)
							}
							disabled={puestos.length === 0} // deshabilitado si no hay puestos
						>
							<span className="alim-drawer-btn-icon">‚úé</span>
							<span>Editar puestos</span>
						</button>

						{/* Configurar Agente (creador del workspace O invitado con rol admin en el workspace) */}
						{(configuracionSeleccionada?.esCreador || configuracionSeleccionada?.rol === 'admin') && (
							<button
								type="button"
								className="alim-drawer-btn-action alim-drawer-btn-config"
								onClick={() => handleAccion(onAbrirModalConfigurarAgente)}
							>
								<span className="alim-drawer-btn-icon">‚öô</span>
								Configurar Agente
							</button>
						)}

						{/* Panel de Permisos (solo superadmin) */}
						{rolGlobal === 'superadmin' && (
							<button
								type="button"
								className="alim-drawer-btn-action alim-drawer-btn-permisos"
								onClick={() => handleAccion(onAbrirModalPanelPermisos)}
							>
								<span className="alim-drawer-btn-icon">üîê</span>
								Panel de Permisos
							</button>
						)}

						{/* Crear nuevo workspace (solo si tiene permisos) */}
						{puedeCrearWorkspaces && (
							<>
								{mostrarFormNuevoWorkspace ? (
									<form className="alim-drawer-form-workspace" onSubmit={handleCrearWorkspace}>
										<input
											type="text"
											className="alim-drawer-input"
											placeholder="Nombre del workspace"
											value={nombreNuevoWorkspace}
											onChange={(e) => setNombreNuevoWorkspace(e.target.value)}
											autoFocus
											disabled={creandoWorkspace}
										/>
										<div className="alim-drawer-form-btns">
											<button
												type="button"
												className="alim-drawer-btn-cancelar"
												onClick={() => {
													setMostrarFormNuevoWorkspace(false);
													setNombreNuevoWorkspace("");
												}}
												disabled={creandoWorkspace}
											>
												Cancelar
											</button>
											<button
												type="submit"
												className="alim-drawer-btn-crear"
												disabled={!nombreNuevoWorkspace.trim() || creandoWorkspace}
											>
												{creandoWorkspace ? "..." : "Crear"}
											</button>
										</div>
									</form>
								) : (
									<button
										type="button"
										className="alim-drawer-btn-action alim-drawer-btn-nuevo-workspace"
										onClick={() => setMostrarFormNuevoWorkspace(true)}
									>
										<span className="alim-drawer-btn-icon">+</span>
										Nuevo workspace
									</button>
								)}
							</>
						)}

						<button
							type="button"
							className="alim-drawer-btn-action alim-drawer-btn-salir"
							onClick={() => handleAccion(onSalir)}
						>
							<span className="alim-drawer-btn-icon">‚Ü©</span>
							<span>Salir</span>
						</button>
					</div>
				</section>
			</aside>
		</div>
	);
};

export default MenuLateral;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (MenuLateral.jsx)

 - Este componente es el "men√∫ hamburguesa" del modo compacto: un panel que
   se desliza desde la izquierda y permite cambiar de puesto o ejecutar
   acciones (nuevo puesto, editar puestos, salir).

 - La prop `abierto` decide si se aplican las clases de apertura en el overlay
   y el drawer; `onCerrar` se dispara al hacer clic fuera del panel o en alguna
   acci√≥n interna.

 - `handleSeleccionarPuesto` combina selecci√≥n de puesto + cierre del men√∫ para
   que la navegaci√≥n se sienta m√°s natural en mobile.

 - `handleAccion` es un peque√±o helper que cierra el men√∫ y luego ejecuta la
   acci√≥n que se le pase (abrir modal, salir, etc.), evitando repetir l√≥gica.
---------------------------------------------------------------------------*/}

{/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICI√ìN DE CADA PARTE (MenuLateral.jsx)

0) Visi√≥n general del componente

   `MenuLateral` es el men√∫ tipo ‚Äúhamburguesa‚Äù para el modo compacto (mobile):

   - Se muestra como un overlay oscuro que cubre la pantalla.
   - Desde la izquierda se desliza un panel (`aside`) con:
       ‚Ä¢ lista de puestos (para cambiar de puesto),
       ‚Ä¢ acciones r√°pidas: nuevo puesto, editar puestos, salir.

   La idea es que en pantallas chicas no haya una barra superior recargada, sino
   un panel lateral m√°s c√≥modo para el dedo.


1) Props del componente

   const MenuLateral = ({
     abierto,
     onCerrar,
     puestos,
     puestoSeleccionado,
     onSeleccionarPuesto,
     onAbrirModalNuevoPuesto,
     onAbrirModalEditarPuestos,
     onSalir,
     coloresSistema,
   }) => { ... }

   - `abierto` (boolean):
       ‚Ä¢ true  ‚Üí el drawer se muestra (overlay activo + panel deslizado),
       ‚Ä¢ false ‚Üí el drawer se oculta.

   - `onCerrar()`:
       ‚Ä¢ callback que se llama para cerrar el men√∫,
       ‚Ä¢ se usa tanto al hacer clic fuera del panel como dentro de algunas acciones.

   - `puestos` (array):
       ‚Ä¢ lista de todos los puestos,
       ‚Ä¢ se usa para dibujar un bot√≥n por cada uno.

   - `puestoSeleccionado` (objeto o null):
       ‚Ä¢ el puesto actualmente activo,
       ‚Ä¢ se muestra en el header y se marca su bot√≥n.

   - `onSeleccionarPuesto(idPuesto)`:
       ‚Ä¢ callback que cambia el puesto activo.

   - `onAbrirModalNuevoPuesto()`:
       ‚Ä¢ abre el modal de alta de puesto.

   - `onAbrirModalEditarPuestos()`:
       ‚Ä¢ abre el modal de edici√≥n masiva de puestos.

   - `onSalir()`:
       ‚Ä¢ vuelve al login / pantalla inicial.

   - `coloresSistema` (array):
       ‚Ä¢ paleta para colorear los botones de puestos (fallback si un puesto no tiene `color`).


2) Helpers internos: handleSeleccionarPuesto y handleAccion

   const handleSeleccionarPuesto = (id) => {
     onSeleccionarPuesto(id);
     onCerrar();
   };

   - Combina dos acciones t√≠picas en mobile:
       ‚Ä¢ cambiar el puesto seleccionado,
       ‚Ä¢ cerrar el men√∫ inmediatamente despu√©s.
   - Mejora la experiencia: el usuario toca un puesto ‚Üí se aplica el cambio y
     el panel se pliega solo.

   const handleAccion = (accion) => {
     onCerrar();
     accion();
   };

   - Recibe una funci√≥n `accion` (por ejemplo, `onAbrirModalNuevoPuesto`).
   - Siempre hace dos pasos, en este orden:
       1) cierra el men√∫ (`onCerrar()`),
       2) ejecuta la acci√≥n recibida.
   - Evita repetir la l√≥gica "cerrar + hacer algo" en cada bot√≥n.


3) Overlay principal (fondo oscuro + click fuera)

   return (
     <div
       className={
         "alim-drawer-overlay" + (abierto ? " alim-drawer-open" : "")
       }
       onClick={onCerrar}
     >
       ...
     </div>
   );

   - `className`:
       ‚Ä¢ `"alim-drawer-overlay"`      ‚Üí base del overlay (cubre toda la pantalla),
       ‚Ä¢ si `abierto` es true         ‚Üí agrega `" alim-drawer-open"`, que normalmente
                                        activa opacidad/animaci√≥n para mostrar el panel.

   - `onClick={onCerrar}`:
       ‚Ä¢ cualquier clic sobre el overlay (fuera del panel) cierra el men√∫,
       ‚Ä¢ es el comportamiento t√≠pico de un drawer en mobile.


4) Panel lateral <aside> y cabecera

   <aside
     className="alim-drawer"
     onClick={(e) => e.stopPropagation()}
   >
     <header className="alim-drawer-header">
       <h2 className="alim-drawer-title">Panel de Alimentadores</h2>
       {puestoSeleccionado && (
         <p className="alim-drawer-subtitle">
           Puesto actual: <strong>{puestoSeleccionado.nombre}</strong>
         </p>
       )}
     </header>
     ...
   </aside>

   - `<aside className="alim-drawer">`:
       ‚Ä¢ es el panel blanco que se desliza desde la izquierda.

   - `onClick={(e) => e.stopPropagation()}`:
       ‚Ä¢ evita que el clic dentro del panel ‚Äúsuba‚Äù al overlay,
       ‚Ä¢ si no estuviera, cualquier clic adentro tambi√©n disparar√≠a `onCerrar`.

   - Header:
       ‚Ä¢ t√≠tulo fijo: ‚ÄúPanel de Alimentadores‚Äù,
       ‚Ä¢ si hay `puestoSeleccionado`, muestra ‚ÄúPuesto actual: <nombre>‚Äù
         para que el usuario sepa d√≥nde est√° parado.


5) Secci√≥n de puestos

   <section className="alim-drawer-section">
     <h3 className="alim-drawer-section-title">Puestos</h3>
     <div className="alim-drawer-puestos">
       {puestos.map((p) => (
         <button
           key={p.id}
           className={
             "alim-btn alim-drawer-btn-puesto" +
             (puestoSeleccionado && puestoSeleccionado.id === p.id
               ? " alim-btn-active"
               : "")
           }
           style={{
             backgroundColor: p.color || coloresSistema[0],
           }}
           onClick={() => handleSeleccionarPuesto(p.id)}
         >
           {p.nombre}
         </button>
       ))}
     </div>
   </section>

   - Se recorre el array `puestos` y se crea un bot√≥n por cada puesto.

   - `className`:
       ‚Ä¢ `"alim-btn alim-drawer-btn-puesto"` ‚Üí estilo base del bot√≥n dentro del drawer,
       ‚Ä¢ si el puesto es el actual (`puestoSeleccionado.id === p.id`), se agrega
         `" alim-btn-active"` para resaltarlo visualmente.

   - `style={{ backgroundColor: p.color || coloresSistema[0] }}`:
       ‚Ä¢ usa el color espec√≠fico del puesto (`p.color`),
       ‚Ä¢ si no tiene, usa el primer color de la paleta.

   - `onClick={() => handleSeleccionarPuesto(p.id)}`:
       ‚Ä¢ selecciona el puesto y cierra el men√∫ (por c√≥mo se implement√≥ el helper).


6) Secci√≥n de acciones

   <section className="alim-drawer-section">
     <h3 className="alim-drawer-section-title">Acciones</h3>
     <div className="alim-drawer-actions">
       <button
         type="button"
         className="alim-btn alim-drawer-btn-action alim-drawer-btn-add"
         onClick={() => handleAccion(onAbrirModalNuevoPuesto)}
       >
         <span className="alim-drawer-btn-add-icon">+</span>
         <span>Nuevo puesto</span>
       </button>

       <button
         type="button"
         className="alim-btn alim-drawer-btn-action alim-btn-edit"
         onClick={() => handleAccion(onAbrirModalEditarPuestos)}
         disabled={puestos.length === 0}
       >
         ‚úé Editar puestos
       </button>

       <button
         type="button"
         className="alim-btn-exit alim-drawer-btn-action"
         onClick={() => handleAccion(onSalir)}
       >
         Salir
       </button>
     </div>
   </section>

   - ‚ÄúNuevo puesto‚Äù:
       ‚Ä¢ bot√≥n con √≠cono ‚Äú+‚Äù y texto ‚ÄúNuevo puesto‚Äù,
       ‚Ä¢ `onClick={() => handleAccion(onAbrirModalNuevoPuesto)}`:
           - cierra el men√∫,
           - abre el modal de creaci√≥n de puesto.

   - ‚ÄúEditar puestos‚Äù:
       ‚Ä¢ muestra √≠cono ‚úé + texto ‚ÄúEditar puestos‚Äù,
       ‚Ä¢ `onClick={() => handleAccion(onAbrirModalEditarPuestos)}`,
       ‚Ä¢ `disabled={puestos.length === 0}`:
           - si no hay ning√∫n puesto, no tiene sentido editar ‚Üí se deshabilita.

   - ‚ÄúSalir‚Äù:
       ‚Ä¢ bot√≥n con estilo de salida (`alim-btn-exit`),
       ‚Ä¢ `onClick={() => handleAccion(onSalir)}`:
           - cierra el men√∫,
           - y luego ejecuta la l√≥gica de salida (normalmente `navigate("/")`). 


7) Export

   export default MenuLateral;

   - Exporta el componente para que `VistaAlimentadores` pueda usarlo.

   - Esa vista controla:
       ‚Ä¢ cu√°ndo abrirlo (`abierto`),
       ‚Ä¢ y qu√© callbacks pasarle (seleccionar puesto, nuevo, editar, salir).

---------------------------------------------------------------------------*/}

========== mi-app/src/paginas/PaginaAlimentadores/componentes/navegacion/SelectorConfiguracion.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/navegacion/SelectorConfiguracion.jsx
// Componente para seleccionar y gestionar workspaces

import React, { useState, useRef, useEffect } from "react";
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import ModalConfirmacion from "../modales/ModalConfirmacion";
import "./SelectorConfiguracion.css";

/**
 * Selector dropdown de workspaces.
 * Permite cambiar entre workspaces y crear nuevos.
 */
const SelectorConfiguracion = ({ onAbrirModalEditarPuestos, onAbrirModalNuevoPuesto, onAbrirModalConfigurarAgente, onAbrirModalGestionarAccesos, onAbrirModalPanelPermisos, puestosLength = 0 }) => {
  const {
    configuraciones,
    configuracionSeleccionada,
    cargando,
    error,
    seleccionarConfiguracion,
    agregarConfiguracion,
    eliminarConfiguracion,
    puedeCrearWorkspaces,
    rolGlobal,
    perfil,
    workspaceDefaultId,
    toggleWorkspaceDefault,
  } = usarContextoConfiguracion();

  const [menuAbierto, setMenuAbierto] = useState(false);
  const [mostrarFormNueva, setMostrarFormNueva] = useState(false);
  const [nombreNueva, setNombreNueva] = useState("");
  const [creando, setCreando] = useState(false);
  const [submenuAbierto, setSubmenuAbierto] = useState(false);
  const [modalEliminarAbierto, setModalEliminarAbierto] = useState(false);

  const hoverTimeoutRef = useRef(null);
  const submenuRef = useRef(null);

  // Limpiar timeout al desmontar
  useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);

  // Cerrar submen√∫ cuando se cierra el men√∫ principal
  useEffect(() => {
    if (!menuAbierto) {
      setSubmenuAbierto(false);
    }
  }, [menuAbierto]);

  const handleSubmenuMouseEnter = () => {
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }
    hoverTimeoutRef.current = setTimeout(() => {
      setSubmenuAbierto(true);
    }, 300); // 300ms de delay para abrir
  };

  const handleSubmenuMouseLeave = () => {
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }
    hoverTimeoutRef.current = setTimeout(() => {
      setSubmenuAbierto(false);
    }, 200); // 200ms de delay para cerrar
  };

  const handleSubmenuClick = () => {
    setSubmenuAbierto(!submenuAbierto);
  };

  const handleSeleccionar = (id) => {
    seleccionarConfiguracion(id);
    setSubmenuAbierto(false);
    setMenuAbierto(false);
  };

  const handleToggleDefault = async (e, id) => {
    e.stopPropagation(); // Evitar que se seleccione el workspace
    try {
      await toggleWorkspaceDefault(id);
    } catch (err) {
      console.error("Error cambiando workspace default:", err);
    }
  };

  const handleCrearNueva = async (e) => {
    e.preventDefault();
    if (!nombreNueva.trim()) return;

    try {
      setCreando(true);
      await agregarConfiguracion(nombreNueva.trim());
      setNombreNueva("");
      setMostrarFormNueva(false);
      setMenuAbierto(false);
    } catch (err) {
      console.error("Error creando workspace:", err);
    } finally {
      setCreando(false);
    }
  };

  const handleEliminarActivo = () => {
    if (!configuracionSeleccionada) return;
    if (configuraciones.length <= 1) {
      alert("No se puede eliminar el √∫nico workspace existente.");
      return;
    }
    // Abrir modal de confirmaci√≥n
    setModalEliminarAbierto(true);
  };

  const confirmarEliminarWorkspace = async () => {
    try {
      // Encontrar el √≠ndice del workspace activo
      const indiceActual = configuraciones.findIndex(c => c.id === configuracionSeleccionada.id);

      // Determinar a qu√© workspace cambiar: anterior si existe, sino siguiente
      let nuevoWorkspace;
      if (indiceActual > 0) {
        nuevoWorkspace = configuraciones[indiceActual - 1];
      } else {
        nuevoWorkspace = configuraciones[indiceActual + 1];
      }

      // Cambiar al nuevo workspace antes de eliminar
      seleccionarConfiguracion(nuevoWorkspace.id);

      // Eliminar el workspace
      await eliminarConfiguracion(configuracionSeleccionada.id);

      setModalEliminarAbierto(false);
      setMenuAbierto(false);
    } catch (err) {
      console.error("Error eliminando workspace:", err);
    }
  };

  if (cargando) {
    return (
      <div className="selector-config selector-config--cargando">
        <span className="selector-config__spinner"></span>
        Cargando...
      </div>
    );
  }

  if (error) {
    return (
      <div className="selector-config selector-config--error">
        Error: {error}
      </div>
    );
  }

  // Si no hay workspaces, mostrar estado seg√∫n permisos del rol
  if (configuraciones.length === 0) {
    // Usuarios sin permiso para crear (operador, observador)
    if (!puedeCrearWorkspaces) {
      return (
        <div className="selector-config">
          <button
            type="button"
            className="selector-config__trigger selector-config__trigger--deshabilitado"
            onClick={() => setMenuAbierto(!menuAbierto)}
            aria-expanded={menuAbierto}
          >
            <span className="selector-config__nombre">Sin workspace</span>
            <span className="selector-config__flecha">{menuAbierto ? "‚ñ≤" : "‚ñº"}</span>
          </button>

          {menuAbierto && (
            <>
              <div
                className="selector-config__overlay"
                onClick={() => setMenuAbierto(false)}
              />
              <div className="selector-config__menu">
                {/* Header con usuario y rol */}
                {perfil && (
                  <div className="selector-config__usuario-header">
                    <span className="selector-config__usuario-nombre">{perfil.nombre || perfil.email}</span>
                    <span className="selector-config__usuario-rol">{perfil.roles?.nombre || rolGlobal}</span>
                  </div>
                )}
                <div className="selector-config__vacio-mensaje selector-config__vacio-mensaje--info">
                  No tienes workspaces asignados.
                  <br />
                  <small>Contacta a un administrador para ser invitado a un workspace.</small>
                </div>
              </div>
            </>
          )}
        </div>
      );
    }

    // Usuarios con permiso para crear (superadmin, admin)
    return (
      <div className="selector-config">
        <button
          type="button"
          className="selector-config__trigger selector-config__trigger--crear"
          onClick={() => setMenuAbierto(!menuAbierto)}
          aria-expanded={menuAbierto}
        >
          <span className="selector-config__nombre">+ Crear Workspace</span>
        </button>

        {menuAbierto && (
          <>
            <div
              className="selector-config__overlay"
              onClick={() => {
                setMenuAbierto(false);
                setMostrarFormNueva(false);
              }}
            />
            <div className="selector-config__menu">
              {/* Header con usuario y rol */}
              {perfil && (
                <div className="selector-config__usuario-header">
                  <span className="selector-config__usuario-nombre">{perfil.nombre || perfil.email}</span>
                  <span className="selector-config__usuario-rol">{perfil.roles?.nombre || rolGlobal}</span>
                </div>
              )}
              <div className="selector-config__vacio-mensaje">
                No tienes workspaces asignados.
                <br />
                Crea uno para empezar.
              </div>
              {mostrarFormNueva ? (
                <form className="selector-config__form" onSubmit={handleCrearNueva}>
                  <input
                    type="text"
                    className="selector-config__input"
                    placeholder="Nombre del workspace"
                    value={nombreNueva}
                    onChange={(e) => setNombreNueva(e.target.value)}
                    autoFocus
                    disabled={creando}
                  />
                  <div className="selector-config__form-btns">
                    <button
                      type="button"
                      className="selector-config__btn-cancelar"
                      onClick={() => {
                        setMostrarFormNueva(false);
                        setNombreNueva("");
                      }}
                      disabled={creando}
                    >
                      Cancelar
                    </button>
                    <button
                      type="submit"
                      className="selector-config__btn-crear"
                      disabled={!nombreNueva.trim() || creando}
                    >
                      {creando ? "Creando..." : "Crear"}
                    </button>
                  </div>
                </form>
              ) : (
                <button
                  type="button"
                  className="selector-config__nueva selector-config__nueva--destacado"
                  onClick={() => setMostrarFormNueva(true)}
                >
                  + Crear mi primer workspace
                </button>
              )}
            </div>
          </>
        )}
      </div>
    );
  }

  return (
    <div className="selector-config">
      <button
        type="button"
        className="selector-config__trigger"
        onClick={() => setMenuAbierto(!menuAbierto)}
        aria-expanded={menuAbierto}
        aria-haspopup="listbox"
      >
        <span className="selector-config__nombre">
          {configuracionSeleccionada?.nombre || "Sin workspace"}
        </span>
        <span className="selector-config__flecha">{menuAbierto ? "‚ñ≤" : "‚ñº"}</span>
      </button>

      {menuAbierto && (
        <>
          {/* Overlay para cerrar al hacer clic fuera */}
          <div
            className="selector-config__overlay"
            onClick={() => {
              setMenuAbierto(false);
              setMostrarFormNueva(false);
            }}
          />

          <div className="selector-config__menu" role="listbox">
            {/* Header con usuario y roles (global + workspace) */}
            {perfil && (
              <div className="selector-config__usuario-header">
                {/* Nombre + Rol global en la misma l√≠nea */}
                <div className="selector-config__usuario-linea">
                  <span className="selector-config__usuario-nombre">{perfil.nombre || perfil.email}</span>
                  <span className="selector-config__rol-global">
                    [ <svg className="selector-config__rol-icono" viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                    </svg>
                    {(() => {
                      const nombresRol = {
                        'superadmin': 'SuperAdmin',
                        'admin': 'Admin',
                        'operador': 'Operador',
                        'observador': 'Observador',
                      };
                      return nombresRol[rolGlobal] || 'Observador';
                    })()} ]
                  </span>
                </div>
                {/* Rol en workspace (solo si es invitado) */}
                {(() => {
                  const rolEnWs = configuracionSeleccionada?.rol;
                  const esCreador = configuracionSeleccionada?.esCreador;

                  if (esCreador === false && rolEnWs) {
                    const nombresRol = {
                      'admin': 'Admin',
                      'operador': 'Operador',
                      'observador': 'Observador',
                    };
                    return (
                      <span className="selector-config__rol-workspace">
                        Rol en Workspace: {nombresRol[rolEnWs] || 'Observador'}
                      </span>
                    );
                  }
                  return null;
                })()}
              </div>
            )}

            {/* Opci√≥n Workspaces con submen√∫ */}
            <div
              className="selector-config__submenu-container"
              ref={submenuRef}
              onMouseEnter={handleSubmenuMouseEnter}
              onMouseLeave={handleSubmenuMouseLeave}
            >
              <button
                type="button"
                className={`selector-config__submenu-trigger ${submenuAbierto ? 'selector-config__submenu-trigger--activo' : ''}`}
                onClick={handleSubmenuClick}
              >
                <span className={`selector-config__submenu-flecha ${submenuAbierto ? 'selector-config__submenu-flecha--abierto' : ''}`}>‚ñº</span>
                <span>Workspace</span>
              </button>

              {/* Submen√∫ de workspaces */}
              {submenuAbierto && (
                <div
                  className="selector-config__submenu"
                  onMouseEnter={handleSubmenuMouseEnter}
                  onMouseLeave={handleSubmenuMouseLeave}
                >
                  {configuraciones.length > 0 ? (
                    <ul className="selector-config__lista">
                      {configuraciones.map((config) => (
                        <li
                          key={config.id}
                          className={`selector-config__item ${
                            config.id === configuracionSeleccionada?.id
                              ? "selector-config__item--activo"
                              : ""
                          }`}
                        >
                          <button
                            type="button"
                            className="selector-config__default-btn"
                            onClick={(e) => handleToggleDefault(e, config.id)}
                            title={config.id === workspaceDefaultId ? "Quitar como default" : "Establecer como default"}
                          >
                            {config.id === workspaceDefaultId ? "‚òÖ" : "‚òÜ"}
                          </button>
                          <button
                            type="button"
                            className="selector-config__item-btn"
                            onClick={() => handleSeleccionar(config.id)}
                            role="option"
                            aria-selected={config.id === configuracionSeleccionada?.id}
                          >
                            <span className="selector-config__item-nombre">
                              {config.nombre}
                              {!config.esCreador && <em className="selector-config__item-invitado">(invitado)</em>}
                            </span>
                            {!config.esCreador && (
                              <span className="selector-config__item-rol">
                                <em>rol: {config.rol || 'observador'}</em>
                              </span>
                            )}
                          </button>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <div className="selector-config__vacio">
                      No hay workspaces
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Separador */}
            <div className="selector-config__separador" />

            {/* Bot√≥n/Form para crear nuevo */}
            {mostrarFormNueva ? (
              <form className="selector-config__form" onSubmit={handleCrearNueva}>
                <input
                  type="text"
                  className="selector-config__input"
                  placeholder="Nombre del workspace"
                  value={nombreNueva}
                  onChange={(e) => setNombreNueva(e.target.value)}
                  autoFocus
                  disabled={creando}
                />
                <div className="selector-config__form-btns">
                  <button
                    type="button"
                    className="selector-config__btn-cancelar"
                    onClick={() => {
                      setMostrarFormNueva(false);
                      setNombreNueva("");
                    }}
                    disabled={creando}
                  >
                    Cancelar
                  </button>
                  <button
                    type="submit"
                    className="selector-config__btn-crear"
                    disabled={!nombreNueva.trim() || creando}
                  >
                    {creando ? "Creando..." : "Crear"}
                  </button>
                </div>
              </form>
            ) : (
              <>
                {/*
                  Permisos en el men√∫:
                  - rolGlobal: rol global del usuario en el sistema (superadmin, admin, operador, observador)
                  - configuracionSeleccionada?.rol: rol del usuario EN ESTE WORKSPACE espec√≠fico
                  - configuracionSeleccionada?.esCreador: true si el usuario es el creador del workspace
                  - Gestionar Accesos: SOLO el creador del workspace
                  - Nuevo puesto / Configurar Agente: creador O invitado con rol admin en el workspace
                  - Editar puestos: creador, admin o operador en el workspace
                  - Panel de Permisos: SOLO superadmin global
                */}
                {(() => {
                  const rolEnWorkspace = configuracionSeleccionada?.rol;
                  const esCreador = configuracionSeleccionada?.esCreador;
                  // Para Nuevo puesto: creador O invitado con rol admin en el workspace (NO incluye superadmin global)
                  const puedeCrearPuesto = esCreador || rolEnWorkspace === 'admin';
                  // Para Editar puestos: creador, admin en workspace, o operador en workspace
                  const esOperadorEnWorkspace = puedeCrearPuesto || rolEnWorkspace === 'operador';

                  return (
                    <>
                      {/* Opci√≥n gestionar accesos (SOLO el creador del workspace) */}
                      {esCreador && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalGestionarAccesos?.();
                          }}
                        >
                          <svg className="selector-config__opcion-icono-svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                            <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                          </svg>
                          Gestionar Accesos
                        </button>
                      )}

                      {/* Opci√≥n nuevo puesto (creador O invitado con rol admin en el workspace) */}
                      {puedeCrearPuesto && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalNuevoPuesto?.();
                          }}
                        >
                          <span className="selector-config__opcion-icono">+</span>
                          Nuevo puesto
                        </button>
                      )}

                      {/* Opci√≥n editar puestos (admin u operador en workspace) */}
                      {esOperadorEnWorkspace && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalEditarPuestos?.();
                          }}
                          disabled={puestosLength === 0}
                        >
                          <span className="selector-config__opcion-icono">‚úé</span>
                          Editar puestos
                        </button>
                      )}

                      {/* Opci√≥n configurar agente (creador O invitado con rol admin en el workspace) */}
                      {puedeCrearPuesto && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalConfigurarAgente?.();
                          }}
                        >
                          <span className="selector-config__opcion-icono">‚öô</span>
                          Configurar Agente
                        </button>
                      )}
                    </>
                  );
                })()}

                {/* Opci√≥n panel de permisos (solo superadmin GLOBAL) */}
                {rolGlobal === 'superadmin' && (
                  <button
                    type="button"
                    className="selector-config__opcion-secundaria"
                    onClick={() => {
                      setMenuAbierto(false);
                      onAbrirModalPanelPermisos?.();
                    }}
                  >
                    <span className="selector-config__opcion-icono">üîê</span>
                    Panel de Permisos
                  </button>
                )}

                {/* Opci√≥n eliminar workspace activo (solo si hay m√°s de uno y es creador/admin) */}
                {configuraciones.length > 1 && configuracionSeleccionada?.esCreador && (
                  <button
                    type="button"
                    className="selector-config__eliminar-activo"
                    onClick={handleEliminarActivo}
                  >
                    <span className="selector-config__eliminar-icono">üóë</span>
                    Eliminar workspace
                  </button>
                )}

                {/* Solo mostrar bot√≥n de crear si tiene permisos */}
                {puedeCrearWorkspaces && (
                  <button
                    type="button"
                    className="selector-config__nueva"
                    onClick={() => setMostrarFormNueva(true)}
                  >
                    + Nuevo workspace
                  </button>
                )}
              </>
            )}
          </div>
        </>
      )}

      {/* Modal de confirmaci√≥n para eliminar workspace */}
      <ModalConfirmacion
        abierto={modalEliminarAbierto}
        titulo="Eliminar workspace"
        mensaje={`¬øEst√°s seguro de que deseas eliminar el workspace "${configuracionSeleccionada?.nombre}"? Esta acci√≥n no se puede deshacer.`}
        textoConfirmar="Eliminar"
        textoCancelar="Cancelar"
        peligroso={true}
        onConfirmar={confirmarEliminarWorkspace}
        onCancelar={() => setModalEliminarAbierto(false)}
      />
    </div>
  );
};

export default SelectorConfiguracion;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/tarjetas/CajaMedicion.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/tarjetas/CajaMedicion.jsx

import React from "react";

/**
 * Formatea un valor seg√∫n la cantidad de decimales configurada.
 * Solo afecta a valores num√©ricos, no modifica el valor interno.
 * @param {string} valor - Valor original (puede ser "--,--" o n√∫mero con coma)
 * @param {number} decimales - Cantidad de decimales a mostrar (0, 1 o 2)
 */
const formatearValorConDecimales = (valor, decimales) => {
	// Si no se especifica decimales, usar 2 por defecto
	if (decimales === undefined || decimales === null) return valor;

	// Si es placeholder, ajustar seg√∫n decimales
	if (valor === "--,--" || valor === "--" || valor === "--,-") {
		if (decimales === 0) return "--";
		if (decimales === 1) return "--,-";
		return "--,--";
	}

	// Convertir coma a punto para parsear
	const numStr = String(valor).replace(",", ".");
	const num = parseFloat(numStr);
	if (isNaN(num)) return valor;

	return num.toFixed(decimales).replace(".", ",");
};

/**
 * Caja individual de medici√≥n con su animaci√≥n de borde y valor.
 */
const CajaMedicion = ({
	box,                              // { etiqueta, valor, enabled, origen }
	indice,                           // posici√≥n dentro del grupo (0..3)
	zona,                             // "sup" o "inf" para identificar el lado
	mideRele,                         // indica si la medici√≥n de rel√© est√° activa
	mideAnalizador,                   // indica si la medici√≥n de analizador est√° activa
	mostrarProgresoRele,              // activa animaci√≥n de borde para rel√©
	mostrarProgresoAnalizador,        // activa animaci√≥n de borde para analizador
	periodoRele,                      // periodo configurado (segundos) para rel√©
	periodoAnalizador,                // periodo configurado (segundos) para analizador
	contadorRele,                     // cu√°ntas lecturas se hicieron para rel√©
	contadorAnalizador,               // cu√°ntas lecturas se hicieron para analizador
	// Polling de lecturas desde BD
	estaPolling = false,              // indica si hay polling activo
	mostrarProgresoPolling = false,   // activa animaci√≥n de borde para polling
	periodoPolling = 60,              // periodo de polling en segundos
	contadorPolling = 0,              // cu√°ntas lecturas se hicieron durante polling
	// Error de polling
	tieneError = false,               // indica si hay error de lectura
	// Estilos globales del box
	estilosBox = null,                // { tituloBox, valorBox, box }
}) => {
	const esDelRele = box.origen === "rele" || !box.origen;       // si no se especifica origen, asumimos rel√©
	const esDelAnalizador = box.origen === "analizador";

	// ===== MODO POLLING (tiene prioridad cuando est√° activo) =====
	// En modo polling, todas las cajas habilitadas muestran animaci√≥n
	const pollingActivo = estaPolling && box.enabled;
	const progresoPollingHabilitado = pollingActivo && mostrarProgresoPolling;

	// ===== MODO MEDICI√ìN TRADICIONAL (rele/analizador) =====
	const medicionActiva =
		!estaPolling &&                                            // solo si NO hay polling activo
		box.enabled &&                                             // la caja debe estar habilitada
		((esDelRele && mideRele) || (esDelAnalizador && mideAnalizador)); // y el equipo correspondiente debe estar midiendo

	const progresoTradicionalHabilitado =
		(esDelRele && mostrarProgresoRele) ||
		(esDelAnalizador && mostrarProgresoAnalizador);            // control global de cu√°ndo mostrar borde animado

	// ===== DECIDIR QU√â ANIMACI√ìN USAR =====
	// Prioridad: polling > medici√≥n tradicional
	let duracionAnimacion;
	let contadorLecturas;
	let propiedadDuracion;
	let usarAnimacion = false;

	if (pollingActivo && progresoPollingHabilitado) {
		// Usar animaci√≥n de polling (reutiliza el CSS de rel√©)
		duracionAnimacion = periodoPolling;
		contadorLecturas = contadorPolling;
		propiedadDuracion = "--rw-progress-duration-rele";          // reutiliza la animaci√≥n del rel√©
		usarAnimacion = true;
	} else if (medicionActiva && progresoTradicionalHabilitado) {
		// Usar animaci√≥n tradicional
		duracionAnimacion = esDelAnalizador ? periodoAnalizador : periodoRele;
		contadorLecturas = esDelAnalizador ? contadorAnalizador : contadorRele;
		propiedadDuracion = esDelRele
			? "--rw-progress-duration-rele"
			: "--rw-progress-duration-analizador";
		usarAnimacion = true;
	} else {
		// Sin animaci√≥n
		duracionAnimacion = 60;
		contadorLecturas = 0;
		propiedadDuracion = "--rw-progress-duration-rele";
	}

	const equipo = pollingActivo ? "polling" : (esDelAnalizador ? "analizador" : "rele");

	let clasesValor = "alim-card-meter-value";                    // clase base del valor

	// TEMPORALMENTE DESACTIVADO: animaci√≥n de borde en el box
	// Se usa la barra de progreso horizontal en su lugar
	// if (usarAnimacion && !tieneError) {
	// 	if (pollingActivo || esDelRele) {
	// 		clasesValor += " alim-meter-progress-rele";
	// 	} else if (esDelAnalizador) {
	// 		clasesValor += " alim-meter-progress-analizador";
	// 	}
	// }

	// si hay error, agregar clase de error
	if (tieneError && box.enabled) {
		clasesValor += " alim-card-meter-value--error";
	}

	// Key que incluye el contador de lecturas para reiniciar animaci√≥n
	const claveValor = `${zona}-${indice}-${equipo}-c${contadorLecturas}`;

	// Determinar qu√© valor mostrar (aplicando formato de decimales)
	const decimalesConfig = estilosBox?.valorBox?.decimales;
	let valorMostrar = box.valor ?? "--,--";
	if (tieneError && box.enabled) {
		valorMostrar = "ERROR";
	} else {
		valorMostrar = formatearValorConDecimales(valorMostrar, decimalesConfig);
	}

	// Construir estilos del t√≠tulo del box (etiqueta como R, S, T)
	const estiloTituloBox = estilosBox?.tituloBox ? {
		fontFamily: estilosBox.tituloBox.fontFamily,
		fontSize: estilosBox.tituloBox.fontSize,
	} : {};

	// Construir estilos del valor del box (n√∫mero) - ahora con tama√±o fijo y overflow
	const boxHeight = estilosBox?.box?.height;
	const estiloValorBase = {
		...(estilosBox?.valorBox ? {
			fontFamily: estilosBox.valorBox.fontFamily,
			fontSize: estilosBox.valorBox.fontSize,
			color: estilosBox.valorBox.color,
		} : {}),
		// El box ahora tiene tama√±o fijo, el texto se recorta si no cabe
		width: "100%",
		...(boxHeight && boxHeight !== "auto" ? { height: boxHeight } : {}),
		overflow: "hidden",
		textOverflow: "ellipsis",
		display: "flex",
		alignItems: "center",
		justifyContent: "center",
	};

	// Combinar con estilos de animaci√≥n si corresponde
	const estiloValor = usarAnimacion && !tieneError
		? {
			...estiloValorBase,
			[propiedadDuracion]: `${duracionAnimacion}s`,
		}
		: estiloValorBase;

	// Estilos del contenedor del box (ancho fijo)
	const estiloMeter = estilosBox?.box?.width ? {
		width: estilosBox.box.width,
		flex: `0 0 ${estilosBox.box.width}`,
	} : {};

	return (
		<div
			key={`${zona}-${indice}`}
			className="alim-card-meter"
			style={Object.keys(estiloMeter).length > 0 ? estiloMeter : undefined}
		>
			<span
				className="alim-card-meter-phase"
				style={estiloTituloBox}
			>
				{box.etiqueta}
			</span>
			<span
				key={claveValor}
				className={clasesValor}
				style={Object.keys(estiloValor).length > 0 ? estiloValor : undefined}
			>
				{valorMostrar}
			</span>
		</div>
	);
};

export default CajaMedicion;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (CajaMedicion.jsx)

 - Representa un √∫nico ‚Äúdisplay‚Äù de la tarjeta (por ejemplo, fase R de corriente),
   encargado de mostrar etiqueta, valor y, opcionalmente, el borde de progreso.

 - `box.origen` decide si la caja pertenece al rel√© o al analizador; si no se
   indica, se asume rel√© por defecto.

 - El par `medicionActiva` + `progresoHabilitado` controla cu√°ndo se aplica la
   clase de borde animado: solo si la caja est√° habilitada y el equipo est√°
   midiendo (y la vista decidi√≥ mostrar progreso).

 - La key `claveValor` incluye el contador de lecturas para que React vuelva a
   montar el span del valor cuando llegue una nueva lectura, reiniciando as√≠ la
   animaci√≥n de borde.

 - `propiedadDuracion` permite ajustar la duraci√≥n de la animaci√≥n v√≠a variable
   CSS diferente para rel√© y analizador.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (CajaMedicion.jsx)

0) Visi√≥n general del componente

   `CajaMedicion` es el ‚Äúdisplay‚Äù individual dentro de la tarjeta:

   - Muestra:
       ‚Ä¢ una etiqueta (ej: "R", "S", "T" o un nombre personalizado),
       ‚Ä¢ un valor num√©rico o placeholder (`"--,--"`).

   - Opcionalmente dibuja una animaci√≥n de borde alrededor del valor para indicar
     el progreso del per√≠odo de medici√≥n (tipo ‚Äúbarra de progreso circular‚Äù):

       ‚Ä¢ puede representar el per√≠odo del rel√©,
       ‚Ä¢ o el del analizador, seg√∫n el origen definido en la caja.


1) Props y rol de cada una

   const CajaMedicion = ({
     box,
     indice,
     zona,
     mideRele,
     mideAnalizador,
     mostrarProgresoRele,
     mostrarProgresoAnalizador,
     periodoRele,
     periodoAnalizador,
     contadorRele,
     contadorAnalizador,
   }) => { ... }

   - `box`:
       ‚Ä¢ objeto con la configuraci√≥n de esta caja:
           - `box.etiqueta`  ‚Üí texto a mostrar encima del valor,
           - `box.valor`     ‚Üí lectura procesada (como string),
           - `box.enabled`   ‚Üí si la caja est√° habilitada para mostrar medici√≥n,
           - `box.origen`    ‚Üí `"rele"`, `"analizador"` o `undefined`:
               ¬∑ si es `"rele"`, la caja depende del rel√©,
               ¬∑ si es `"analizador"`, depende del analizador,
               ¬∑ si no se indica, se asume rel√© por defecto.

   - `indice`:
       ‚Ä¢ posici√≥n dentro del grupo de cajas (0, 1, 2 o 3),
       ‚Ä¢ se usa para construir keys √∫nicas.

   - `zona`:
       ‚Ä¢ indica si esta caja est√° en la parte:
           - `"sup"` ‚Üí bloque superior de la tarjeta,
           - `"inf"` ‚Üí bloque inferior.
       ‚Ä¢ tambi√©n participa en la generaci√≥n de keys.

   - `mideRele` / `mideAnalizador`:
       ‚Ä¢ booleans que indican si hay mediciones activas para cada equipo.
       ‚Ä¢ vienen del contexto y reflejan el estado real de los timers.

   - `mostrarProgresoRele` / `mostrarProgresoAnalizador`:
       ‚Ä¢ booleans que controlan si se debe animar el borde para cada equipo.
       ‚Ä¢ los gestiona `TarjetaAlimentador` seg√∫n si ya hubo lecturas, etc.

   - `periodoRele` / `periodoAnalizador`:
       ‚Ä¢ duraci√≥n del ciclo de actualizaci√≥n en segundos,
       ‚Ä¢ se usan para ajustar la velocidad de la animaci√≥n del borde.

   - `contadorRele` / `contadorAnalizador`:
       ‚Ä¢ se incrementan en cada lectura,
       ‚Ä¢ sirven para forzar el reinicio de la animaci√≥n cuando llega un nuevo set
         de datos (usando la key).


2) Banderas de origen: esDelRele / esDelAnalizador

   const esDelRele = box.origen === "rele" || !box.origen;
   const esDelAnalizador = box.origen === "analizador";

   - `esDelRele`:
       ‚Ä¢ es true si `box.origen` es `"rele"`,
       ‚Ä¢ o si `box.origen` no est√° definido (`!box.origen`),
       ‚Ä¢ en otras palabras: si no se aclara, asumimos rel√© como origen por defecto.

   - `esDelAnalizador`:
       ‚Ä¢ true solo si `box.origen === "analizador"`.

   - Esto permite que la misma caja se integre a la l√≥gica de:
       ‚Ä¢ mediciones y animaciones del rel√©,
       ‚Ä¢ o del analizador,
       ‚Ä¢ sin mezclar ambas cosas a la vez.


3) Determinar si la medici√≥n est√° activa en esta caja

   const medicionActiva =
     box.enabled &&
     ((esDelRele && mideRele) || (esDelAnalizador && mideAnalizador));

   - La caja solo debe considerarse ‚Äúactiva‚Äù si se cumplen dos condiciones:

       1) `box.enabled` es true:
           ‚Ä¢ el mapeo habilit√≥ esta caja (se decidi√≥ usarla).

       2) El equipo correspondiente est√° midiendo:
           ‚Ä¢ si la caja es del rel√© ‚Üí se requiere `mideRele === true`,
           ‚Ä¢ si es del analizador ‚Üí se requiere `mideAnalizador === true`.

   - Si cualquiera de estas condiciones falla:
       ‚Ä¢ `medicionActiva` ser√° false,
       ‚Ä¢ no se mostrar√° animaci√≥n de progreso.


4) Control de progreso: progresoHabilitado

   const progresoHabilitado =
     (esDelRele && mostrarProgresoRele) ||
     (esDelAnalizador && mostrarProgresoAnalizador);

   - Esta bandera no mira solo el estado de medici√≥n, sino la decisi√≥n de la vista
     sobre si debe mostrarse la animaci√≥n en este momento.

   - Resumen:

       ‚Ä¢ Para cajas de rel√©:
             `esDelRele && mostrarProgresoRele`

       ‚Ä¢ Para cajas de analizador:
             `esDelAnalizador && mostrarProgresoAnalizador`

   - `mostrarProgresoRele` / `mostrarProgresoAnalizador` los maneja
     `TarjetaAlimentador` usando contadores de lecturas:
       ‚Ä¢ se activan cuando llega al menos una lectura,
       ‚Ä¢ se apagan si se detiene la medici√≥n o se cambia de puesto.


5) Equipo, duraci√≥n y contador de lecturas

   const equipo = esDelAnalizador ? "analizador" : "rele";

   - Texto de conveniencia para identificar a cu√°l equipo est√° asociada la caja.

   const duracionAnimacion = esDelAnalizador
     ? periodoAnalizador
     : periodoRele;

   - ‚ÄúCu√°nto dura‚Äù el ciclo de animaci√≥n del borde:
       ‚Ä¢ si la caja es del analizador ‚Üí usa `periodoAnalizador`,
       ‚Ä¢ si no ‚Üí usa `periodoRele`.

   const contadorLecturas = esDelAnalizador
     ? contadorAnalizador
     : contadorRele;

   - Se elige el contador que corresponde al equipo de esta caja:

       ‚Ä¢ analizador ‚Üí `contadorAnalizador`,
       ‚Ä¢ rel√©       ‚Üí `contadorRele`.

   - Este valor se usar√° despu√©s para generar una key √∫nica y provocar que
     React remonte el elemento cuando cambie (reiniciando la animaci√≥n).


6) Construcci√≥n de clases CSS para el valor

   let clasesValor = "alim-card-meter-value";

   if (medicionActiva && progresoHabilitado) {
     if (esDelRele) {
       clasesValor += " alim-meter-progress-rele";
     } else if (esDelAnalizador) {
       clasesValor += " alim-meter-progress-analizador";
     }
   }

   - Siempre partimos de la clase base `"alim-card-meter-value"`.

   - Si la medici√≥n est√° activa y el progreso est√° habilitado:

       ‚Ä¢ para cajas del rel√©:
           - se agrega `"alim-meter-progress-rele"`.

       ‚Ä¢ para cajas del analizador:
           - se agrega `"alim-meter-progress-analizador"`.

   - Estas clases extra son las que el CSS usa para dibujar el borde animado,
     usando las variables `--rw-progress-duration-rele` o
     `--rw-progress-duration-analizador`.


7) Key para reiniciar animaci√≥n y variable CSS de duraci√≥n

   const claveValor = `${zona}-${indice}-${equipo}-c${contadorLecturas}`;

   - Esta key se aplica al `<span>` que muestra el valor:

       ‚Ä¢ incluye:
           - `zona` (sup/inf),
           - `indice` dentro del grupo,
           - `equipo` ("rele"/"analizador"),
           - `contadorLecturas`.

   - Cuando `contadorLecturas` cambia (ej: llega una nueva lectura):

       ‚Ä¢ la key cambia,
       ‚Ä¢ React desmonta y vuelve a montar el `<span>`,
       ‚Ä¢ y la animaci√≥n CSS se reinicia desde cero.

   const propiedadDuracion = esDelRele
     ? "--rw-progress-duration-rele"
     : "--rw-progress-duration-analizador";

   - Esta string representa el nombre de la variable CSS que controla 
     la duraci√≥n de la animaci√≥n:

       ‚Ä¢ para cajas del rel√© ‚Üí `"--rw-progress-duration-rele"`,
       ‚Ä¢ para cajas del analizador ‚Üí `"--rw-progress-duration-analizador"`.


8) JSX final

   return (
     <div key={`${zona}-${indice}`} className="alim-card-meter">
       <span className="alim-card-meter-phase">{box.etiqueta}</span>
       <span
         key={claveValor}
         className={clasesValor}
         style={
           medicionActiva && progresoHabilitado
             ? { [propiedadDuracion]: `${duracionAnimacion}s` }
             : undefined
         }
       >
         {box.valor ?? "--,--"}
       </span>
     </div>
   );

   - Contenedor de la caja:
       ‚Ä¢ `<div className="alim-card-meter">` agrupa etiqueta y valor.
       ‚Ä¢ usa `key={`${zona}-${indice`}` para identificar la caja dentro del
         grupo de `GrupoMedidores`.

   - Etiqueta:
       ‚Ä¢ `<span className="alim-card-meter-phase">{box.etiqueta}</span>`
       ‚Ä¢ muestra el texto configurado (ej: R, S, T, ‚ÄúPromedio‚Äù, etc.).

   - Valor:
       ‚Ä¢ `<span key={claveValor} className={clasesValor} ...>`
       ‚Ä¢ `key={claveValor}`:
           - se apoya en el contador de lecturas para reiniciar animaci√≥n.
       ‚Ä¢ `className={clasesValor}`:
           - incluye o no las clases de animaci√≥n seg√∫n corresponda.
       ‚Ä¢ `style={ ... }`:
           - si la medici√≥n est√° activa y el progreso habilitado, se pasa
             un objeto con la variable CSS `[propiedadDuracion]` ajustada
             a `${duracionAnimacion}s`.
           - si no, `style` queda `undefined` y no se aplica ning√∫n override.

       ‚Ä¢ `{box.valor ?? "--,--"}`:
           - muestra `box.valor` si est√° definido,
           - si viene `null` o `undefined`, muestra `"--,--"` como placeholder.


9) Export

   export default CajaMedicion;

   - Permite usar esta caja desde `TarjetaAlimentador`, que es la que decide
     cu√°ntas cajas hay, c√≥mo se agrupan y con qu√© par√°metros se renderiza cada una.

---------------------------------------------------------------------------*/
========== mi-app/src/paginas/PaginaAlimentadores/componentes/tarjetas/GapResizer.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/tarjetas/GapResizer.jsx

import React, { useState, useRef, useEffect, useCallback } from "react";
import "./GapResizer.css";

/**
 * Componente que permite ajustar el gap entre tarjetas.
 * Aparece como una l√≠nea con un c√≠rculo al hacer hover entre tarjetas.
 *
 * Comportamiento:
 * - Al hacer hover sobre el handle: aparece la barra de gap con el valor actual
 * - Al arrastrar con click izquierdo: ajusta el gap visualmente
 * - Al hacer doble click: se habilita la edici√≥n manual del input
 * - Enter o click fuera del input: confirma el valor y oculta la barra
 * - Escape: cancela y oculta la barra
 *
 * @param {number} gap - Gap actual en p√≠xeles
 * @param {function} onGapChange - Callback (nuevoGap)
 */
const GapResizer = ({ gap, onGapChange, minGap = 0, maxGap = 500 }) => {
	const [isHovered, setIsHovered] = useState(false);
	const [isDragging, setIsDragging] = useState(false);
	const [isEditing, setIsEditing] = useState(false); // true = input editable
	const [inputValue, setInputValue] = useState(gap);
	const inputRef = useRef(null);
	const containerRef = useRef(null);
	const hitboxRef = useRef(null);
	const startXRef = useRef(0);
	const startGapRef = useRef(gap);

	// Actualizar inputValue cuando cambia el gap desde afuera (pero no durante edici√≥n)
	useEffect(() => {
		if (!isEditing) {
			setInputValue(gap);
		}
	}, [gap, isEditing]);

	// Detectar clicks fuera del componente para cerrar
	// NOTA: No cerrar si est√° en modo edici√≥n (solo Enter/Escape cierran)
	useEffect(() => {
		const handleClickOutside = (e) => {
			if (containerRef.current && !containerRef.current.contains(e.target)) {
				// Solo ocultar si NO est√° editando
				if (!isEditing) {
					setIsHovered(false);
				}
			}
		};

		// Solo escuchar si est√° activo y no editando
		if (isHovered && !isEditing) {
			document.addEventListener('mousedown', handleClickOutside);
		}

		return () => {
			document.removeEventListener('mousedown', handleClickOutside);
		};
	}, [isHovered, isEditing]);

	// ===== DRAG HANDLERS =====
	const handleMouseDown = useCallback((e) => {
		// Solo drag con click izquierdo (button 0)
		if (e.button !== 0) return;
		e.preventDefault();
		e.stopPropagation();
		setIsDragging(true);
		startXRef.current = e.clientX;
		startGapRef.current = gap;
	}, [gap]);

	const handleMouseMove = useCallback((e) => {
		if (!isDragging) return;

		const deltaX = e.clientX - startXRef.current;
		// Cada 2px de movimiento = 1px de gap
		const newGap = Math.round(startGapRef.current + deltaX / 2);
		const clampedGap = Math.max(minGap, Math.min(maxGap, newGap));

		onGapChange(clampedGap);
		setInputValue(clampedGap);
	}, [isDragging, minGap, maxGap, onGapChange]);

	const handleMouseUp = useCallback((e) => {
		setIsDragging(false);

		// Verificar si el mouse est√° fuera del hitbox al soltar
		// Si est√° fuera, ocultar la barra
		if (hitboxRef.current) {
			const rect = hitboxRef.current.getBoundingClientRect();
			const mouseX = e.clientX;
			const mouseY = e.clientY;
			const isOutside =
				mouseX < rect.left ||
				mouseX > rect.right ||
				mouseY < rect.top ||
				mouseY > rect.bottom;

			if (isOutside && !isEditing) {
				setIsHovered(false);
			}
		}
	}, [isEditing]);

	// Doble click para activar modo edici√≥n
	const handleDoubleClick = useCallback((e) => {
		e.preventDefault();
		e.stopPropagation();
		setIsEditing(true);
		setInputValue(gap);
	}, [gap]);

	// Agregar/remover listeners globales para el drag
	useEffect(() => {
		if (isDragging) {
			window.addEventListener("mousemove", handleMouseMove);
			window.addEventListener("mouseup", handleMouseUp);
		}
		return () => {
			window.removeEventListener("mousemove", handleMouseMove);
			window.removeEventListener("mouseup", handleMouseUp);
		};
	}, [isDragging, handleMouseMove, handleMouseUp]);

	// ===== INPUT HANDLERS =====
	// Click en el valor para habilitar edici√≥n
	const handleValueClick = (e) => {
		e.stopPropagation();
		if (!isDragging) {
			setIsEditing(true);
			setInputValue(gap);
		}
	};

	// Enfocar el input cuando se activa la edici√≥n
	useEffect(() => {
		if (isEditing && inputRef.current) {
			inputRef.current.focus();
			inputRef.current.select();
		}
	}, [isEditing]);

	const handleInputChange = (e) => {
		setInputValue(e.target.value);
	};

	const confirmarValor = () => {
		const numValue = parseInt(inputValue, 10);
		if (!isNaN(numValue)) {
			const clampedGap = Math.max(minGap, Math.min(maxGap, numValue));
			onGapChange(clampedGap);
			setInputValue(clampedGap);
		} else {
			setInputValue(gap);
		}
		setIsEditing(false);
	};

	const handleInputBlur = () => {
		// Al perder foco (click fuera), confirmar valor y cerrar igual que Enter
		confirmarValor();
		setIsHovered(false);
	};

	const handleInputKeyDown = (e) => {
		if (e.key === "Enter") {
			e.preventDefault();
			confirmarValor();
			// Tambi√©n ocultar la barra de gap completamente
			setIsHovered(false);
		} else if (e.key === "Escape") {
			setInputValue(gap);
			setIsEditing(false);
			// Tambi√©n ocultar la barra de gap completamente
			setIsHovered(false);
		}
	};

	const isActive = isHovered || isDragging || isEditing;

	return (
		<div
			ref={containerRef}
			className={`gap-resizer ${isActive ? "gap-resizer--active" : ""}`}
			style={{ width: `${gap}px` }}
		>
			{/* Hitbox centrado directamente en el gap-resizer */}
			<div
				ref={hitboxRef}
				className="gap-resizer__hitbox"
				style={{ width: `${Math.min(30, gap)}px` }}
				onMouseEnter={() => setIsHovered(true)}
				onMouseLeave={() => !isDragging && !isEditing && setIsHovered(false)}
				onMouseDown={handleMouseDown}
				onDoubleClick={handleDoubleClick}
			/>

			{/* Handle visual (solo decorativo, los eventos van al hitbox) */}
			<div
				className={`gap-resizer__handle ${isDragging ? "gap-resizer__handle--dragging" : ""}`}
				title="Arrastra para ajustar el espaciado"
			>
				<div className="gap-resizer__line" />
				<div className="gap-resizer__circle" />
				<div className="gap-resizer__line" />
			</div>

			{isActive && (
				<div className="gap-resizer__input-container">
					{isEditing ? (
						<input
							ref={inputRef}
							type="number"
							className="gap-resizer__input"
							value={inputValue}
							onChange={handleInputChange}
							onBlur={handleInputBlur}
							onKeyDown={handleInputKeyDown}
							min={minGap}
							max={maxGap}
						/>
					) : (
						<span
							className="gap-resizer__value"
							onClick={handleValueClick}
							title="Click para editar"
						>
							{gap}px
						</span>
					)}
				</div>
			)}
		</div>
	);
};

export default GapResizer;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaTarjetas.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaTarjetas.jsx

import React, { useRef, useEffect, useState, useCallback } from "react";
import TarjetaAlimentador from "./TarjetaAlimentador.jsx";
import GapResizer from "./GapResizer.jsx";
import RowGapResizer from "./RowGapResizer.jsx";
import GrillaUnifilar from "./GrillaUnifilar.jsx";
import useGrillaUnifilar from "../../hooks/useGrillaUnifilar.js";
import useChispas from "../../hooks/useChispas.js";
import "./GrillaTarjetas.css";

// Breakpoint para desactivar los controles de gap en m√≥viles/tablets
const BREAKPOINT_MOBILE = 982;

// Gaps fijos para modo m√≥vil
const GAP_FIJO_MOBILE = 10;
const ROW_GAP_FIJO_MOBILE = 20;

/**
 * Verifica si un alimentador tiene la configuraci√≥n completa para hacer polling.
 * Requisitos:
 * - Al menos una zona (superior o inferior) con registrador_id definido
 * - intervalo_consulta_ms definido y > 0
 * - Al menos un box habilitado (enabled: true) con un √≠ndice v√°lido en una zona que tenga registrador
 */
const puedeHacerPolling = (alim) => {
	// 1. Verificar intervalo_consulta_ms
	if (!alim.intervalo_consulta_ms || alim.intervalo_consulta_ms <= 0) {
		return false;
	}

	// 2. Verificar card_design y zonas
	const cardDesign = alim.card_design || {};
	const superior = cardDesign.superior || {};
	const inferior = cardDesign.inferior || {};

	// 3. Verificar que haya al menos una zona con registrador_id
	const tieneRegistradorSuperior = !!superior.registrador_id;
	const tieneRegistradorInferior = !!inferior.registrador_id;

	// Compatibilidad con formato antiguo: registrador_id en ra√≠z
	const tieneRegistradorLegacy = !!alim.registrador_id;

	if (!tieneRegistradorSuperior && !tieneRegistradorInferior && !tieneRegistradorLegacy) {
		return false;
	}

	// 4. Verificar que haya al menos un box habilitado con √≠ndice v√°lido en una zona que tenga registrador
	const tieneBoxHabilitado = (boxes) => {
		return boxes.some((box) => {
			if (!box.enabled) return false;
			// El √≠ndice puede estar en 'indice' (formato modal) o 'registro' (formato normalizado)
			const indice = box.indice !== undefined ? box.indice : box.registro;
			// Considerar v√°lido si es un n√∫mero >= 0 o un string num√©rico no vac√≠o
			if (indice === null || indice === undefined || indice === "") {
				return false;
			}
			const numIndice = Number(indice);
			return Number.isFinite(numIndice) && numIndice >= 0;
		});
	};

	const boxesSuperior = superior.boxes || [];
	const boxesInferior = inferior.boxes || [];

	// Verificar si hay boxes habilitados en zonas que tienen registrador
	const superiorValido = tieneRegistradorSuperior && tieneBoxHabilitado(boxesSuperior);
	const inferiorValido = tieneRegistradorInferior && tieneBoxHabilitado(boxesInferior);
	// Compatibilidad legacy: si hay registrador en ra√≠z, cualquier box habilitado vale
	const legacyValido = tieneRegistradorLegacy && (tieneBoxHabilitado(boxesSuperior) || tieneBoxHabilitado(boxesInferior));

	return superiorValido || inferiorValido || legacyValido;
};

/**
 * Grilla de tarjetas de alimentadores.
 *
 * Estructura:
 * - El primer RowGapResizer controla la separaci√≥n del men√∫ (est√° fuera del grid)
 * - Las tarjetas se renderizan en un flex container con flex-wrap
 * - El row-gap del grid se controla via CSS
 * - Los RowGapResizers se posicionan con position: absolute sobre los espacios entre filas
 * - Cada tarjeta tiene un GapResizer a la derecha para controlar el espaciado horizontal
 * - Los GapResizers se ocultan durante drag & drop
 * - En pantallas peque√±as (< 982px) los controles de gap se desactivan y se usan valores fijos
 */
const GrillaTarjetas = ({
	alimentadores,
	lecturas,
	puestoId,
	workspaceId,             // ID del workspace para la grilla unifiliar
	elementoArrastrandoId,
	onAbrirConfiguracion,
	onAbrirHistorial,        // callback para abrir modal de historial
	onDragStart,
	onDragOver,
	onDrop,
	onDragEnd,
	onDropAlFinal,
	onAgregarNuevo,
	puedeAgregarNuevo = true, // si false, la card "Nuevo Registrador" est√° deshabilitada
	esObservador = false,    // si true, oculta el bot√≥n de estad√≠sticas
	estaMidiendo,
	obtenerTimestampInicio,
	obtenerContadorLecturas,
	// Gaps horizontales (entre tarjetas)
	obtenerGap,
	onGapChange,
	// Gaps verticales (entre filas)
	obtenerRowGap,
	onRowGapChange,
	// Skeleton card (opcional, se muestra mientras se guarda)
	skeletonCard = null,
	// Polling de lecturas
	estaPolling,              // (alimId) => boolean
	onPlayStopClick,          // (alimId) => void
	obtenerContadorPolling,   // (alimId) => number - contador de lecturas para animaci√≥n
	obtenerErrorPolling,      // (alimId) => { mensaje, timestamp } | null - error de lectura
	// Escala de tarjetas
	obtenerEscalaEfectiva,    // (alimId, puestoId) => number - escala efectiva considerando jerarqu√≠a
	onEscalaChange,           // (alimId, nuevaEscala) => void - callback para cambiar escala individual
	ESCALA_MIN = 0.5,
	ESCALA_MAX = 2.0,
}) => {
	const gridRef = useRef(null);
	// Posiciones Y de los espacios entre filas (para posicionar los RowGapResizers)
	const [posicionesEntreFilas, setPosicionesEntreFilas] = useState([]);
	// Mapa de filas por tarjeta para detectar cambios de fila
	const filasAnterioresRef = useRef({});
	// Snapshot de TODOS los gaps cuando se detecta un cambio de layout por resize
	// Se guarda una vez y se restaura cuando se vuelve a la configuraci√≥n original
	const snapshotGapsRef = useRef(null);
	// N√∫mero de filas en el snapshot (para saber cu√°ndo restaurar)
	const numFilasSnapshotRef = useRef(null);
	// Estado para detectar si estamos en modo m√≥vil (< 982px)
	const [esModoMobile, setEsModoMobile] = useState(() =>
		typeof window !== 'undefined' ? window.innerWidth < BREAKPOINT_MOBILE : false
	);

	// Mapa de fila por tarjeta (para aplicar margin-top individual)
	const [filasPorTarjeta, setFilasPorTarjeta] = useState({});
	// Primera tarjeta de cada fila (para saber d√≥nde poner el RowGapResizer)
	const [primerasTarjetasPorFila, setPrimerasTarjetasPorFila] = useState({});

	// Hook para la grilla unifiliar (dibujo de diagramas)
	const grillaUnifilar = useGrillaUnifilar(puestoId, workspaceId);

	// Hook para animaci√≥n de chispas
	const chispasHook = useChispas({
		bornes: grillaUnifilar.bornes,
		celdas: grillaUnifilar.celdas,
		chispasConfig: grillaUnifilar.chispasConfig,
		grosorLinea: grillaUnifilar.grosorLinea,
	});

	// Detectar las posiciones entre filas y manejar gaps de tarjetas que cambian de fila
	const detectarFilasYFinales = useCallback(() => {
		if (!gridRef.current) return;

		const nuevasPosiciones = [];
		const nuevasFilasPorTarjeta = {};
		const nuevasPrimerasPorFila = {}; // { filaIndex: alimId }
		let ultimoLeft = null;
		let ultimoBottom = null;
		let filaIndex = 0;

		// Incluir todos los wrappers de alimentadores y la tarjeta "Nuevo Registrador"
		const tarjetas = Array.from(gridRef.current.querySelectorAll('.alim-card-wrapper, .alim-card-add'));
		const gridRect = gridRef.current.getBoundingClientRect();

		tarjetas.forEach((wrapper, index) => {
			const alimId = wrapper.dataset.alimId || 'nuevo-registrador';
			const rect = wrapper.getBoundingClientRect();

			// Detectar cambio de fila: si esta tarjeta est√° m√°s a la izquierda que la anterior,
			// significa que salt√≥ a una nueva fila (flex-wrap)
			// Usamos left en lugar de top porque top se ve afectado por margin-top
			if (ultimoLeft !== null && rect.left < ultimoLeft) {
				// Guardar la posici√≥n Y entre filas (relativa al grid)
				const posY = ultimoBottom - gridRect.top;
				nuevasPosiciones.push({
					filaIndex: filaIndex + 1,
					top: posY
				});
				filaIndex++;
				// Esta tarjeta es la primera de la nueva fila
				nuevasPrimerasPorFila[filaIndex] = alimId;
			} else if (index === 0) {
				// La primera tarjeta es la primera de la fila 0
				nuevasPrimerasPorFila[0] = alimId;
			}

			// Guardar en qu√© fila est√° cada tarjeta
			nuevasFilasPorTarjeta[alimId] = filaIndex;

			ultimoLeft = rect.left;
			ultimoBottom = rect.bottom;
		});

		const numFilasActual = filaIndex + 1; // N√∫mero total de filas
		const filasAnteriores = filasAnterioresRef.current;
		const numFilasAnterior = Object.keys(filasAnteriores).length > 0
			? Math.max(...Object.values(filasAnteriores)) + 1
			: numFilasActual;

		// Detectar si aument√≥ el n√∫mero de filas (se achic√≥ la pantalla)
		if (numFilasActual > numFilasAnterior) {
			// Si no hay snapshot, guardar todos los gaps actuales
			if (snapshotGapsRef.current === null) {
				const snapshot = {};
				alimentadores.forEach((alim) => {
					snapshot[alim.id] = obtenerGap(alim.id);
				});
				snapshotGapsRef.current = snapshot;
				numFilasSnapshotRef.current = numFilasAnterior;
			}

			// Resetear gaps de tarjetas que bajaron de fila
			Object.keys(nuevasFilasPorTarjeta).forEach((alimId) => {
				if (alimId === 'nuevo-registrador') return;
				const filaAnterior = filasAnteriores[alimId];
				const filaNueva = nuevasFilasPorTarjeta[alimId];

				if (filaAnterior !== undefined && filaNueva > filaAnterior) {
					onGapChange(alimId, 10);
				}
			});
		}
		// Detectar si disminuy√≥ el n√∫mero de filas (se ensanch√≥ la pantalla)
		else if (numFilasActual < numFilasAnterior) {
			// Si volvimos al n√∫mero de filas del snapshot (o menos), restaurar todos los gaps
			if (snapshotGapsRef.current !== null && numFilasActual <= numFilasSnapshotRef.current) {
				Object.keys(snapshotGapsRef.current).forEach((alimId) => {
					onGapChange(alimId, snapshotGapsRef.current[alimId]);
				});
				// Limpiar el snapshot
				snapshotGapsRef.current = null;
				numFilasSnapshotRef.current = null;
			}
		}

		// Actualizar referencia de filas anteriores
		filasAnterioresRef.current = nuevasFilasPorTarjeta;

		// Solo actualizar posiciones si realmente cambi√≥
		const posicionesStr = JSON.stringify(nuevasPosiciones);
		setPosicionesEntreFilas(prev => {
			const prevStr = JSON.stringify(prev);
			if (prevStr !== posicionesStr) {
				return nuevasPosiciones;
			}
			return prev;
		});

		// Actualizar mapa de filas por tarjeta
		const filasStr = JSON.stringify(nuevasFilasPorTarjeta);
		setFilasPorTarjeta(prev => {
			if (JSON.stringify(prev) !== filasStr) {
				return nuevasFilasPorTarjeta;
			}
			return prev;
		});

		// Actualizar primeras tarjetas por fila
		const primerasStr = JSON.stringify(nuevasPrimerasPorFila);
		setPrimerasTarjetasPorFila(prev => {
			if (JSON.stringify(prev) !== primerasStr) {
				return nuevasPrimerasPorFila;
			}
			return prev;
		});
	}, [onGapChange, obtenerGap, alimentadores]);

	// Ejecutar detecci√≥n despu√©s del primer render y cuando cambian dependencias
	useEffect(() => {
		const raf = requestAnimationFrame(() => {
			detectarFilasYFinales();
		});
		return () => cancelAnimationFrame(raf);
	}, [alimentadores, detectarFilasYFinales]);

	// Re-detectar en resize
	useEffect(() => {
		const handleResize = () => {
			requestAnimationFrame(detectarFilasYFinales);
		};

		window.addEventListener('resize', handleResize);

		// ResizeObserver para el grid
		const resizeObserver = new ResizeObserver(() => {
			requestAnimationFrame(detectarFilasYFinales);
		});

		if (gridRef.current) {
			resizeObserver.observe(gridRef.current);
		}

		return () => {
			window.removeEventListener('resize', handleResize);
			resizeObserver.disconnect();
		};
	}, [detectarFilasYFinales]);

	// Re-detectar cuando cambian los row gaps o el puesto seleccionado
	useEffect(() => {
		const timer = setTimeout(() => {
			requestAnimationFrame(detectarFilasYFinales);
		}, 50);
		return () => clearTimeout(timer);
	}, [obtenerRowGap, puestoId, detectarFilasYFinales]);

	// Detectar modo m√≥vil al cambiar el tama√±o de ventana
	useEffect(() => {
		const handleResize = () => {
			const nuevoEsMobile = window.innerWidth < BREAKPOINT_MOBILE;
			setEsModoMobile(nuevoEsMobile);
		};

		window.addEventListener('resize', handleResize);
		return () => window.removeEventListener('resize', handleResize);
	}, []);

	// En modo m√≥vil, usar gaps fijos; en desktop, usar los configurados (con puestoId)
	const rowGapPrimero = esModoMobile ? ROW_GAP_FIJO_MOBILE : obtenerRowGap(puestoId, 0);

	// Funci√≥n para obtener el margin-top de una tarjeta seg√∫n su fila
	const obtenerMarginTop = (alimId) => {
		const fila = filasPorTarjeta[alimId];
		if (fila === undefined || fila === 0) return 0; // Primera fila no tiene margin
		// Buscar si esta tarjeta es la primera de su fila
		if (primerasTarjetasPorFila[fila] === alimId) {
			return esModoMobile ? ROW_GAP_FIJO_MOBILE : obtenerRowGap(puestoId, fila);
		}
		return esModoMobile ? ROW_GAP_FIJO_MOBILE : obtenerRowGap(puestoId, fila);
	};

	return (
		<div className="grilla-con-row-gaps">
			{/* Grilla unifiliar para dibujar diagramas - solo en desktop (no m√≥viles/tablets) */}
			{!esModoMobile && (
				<GrillaUnifilar
					celdas={grillaUnifilar.celdas}
					textos={grillaUnifilar.textos}
					modoEdicion={grillaUnifilar.modoEdicion}
					colorSeleccionado={grillaUnifilar.colorSeleccionado}
					herramienta={grillaUnifilar.herramienta}
					estaPintando={grillaUnifilar.estaPintando}
					coloresDisponibles={grillaUnifilar.coloresDisponibles}
					fuentesDisponibles={grillaUnifilar.fuentesDisponibles}
					tamanosDisponibles={grillaUnifilar.tamanosDisponibles}
					grosoresDisponibles={grillaUnifilar.grosoresDisponibles}
					grosorLinea={grillaUnifilar.grosorLinea}
					onCambiarGrosor={grillaUnifilar.cambiarGrosor}
					configTexto={grillaUnifilar.configTexto}
					onConfigTextoChange={grillaUnifilar.setConfigTexto}
					textoSeleccionadoId={grillaUnifilar.textoSeleccionadoId}
					onTextoSeleccionadoChange={grillaUnifilar.setTextoSeleccionadoId}
					onPintarCelda={grillaUnifilar.pintarCelda}
					onIniciarPintado={grillaUnifilar.iniciarPintado}
					onDetenerPintado={grillaUnifilar.detenerPintado}
					onCambiarColor={grillaUnifilar.setColorSeleccionado}
					onSeleccionarPincel={grillaUnifilar.seleccionarPincel}
					onSeleccionarBorrador={grillaUnifilar.seleccionarBorrador}
					onSeleccionarTexto={grillaUnifilar.seleccionarTexto}
					onSeleccionarBalde={grillaUnifilar.seleccionarBalde}
					onSeleccionarMover={grillaUnifilar.seleccionarMover}
					onRellenarConectadas={grillaUnifilar.rellenarConectadas}
					onBorrarArea={grillaUnifilar.borrarArea}
					onObtenerCeldasConectadas={grillaUnifilar.obtenerCeldasConectadas}
					onMoverCeldasConectadas={grillaUnifilar.moverCeldasConectadas}
					onAgregarTexto={grillaUnifilar.agregarTexto}
					onActualizarTexto={grillaUnifilar.actualizarTexto}
					onEliminarTexto={grillaUnifilar.eliminarTexto}
					onLimpiarTodo={grillaUnifilar.limpiarTodo}
					onCerrarEdicion={grillaUnifilar.desactivarEdicion}
					// === SISTEMA DE BORNES Y CHISPAS ===
					bornes={grillaUnifilar.bornes}
					chispasConfig={grillaUnifilar.chispasConfig}
					tiposBorne={grillaUnifilar.tiposBorne}
					onSeleccionarBorne={grillaUnifilar.seleccionarBorne}
					onAgregarBorne={grillaUnifilar.agregarBorne}
					onEliminarBorneEnPosicion={grillaUnifilar.eliminarBorneEnPosicion}
					onActualizarChispasConfig={grillaUnifilar.actualizarChispasConfig}
					// Estado y control de animaci√≥n de chispas
					animandoChispas={chispasHook.animando}
					onToggleAnimacionChispas={chispasHook.toggleAnimacion}
					chispasRef={chispasHook.chispasRef}
					onObtenerPosicionPixelChispa={chispasHook.obtenerPosicionPixel}
					onObtenerEstelaPixeles={chispasHook.obtenerEstelaPixeles}
				/>
			)}

			{/* Bot√≥n flotante para activar/desactivar modo edici√≥n de diagrama - solo en desktop */}
			{!esModoMobile && !grillaUnifilar.modoEdicion && (
				<button
					type="button"
					className="grilla-btn-editar-diagrama"
					onClick={grillaUnifilar.activarEdicion}
					title="Editar diagrama unifiliar"
				>
					<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
						<path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.996.996 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
					</svg>
				</button>
			)}

			{/* Botones flotantes para guardar/cargar diagrama - solo en modo edici√≥n y desktop */}
			{!esModoMobile && grillaUnifilar.modoEdicion && (
				<div className="grilla-btns-archivo">
					{/* Bot√≥n guardar (arriba) */}
					<button
						type="button"
						className="grilla-btn-archivo grilla-btn-archivo--guardar"
						onClick={grillaUnifilar.exportarAArchivo}
						title="Guardar diagrama a archivo"
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
							<path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
						</svg>
					</button>
					{/* Bot√≥n abrir (abajo) */}
					<label
						className="grilla-btn-archivo grilla-btn-archivo--abrir"
						title="Cargar diagrama desde archivo"
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
							<path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/>
						</svg>
						<input
							type="file"
							accept=".json"
							style={{ display: "none" }}
							onChange={async (e) => {
								const archivo = e.target.files?.[0];
								if (archivo) {
									const exito = await grillaUnifilar.importarDesdeArchivo(archivo);
									if (!exito) {
										alert("Error al cargar el archivo. Verifica que sea un archivo JSON v√°lido.");
									}
								}
								e.target.value = "";
							}}
						/>
					</label>
				</div>
			)}

			{/* RowGapResizer para la primera fila (separaci√≥n del men√∫) - solo en desktop */}
			{!elementoArrastrandoId && !esModoMobile && (
				<RowGapResizer
					gap={obtenerRowGap(puestoId, 0)}
					onGapChange={(nuevoGap) => onRowGapChange(puestoId, 0, nuevoGap)}
					rowIndex={0}
				/>
			)}
			{/* Spacer fijo durante drag o en modo m√≥vil */}
			{(elementoArrastrandoId || esModoMobile) && (
				<div style={{ height: rowGapPrimero }} />
			)}

			{/* Mensaje cuando no hay alimentadores */}
			{alimentadores.length === 0 && (
				<p className="alim-empty-message">
					Este puesto no tiene alimentadores. Haz clic en el bot√≥n de abajo para agregar.
				</p>
			)}

			<div
				ref={gridRef}
				className="alim-cards-grid"
			>
				{alimentadores.map((alim) => {
					const lecturasAlim = lecturas[alim.id] || {};
					const mideRele = estaMidiendo(alim.id, "rele");
					const mideAnalizador = estaMidiendo(alim.id, "analizador");
					const gapTarjeta = obtenerGap(alim.id);
					const marginTop = obtenerMarginTop(alim.id);

					return (
						<React.Fragment key={alim.id}>
							{/* Tarjeta del alimentador */}
							<div
								className="alim-card-wrapper"
								data-alim-id={alim.id}
								style={{ marginTop: marginTop > 0 ? `${marginTop}px` : undefined }}
							>
								<TarjetaAlimentador
									nombre={alim.nombre}
									color={alim.color}
									onConfigClick={() => onAbrirConfiguracion(puestoId, alim)}
									onHistorialClick={onAbrirHistorial ? () => onAbrirHistorial(puestoId, alim) : undefined}
									esObservador={esObservador}
									topSide={lecturasAlim.parteSuperior}
									bottomSide={lecturasAlim.parteInferior}
									draggable={true}
									isDragging={elementoArrastrandoId === alim.id}
									onDragStart={() => onDragStart(alim.id)}
									onDragOver={onDragOver}
									onDrop={(e) => {
										e.preventDefault();
										onDrop(alim.id);
									}}
									onDragEnd={onDragEnd}
									mideRele={mideRele}
									mideAnalizador={mideAnalizador}
									periodoRele={alim.periodoSegundos || 60}
									periodoAnalizador={alim.analizador?.periodoSegundos || 60}
									timestampInicioRele={obtenerTimestampInicio(alim.id, "rele")}
									timestampInicioAnalizador={obtenerTimestampInicio(alim.id, "analizador")}
									contadorRele={obtenerContadorLecturas(alim.id, "rele")}
									contadorAnalizador={obtenerContadorLecturas(alim.id, "analizador")}
									// Polling de lecturas
									estaPolling={estaPolling ? estaPolling(alim.id) : false}
									puedePolling={puedeHacerPolling(alim)}
									onPlayStopClick={() => onPlayStopClick && onPlayStopClick(alim.id)}
									contadorPolling={obtenerContadorPolling ? obtenerContadorPolling(alim.id) : 0}
									periodoPolling={(alim.intervalo_consulta_ms || 60000) / 1000}
									errorPolling={obtenerErrorPolling ? obtenerErrorPolling(alim.id) : null}
									// Escala de tarjetas
									// En modo m√≥vil, la escala es fija en 1 y no se puede cambiar (no se pasa onEscalaChange)
									escala={obtenerEscalaEfectiva ? obtenerEscalaEfectiva(alim.id, puestoId) : 1.0}
									onEscalaChange={!esModoMobile && onEscalaChange ? (nuevaEscala) => onEscalaChange(alim.id, nuevaEscala) : undefined}
									ESCALA_MIN={ESCALA_MIN}
									ESCALA_MAX={ESCALA_MAX}
								/>
							</div>
							{/* GapResizer a la derecha de cada tarjeta (elemento hermano independiente) */}
							{/* Usa el mismo marginTop que la tarjeta para alinearse verticalmente */}
							{!elementoArrastrandoId && !esModoMobile ? (
								<div style={{ marginTop: marginTop > 0 ? `${marginTop}px` : undefined }}>
									<GapResizer
										gap={gapTarjeta}
										onGapChange={(nuevoGap) => onGapChange(alim.id, nuevoGap)}
									/>
								</div>
							) : (
								<div className="gap-spacer" style={{ width: esModoMobile ? GAP_FIJO_MOBILE : gapTarjeta, marginTop: marginTop > 0 ? `${marginTop}px` : undefined }} />
							)}
						</React.Fragment>
					);
				})}

				{/* Skeleton card (se muestra mientras se guarda un nuevo alimentador) */}
				{skeletonCard && (() => {
					const marginTopSkeleton = obtenerMarginTop('nuevo-registrador');
					return (
						<React.Fragment>
							<div
								className="alim-card-wrapper"
								data-alim-id="skeleton"
								style={{ marginTop: marginTopSkeleton > 0 ? `${marginTopSkeleton}px` : undefined }}
							>
								{skeletonCard}
							</div>
							{/* Gap despu√©s del skeleton */}
							<div className="gap-spacer" style={{ width: esModoMobile ? GAP_FIJO_MOBILE : 10 }} />
						</React.Fragment>
					);
				})()}

				{/* Tarjeta "Nuevo Registrador" o zona de drop */}
				{/* Solo se muestra si: est√° arrastrando (zona de drop) O tiene permisos para agregar */}
				{(elementoArrastrandoId || puedeAgregarNuevo) && (() => {
					const marginTopNuevo = obtenerMarginTop('nuevo-registrador');
					const styleNuevo = {
						width: 304, minWidth: 304, maxWidth: 304, height: 279, minHeight: 279,
						...(marginTopNuevo > 0 && { marginTop: `${marginTopNuevo}px` })
					};

					return elementoArrastrandoId ? (
						<div
							className="alim-card-add"
							style={styleNuevo}
							onDragOver={onDragOver}
							onDrop={(e) => {
								e.preventDefault();
								onDropAlFinal();
							}}
						>
							<span style={{ textAlign: "center", padding: "1rem" }}>
								Soltar aqu√≠ para mover al final
							</span>
						</div>
					) : (
						<div
							className="alim-card-add"
							style={styleNuevo}
							onClick={onAgregarNuevo}
						>
							<span className="alim-card-add-plus">+</span>
							<span className="alim-card-add-text">Nuevo Registrador</span>
						</div>
					);
				})()}

				{/* RowGapResizers posicionados absolutamente sobre los espacios entre filas - solo en desktop */}
				{!elementoArrastrandoId && !esModoMobile && posicionesEntreFilas.map((pos) => (
					<div
						key={`row-gap-${pos.filaIndex}`}
						className="row-gap-resizer-overlay"
						style={{ top: `${pos.top}px` }}
					>
						<RowGapResizer
							gap={obtenerRowGap(puestoId, pos.filaIndex)}
							onGapChange={(nuevoGap) => onRowGapChange(puestoId, pos.filaIndex, nuevoGap)}
							rowIndex={pos.filaIndex}
						/>
					</div>
				))}
			</div>
		</div>
	);
};

export default GrillaTarjetas;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaUnifilar.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaUnifilar.jsx

import React, { useRef, useEffect, useCallback, useState } from "react";
import ColorPickerSimple from "../modales/ColorPickerSimple";
import "./GrillaUnifilar.css";

/**
 * Componente de grilla unifiliar para dibujar diagramas
 *
 * Funciona en dos modos:
 * - Modo edici√≥n: grilla visible al frente, permite dibujar
 * - Modo normal: solo muestra el dibujo como fondo transparente
 */
const GrillaUnifilar = ({
	// Estado de las celdas pintadas
	celdas,
	// Textos agregados
	textos = [],
	// ¬øEst√° en modo edici√≥n?
	modoEdicion,
	// Color seleccionado para pintar
	colorSeleccionado,
	// Herramienta activa: "pincel", "borrador", "texto", "balde", "mover" o "borne"
	herramienta,
	// ¬øEst√° pintando? (mouse presionado)
	estaPintando,
	// Colores disponibles
	coloresDisponibles,
	// Fuentes y tama√±os disponibles
	fuentesDisponibles = [],
	tamanosDisponibles = [],
	// Grosores de l√≠nea
	grosoresDisponibles = [],
	grosorLinea = 12,
	onCambiarGrosor,
	// Configuraci√≥n de texto actual
	configTexto = {},
	onConfigTextoChange,
	// Texto seleccionado
	textoSeleccionadoId,
	onTextoSeleccionadoChange,
	// Callbacks
	onPintarCelda,
	onIniciarPintado,
	onDetenerPintado,
	onCambiarColor,
	onSeleccionarPincel,
	onSeleccionarBorrador,
	onSeleccionarTexto,
	onSeleccionarBalde,
	onSeleccionarMover,
	onSeleccionarBorne,
	onRellenarConectadas,
	onBorrarArea,
	onObtenerCeldasConectadas,
	onMoverCeldasConectadas,
	onAgregarTexto,
	onActualizarTexto,
	onEliminarTexto,
	onLimpiarTodo,
	onCerrarEdicion,
	// === SISTEMA DE BORNES Y CHISPAS ===
	bornes = [],
	chispasConfig = {},
	tiposBorne = {},
	onAgregarBorne,
	onEliminarBorneEnPosicion,
	onActualizarChispasConfig,
	// Estado de animaci√≥n de chispas (controlado externamente)
	animandoChispas = false,
	onToggleAnimacionChispas,
	// Ref a chispas activas (mutable, no causa re-renders)
	chispasRef: chispasRefProp,
	onObtenerPosicionPixelChispa,
	onObtenerEstelaPixeles,
}) => {
	const canvasRef = useRef(null);
	const canvasChispasRef = useRef(null); // Canvas separado para chispas
	const contenedorRef = useRef(null);
	const [dimensiones, setDimensiones] = useState({ ancho: 0, alto: 0 });
	const chispasAnimationRef = useRef(null); // Ref para el loop de animaci√≥n de chispas
	// Refs para acceder a valores actuales en el loop de animaci√≥n sin re-renderizar
	const chispasPropsRef = useRef({ onObtenerPosicionPixelChispa, onObtenerEstelaPixeles });
	// Estado para el input de texto (nuevo o edici√≥n)
	// valorOriginal guarda el texto antes de editar para poder descartarlo
	const [inputTexto, setInputTexto] = useState({ visible: false, x: 0, y: 0, valor: "", editandoId: null, ancho: 220, alto: 55, valorOriginal: "" });
	// Estado para redimensionar el textarea
	const [redimensionando, setRedimensionando] = useState({ activo: false, handle: null, inicioX: 0, inicioY: 0, anchoInicial: 0, altoInicial: 0 });
	const textareaRef = useRef(null);
	// Estado para saber si Shift est√° presionado
	const [shiftPresionado, setShiftPresionado] = useState(false);
	// Estado para arrastrar texto
	const [arrastrando, setArrastrando] = useState({ activo: false, textoId: null, offsetX: 0, offsetY: 0 });
	// Estado para arrastrar l√≠neas conectadas
	const [arrastrandoLineas, setArrastrandoLineas] = useState({
		activo: false,
		celdasConectadas: [],    // Array de claves "x,y" de las celdas conectadas
		celdaInicialX: 0,        // Celda donde se hizo click inicial
		celdaInicialY: 0,
		ultimaCeldaX: 0,         // √öltima celda donde estaba el mouse (para calcular delta)
		ultimaCeldaY: 0,
	});
	// Estado para saber si el mouse est√° sobre un texto (para cambiar cursor)
	const [sobreTexto, setSobreTexto] = useState(false);
	// Estado para saber si el mouse est√° sobre una l√≠nea (para cambiar cursor)
	const [sobreLinea, setSobreLinea] = useState(false);
	// Estado para modo gotero (eyedropper)
	const [modoGotero, setModoGotero] = useState(false);
	// Estado para selecci√≥n de √°rea del borrador (como en Paint)
	const [areaBorrador, setAreaBorrador] = useState({
		activo: false,
		inicioX: 0,      // Coordenada de celda inicial X
		inicioY: 0,      // Coordenada de celda inicial Y
		actualX: 0,      // Coordenada de celda actual X
		actualY: 0,      // Coordenada de celda actual Y
	});
	// Estado para texto copiado (portapapeles interno)
	const [textoCopiado, setTextoCopiado] = useState(null);
	// === ESTADOS PARA BORNES Y CHISPAS ===
	// Tipo de borne a colocar cuando herramienta es "borne"
	const [tipoBorneActivo, setTipoBorneActivo] = useState("EMISOR");
	// Panel de configuraci√≥n de chispas visible
	const [panelChispasVisible, setPanelChispasVisible] = useState(false);
	// Estado para men√∫ contextual
	const [menuContextual, setMenuContextual] = useState({
		visible: false,
		x: 0,
		y: 0,
		pixelX: 0,  // Posici√≥n en p√≠xeles donde pegar
		pixelY: 0,
		hayTextoEnPosicion: false,  // Si hay un texto donde se hizo click
	});
	// Posici√≥n actual del mouse (para pegar en la posici√≥n correcta)
	const posicionMouseRef = useRef({ x: 0, y: 0 });

	/**
	 * Detectar teclas Shift, Delete, Ctrl+C y Ctrl+V
	 */
	useEffect(() => {
		const handleKeyDown = (e) => {
			if (e.key === "Shift") {
				setShiftPresionado(true);
			}
			// Delete o Backspace para eliminar texto seleccionado
			if ((e.key === "Delete" || e.key === "Backspace") && textoSeleccionadoId && herramienta === "texto" && !inputTexto.visible) {
				e.preventDefault();
				onEliminarTexto?.(textoSeleccionadoId);
			}
			// Ctrl+C para copiar texto seleccionado
			if (e.ctrlKey && e.key === "c" && textoSeleccionadoId && herramienta === "texto" && modoEdicion && !inputTexto.visible) {
				e.preventDefault();
				const textoACopiar = textos.find(t => t.id === textoSeleccionadoId);
				if (textoACopiar) {
					setTextoCopiado({ ...textoACopiar });
				}
			}
			// Ctrl+V para pegar texto
			if (e.ctrlKey && e.key === "v" && textoCopiado && herramienta === "texto" && modoEdicion && !inputTexto.visible) {
				e.preventDefault();
				// Pegar en la posici√≥n actual del mouse
				const nuevoTexto = {
					...textoCopiado,
					id: `texto-${Date.now()}`,
					x: posicionMouseRef.current.x,
					y: posicionMouseRef.current.y,
				};
				onAgregarTexto?.(nuevoTexto.x, nuevoTexto.y, nuevoTexto.texto);
				// Actualizar el texto reci√©n pegado con los estilos del copiado
				setTimeout(() => {
					// Buscar el √∫ltimo texto agregado y actualizarlo con los estilos
					const ultimoTexto = textos[textos.length - 1];
					if (ultimoTexto) {
						onActualizarTexto?.(ultimoTexto.id, {
							color: textoCopiado.color,
							fuente: textoCopiado.fuente,
							tamano: textoCopiado.tamano,
							negrita: textoCopiado.negrita,
							cursiva: textoCopiado.cursiva,
						});
					}
				}, 50);
			}
		};
		const handleKeyUp = (e) => {
			if (e.key === "Shift") {
				setShiftPresionado(false);
			}
		};

		window.addEventListener("keydown", handleKeyDown);
		window.addEventListener("keyup", handleKeyUp);

		return () => {
			window.removeEventListener("keydown", handleKeyDown);
			window.removeEventListener("keyup", handleKeyUp);
		};
	}, [textoSeleccionadoId, herramienta, inputTexto.visible, onEliminarTexto, textos, textoCopiado, modoEdicion, onAgregarTexto, onActualizarTexto]);

	/**
	 * Calcular dimensiones - siempre usa el contenedor padre (para que las coordenadas coincidan)
	 */
	useEffect(() => {
		let resizeObserver = null;
		let timer = null;

		const actualizarDimensiones = () => {
			if (!contenedorRef.current) return;

			// Obtener el contenedor padre (.grilla-con-row-gaps)
			const padre = contenedorRef.current.parentElement;
			if (!padre) return;

			const rect = padre.getBoundingClientRect();
			if (rect.width > 0 && rect.height > 0) {
				setDimensiones({
					ancho: rect.width,
					alto: rect.height
				});
			}
		};

		// Esperar un frame para que el CSS se aplique
		requestAnimationFrame(actualizarDimensiones);

		// Tambi√©n actualizar despu√©s de peque√±os delays para asegurar que las dimensiones sean correctas
		timer = setTimeout(actualizarDimensiones, 50);
		const timer2 = setTimeout(actualizarDimensiones, 150);

		// Observar cambios de tama√±o del contenedor
		resizeObserver = new ResizeObserver(actualizarDimensiones);
		if (contenedorRef.current?.parentElement) {
			resizeObserver.observe(contenedorRef.current.parentElement);
		}

		window.addEventListener("resize", actualizarDimensiones);

		return () => {
			clearTimeout(timer);
			clearTimeout(timer2);
			if (resizeObserver) resizeObserver.disconnect();
			window.removeEventListener("resize", actualizarDimensiones);
		};
	}, [modoEdicion]); // Re-calcular cuando cambia el modo

	/**
	 * Dibujar el canvas
	 */
	useEffect(() => {
		const canvas = canvasRef.current;
		if (!canvas || dimensiones.ancho === 0) return;

		const ctx = canvas.getContext("2d");
		const { ancho, alto } = dimensiones;

		// Ajustar tama√±o del canvas
		canvas.width = ancho;
		canvas.height = alto;

		// Limpiar canvas
		ctx.clearRect(0, 0, ancho, alto);

		// Dibujar grilla solo en modo edici√≥n
		if (modoEdicion) {
			ctx.strokeStyle = "rgba(148, 163, 184, 0.5)"; // Color m√°s visible
			ctx.lineWidth = 1;

			// L√≠neas verticales
			for (let x = 0; x <= ancho; x += grosorLinea) {
				ctx.beginPath();
				ctx.moveTo(x + 0.5, 0); // +0.5 para l√≠neas m√°s n√≠tidas
				ctx.lineTo(x + 0.5, alto);
				ctx.stroke();
			}

			// L√≠neas horizontales
			for (let y = 0; y <= alto; y += grosorLinea) {
				ctx.beginPath();
				ctx.moveTo(0, y + 0.5); // +0.5 para l√≠neas m√°s n√≠tidas
				ctx.lineTo(ancho, y + 0.5);
				ctx.stroke();
			}
		}

		// Dibujar celdas pintadas
		Object.entries(celdas).forEach(([clave, color]) => {
			const [x, y] = clave.split(",").map(Number);
			ctx.fillStyle = color;
			ctx.fillRect(
				x * grosorLinea,
				y * grosorLinea,
				grosorLinea,
				grosorLinea
			);
		});

		// Dibujar textos (con soporte multil√≠nea)
		textos.forEach((t) => {
			const fontStyle = `${t.cursiva ? "italic " : ""}${t.negrita ? "bold " : ""}${t.tamano}px ${t.fuente}`;
			ctx.font = fontStyle;
			ctx.fillStyle = t.color;
			ctx.textBaseline = "top";

			// Dividir texto en l√≠neas
			const lineas = t.texto.split("\n");
			const alturaLinea = t.tamano * 1.2; // 1.2 de line-height
			let anchoMaximo = 0;

			// Dibujar cada l√≠nea
			lineas.forEach((linea, index) => {
				ctx.fillText(linea, t.x, t.y + index * alturaLinea);
				const anchoLinea = ctx.measureText(linea).width;
				if (anchoLinea > anchoMaximo) anchoMaximo = anchoLinea;
			});

			// Si est√° seleccionado, dibujar borde
			if (modoEdicion && textoSeleccionadoId === t.id) {
				const alturaTotal = lineas.length * alturaLinea;
				ctx.strokeStyle = "#22d3ee";
				ctx.lineWidth = 2;
				ctx.setLineDash([4, 2]);
				ctx.strokeRect(t.x - 2, t.y - 2, anchoMaximo + 4, alturaTotal + 4);
				ctx.setLineDash([]);
			}
		});

		// Dibujar bornes
		bornes.forEach((borne) => {
			const centroX = borne.x * grosorLinea + grosorLinea / 2;
			const centroY = borne.y * grosorLinea + grosorLinea / 2;
			const radio = grosorLinea * 0.8;

			// C√≠rculo exterior con borde
			ctx.beginPath();
			ctx.arc(centroX, centroY, radio, 0, Math.PI * 2);
			ctx.fillStyle = borne.color;
			ctx.fill();
			ctx.strokeStyle = borne.tipo === "EMISOR" ? "#0ea5e9" : "#ea580c";
			ctx.lineWidth = 2;
			ctx.stroke();

			// Letra E o R en el centro
			ctx.font = `bold ${grosorLinea * 0.7}px sans-serif`;
			ctx.fillStyle = "#ffffff";
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.fillText(borne.tipo === "EMISOR" ? "E" : "R", centroX, centroY);
		});

		// NOTA: Las chispas ahora se dibujan en un canvas separado (canvasChispasRef)
		// para evitar redibujar todo el canvas 60 veces por segundo

		// Dibujar rect√°ngulo de selecci√≥n del borrador (si est√° activo)
		if (areaBorrador.activo) {
			const minX = Math.min(areaBorrador.inicioX, areaBorrador.actualX);
			const maxX = Math.max(areaBorrador.inicioX, areaBorrador.actualX);
			const minY = Math.min(areaBorrador.inicioY, areaBorrador.actualY);
			const maxY = Math.max(areaBorrador.inicioY, areaBorrador.actualY);

			const rectX = minX * grosorLinea;
			const rectY = minY * grosorLinea;
			const rectW = (maxX - minX + 1) * grosorLinea;
			const rectH = (maxY - minY + 1) * grosorLinea;

			// Fondo semitransparente rojo
			ctx.fillStyle = "rgba(239, 68, 68, 0.25)";
			ctx.fillRect(rectX, rectY, rectW, rectH);

			// Borde rojo punteado
			ctx.strokeStyle = "#ef4444";
			ctx.lineWidth = 2;
			ctx.setLineDash([6, 3]);
			ctx.strokeRect(rectX, rectY, rectW, rectH);
			ctx.setLineDash([]);
		}
	}, [celdas, textos, modoEdicion, dimensiones, textoSeleccionadoId, grosorLinea, areaBorrador, bornes]);

	// Mantener ref actualizado con los props de chispas
	useEffect(() => {
		chispasPropsRef.current = { onObtenerPosicionPixelChispa, onObtenerEstelaPixeles };
	}, [onObtenerPosicionPixelChispa, onObtenerEstelaPixeles]);

	/**
	 * Canvas separado para chispas - usa requestAnimationFrame independiente
	 * Esto evita redibujar todo el canvas principal 60 veces por segundo
	 */
	useEffect(() => {
		const canvasChispas = canvasChispasRef.current;
		if (!canvasChispas || dimensiones.ancho === 0) return;

		// Ajustar tama√±o del canvas de chispas
		canvasChispas.width = dimensiones.ancho;
		canvasChispas.height = dimensiones.alto;

		const ctx = canvasChispas.getContext("2d");

		// Configuraci√≥n de chispas
		const colorChispa = chispasConfig.color || "#fef08a";
		const tamanoChispa = chispasConfig.tamano || 4;
		const mostrarEstela = chispasConfig.estela !== false;
		const formaChispa = chispasConfig.forma || "circulo";

		// Convertir color hex a RGB
		const hexToRgb = (hex) => {
			const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
			return result ? {
				r: parseInt(result[1], 16),
				g: parseInt(result[2], 16),
				b: parseInt(result[3], 16)
			} : { r: 254, g: 240, b: 138 };
		};
		const rgb = hexToRgb(colorChispa);

		// Funci√≥n para calcular √°ngulo de direcci√≥n
		const calcularAngulo = (chispa) => {
			const { ruta, posicion } = chispa;
			if (!ruta || ruta.length < 2 || posicion >= ruta.length - 1) return 0;
			const [x1, y1] = ruta[posicion].split(",").map(Number);
			const [x2, y2] = ruta[posicion + 1].split(",").map(Number);
			return Math.atan2(y2 - y1, x2 - x1);
		};

		// Funci√≥n para dibujar formas
		const dibujarForma = (x, y, tamano, color, angulo = 0, opacidad = 1) => {
			ctx.save();
			ctx.translate(x, y);
			ctx.rotate(angulo);
			ctx.globalAlpha = opacidad;

			switch (formaChispa) {
				case "cuadrado":
					ctx.fillStyle = color;
					ctx.fillRect(-tamano, -tamano, tamano * 2, tamano * 2);
					break;

				case "estrella":
					ctx.fillStyle = color;
					ctx.beginPath();
					for (let i = 0; i < 8; i++) {
						const radio = i % 2 === 0 ? tamano * 1.2 : tamano * 0.4;
						const a = (i * Math.PI) / 4;
						if (i === 0) ctx.moveTo(Math.cos(a) * radio, Math.sin(a) * radio);
						else ctx.lineTo(Math.cos(a) * radio, Math.sin(a) * radio);
					}
					ctx.closePath();
					ctx.fill();
					break;

				case "rayo":
					ctx.fillStyle = color;
					ctx.beginPath();
					ctx.moveTo(-tamano * 1.2, -tamano * 0.3);
					ctx.lineTo(-tamano * 0.3, tamano * 0.5);
					ctx.lineTo(-tamano * 0.3, 0);
					ctx.lineTo(tamano * 1.2, tamano * 0.3);
					ctx.lineTo(tamano * 0.3, -tamano * 0.5);
					ctx.lineTo(tamano * 0.3, 0);
					ctx.closePath();
					ctx.fill();
					break;

				case "flecha":
					ctx.fillStyle = color;
					ctx.beginPath();
					ctx.moveTo(tamano * 1.2, 0);
					ctx.lineTo(-tamano * 0.8, -tamano * 0.8);
					ctx.lineTo(-tamano * 0.4, 0);
					ctx.lineTo(-tamano * 0.8, tamano * 0.8);
					ctx.closePath();
					ctx.fill();
					break;

				case "gota":
					ctx.fillStyle = color;
					ctx.beginPath();
					ctx.moveTo(tamano * 1.2, 0);
					ctx.quadraticCurveTo(0, -tamano * 0.8, -tamano * 0.8, 0);
					ctx.quadraticCurveTo(0, tamano * 0.8, tamano * 1.2, 0);
					ctx.fill();
					break;

				case "anillo":
					ctx.strokeStyle = color;
					ctx.lineWidth = tamano * 0.4;
					ctx.beginPath();
					ctx.arc(0, 0, tamano * 0.8, 0, Math.PI * 2);
					ctx.stroke();
					break;

				case "barra":
					if (color.startsWith("#")) {
						const gradientBarra = ctx.createLinearGradient(-tamano * 6, 0, tamano * 6, 0);
						gradientBarra.addColorStop(0, "transparent");
						gradientBarra.addColorStop(0.15, `${color}15`);
						gradientBarra.addColorStop(0.3, `${color}40`);
						gradientBarra.addColorStop(0.45, `${color}80`);
						gradientBarra.addColorStop(0.5, color);
						gradientBarra.addColorStop(0.55, `${color}80`);
						gradientBarra.addColorStop(0.7, `${color}40`);
						gradientBarra.addColorStop(0.85, `${color}15`);
						gradientBarra.addColorStop(1, "transparent");
						ctx.fillStyle = gradientBarra;
						ctx.fillRect(-tamano * 6, -tamano * 1.2, tamano * 12, tamano * 2.4);
					}
					ctx.fillStyle = color;
					ctx.fillRect(-tamano * 0.4, -tamano * 1.2, tamano * 0.8, tamano * 2.4);
					break;

				case "circulo":
				default:
					ctx.fillStyle = color;
					ctx.beginPath();
					ctx.arc(0, 0, tamano, 0, Math.PI * 2);
					ctx.fill();
					break;
			}

			ctx.restore();
		};

		// Loop de dibujo de chispas
		const dibujarChispas = () => {
			// Limpiar canvas de chispas
			ctx.clearRect(0, 0, dimensiones.ancho, dimensiones.alto);

			// Obtener chispas directamente del ref (mutable, sin pasar por React)
			const chispasActuales = chispasRefProp?.current || [];
			// Obtener funciones desde el ref de props
			const { onObtenerPosicionPixelChispa: getPosicion, onObtenerEstelaPixeles: getEstela } = chispasPropsRef.current;

			if (chispasActuales.length > 0 && getPosicion) {
				for (let i = 0; i < chispasActuales.length; i++) {
					const chispa = chispasActuales[i];
					const angulo = calcularAngulo(chispa);

					// Dibujar estela
					if (mostrarEstela && getEstela) {
						const estelaPixeles = getEstela(chispa);
						for (let j = 0; j < estelaPixeles.length; j++) {
							const punto = estelaPixeles[j];
							dibujarForma(
								punto.x,
								punto.y,
								tamanoChispa * 0.6,
								`rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${punto.opacidad * 0.6})`,
								angulo,
								punto.opacidad * 0.6
							);
						}
					}

					// Dibujar chispa principal
					const pos = getPosicion(chispa);

					// Efecto de brillo (glow)
					if (["circulo", "estrella", "anillo"].includes(formaChispa)) {
						const gradient = ctx.createRadialGradient(
							pos.x, pos.y, 0,
							pos.x, pos.y, tamanoChispa * 2
						);
						gradient.addColorStop(0, colorChispa);
						gradient.addColorStop(0.5, `${colorChispa}80`);
						gradient.addColorStop(1, "transparent");

						ctx.beginPath();
						ctx.arc(pos.x, pos.y, tamanoChispa * 2, 0, Math.PI * 2);
						ctx.fillStyle = gradient;
						ctx.fill();
					}

					dibujarForma(pos.x, pos.y, tamanoChispa, colorChispa, angulo);
				}
			}

			// Continuar el loop si hay animaci√≥n activa
			if (animandoChispas) {
				chispasAnimationRef.current = requestAnimationFrame(dibujarChispas);
			}
		};

		// Iniciar o detener el loop seg√∫n el estado
		if (animandoChispas) {
			chispasAnimationRef.current = requestAnimationFrame(dibujarChispas);
		} else {
			// Limpiar canvas cuando se detiene la animaci√≥n
			ctx.clearRect(0, 0, dimensiones.ancho, dimensiones.alto);
		}

		// Cleanup
		return () => {
			if (chispasAnimationRef.current) {
				cancelAnimationFrame(chispasAnimationRef.current);
			}
		};
	}, [dimensiones, animandoChispas, chispasConfig]);

	/**
	 * Obtener coordenadas de celda desde evento de mouse
	 */
	const obtenerCoordenadas = useCallback((e) => {
		const canvas = canvasRef.current;
		if (!canvas) return null;

		const rect = canvas.getBoundingClientRect();
		const x = Math.floor((e.clientX - rect.left) / grosorLinea);
		const y = Math.floor((e.clientY - rect.top) / grosorLinea);

		return { x, y };
	}, [grosorLinea]);

	/**
	 * Obtener coordenadas en p√≠xeles desde evento de mouse
	 */
	const obtenerCoordenadasPixel = useCallback((e) => {
		const canvas = canvasRef.current;
		if (!canvas) return null;

		const rect = canvas.getBoundingClientRect();
		return {
			x: e.clientX - rect.left,
			y: e.clientY - rect.top
		};
	}, []);

	/**
	 * Verificar si hay una celda pintada en las coordenadas de celda dadas
	 * @param {number} x - Coordenada X de celda
	 * @param {number} y - Coordenada Y de celda
	 * @returns {boolean} true si hay una celda pintada
	 */
	const hayCeldaEn = useCallback((x, y) => {
		const claveCelda = `${x},${y}`;
		return !!celdas[claveCelda];
	}, [celdas]);

	/**
	 * Verificar si un punto est√° sobre un texto y devolver el texto
	 * (con soporte para texto multil√≠nea)
	 */
	const textoEnPunto = useCallback((px, py) => {
		const canvas = canvasRef.current;
		if (!canvas) return null;

		const ctx = canvas.getContext("2d");

		// Buscar en orden inverso (los √∫ltimos est√°n encima)
		for (let i = textos.length - 1; i >= 0; i--) {
			const t = textos[i];
			const fontStyle = `${t.cursiva ? "italic " : ""}${t.negrita ? "bold " : ""}${t.tamano}px ${t.fuente}`;
			ctx.font = fontStyle;

			// Calcular dimensiones considerando m√∫ltiples l√≠neas
			const lineas = t.texto.split("\n");
			const alturaLinea = t.tamano * 1.2;
			let anchoMaximo = 0;
			lineas.forEach(linea => {
				const anchoLinea = ctx.measureText(linea).width;
				if (anchoLinea > anchoMaximo) anchoMaximo = anchoLinea;
			});
			const alturaTotal = lineas.length * alturaLinea;

			if (
				px >= t.x - 2 &&
				px <= t.x + anchoMaximo + 2 &&
				py >= t.y - 2 &&
				py <= t.y + alturaTotal + 2
			) {
				return t;
			}
		}
		return null;
	}, [textos]);

	/**
	 * Manejar click o movimiento con mouse presionado
	 */
	const manejarPintado = useCallback((e) => {
		if (!modoEdicion || herramienta === "texto") return;

		const coords = obtenerCoordenadas(e);
		if (coords) {
			onPintarCelda(coords.x, coords.y, shiftPresionado);
		}
	}, [modoEdicion, herramienta, obtenerCoordenadas, onPintarCelda, shiftPresionado]);

	/**
	 * Capturar color del canvas con el gotero
	 */
	const capturarColorGotero = useCallback((e) => {
		const canvas = canvasRef.current;
		if (!canvas) return;

		const ctx = canvas.getContext("2d");
		const rect = canvas.getBoundingClientRect();
		const x = e.clientX - rect.left;
		const y = e.clientY - rect.top;

		// Obtener el color del p√≠xel
		const pixel = ctx.getImageData(x, y, 1, 1).data;

		// Convertir a hex
		const r = pixel[0].toString(16).padStart(2, "0");
		const g = pixel[1].toString(16).padStart(2, "0");
		const b = pixel[2].toString(16).padStart(2, "0");
		const colorHex = `#${r}${g}${b}`;

		// Cambiar el color seleccionado
		onCambiarColor(colorHex);

		// Desactivar modo gotero
		setModoGotero(false);
	}, [onCambiarColor]);

	/**
	 * Mouse down - iniciar pintado, manejar texto, o iniciar arrastre
	 * Solo responde al bot√≥n izquierdo del mouse (button 0)
	 */
	const handleMouseDown = useCallback((e) => {
		if (!modoEdicion) return;
		// Ignorar clicks que no sean del bot√≥n izquierdo (0 = izquierdo, 2 = derecho)
		if (e.button !== 0) return;
		e.preventDefault();

		// Si el men√∫ contextual est√° abierto, solo cerrarlo y no hacer nada m√°s
		if (menuContextual.visible) {
			setMenuContextual(prev => ({ ...prev, visible: false }));
			return;
		}

		// Si el modo gotero est√° activo, capturar el color
		if (modoGotero) {
			capturarColorGotero(e);
			return;
		}

		if (herramienta === "texto") {
			const coords = obtenerCoordenadasPixel(e);
			if (!coords) return;

			// Verificar si hay un texto en esta posici√≥n
			const textoEncontrado = textoEnPunto(coords.x, coords.y);

			if (textoEncontrado) {
				// Seleccionar texto existente e iniciar arrastre
				onTextoSeleccionadoChange?.(textoEncontrado.id);
				setArrastrando({
					activo: true,
					textoId: textoEncontrado.id,
					offsetX: coords.x - textoEncontrado.x,
					offsetY: coords.y - textoEncontrado.y
				});
			} else {
				// Si hay un texto seleccionado, solo deseleccionarlo sin crear nuevo input
				if (textoSeleccionadoId) {
					onTextoSeleccionadoChange?.(null);
					return;
				}
				// Mostrar input para nuevo texto
				setInputTexto({
					visible: true,
					x: coords.x,
					y: coords.y,
					valor: "",
					editandoId: null,
					ancho: 220,
					alto: 55,
					valorOriginal: ""
				});
			}
		} else if (herramienta === "borne") {
			// Herramienta borne: colocar o eliminar borne
			const coords = obtenerCoordenadas(e);
			if (coords) {
				// Verificar si ya hay un borne en esta posici√≥n
				const borneExistente = bornes.find(b => b.x === coords.x && b.y === coords.y);
				if (borneExistente) {
					// Si hay un borne, eliminarlo
					onEliminarBorneEnPosicion?.(coords.x, coords.y);
				} else {
					// Si no hay borne, agregar uno del tipo activo
					onAgregarBorne?.(coords.x, coords.y, tipoBorneActivo);
				}
			}
		} else if (herramienta === "balde") {
			// Herramienta balde: rellenar celdas conectadas
			const coords = obtenerCoordenadas(e);
			if (coords) {
				onRellenarConectadas?.(coords.x, coords.y);
			}
		} else if (herramienta === "mover") {
			// Herramienta mover: iniciar arrastre de l√≠neas conectadas
			const coords = obtenerCoordenadas(e);
			if (coords && hayCeldaEn(coords.x, coords.y)) {
				// Obtener todas las celdas conectadas desde esta posici√≥n
				const celdasConectadas = onObtenerCeldasConectadas?.(coords.x, coords.y, celdas) || [];
				if (celdasConectadas.length > 0) {
					setArrastrandoLineas({
						activo: true,
						celdasConectadas,
						celdaInicialX: coords.x,
						celdaInicialY: coords.y,
						ultimaCeldaX: coords.x,
						ultimaCeldaY: coords.y,
					});
				}
			}
		} else if (herramienta === "borrador") {
			// Borrador: iniciar selecci√≥n de √°rea
			const coords = obtenerCoordenadas(e);
			if (coords) {
				setAreaBorrador({
					activo: true,
					inicioX: coords.x,
					inicioY: coords.y,
					actualX: coords.x,
					actualY: coords.y,
				});
			}
		} else {
			// Pincel
			const coords = obtenerCoordenadas(e);
			if (coords) {
				onIniciarPintado(coords.x, coords.y);
				onPintarCelda(coords.x, coords.y, shiftPresionado);
			}
		}
	}, [modoEdicion, modoGotero, capturarColorGotero, herramienta, obtenerCoordenadas, obtenerCoordenadasPixel, textoEnPunto, onIniciarPintado, onPintarCelda, onRellenarConectadas, onObtenerCeldasConectadas, onTextoSeleccionadoChange, shiftPresionado, hayCeldaEn, celdas, menuContextual.visible, textoSeleccionadoId]);

	/**
	 * Doble clic - editar texto existente
	 */
	const handleDoubleClick = useCallback((e) => {
		if (!modoEdicion || herramienta !== "texto") return;
		e.preventDefault();

		const coords = obtenerCoordenadasPixel(e);
		if (!coords) return;

		const textoEncontrado = textoEnPunto(coords.x, coords.y);
		if (textoEncontrado) {
			// Cargar el color y configuraci√≥n del texto en los controles
			onCambiarColor(textoEncontrado.color);
			onConfigTextoChange?.({
				fuente: textoEncontrado.fuente,
				tamano: textoEncontrado.tamano,
				negrita: textoEncontrado.negrita,
				cursiva: textoEncontrado.cursiva,
			});
			// Abrir input para editar el texto - calcular dimensiones seg√∫n el texto existente
			const canvas = canvasRef.current;
			const ctx = canvas?.getContext("2d");
			let anchoCalculado = 200;
			let altoCalculado = 40;
			if (ctx) {
				const fontStyle = `${textoEncontrado.cursiva ? "italic " : ""}${textoEncontrado.negrita ? "bold " : ""}${textoEncontrado.tamano}px ${textoEncontrado.fuente}`;
				ctx.font = fontStyle;
				const lineas = textoEncontrado.texto.split("\n");
				const alturaLinea = textoEncontrado.tamano * 1.2;
				let anchoMax = 0;
				lineas.forEach(linea => {
					const w = ctx.measureText(linea).width;
					if (w > anchoMax) anchoMax = w;
				});
				anchoCalculado = Math.max(200, anchoMax + 30);
				altoCalculado = Math.max(40, lineas.length * alturaLinea + 20);
			}
			setInputTexto({
				visible: true,
				x: textoEncontrado.x,
				y: textoEncontrado.y,
				valor: textoEncontrado.texto,
				editandoId: textoEncontrado.id,
				ancho: anchoCalculado,
				alto: altoCalculado,
				valorOriginal: textoEncontrado.texto
			});
			onTextoSeleccionadoChange?.(textoEncontrado.id);
		}
	}, [modoEdicion, herramienta, obtenerCoordenadasPixel, textoEnPunto, onTextoSeleccionadoChange, onCambiarColor, onConfigTextoChange]);

	/**
	 * Mouse move - continuar pintado o arrastre de texto/l√≠neas
	 */
	const handleMouseMove = useCallback((e) => {
		if (!modoEdicion) return;

		// Guardar posici√≥n del mouse para Ctrl+V
		const coordsPixel = obtenerCoordenadasPixel(e);
		if (coordsPixel) {
			posicionMouseRef.current = { x: coordsPixel.x, y: coordsPixel.y };
		}

		// Mover texto si est√° arrastrando
		if (arrastrando.activo && arrastrando.textoId) {
			const coords = obtenerCoordenadasPixel(e);
			if (coords) {
				onActualizarTexto?.(arrastrando.textoId, {
					x: coords.x - arrastrando.offsetX,
					y: coords.y - arrastrando.offsetY
				});
			}
			return;
		}

		// Mover l√≠neas conectadas si est√° arrastrando
		if (arrastrandoLineas.activo && arrastrandoLineas.celdasConectadas.length > 0) {
			const coords = obtenerCoordenadas(e);
			if (coords) {
				const deltaX = coords.x - arrastrandoLineas.ultimaCeldaX;
				const deltaY = coords.y - arrastrandoLineas.ultimaCeldaY;

				if (deltaX !== 0 || deltaY !== 0) {
					// Mover las celdas
					onMoverCeldasConectadas?.(arrastrandoLineas.celdasConectadas, deltaX, deltaY);

					// Actualizar las posiciones de las celdas conectadas (sumar el delta)
					const nuevasCeldasConectadas = arrastrandoLineas.celdasConectadas.map(clave => {
						const [x, y] = clave.split(",").map(Number);
						return `${x + deltaX},${y + deltaY}`;
					});

					// Actualizar el estado con la nueva posici√≥n
					setArrastrandoLineas(prev => ({
						...prev,
						celdasConectadas: nuevasCeldasConectadas,
						ultimaCeldaX: coords.x,
						ultimaCeldaY: coords.y,
					}));
				}
			}
			return;
		}

		// Actualizar √°rea del borrador si est√° seleccionando
		if (areaBorrador.activo) {
			const coords = obtenerCoordenadas(e);
			if (coords) {
				setAreaBorrador(prev => ({
					...prev,
					actualX: coords.x,
					actualY: coords.y,
				}));
			}
			return;
		}

		// Detectar si el mouse est√° sobre un texto (para cambiar cursor)
		if (herramienta === "texto") {
			const coords = obtenerCoordenadasPixel(e);
			if (coords) {
				const textoEncontrado = textoEnPunto(coords.x, coords.y);
				setSobreTexto(!!textoEncontrado);
			}
		}

		// Detectar si el mouse est√° sobre una l√≠nea (para cambiar cursor en herramienta mover)
		if (herramienta === "mover") {
			const coords = obtenerCoordenadas(e);
			if (coords) {
				setSobreLinea(hayCeldaEn(coords.x, coords.y));
			}
		}

		if (!estaPintando || herramienta === "texto" || herramienta === "mover" || herramienta === "borrador") return;
		manejarPintado(e);
	}, [modoEdicion, arrastrando, arrastrandoLineas, areaBorrador.activo, estaPintando, herramienta, obtenerCoordenadas, obtenerCoordenadasPixel, onActualizarTexto, onMoverCeldasConectadas, manejarPintado, textoEnPunto, hayCeldaEn]);

	/**
	 * Mouse up - detener pintado o arrastre
	 */
	const handleMouseUp = useCallback(() => {
		if (!modoEdicion) return;

		// Si estaba seleccionando √°rea para borrar, ejecutar el borrado
		if (areaBorrador.activo) {
			onBorrarArea?.(
				areaBorrador.inicioX,
				areaBorrador.inicioY,
				areaBorrador.actualX,
				areaBorrador.actualY
			);
			setAreaBorrador({
				activo: false,
				inicioX: 0,
				inicioY: 0,
				actualX: 0,
				actualY: 0,
			});
		}

		onDetenerPintado();
		setArrastrando({ activo: false, textoId: null, offsetX: 0, offsetY: 0 });
		setArrastrandoLineas({
			activo: false,
			celdasConectadas: [],
			celdaInicialX: 0,
			celdaInicialY: 0,
			ultimaCeldaX: 0,
			ultimaCeldaY: 0,
		});
	}, [modoEdicion, onDetenerPintado, areaBorrador, onBorrarArea]);

	/**
	 * Mouse leave - detener pintado si sale del canvas
	 */
	const handleMouseLeave = useCallback(() => {
		if (estaPintando) {
			onDetenerPintado();
		}
		if (arrastrando.activo) {
			setArrastrando({ activo: false, textoId: null, offsetX: 0, offsetY: 0 });
		}
		if (arrastrandoLineas.activo) {
			setArrastrandoLineas({
				activo: false,
				celdasConectadas: [],
				celdaInicialX: 0,
				celdaInicialY: 0,
				ultimaCeldaX: 0,
				ultimaCeldaY: 0,
			});
		}
		// Cancelar selecci√≥n de √°rea del borrador si sale del canvas
		if (areaBorrador.activo) {
			setAreaBorrador({
				activo: false,
				inicioX: 0,
				inicioY: 0,
				actualX: 0,
				actualY: 0,
			});
		}
		setSobreTexto(false);
		setSobreLinea(false);
	}, [estaPintando, arrastrando.activo, arrastrandoLineas.activo, areaBorrador.activo, onDetenerPintado]);

	/**
	 * Click derecho - mostrar men√∫ contextual para copiar/pegar
	 */
	const handleContextMenu = useCallback((e) => {
		// Siempre prevenir men√∫ del browser en modo edici√≥n
		if (!modoEdicion) return;

		// Si no es herramienta texto, solo prevenir el men√∫ del browser pero no mostrar nuestro men√∫
		if (herramienta !== "texto") {
			e.preventDefault();
			return;
		}

		e.preventDefault();
		e.stopPropagation();

		// Si el men√∫ contextual ya est√° abierto, solo cerrarlo
		if (menuContextual.visible) {
			setMenuContextual(prev => ({ ...prev, visible: false }));
			return;
		}

		const coords = obtenerCoordenadasPixel(e);
		if (!coords) return;

		// Verificar si hay un texto en esta posici√≥n para seleccionarlo
		const textoEncontrado = textoEnPunto(coords.x, coords.y);
		if (textoEncontrado) {
			onTextoSeleccionadoChange?.(textoEncontrado.id);
		} else {
			// Si hay un texto seleccionado y se hace click derecho fuera de √©l,
			// solo deseleccionar sin mostrar el men√∫ contextual
			if (textoSeleccionadoId) {
				onTextoSeleccionadoChange?.(null);
				return;
			}
		}

		// Obtener posici√≥n relativa al canvas para el men√∫
		const canvas = canvasRef.current;
		const rect = canvas.getBoundingClientRect();

		setMenuContextual({
			visible: true,
			x: e.clientX - rect.left,
			y: e.clientY - rect.top,
			pixelX: coords.x,
			pixelY: coords.y,
			// Guardar si hay texto seleccionado en el momento del click
			hayTextoEnPosicion: !!textoEncontrado,
		});
	}, [modoEdicion, herramienta, obtenerCoordenadasPixel, textoEnPunto, onTextoSeleccionadoChange, textoSeleccionadoId, menuContextual.visible]);

	/**
	 * Copiar texto seleccionado
	 */
	const copiarTexto = useCallback(() => {
		if (textoSeleccionadoId) {
			const textoACopiar = textos.find(t => t.id === textoSeleccionadoId);
			if (textoACopiar) {
				setTextoCopiado({ ...textoACopiar });
			}
			// Quitar la selecci√≥n despu√©s de copiar
			onTextoSeleccionadoChange?.(null);
		}
		setMenuContextual(prev => ({ ...prev, visible: false }));
	}, [textoSeleccionadoId, textos, onTextoSeleccionadoChange]);

	/**
	 * Pegar texto copiado
	 */
	const pegarTexto = useCallback(() => {
		if (textoCopiado) {
			onAgregarTexto?.(menuContextual.pixelX, menuContextual.pixelY, textoCopiado.texto);
			// Actualizar el texto reci√©n pegado con los estilos del copiado
			setTimeout(() => {
				const ultimoTexto = textos[textos.length - 1];
				if (ultimoTexto) {
					onActualizarTexto?.(ultimoTexto.id, {
						color: textoCopiado.color,
						fuente: textoCopiado.fuente,
						tamano: textoCopiado.tamano,
						negrita: textoCopiado.negrita,
						cursiva: textoCopiado.cursiva,
					});
				}
			}, 50);
		}
		setMenuContextual(prev => ({ ...prev, visible: false }));
	}, [textoCopiado, menuContextual.pixelX, menuContextual.pixelY, onAgregarTexto, onActualizarTexto, textos]);

	/**
	 * Eliminar texto seleccionado desde el men√∫ contextual
	 */
	const eliminarTextoMenu = useCallback(() => {
		if (textoSeleccionadoId) {
			onEliminarTexto?.(textoSeleccionadoId);
		}
		setMenuContextual(prev => ({ ...prev, visible: false }));
	}, [textoSeleccionadoId, onEliminarTexto]);

	/**
	 * Cerrar men√∫ contextual al hacer click fuera
	 */
	useEffect(() => {
		const handleClick = () => {
			if (menuContextual.visible) {
				setMenuContextual(prev => ({ ...prev, visible: false }));
			}
		};

		if (menuContextual.visible) {
			// Usar setTimeout para evitar que el click que abre el men√∫ lo cierre
			setTimeout(() => {
				window.addEventListener("click", handleClick);
			}, 0);
		}

		return () => {
			window.removeEventListener("click", handleClick);
		};
	}, [menuContextual.visible]);

	// Touch events para m√≥vil
	const handleTouchStart = useCallback((e) => {
		if (!modoEdicion || herramienta === "texto") return;
		e.preventDefault();
		const touch = e.touches[0];
		const coords = obtenerCoordenadas({ clientX: touch.clientX, clientY: touch.clientY });
		if (coords) {
			onIniciarPintado(coords.x, coords.y);
			onPintarCelda(coords.x, coords.y, false);
		}
	}, [modoEdicion, herramienta, obtenerCoordenadas, onIniciarPintado, onPintarCelda]);

	const handleTouchMove = useCallback((e) => {
		if (!modoEdicion || !estaPintando || herramienta === "texto") return;
		e.preventDefault();
		const touch = e.touches[0];
		const mouseEvent = { clientX: touch.clientX, clientY: touch.clientY };
		manejarPintado(mouseEvent);
	}, [modoEdicion, estaPintando, herramienta, manejarPintado]);

	const handleTouchEnd = useCallback(() => {
		if (!modoEdicion) return;
		onDetenerPintado();
	}, [modoEdicion, onDetenerPintado]);

	/**
	 * Confirmar texto ingresado (nuevo o editado)
	 */
	const confirmarTexto = useCallback(() => {
		if (inputTexto.valor.trim()) {
			if (inputTexto.editandoId) {
				// Actualizar texto existente - incluir color, fuente, tama√±o, negrita y cursiva
				onActualizarTexto?.(inputTexto.editandoId, {
					texto: inputTexto.valor,
					color: colorSeleccionado,
					fuente: configTexto.fuente,
					tamano: configTexto.tamano,
					negrita: configTexto.negrita,
					cursiva: configTexto.cursiva,
				});
			} else {
				// Agregar nuevo texto
				onAgregarTexto?.(inputTexto.x, inputTexto.y, inputTexto.valor);
			}
		} else if (inputTexto.editandoId) {
			// Si el texto queda vac√≠o al editar, eliminar
			onEliminarTexto?.(inputTexto.editandoId);
		}
		setInputTexto({ visible: false, x: 0, y: 0, valor: "", editandoId: null, ancho: 220, alto: 55, valorOriginal: "" });
	}, [inputTexto, colorSeleccionado, configTexto, onAgregarTexto, onActualizarTexto, onEliminarTexto]);

	/**
	 * Cancelar input de texto (para nuevo texto, simplemente cierra)
	 */
	const cancelarTexto = useCallback(() => {
		setInputTexto({ visible: false, x: 0, y: 0, valor: "", editandoId: null, ancho: 220, alto: 55, valorOriginal: "" });
	}, []);

	/**
	 * Descartar cambios y volver al valor original (solo para edici√≥n)
	 */
	const descartarCambios = useCallback(() => {
		setInputTexto({ visible: false, x: 0, y: 0, valor: "", editandoId: null, ancho: 220, alto: 55, valorOriginal: "" });
	}, []);

	/**
	 * Eliminar el texto que se est√° editando
	 */
	const eliminarTextoActual = useCallback(() => {
		if (inputTexto.editandoId) {
			onEliminarTexto?.(inputTexto.editandoId);
		}
		setInputTexto({ visible: false, x: 0, y: 0, valor: "", editandoId: null, ancho: 220, alto: 55, valorOriginal: "" });
	}, [inputTexto.editandoId, onEliminarTexto]);

	/**
	 * Manejar teclas en el textarea de texto
	 * - Enter: confirma el texto
	 * - Alt+Enter: agrega salto de l√≠nea
	 * - Escape: cancela
	 */
	const handleInputKeyDown = useCallback((e) => {
		if (e.key === "Enter") {
			if (e.altKey) {
				// Alt+Enter: insertar salto de l√≠nea
				e.preventDefault();
				const textarea = e.target;
				const start = textarea.selectionStart;
				const end = textarea.selectionEnd;
				const valor = inputTexto.valor;
				const nuevoValor = valor.substring(0, start) + "\n" + valor.substring(end);
				setInputTexto(prev => ({ ...prev, valor: nuevoValor }));
				// Reposicionar cursor despu√©s del salto de l√≠nea
				setTimeout(() => {
					textarea.selectionStart = textarea.selectionEnd = start + 1;
				}, 0);
			} else {
				// Enter solo: confirmar texto
				e.preventDefault();
				confirmarTexto();
			}
		} else if (e.key === "Escape") {
			cancelarTexto();
		}
	}, [confirmarTexto, cancelarTexto, inputTexto.valor]);

	/**
	 * Manejar cambio de texto en el textarea
	 */
	const handleTextareaInput = useCallback((e) => {
		setInputTexto(prev => ({ ...prev, valor: e.target.value }));
	}, []);

	/**
	 * Iniciar redimensionamiento del textarea
	 */
	const iniciarRedimension = useCallback((e, handle) => {
		e.preventDefault();
		e.stopPropagation();
		setRedimensionando({
			activo: true,
			handle,
			inicioX: e.clientX,
			inicioY: e.clientY,
			anchoInicial: inputTexto.ancho,
			altoInicial: inputTexto.alto,
		});
	}, [inputTexto.ancho, inputTexto.alto]);

	/**
	 * Manejar movimiento durante redimensionamiento
	 */
	useEffect(() => {
		if (!redimensionando.activo) return;

		const handleMouseMove = (e) => {
			const deltaX = e.clientX - redimensionando.inicioX;
			const deltaY = e.clientY - redimensionando.inicioY;
			const handle = redimensionando.handle;

			let nuevoAncho = redimensionando.anchoInicial;
			let nuevoAlto = redimensionando.altoInicial;

			// Calcular nuevo tama√±o seg√∫n el handle
			if (handle.includes("e")) nuevoAncho = Math.max(100, redimensionando.anchoInicial + deltaX);
			if (handle.includes("w")) nuevoAncho = Math.max(100, redimensionando.anchoInicial - deltaX);
			if (handle.includes("s")) nuevoAlto = Math.max(30, redimensionando.altoInicial + deltaY);
			if (handle.includes("n")) nuevoAlto = Math.max(30, redimensionando.altoInicial - deltaY);

			setInputTexto(prev => ({ ...prev, ancho: nuevoAncho, alto: nuevoAlto }));
		};

		const handleMouseUp = () => {
			setRedimensionando({ activo: false, handle: null, inicioX: 0, inicioY: 0, anchoInicial: 0, altoInicial: 0 });
		};

		window.addEventListener("mousemove", handleMouseMove);
		window.addEventListener("mouseup", handleMouseUp);

		return () => {
			window.removeEventListener("mousemove", handleMouseMove);
			window.removeEventListener("mouseup", handleMouseUp);
		};
	}, [redimensionando]);

	// Si no hay dibujo y no est√° en modo edici√≥n, no renderizar nada
	if (!modoEdicion && Object.keys(celdas).length === 0 && textos.length === 0) {
		return null;
	}

	// Cursor seg√∫n herramienta y estado
	const getCursor = () => {
		if (!modoEdicion) return "default";
		// Si el modo gotero est√° activo, mostrar cursor de cuentagotas
		if (modoGotero) return "crosshair";
		if (arrastrando.activo) return "grabbing";
		if (arrastrandoLineas.activo) return "grabbing";
		if (herramienta === "borrador") return "crosshair";
		if (herramienta === "balde") return "crosshair";
		if (herramienta === "borne") return "crosshair";
		if (herramienta === "mover") {
			// Mostrar manito si est√° sobre una l√≠nea
			if (sobreLinea) return "grab";
			return "move";
		}
		if (herramienta === "texto") {
			// Mostrar manito si est√° sobre un texto existente
			if (sobreTexto) return "grab";
			return "text";
		}
		// Pincel usa el mismo cursor que borrador (crosshair)
		return "crosshair";
	};

	return (
		<div
			ref={contenedorRef}
			className={`grilla-unifilar ${modoEdicion ? "grilla-unifilar--editando" : "grilla-unifilar--fondo"}`}
			onContextMenu={handleContextMenu}
		>
			<canvas
				ref={canvasRef}
				className="grilla-unifilar__canvas"
				onMouseDown={handleMouseDown}
				onMouseMove={handleMouseMove}
				onMouseUp={handleMouseUp}
				onMouseLeave={handleMouseLeave}
				onDoubleClick={handleDoubleClick}
				onContextMenu={handleContextMenu}
				onTouchStart={handleTouchStart}
				onTouchMove={handleTouchMove}
				onTouchEnd={handleTouchEnd}
				style={{ cursor: getCursor() }}
			/>
			{/* Canvas overlay para chispas - separado para mejor rendimiento */}
			<canvas
				ref={canvasChispasRef}
				className="grilla-unifilar__canvas-chispas"
				style={{ pointerEvents: "none" }}
			/>

			{/* Men√∫ contextual para copiar/pegar texto */}
			{menuContextual.visible && (
				<div
					className="grilla-unifilar__menu-contextual"
					style={{ left: menuContextual.x, top: menuContextual.y }}
					onClick={(e) => e.stopPropagation()}
					onContextMenu={(e) => e.preventDefault()}
				>
					<button
						type="button"
						className={`grilla-unifilar__menu-item ${!menuContextual.hayTextoEnPosicion ? "grilla-unifilar__menu-item--disabled" : ""}`}
						onClick={copiarTexto}
						disabled={!menuContextual.hayTextoEnPosicion}
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
							<path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
						</svg>
						<span>Copiar</span>
						<span className="grilla-unifilar__menu-shortcut">Ctrl+C</span>
					</button>
					<button
						type="button"
						className={`grilla-unifilar__menu-item ${!textoCopiado ? "grilla-unifilar__menu-item--disabled" : ""}`}
						onClick={pegarTexto}
						disabled={!textoCopiado}
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
							<path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"/>
						</svg>
						<span>Pegar</span>
						<span className="grilla-unifilar__menu-shortcut">Ctrl+V</span>
					</button>
					{/* Separador */}
					{menuContextual.hayTextoEnPosicion && (
						<div className="grilla-unifilar__menu-separator" />
					)}
					{/* Eliminar - solo si hay texto en la posici√≥n */}
					<button
						type="button"
						className={`grilla-unifilar__menu-item grilla-unifilar__menu-item--eliminar ${!menuContextual.hayTextoEnPosicion ? "grilla-unifilar__menu-item--disabled" : ""}`}
						onClick={eliminarTextoMenu}
						disabled={!menuContextual.hayTextoEnPosicion}
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
							<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
						</svg>
						<span>Eliminar</span>
						<span className="grilla-unifilar__menu-shortcut">Delete</span>
					</button>
				</div>
			)}

			{/* Textarea flotante redimensionable para texto */}
			{inputTexto.visible && (
				<div
					className="grilla-unifilar__input-texto"
					style={{ left: inputTexto.x, top: inputTexto.y }}
				>
					<div className="grilla-unifilar__input-wrapper">
						<div
							className="grilla-unifilar__textarea-container"
							style={{ width: inputTexto.ancho, height: inputTexto.alto }}
						>
							<textarea
								ref={textareaRef}
								autoFocus
								value={inputTexto.valor}
								onChange={handleTextareaInput}
								onKeyDown={handleInputKeyDown}
								placeholder="Escribir texto... (Alt+Enter para nueva l√≠nea)"
								style={{
									fontFamily: configTexto.fuente,
									fontSize: `${configTexto.tamano}px`,
									fontWeight: configTexto.negrita ? "bold" : "normal",
									fontStyle: configTexto.cursiva ? "italic" : "normal",
									color: colorSeleccionado,
								}}
							/>
							{/* Handles de redimensionamiento - Esquinas */}
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--nw" onMouseDown={(e) => iniciarRedimension(e, "nw")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--ne" onMouseDown={(e) => iniciarRedimension(e, "ne")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--sw" onMouseDown={(e) => iniciarRedimension(e, "sw")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--se" onMouseDown={(e) => iniciarRedimension(e, "se")} />
							{/* Handles de redimensionamiento - Lados */}
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--n" onMouseDown={(e) => iniciarRedimension(e, "n")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--s" onMouseDown={(e) => iniciarRedimension(e, "s")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--e" onMouseDown={(e) => iniciarRedimension(e, "e")} />
							<div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--w" onMouseDown={(e) => iniciarRedimension(e, "w")} />
						</div>
						{/* Botones de acci√≥n */}
						<div className="grilla-unifilar__input-acciones">
							{/* Aceptar */}
							<button
								type="button"
								className="grilla-unifilar__input-btn grilla-unifilar__input-btn--aceptar"
								onClick={confirmarTexto}
								title="Aceptar (Enter)"
							>
								<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
									<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
								</svg>
							</button>
							{/* Cerrar/Volver - cambia seg√∫n si es nuevo texto o edici√≥n */}
							<button
								type="button"
								className={`grilla-unifilar__input-btn ${inputTexto.editandoId ? "grilla-unifilar__input-btn--volver" : "grilla-unifilar__input-btn--cerrar"}`}
								onClick={cancelarTexto}
								title={inputTexto.editandoId ? "Volver (Esc)" : "Cerrar (Esc)"}
							>
								{inputTexto.editandoId ? (
									/* Icono de undo (deshacer) para edici√≥n */
									<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
										<path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
									</svg>
								) : (
									/* X para cerrar nuevo texto */
									<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
										<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
									</svg>
								)}
							</button>
						</div>
					</div>
				</div>
			)}

			{/* Barra de herramientas - solo en modo edici√≥n */}
			{modoEdicion && (
				<div className="grilla-unifilar__toolbar">
					{/* Selector de colores */}
					<div className="grilla-unifilar__colores">
						{coloresDisponibles.map((c) => (
							<button
								key={c.id}
								type="button"
								className={`grilla-unifilar__color ${colorSeleccionado === c.color ? "grilla-unifilar__color--activo" : ""} ${c.id === "negro" ? "grilla-unifilar__color--negro" : ""}`}
								style={{ backgroundColor: c.color }}
								onClick={() => {
									onCambiarColor(c.color);
									if (herramienta !== "texto") {
										onSeleccionarPincel();
									}
								}}
								title={c.nombre}
							/>
						))}
						{/* Separador entre negro y color picker */}
						<div className="grilla-unifilar__separador" />
						{/* Color picker personalizado */}
						<ColorPickerSimple
							color={colorSeleccionado}
							onChange={(color) => {
								onCambiarColor(color);
								if (herramienta !== "texto") {
									onSeleccionarPincel();
								}
							}}
							label=""
							posicionArriba={true}
						/>
					</div>

					{/* Secci√≥n de grosor y gotero */}
					<div className="grilla-unifilar__seccion-grosor">
						{/* Selector de grosor de l√≠nea */}
						<select
							className="grilla-unifilar__select grilla-unifilar__select--grosor"
							value={grosorLinea}
							onChange={(e) => onCambiarGrosor?.(Number(e.target.value))}
							title="Grosor de l√≠nea"
						>
							{grosoresDisponibles.map((g) => (
								<option key={g.id} value={g.valor}>
									{g.nombre}
								</option>
							))}
						</select>
						{/* Gotero - copiar color del canvas */}
						<button
							type="button"
							className={`grilla-unifilar__btn ${modoGotero ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={() => setModoGotero(!modoGotero)}
							title="Gotero - clic en el canvas para copiar color"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M20.71 5.63l-2.34-2.34a1 1 0 00-1.41 0l-3.12 3.12-1.41-1.41-1.42 1.42 1.41 1.41-7.83 7.83a2 2 0 00-.59 1.42V19h2.83c.53 0 1.04-.21 1.42-.59l7.83-7.83 1.41 1.41 1.42-1.42-1.41-1.41 3.12-3.12a1 1 0 00.09-1.41zM6.41 18H5v-1.41l7.83-7.83 1.41 1.41L6.41 18z"/>
							</svg>
						</button>
					</div>

					{/* Herramientas */}
					<div className="grilla-unifilar__herramientas">
						{/* Pincel */}
						<button
							type="button"
							className={`grilla-unifilar__btn ${herramienta === "pincel" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={onSeleccionarPincel}
							title="Pincel (mantener Shift para l√≠nea recta)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34a.996.996 0 00-1.41 0L9 12.25 11.75 15l8.96-8.96a.996.996 0 000-1.41z"/>
							</svg>
						</button>
						<button
							type="button"
							className={`grilla-unifilar__btn ${herramienta === "borrador" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={onSeleccionarBorrador}
							title="Borrador"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M15.14 3c-.51 0-1.02.2-1.41.59L2.59 14.73c-.78.78-.78 2.05 0 2.83l3.85 3.85c.39.39.9.59 1.41.59h8.48c.53 0 1.04-.21 1.41-.59l3.67-3.67c.78-.78.78-2.05 0-2.83L12.56 3.59C12.17 3.2 11.66 3 11.14 3h4zm-9.71 18H8.3l8.57-8.57-2.83-2.83L5.43 18.17l-.01 2.83z"/>
							</svg>
						</button>
						<button
							type="button"
							className={`grilla-unifilar__btn ${herramienta === "balde" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={onSeleccionarBalde}
							title="Balde de pintura (cambiar color de l√≠neas conectadas)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M19 11.5s-2 2.17-2 3.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-3.5-2-3.5zM5.21 10L10 5.21 14.79 10H5.21zM16.56 8.94L10 2.38 3.44 8.94c-.59.59-.59 1.54 0 2.12l6.56 6.56c.59.59 1.54.59 2.12 0l6.44-6.44c.59-.59.59-1.54 0-2.12l-.12-.12z"/>
							</svg>
						</button>
						<button
							type="button"
							className={`grilla-unifilar__btn ${herramienta === "texto" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={onSeleccionarTexto}
							title="Texto (doble clic para editar, arrastrar para mover)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M5 4v3h5.5v12h3V7H19V4H5z"/>
							</svg>
						</button>
						<button
							type="button"
							className={`grilla-unifilar__btn ${herramienta === "mover" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={onSeleccionarMover}
							title="Mover l√≠neas (arrastra l√≠neas conectadas)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"/>
							</svg>
						</button>
						<button
							type="button"
							className="grilla-unifilar__btn grilla-unifilar__btn--peligro"
							onClick={onLimpiarTodo}
							title="Limpiar todo"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
							</svg>
						</button>

						{/* Separador */}
						<div className="grilla-unifilar__separador" />

						{/* === HERRAMIENTAS DE BORNES Y CHISPAS === */}
						{/* Borne Emisor */}
						<button
							type="button"
							className={`grilla-unifilar__btn grilla-unifilar__btn--emisor ${herramienta === "borne" && tipoBorneActivo === "EMISOR" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={() => {
								setTipoBorneActivo("EMISOR");
								onSeleccionarBorne?.();
							}}
							title="Colocar borne emisor (origen de chispas)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M11 21h-1l1-7H7.5c-.58 0-.57-.32-.38-.66l.07-.12C8.48 10.94 10.42 7.54 13 3h1l-1 7h3.5c.49 0 .56.33.47.51l-.07.15C12.96 17.55 11 21 11 21z"/>
							</svg>
						</button>
						{/* Borne Receptor */}
						<button
							type="button"
							className={`grilla-unifilar__btn grilla-unifilar__btn--receptor ${herramienta === "borne" && tipoBorneActivo === "RECEPTOR" ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={() => {
								setTipoBorneActivo("RECEPTOR");
								onSeleccionarBorne?.();
							}}
							title="Colocar borne receptor (destino de chispas)"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" strokeWidth="2"/>
								<circle cx="12" cy="12" r="6" fill="none" stroke="currentColor" strokeWidth="2"/>
								<circle cx="12" cy="12" r="2"/>
							</svg>
						</button>
						{/* Play/Stop chispas */}
						<button
							type="button"
							className={`grilla-unifilar__btn ${animandoChispas ? "grilla-unifilar__btn--activo grilla-unifilar__btn--animando" : ""}`}
							onClick={onToggleAnimacionChispas}
							title={animandoChispas ? "Detener animaci√≥n de chispas" : "Iniciar animaci√≥n de chispas"}
							disabled={bornes.filter(b => b.tipo === "EMISOR").length === 0 || bornes.filter(b => b.tipo === "RECEPTOR").length === 0}
						>
							{animandoChispas ? (
								<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
									<rect x="6" y="4" width="4" height="16"/>
									<rect x="14" y="4" width="4" height="16"/>
								</svg>
							) : (
								<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
									<path d="M8 5v14l11-7z"/>
								</svg>
							)}
						</button>
						{/* Configuraci√≥n de chispas */}
						<button
							type="button"
							className={`grilla-unifilar__btn ${panelChispasVisible ? "grilla-unifilar__btn--activo" : ""}`}
							onClick={() => setPanelChispasVisible(!panelChispasVisible)}
							title="Configuraci√≥n de chispas"
						>
							<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
								<path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
							</svg>
						</button>
					</div>

					{/* Opciones de texto - solo si herramienta es texto */}
					{herramienta === "texto" && (
						<div className="grilla-unifilar__texto-opciones">
							{/* Selector de fuente */}
							<select
								className="grilla-unifilar__select"
								value={configTexto.fuente}
								onChange={(e) => {
									const nuevaFuente = e.target.value;
									// Siempre actualizar configTexto para el textarea visible
									onConfigTextoChange?.({ ...configTexto, fuente: nuevaFuente });
									// Si hay un texto seleccionado (sin textarea abierto), actualizarlo directamente
									if (!inputTexto.visible && textoSeleccionadoId) {
										onActualizarTexto?.(textoSeleccionadoId, { fuente: nuevaFuente });
									}
								}}
								title="Fuente"
							>
								{fuentesDisponibles.map((f) => (
									<option key={f.id} value={f.familia}>
										{f.nombre}
									</option>
								))}
							</select>

							{/* Selector de tama√±o */}
							<select
								className="grilla-unifilar__select grilla-unifilar__select--tamano"
								value={configTexto.tamano}
								onChange={(e) => {
									const nuevoTamano = Number(e.target.value);
									// Siempre actualizar configTexto para el textarea visible
									onConfigTextoChange?.({ ...configTexto, tamano: nuevoTamano });
									// Si hay un texto seleccionado (sin textarea abierto), actualizarlo directamente
									if (!inputTexto.visible && textoSeleccionadoId) {
										onActualizarTexto?.(textoSeleccionadoId, { tamano: nuevoTamano });
									}
								}}
								title="Tama√±o"
							>
								{tamanosDisponibles.map((t) => (
									<option key={t} value={t}>
										{t}px
									</option>
								))}
							</select>

							{/* Bot√≥n negrita */}
							<button
								type="button"
								className={`grilla-unifilar__btn grilla-unifilar__btn--formato ${
									configTexto.negrita ? "grilla-unifilar__btn--activo" : ""
								}`}
								onClick={() => {
									// Si hay textarea abierto (editando o creando), cambiar configTexto
									if (inputTexto.visible) {
										onConfigTextoChange?.({ ...configTexto, negrita: !configTexto.negrita });
									} else if (textoSeleccionadoId) {
										// Si hay un texto seleccionado sin textarea, actualizarlo directamente
										const textoActual = textos.find(t => t.id === textoSeleccionadoId);
										if (textoActual) {
											onActualizarTexto?.(textoSeleccionadoId, { negrita: !textoActual.negrita });
										}
									} else {
										// Cambiar config para el pr√≥ximo texto
										onConfigTextoChange?.({ ...configTexto, negrita: !configTexto.negrita });
									}
								}}
								title="Negrita"
							>
								<strong>B</strong>
							</button>

							{/* Bot√≥n cursiva */}
							<button
								type="button"
								className={`grilla-unifilar__btn grilla-unifilar__btn--formato ${
									configTexto.cursiva ? "grilla-unifilar__btn--activo" : ""
								}`}
								onClick={() => {
									// Si hay textarea abierto (editando o creando), cambiar configTexto
									if (inputTexto.visible) {
										onConfigTextoChange?.({ ...configTexto, cursiva: !configTexto.cursiva });
									} else if (textoSeleccionadoId) {
										// Si hay un texto seleccionado sin textarea, actualizarlo directamente
										const textoActual = textos.find(t => t.id === textoSeleccionadoId);
										if (textoActual) {
											onActualizarTexto?.(textoSeleccionadoId, { cursiva: !textoActual.cursiva });
										}
									} else {
										// Cambiar config para el pr√≥ximo texto
										onConfigTextoChange?.({ ...configTexto, cursiva: !configTexto.cursiva });
									}
								}}
								title="Cursiva"
							>
								<em>I</em>
							</button>

							{/* Eliminar texto seleccionado */}
							{textoSeleccionadoId && (
								<button
									type="button"
									className="grilla-unifilar__btn grilla-unifilar__btn--peligro"
									onClick={() => onEliminarTexto?.(textoSeleccionadoId)}
									title="Eliminar texto (Delete)"
								>
									<svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
										<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
									</svg>
								</button>
							)}
						</div>
					)}

					{/* Panel de configuraci√≥n de chispas */}
					{panelChispasVisible && (
						<div className="grilla-unifilar__panel-chispas">
							<div className="grilla-unifilar__panel-header">
								<div className="grilla-unifilar__panel-titulo">Configuraci√≥n de Chispas</div>
								<div className="grilla-unifilar__panel-info-inline">
									Emisores: {bornes.filter(b => b.tipo === "EMISOR").length} | Receptores: {bornes.filter(b => b.tipo === "RECEPTOR").length}
								</div>
							</div>

							<div className="grilla-unifilar__panel-columnas">
								{/* === COLUMNA IZQUIERDA === */}
								<div className="grilla-unifilar__panel-columna">
									{/* Forma y Color en fila */}
									<div className="grilla-unifilar__panel-fila">
										<div className="grilla-unifilar__panel-campo grilla-unifilar__panel-campo--flex">
											<label>Forma:</label>
											<select
												className="grilla-unifilar__panel-select"
												value={chispasConfig.forma || "circulo"}
												onChange={(e) => onActualizarChispasConfig?.({ forma: e.target.value })}
											>
												<option value="circulo">C√≠rculo</option>
												<option value="cuadrado">Cuadrado</option>
												<option value="estrella">Estrella</option>
												<option value="rayo">Rayo</option>
												<option value="flecha">Flecha</option>
												<option value="gota">Gota</option>
												<option value="anillo">Anillo</option>
												<option value="barra">Barra |</option>
											</select>
										</div>
										<div className="grilla-unifilar__panel-campo grilla-unifilar__panel-campo--color">
											<label>Color:</label>
											<input
												type="color"
												value={chispasConfig.color || "#fef08a"}
												onChange={(e) => onActualizarChispasConfig?.({ color: e.target.value })}
											/>
										</div>
									</div>

									{/* Tama√±o */}
									<div className="grilla-unifilar__panel-campo">
										<label>Tama√±o:</label>
										<div className="grilla-unifilar__panel-slider-input">
											<input
												type="range"
												min="2"
												max="10"
												value={chispasConfig.tamano || 4}
												onChange={(e) => onActualizarChispasConfig?.({ tamano: Number(e.target.value) })}
											/>
											<input
												type="number"
												className="grilla-unifilar__panel-number"
												min="2"
												max="10"
												value={chispasConfig.tamano || 4}
												onChange={(e) => {
													const val = Math.min(10, Math.max(2, Number(e.target.value) || 2));
													onActualizarChispasConfig?.({ tamano: val });
												}}
												onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
											/>
											<span className="grilla-unifilar__panel-unidad">px</span>
										</div>
									</div>

									{/* Velocidad */}
									<div className="grilla-unifilar__panel-campo">
										<label>Velocidad:</label>
										<div className="grilla-unifilar__panel-slider-input">
											<input
												type="range"
												min="1"
												max="20"
												value={chispasConfig.velocidad || 8}
												onChange={(e) => onActualizarChispasConfig?.({ velocidad: Number(e.target.value) })}
											/>
											<input
												type="number"
												className="grilla-unifilar__panel-number"
												min="1"
												max="20"
												value={chispasConfig.velocidad || 8}
												onChange={(e) => {
													const val = Math.min(20, Math.max(1, Number(e.target.value) || 1));
													onActualizarChispasConfig?.({ velocidad: val });
												}}
												onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
											/>
											<span className="grilla-unifilar__panel-unidad">cel/s</span>
										</div>
									</div>
								</div>

								{/* === COLUMNA DERECHA === */}
								<div className="grilla-unifilar__panel-columna">
									{/* Intervalo entre emisiones (en segundos) */}
									<div className="grilla-unifilar__panel-campo">
										<label>Intervalo:</label>
										<div className="grilla-unifilar__panel-slider-input">
											<input
												type="range"
												min="0.3"
												max="5"
												step="0.1"
												value={(chispasConfig.frecuenciaEmision || 2000) / 1000}
												onChange={(e) => onActualizarChispasConfig?.({ frecuenciaEmision: Math.round(Number(e.target.value) * 1000) })}
											/>
											<input
												type="number"
												className="grilla-unifilar__panel-number"
												min="0.3"
												max="5"
												step="0.1"
												value={((chispasConfig.frecuenciaEmision || 2000) / 1000).toFixed(1)}
												onChange={(e) => {
													const val = Math.min(5, Math.max(0.3, Number(e.target.value) || 0.3));
													onActualizarChispasConfig?.({ frecuenciaEmision: Math.round(val * 1000) });
												}}
												onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
											/>
											<span className="grilla-unifilar__panel-unidad">seg</span>
										</div>
									</div>

									{/* Estela checkbox + longitud */}
									<div className="grilla-unifilar__panel-campo grilla-unifilar__panel-campo--checkbox">
										<label>
											<input
												type="checkbox"
												checked={chispasConfig.estela !== false}
												onChange={(e) => onActualizarChispasConfig?.({ estela: e.target.checked })}
											/>
											Mostrar estela
										</label>
									</div>

									{/* Longitud estela */}
									{chispasConfig.estela !== false && (
										<div className="grilla-unifilar__panel-campo">
											<label>Longitud:</label>
											<div className="grilla-unifilar__panel-slider-input">
												<input
													type="range"
													min="1"
													max="10"
													value={chispasConfig.longitudEstela || 5}
													onChange={(e) => onActualizarChispasConfig?.({ longitudEstela: Number(e.target.value) })}
												/>
												<input
													type="number"
													className="grilla-unifilar__panel-number"
													min="1"
													max="10"
													value={chispasConfig.longitudEstela || 5}
													onChange={(e) => {
														const val = Math.min(10, Math.max(1, Number(e.target.value) || 1));
														onActualizarChispasConfig?.({ longitudEstela: val });
													}}
													onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
												/>
												<span className="grilla-unifilar__panel-unidad">celdas</span>
											</div>
										</div>
									)}
								</div>
							</div>
						</div>
					)}

					{/* Indicador de Shift */}
					{herramienta === "pincel" && shiftPresionado && (
						<div className="grilla-unifilar__shift-indicator">
							L√≠nea recta
						</div>
					)}

					{/* Bot√≥n cerrar */}
					<button
						type="button"
						className="grilla-unifilar__btn grilla-unifilar__btn--cerrar"
						onClick={onCerrarEdicion}
						title="Finalizar edici√≥n"
					>
						<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
							<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
						</svg>
						<span>Listo</span>
					</button>
				</div>
			)}
		</div>
	);
};

export default GrillaUnifilar;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/tarjetas/GrupoMedidores.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/tarjetas/GrupoMedidores.jsx

import React from "react"; 

/**
 * Renderiza un grupo de cajas de medici√≥n (parte superior o inferior).
 */
const GrupoMedidores = ({ titulo, boxes, zona, renderizarCaja, estiloTitulo, gap }) => {     // zona: "sup" o "inf"
	// Estilo del contenedor de boxes (gap din√°mico)
	const estiloMeters = gap ? { gap } : {};

	return (
		<div className="alim-card-section">
			<h3
				className="alim-card-section-title"
				style={estiloTitulo || {}}
			>{titulo}</h3>            {/* t√≠tulo del bloque (ej: CONSUMO, TENSI√ìN) */}
			<div
				className="alim-card-meters"
				style={Object.keys(estiloMeters).length > 0 ? estiloMeters : undefined}
			>
				{boxes.map((box, idx) => renderizarCaja(box, idx, zona))}     {/* delega el render de cada CajaMedicion */}
			</div>
		</div>
	);
};

export default GrupoMedidores;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (GrupoMedidores.jsx)

 - Este componente es un contenedor: solo recibe `titulo`, `boxes` y una
   funci√≥n `renderizarCaja` y se encarga de ordenarlos dentro del layout de la
   tarjeta (`alim-card-section` / `alim-card-meters`).

 - La prop `zona` sirve para que el renderizador de cajas sepa si est√° dibujando
   la parte superior ("sup") o inferior ("inf") de la tarjeta.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (GrupoMedidores.jsx)

0) Visi√≥n general del componente

   `GrupoMedidores` es un componente muy simple que act√∫a como contenedor de un
   bloque de mediciones dentro de la tarjeta de alimentador.

   Pod√©s verlo como ‚Äúla fila‚Äù que contiene:
     - un t√≠tulo (por ejemplo: ‚ÄúCONSUMO (A)‚Äù o ‚ÄúTENSI√ìN (kV)‚Äù),
     - una serie de cajas de medici√≥n (`CajaMedicion`) ordenadas en una l√≠nea.

   No sabe de d√≥nde vienen los datos ni c√≥mo se dibuja cada caja; solo recibe
   todo por props y lo coloca en el layout correcto.


1) Props del componente

   const GrupoMedidores = ({ titulo, boxes, zona, renderizarCaja }) => { ... }

   - `titulo` (string):
       ‚Ä¢ texto que se muestra arriba del grupo,
       ‚Ä¢ ejemplos: ‚ÄúCONSUMO (A)‚Äù, ‚ÄúTENSI√ìN (kV)‚Äù, ‚ÄúPOTENCIAS‚Äù, etc.

   - `boxes` (array):
       ‚Ä¢ lista de objetos de caja ya normalizados,
       ‚Ä¢ t√≠picamente cada `box` tiene:
           - `etiqueta`  ‚Üí texto de cabecera de la caja,
           - `valor`     ‚Üí valor a mostrar,
           - `enabled`   ‚Üí si est√° activa o no,
           - `origen`    ‚Üí de d√≥nde viene la medici√≥n (rel√© / analizador).

       ‚Ä¢ Este componente NO modifica ni interpreta ese contenido,
         solo los recorre para dibujarlos.

   - `zona` (string):
       ‚Ä¢ indica si este grupo pertenece a:
           - "sup" ‚Üí parte superior de la tarjeta,
           - "inf" ‚Üí parte inferior de la tarjeta.
       ‚Ä¢ Se le pasa al renderizador de cajas para que pueda ajustar estilos/
         l√≥gica seg√∫n la zona si es necesario.

   - `renderizarCaja` (funci√≥n):
       ‚Ä¢ funci√≥n que sabe c√≥mo transformar `{ box, idx, zona }` en un elemento
         React (normalmente una `CajaMedicion`).
       ‚Ä¢ Firma t√≠pica: `(box, idx, zona) => <CajaMedicion ... />`
       ‚Ä¢ La idea es que `GrupoMedidores` no tenga que conocer los detalles de
         `CajaMedicion`; solo delega el trabajo.


2) JSX del componente

   return (
     <div className="alim-card-section">
       <h3 className="alim-card-section-title">{titulo}</h3>
       <div className="alim-card-meters">
         {boxes.map((box, idx) => renderizarCaja(box, idx, zona))}
       </div>
     </div>
   );

   2.1) Contenedor principal

   - `<div className="alim-card-section">`:
       ‚Ä¢ envuelve todo el bloque (t√≠tulo + cajas),
       ‚Ä¢ la clase se usa en CSS para dar m√°rgenes, separaci√≥n vertical, etc.

   2.2) T√≠tulo de la secci√≥n

   - `<h3 className="alim-card-section-title">{titulo}</h3>`:
       ‚Ä¢ muestra el t√≠tulo que se pas√≥ por props,
       ‚Ä¢ sirve como encabezado visual del grupo de medidores.

   2.3) Contenedor de cajas

   - `<div className="alim-card-meters">`:
       ‚Ä¢ contenedor donde se colocan las cajas de medici√≥n,
       ‚Ä¢ normalmente se renderizan en fila o grilla seg√∫n el CSS.

   - `{boxes.map((box, idx) => renderizarCaja(box, idx, zona))}`:
       ‚Ä¢ recorre el array `boxes`,
       ‚Ä¢ por cada elemento llama a `renderizarCaja(box, idx, zona)`,
       ‚Ä¢ `renderizarCaja` devuelve el JSX de la caja (por ejemplo, `CajaMedicion`),
       ‚Ä¢ de esta forma:
           - `GrupoMedidores` no est√° atado a un tipo de caja espec√≠fico,
           - solo se encarga de ‚Äúinvocar‚Äù al renderizador en el orden correcto.


3) Export

   export default GrupoMedidores;

   - Exporta el componente para ser usado dentro de `TarjetaAlimentador`.
   - La tarjeta crea los objetos `sup` e `inf` (con `titulo` y `boxes`) y
     luego se los pasa a `GrupoMedidores` para que los dibuje.

---------------------------------------------------------------------------*/
========== mi-app/src/paginas/PaginaAlimentadores/componentes/tarjetas/RowGapResizer.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/tarjetas/RowGapResizer.jsx

import React, { useState, useRef, useEffect, useCallback } from "react";
import "./RowGapResizer.css";

/**
 * Componente que permite ajustar el gap vertical entre filas de tarjetas.
 * Aparece como una l√≠nea horizontal con un c√≠rculo al hacer hover entre filas.
 *
 * Comportamiento:
 * - Al hacer hover sobre el handle: aparece la barra de gap con el valor actual
 * - Al arrastrar con click izquierdo: ajusta el gap visualmente (movimiento vertical)
 * - Al hacer doble click: se habilita la edici√≥n manual del input
 * - Enter o click fuera del input: confirma el valor y oculta la barra
 * - Escape: cancela y oculta la barra
 *
 * @param {number} gap - Gap actual en p√≠xeles
 * @param {function} onGapChange - Callback (nuevoGap)
 * @param {number} rowIndex - √çndice de la fila (0 = primera fila, separaci√≥n del men√∫)
 */
const RowGapResizer = ({ gap, onGapChange, rowIndex, minGap = 0, maxGap = 400 }) => {
	const [isHovered, setIsHovered] = useState(false);
	const [isDragging, setIsDragging] = useState(false);
	const [isEditing, setIsEditing] = useState(false);
	const [inputValue, setInputValue] = useState(gap);
	const inputRef = useRef(null);
	const containerRef = useRef(null);
	const hitboxRef = useRef(null);
	const startYRef = useRef(0);
	const startGapRef = useRef(gap);

	// Actualizar inputValue cuando cambia el gap desde afuera
	useEffect(() => {
		if (!isEditing) {
			setInputValue(gap);
		}
	}, [gap, isEditing]);

	// Detectar clicks fuera del componente para cerrar
	useEffect(() => {
		const handleClickOutside = (e) => {
			if (containerRef.current && !containerRef.current.contains(e.target)) {
				if (!isEditing) {
					setIsHovered(false);
				}
			}
		};

		if (isHovered && !isEditing) {
			document.addEventListener('mousedown', handleClickOutside);
		}

		return () => {
			document.removeEventListener('mousedown', handleClickOutside);
		};
	}, [isHovered, isEditing]);

	// ===== DRAG HANDLERS =====
	const handleMouseDown = useCallback((e) => {
		if (e.button !== 0) return;
		e.preventDefault();
		e.stopPropagation();
		setIsDragging(true);
		startYRef.current = e.clientY;
		startGapRef.current = gap;
	}, [gap]);

	const handleMouseMove = useCallback((e) => {
		if (!isDragging) return;

		const deltaY = e.clientY - startYRef.current;
		// Cada 2px de movimiento = 1px de gap
		const newGap = Math.round(startGapRef.current + deltaY / 2);
		const clampedGap = Math.max(minGap, Math.min(maxGap, newGap));

		onGapChange(clampedGap);
		setInputValue(clampedGap);
	}, [isDragging, minGap, maxGap, onGapChange]);

	const handleMouseUp = useCallback((e) => {
		setIsDragging(false);

		// Verificar si el mouse est√° fuera del hitbox al soltar
		if (hitboxRef.current) {
			const rect = hitboxRef.current.getBoundingClientRect();
			const mouseX = e.clientX;
			const mouseY = e.clientY;
			const isOutside =
				mouseX < rect.left ||
				mouseX > rect.right ||
				mouseY < rect.top ||
				mouseY > rect.bottom;

			if (isOutside && !isEditing) {
				setIsHovered(false);
			}
		}
	}, [isEditing]);

	// Doble click para activar modo edici√≥n
	const handleDoubleClick = useCallback((e) => {
		e.preventDefault();
		e.stopPropagation();
		setIsEditing(true);
		setInputValue(gap);
	}, [gap]);

	// Agregar/remover listeners globales para el drag
	useEffect(() => {
		if (isDragging) {
			window.addEventListener("mousemove", handleMouseMove);
			window.addEventListener("mouseup", handleMouseUp);
		}
		return () => {
			window.removeEventListener("mousemove", handleMouseMove);
			window.removeEventListener("mouseup", handleMouseUp);
		};
	}, [isDragging, handleMouseMove, handleMouseUp]);

	// ===== INPUT HANDLERS =====
	const handleValueClick = (e) => {
		e.stopPropagation();
		if (!isDragging) {
			setIsEditing(true);
			setInputValue(gap);
		}
	};

	useEffect(() => {
		if (isEditing && inputRef.current) {
			inputRef.current.focus();
			inputRef.current.select();
		}
	}, [isEditing]);

	const handleInputChange = (e) => {
		setInputValue(e.target.value);
	};

	const confirmarValor = () => {
		const numValue = parseInt(inputValue, 10);
		if (!isNaN(numValue)) {
			const clampedGap = Math.max(minGap, Math.min(maxGap, numValue));
			onGapChange(clampedGap);
			setInputValue(clampedGap);
		} else {
			setInputValue(gap);
		}
		setIsEditing(false);
	};

	const handleInputBlur = () => {
		confirmarValor();
		setIsHovered(false);
	};

	const handleInputKeyDown = (e) => {
		if (e.key === "Enter") {
			e.preventDefault();
			confirmarValor();
			setIsHovered(false);
		} else if (e.key === "Escape") {
			setInputValue(gap);
			setIsEditing(false);
			setIsHovered(false);
		}
	};

	const isActive = isHovered || isDragging || isEditing;

	return (
		<div
			ref={containerRef}
			className={`row-gap-resizer ${isActive ? "row-gap-resizer--active" : ""}`}
			style={{ height: `${gap}px` }}
		>
			<div className="row-gap-resizer__track">
				<div className="row-gap-resizer__handle-wrapper">
					{/* Zona de hitbox invisible */}
					<div
						ref={hitboxRef}
						className="row-gap-resizer__hitbox"
						onMouseEnter={() => setIsHovered(true)}
						onMouseLeave={() => !isDragging && !isEditing && setIsHovered(false)}
						onMouseDown={handleMouseDown}
						onDoubleClick={handleDoubleClick}
					/>
					{/* Handle visual */}
					<div
						className={`row-gap-resizer__handle ${isDragging ? "row-gap-resizer__handle--dragging" : ""}`}
						title="Arrastra para ajustar el espaciado vertical"
					>
						<div className="row-gap-resizer__line" />
						<div className="row-gap-resizer__circle" />
						<div className="row-gap-resizer__line" />
					</div>
				</div>

				{isActive && (
					<div className="row-gap-resizer__input-container">
						{isEditing ? (
							<input
								ref={inputRef}
								type="number"
								className="row-gap-resizer__input"
								value={inputValue}
								onChange={handleInputChange}
								onBlur={handleInputBlur}
								onKeyDown={handleInputKeyDown}
								min={minGap}
								max={maxGap}
							/>
						) : (
							<span
								className="row-gap-resizer__value"
								onClick={handleValueClick}
								title="Click para editar"
							>
								{gap}px
							</span>
						)}
					</div>
				)}
			</div>
		</div>
	);
};

export default RowGapResizer;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/tarjetas/SkeletonCard.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/tarjetas/SkeletonCard.jsx
// Componente skeleton (esqueleto) que se muestra mientras se carga/guarda un alimentador

import React from "react";
import "./SkeletonCard.css";

const SkeletonCard = () => {
	return (
		<div className="skeleton-card">
			{/* Header de la tarjeta - botones a la izquierda, t√≠tulo a la derecha */}
			<div className="skeleton-header">
				<div className="skeleton-buttons">
					<div className="skeleton-button-square"></div>
					<div className="skeleton-button-square"></div>
				</div>
				<div className="skeleton-title"></div>
			</div>

			{/* Parte superior (ej: Corriente) */}
			<div className="skeleton-section">
				<div className="skeleton-section-title"></div>
				<div className="skeleton-boxes">
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
				</div>
			</div>

			{/* Parte inferior (ej: Tensi√≥n) */}
			<div className="skeleton-section">
				<div className="skeleton-section-title"></div>
				<div className="skeleton-boxes">
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
				</div>
			</div>
		</div>
	);
};

export default SkeletonCard;

========== mi-app/src/paginas/PaginaAlimentadores/componentes/tarjetas/TarjetaAlimentador.jsx ==========
// src/paginas/PaginaAlimentadores/componentes/tarjetas/TarjetaAlimentador.jsx

import React, { useEffect, useRef, useState } from "react";   // React + hooks para estado y refs
import { createPortal } from "react-dom";
import "./TarjetaAlimentador.css";                            // estilos visuales de la tarjeta
import configIcon from "../../../../assets/imagenes/Config_Icon.png"; // icono de configuraci√≥n (tuerca)
import CajaMedicion from "./CajaMedicion.jsx";                // box individual de medici√≥n
import GrupoMedidores from "./GrupoMedidores.jsx";            // grupo de cajas (parte superior/inferior)
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion"; // para estilos globales

// Helper que prepara la estructura de un lado de la tarjeta (sup/inf)
const construirLado = (side, tituloDefault) => {                         // side: config del lado, tituloDefault: texto por defecto
  const cajasPorDefecto = ["R", "S", "T"].map((label) => ({              // arma 3 cajas por defecto (R, S, T)
    etiqueta: label,                                                     // etiqueta visible arriba del box
    valor: "--,--",                                                      // valor inicial cuando no hay lectura
    enabled: false,                                                      // por defecto la caja no est√° habilitada
    origen: null,                                                        // origen a√∫n no definido (rele/analizador)
  }));

  if (!side) {                                                           // si no hay configuraci√≥n para este lado...
    return {
      titulo: tituloDefault,                                             // usa el t√≠tulo por defecto
      boxes: cajasPorDefecto,                                           // y las cajas b√°sicas
      oculto: false,                                                     // por defecto no est√° oculto
    };
  }

  const titulo =
    (side.titulo && String(side.titulo).trim()) || tituloDefault;       // toma el t√≠tulo de la config o cae al default
  const oculto = !!side.oculto;                                          // si est√° marcado como oculto

  let boxes = Array.isArray(side.boxes) ? side.boxes : [];              // garantiza que boxes sea un array
  boxes = boxes.slice(0, 4);                                            // m√°ximo 4 cajas por lado

  if (boxes.length === 0) {                                             // si no hay ninguna caja configurada...
    boxes = cajasPorDefecto;                                            // usa las 3 por defecto
  } else {
    boxes = boxes.map((b, idx) => ({
      etiqueta:
        (b?.etiqueta && String(b.etiqueta).trim()) ||                   // etiqueta personalizada si existe
        `Box ${idx + 1}`,                                               // si no, "Box 1", "Box 2", etc.
      valor:
        b?.valor == null || b.valor === ""                              // si no hay valor num√©rico v√°lido...
          ? "--,--"                                                     // muestra placeholder
          : String(b.valor),                                            // convierte el valor a string
      enabled: !!b?.enabled,                                            // fuerza a booleano (true/false)
      origen: b?.origen || null,                                        // origen de datos o null si no est√° definido
    }));
  }

  return { titulo, boxes, oculto };                                     // devuelve t√≠tulo final, lista de cajas y si est√° oculto
};

const TarjetaAlimentador = ({
  nombre,
  color,
  onConfigClick,           // abre modal de configuraci√≥n del alimentador
  onHistorialClick,        // abre modal de historial de lecturas
  esObservador = false,    // si true, oculta el bot√≥n de estad√≠sticas (rol observador)
  topSide,                 // dise√±o + valores para la parte superior
  bottomSide,              // dise√±o + valores para la parte inferior
  draggable = false,       // si la tarjeta se puede arrastrar
  isDragging = false,      // estado visual mientras se arrastra
  onDragStart,
  onDragOver,
  onDrop,
  onDragEnd,

  // Info de mediciones y periodos
  mideRele = false,
  mideAnalizador = false,
  periodoRele = 60,
  periodoAnalizador = 60,
  timestampInicioRele = null,          // (reservado por si se usan futuras animaciones)
  timestampInicioAnalizador = null,    // idem
  contadorRele = 0,                    // n√∫mero de lecturas realizadas para rel√©
  contadorAnalizador = 0,              // n√∫mero de lecturas realizadas para analizador

  // Play/Stop para polling de lecturas
  estaPolling = false,                 // indica si est√° activo el polling de lecturas
  puedePolling = false,                // indica si la card tiene config completa para polling
  onPlayStopClick,                     // callback para iniciar/detener polling
  contadorPolling = 0,                 // n√∫mero de lecturas realizadas durante polling
  periodoPolling = 60,                 // periodo de polling en segundos (para animaci√≥n)
  errorPolling = null,                 // { mensaje, timestamp } si hay error de lectura

  // Escala de la tarjeta
  escala = 1.0,                        // escala efectiva a aplicar (ya calculada)
  onEscalaChange,                      // callback para cambiar escala individual
  ESCALA_MIN = 0.5,                    // l√≠mites de escala
  ESCALA_MAX = 2.0,
}) => {
  // Obtener estilos globales del contexto
  const { estilosGlobales } = usarContextoConfiguracion();

  // Control local de animaciones de borde: solo se activan tras recibir una lectura
  const [mostrarProgresoRele, setMostrarProgresoRele] = useState(false);
  const [mostrarProgresoAnalizador, setMostrarProgresoAnalizador] =
    useState(false);
  const [mostrarProgresoPolling, setMostrarProgresoPolling] = useState(false);
  const [cicloPolling, setCicloPolling] = useState(0); // contador local para reiniciar animaci√≥n de barra
  const ultimoContadorReleRef = useRef(contadorRele);
  const ultimoContadorAnalizadorRef = useRef(contadorAnalizador);
  const ultimoContadorPollingRef = useRef(contadorPolling);

  // Control del popover de escala
  const [mostrarPopoverEscala, setMostrarPopoverEscala] = useState(false);
  const [posicionPopover, setPosicionPopover] = useState({ top: 0, left: 0 });
  const [valorEscalaInput, setValorEscalaInput] = useState(escala.toString());
  const triangleRef = useRef(null);
  const popoverRef = useRef(null);

  // Control del men√∫ desplegable de opciones
  const [menuAbierto, setMenuAbierto] = useState(false);
  const menuRef = useRef(null);
  const cardRef = useRef(null);

  // Si se cambia de puesto o se detiene la medici√≥n de rel√©, resetea la animaci√≥n
  useEffect(() => {
    if (!mideRele) {
      setMostrarProgresoRele(false);
      ultimoContadorReleRef.current = contadorRele;
      return;
    }

    if (contadorRele !== ultimoContadorReleRef.current) {
      ultimoContadorReleRef.current = contadorRele;
      setMostrarProgresoRele(contadorRele > 0);
    }
  }, [contadorRele, mideRele]);

  // Idem para el analizador
  useEffect(() => {
    if (!mideAnalizador) {
      setMostrarProgresoAnalizador(false);
      ultimoContadorAnalizadorRef.current = contadorAnalizador;
      return;
    }

    if (contadorAnalizador !== ultimoContadorAnalizadorRef.current) {
      ultimoContadorAnalizadorRef.current = contadorAnalizador;
      setMostrarProgresoAnalizador(contadorAnalizador > 0);
    }
  }, [contadorAnalizador, mideAnalizador]);

  // Control de animaci√≥n para polling de lecturas desde BD
  // El contador se incrementa 1 vez por ciclo desde VistaAlimentadores
  useEffect(() => {
    if (!estaPolling) {
      setMostrarProgresoPolling(false);
      ultimoContadorPollingRef.current = contadorPolling;
      return;
    }

    if (contadorPolling !== ultimoContadorPollingRef.current) {
      ultimoContadorPollingRef.current = contadorPolling;
      setMostrarProgresoPolling(contadorPolling > 0);
      // Incrementar cicloPolling para reiniciar la animaci√≥n de la barra
      setCicloPolling(prev => prev + 1);
    }
  }, [contadorPolling, estaPolling]);

  // Sincronizar input con escala cuando cambia externamente
  useEffect(() => {
    setValorEscalaInput(escala.toString());
  }, [escala]);

  // Toggle del popover de escala
  const togglePopoverEscala = (e) => {
    e.stopPropagation();
    if (mostrarPopoverEscala) {
      setMostrarPopoverEscala(false);
      return;
    }
    if (triangleRef.current) {
      const rect = triangleRef.current.getBoundingClientRect();
      setPosicionPopover({
        top: rect.bottom + 8,
        left: rect.left + rect.width / 2 - 60, // centrar popover (120px / 2)
      });
      setMostrarPopoverEscala(true);
    }
  };

  // Cerrar popover al hacer click fuera
  useEffect(() => {
    if (!mostrarPopoverEscala) return;
    const handleClickOutside = (event) => {
      if (
        popoverRef.current &&
        !popoverRef.current.contains(event.target) &&
        triangleRef.current &&
        !triangleRef.current.contains(event.target)
      ) {
        setMostrarPopoverEscala(false);
      }
    };
    const timeoutId = setTimeout(() => {
      document.addEventListener("mousedown", handleClickOutside);
    }, 10);
    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [mostrarPopoverEscala]);

  // Cerrar men√∫ desplegable al hacer click fuera o al hacer scroll
  useEffect(() => {
    if (!menuAbierto) return;
    const handleClickOutside = (event) => {
      if (
        menuRef.current &&
        !menuRef.current.contains(event.target) &&
        cardRef.current &&
        !cardRef.current.querySelector(".alim-card-menu-toggle")?.contains(event.target)
      ) {
        setMenuAbierto(false);
      }
    };
    // Cerrar al hacer scroll con la rueda del rat√≥n
    const handleWheel = () => {
      setMenuAbierto(false);
    };
    const timeoutId = setTimeout(() => {
      document.addEventListener("mousedown", handleClickOutside);
      window.addEventListener("wheel", handleWheel, { passive: true });
    }, 10);
    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener("mousedown", handleClickOutside);
      window.removeEventListener("wheel", handleWheel);
    };
  }, [menuAbierto]);

  // Estado para posici√≥n del men√∫ flotante
  const [posicionMenu, setPosicionMenu] = useState({ top: 0, left: 0, width: 0 });

  // Toggle del men√∫ desplegable
  const toggleMenu = (e) => {
    e.stopPropagation();
    if (!menuAbierto && cardRef.current) {
      const rect = cardRef.current.getBoundingClientRect();
      const alturaMenu = 48; // altura aproximada del men√∫
      const separacion = 3; // separaci√≥n entre men√∫ y card
      setPosicionMenu({
        top: rect.top - alturaMenu - separacion, // arriba del header con separaci√≥n
        left: rect.left,
        width: rect.width,
      });
    }
    setMenuAbierto(!menuAbierto);
  };

  // Aplicar escala inmediatamente al cambiar el input
  const handleEscalaInputChange = (e) => {
    const valorStr = e.target.value;
    setValorEscalaInput(valorStr);

    // Aplicar inmediatamente si es un valor v√°lido
    const valor = parseFloat(valorStr);
    if (!isNaN(valor) && valor >= ESCALA_MIN && valor <= ESCALA_MAX) {
      onEscalaChange?.(valor);
    }
  };

  // Cerrar con Escape
  const handleEscalaKeyDown = (e) => {
    if (e.key === "Escape") {
      setMostrarPopoverEscala(false);
    }
  };

  // Incrementar escala
  const handleIncrementarEscala = () => {
    const valorActual = parseFloat(valorEscalaInput) || escala;
    const nuevoValor = Math.min(ESCALA_MAX, Math.round((valorActual + 0.01) * 100) / 100);
    setValorEscalaInput(nuevoValor.toString());
    onEscalaChange?.(nuevoValor);
  };

  // Decrementar escala
  const handleDecrementarEscala = () => {
    const valorActual = parseFloat(valorEscalaInput) || escala;
    const nuevoValor = Math.max(ESCALA_MIN, Math.round((valorActual - 0.01) * 100) / 100);
    setValorEscalaInput(nuevoValor.toString());
    onEscalaChange?.(nuevoValor);
  };

  // Resetear escala a 1.0
  const handleResetearEscala = () => {
    setValorEscalaInput("1");
    onEscalaChange?.(1.0);
  };

  // Armar lados de la tarjeta con valores por defecto si no hay dise√±o
  const sup = construirLado(topSide, "CONSUMO (A)");
  const inf = construirLado(bottomSide, "TENSI√ìN (kV)");

  // Detectar si alg√∫n lado tiene 4 boxes (para ensanchar la tarjeta)
  const maxBoxes = Math.max(sup.boxes.length, inf.boxes.length);
  const isWide = maxBoxes >= 4;

  // Determinar si hay error en cada zona
  // errorPolling tiene: { superior, inferior } para mostrar "ERROR" en boxes (desde 1er error)
  //                     { superiorCritico, inferiorCritico } para mostrar overlay (3+ errores)
  const errorSuperior = errorPolling?.superior || false;
  const errorInferior = errorPolling?.inferior || false;
  const tieneAlgunError = errorSuperior || errorInferior;

  // Para el overlay: solo mostrar cuando hay 3+ errores consecutivos
  const errorSuperiorCritico = errorPolling?.superiorCritico || false;
  const errorInferiorCritico = errorPolling?.inferiorCritico || false;
  const tieneErrorCritico = errorSuperiorCritico || errorInferiorCritico;

  // Armar clases de la card
  const clasesCard = ["alim-card"];
  if (isWide) clasesCard.push("alim-card-wide");
  if (isDragging) clasesCard.push("alim-card-dragging");
  if (tieneErrorCritico) clasesCard.push("alim-card-error"); // borde rojo solo cuando es cr√≠tico

  const renderizarCaja = (box, idx, zona) => {
    // Determinar si esta zona tiene error
    const zonaConError = zona === "sup" ? errorSuperior : errorInferior;
    return (
      <CajaMedicion
        key={`${zona}-${idx}`}                                           // key estable por lado e √≠ndice
        box={box}                                                        // datos de la caja (etiqueta, valor, enabled, origen)
        indice={idx}                                                     // posici√≥n dentro del grupo
        zona={zona}                                                      // identifica si la caja es superior o inferior
        mideRele={mideRele}                                              // indica si hay medici√≥n de rel√© activa
        mideAnalizador={mideAnalizador}                                  // indica si hay medici√≥n de analizador activa
        mostrarProgresoRele={mostrarProgresoRele}                        // controla animaci√≥n de borde del rel√©
        mostrarProgresoAnalizador={mostrarProgresoAnalizador}            // controla animaci√≥n de borde del analizador
        periodoRele={periodoRele}                                        // periodo configurado para rel√©
        periodoAnalizador={periodoAnalizador}                            // periodo configurado para analizador
        contadorRele={contadorRele}                                      // contador de lecturas del rel√©
        contadorAnalizador={contadorAnalizador}                          // contador de lecturas del analizador
        // Polling de lecturas desde BD
        estaPolling={estaPolling}                                        // indica si hay polling activo
        mostrarProgresoPolling={mostrarProgresoPolling}                  // controla animaci√≥n de borde del polling
        periodoPolling={periodoPolling}                                  // periodo de polling en segundos
        contadorPolling={contadorPolling}                                // contador de lecturas de polling
        // Error de polling por zona
        tieneError={zonaConError}                                        // indica si esta zona tiene error de lectura
        // Estilos globales para box
        estilosBox={{
          tituloBox: {
            fontFamily: estilosGlobales?.tituloBox?.fontFamily || "inherit",
            fontSize: estilosGlobales?.tituloBox?.fontSize || "1rem",
          },
          valorBox: {
            fontFamily: estilosGlobales?.valorBox?.fontFamily || "'DS-Digital', 'Courier New', monospace",
            fontSize: estilosGlobales?.valorBox?.fontSize || "1.5rem",
            color: estilosGlobales?.valorBox?.color || "#ffff00",
            decimales: estilosGlobales?.valorBox?.decimales ?? 2,
          },
          box: {
            width: estilosGlobales?.box?.width || "80px",
            height: estilosGlobales?.box?.height || "auto",
          },
        }}
      />
    );
  };

  // Determinar si la escala es diferente al default (para mostrar indicador)
  const escalaModificada = escala !== 1.0;

  // Calcular estilos de escala para el contenedor
  const estiloEscala = escala !== 1.0 ? {
    transform: `scale(${escala})`,
    transformOrigin: "top left",
  } : {};

  return (
    <div
      ref={cardRef}
      className={clasesCard.join(" ")}
      style={{
        cursor: draggable ? "grab" : "default",
        ...estiloEscala,
      }}
      draggable={draggable}
      onDragStart={onDragStart}
      onDragOver={onDragOver}
      onDrop={onDrop}
      onDragEnd={onDragEnd}
    >
        {/* Header con nombre y botones de acciones */}
        <div
          className="alim-card-header"
          style={{
            background: `linear-gradient(to right, ${color || "#0ea5e9"}, ${color || "#0ea5e9"}80)`
          }}
        >
          {/* Flecha animada para desplegar men√∫ */}
          <button
            type="button"
            className={`alim-card-menu-toggle ${menuAbierto ? "alim-card-menu-toggle--abierto" : ""}`}
            onClick={toggleMenu}
            title="Opciones"
          >
            <span className="alim-card-menu-arrow">‚ñº</span>
          </button>

          <span
            className="alim-card-title"
            style={{
              fontFamily: estilosGlobales?.header?.fontFamily || "inherit",
              fontSize: estilosGlobales?.header?.fontSize || "1rem",
              fontWeight: estilosGlobales?.header?.fontWeight || 700,
            }}
          >{nombre}</span>
        </div>

        {/* Barra de progreso de polling */}
        {estaPolling && mostrarProgresoPolling && (
          <div className="alim-card-progress-track" key={cicloPolling}>
            <div
              className="alim-card-progress-fill"
              style={{ "--progress-duration": `${periodoPolling}s` }}
            >
              <div className="alim-card-progress-spark" />
            </div>
          </div>
        )}

        {/* Cuerpo con los 2 bloques (superior / inferior) */}
        <div className="alim-card-body">
          {/* ===== PARTE SUPERIOR ===== */}
          {!sup.oculto && (
            <GrupoMedidores
              titulo={sup.titulo}
              boxes={sup.boxes}
              zona="sup"
              renderizarCaja={renderizarCaja}
              estiloTitulo={{
                fontFamily: estilosGlobales?.tituloZona?.fontFamily || "inherit",
                fontSize: estilosGlobales?.tituloZona?.fontSize || "0.8rem",
              }}
              gap={estilosGlobales?.box?.gap}
            />
          )}

          {/* ===== PARTE INFERIOR ===== */}
          {!inf.oculto && (
            <GrupoMedidores
              titulo={inf.titulo}
              boxes={inf.boxes}
              zona="inf"
              renderizarCaja={renderizarCaja}
              estiloTitulo={{
                fontFamily: estilosGlobales?.tituloZona?.fontFamily || "inherit",
                fontSize: estilosGlobales?.tituloZona?.fontSize || "0.8rem",
              }}
              gap={estilosGlobales?.box?.gap}
            />
          )}

          {/* ===== OVERLAY DE ERROR ===== */}
          {/* Mostrar overlay solo cuando hay 3+ errores consecutivos (error cr√≠tico) */}
          {tieneErrorCritico && (
            <div className="alim-card-error-overlay alim-card-error-overlay--parpadeo">
              <div className="alim-card-error-content">
                <span className="alim-card-error-icon">‚ö†</span>
                <span className="alim-card-error-title">ATENCI√ìN</span>
                <span className="alim-card-error-message">Posiblemente fuera de servicio</span>
                <span className="alim-card-error-detail">Las √∫ltimas 3 lecturas no fueron v√°lidas o dieron error</span>
              </div>
            </div>
          )}

          {/* ===== TRI√ÅNGULO DE ESCALA ===== */}
          {/* Posicionado absolutamente dentro del body para no agregar altura */}
          {onEscalaChange && (
            <button
              ref={triangleRef}
              type="button"
              className={`alim-card-scale-btn${escalaModificada ? " alim-card-scale-btn--active" : ""}`}
              onClick={togglePopoverEscala}
              title={`Escala: ${escala}x (click para cambiar)`}
            >
              <span className="alim-card-scale-triangle">‚ñº</span>
              {escalaModificada && (
                <span className="alim-card-scale-value">{escala}x</span>
              )}
            </button>
          )}
        </div>

      {/* Popover de escala (portal) */}
      {mostrarPopoverEscala &&
        createPortal(
          <div
            ref={popoverRef}
            className="alim-card-scale-popover"
            style={{ top: `${posicionPopover.top}px`, left: `${posicionPopover.left}px` }}
            onClick={(e) => e.stopPropagation()}
            onMouseDown={(e) => e.stopPropagation()}
          >
            <label className="alim-card-scale-label">
              Escala ({ESCALA_MIN} - {ESCALA_MAX})
            </label>
            <div className="alim-card-scale-controls">
              <button
                type="button"
                className="alim-card-scale-pm-btn"
                onClick={handleDecrementarEscala}
                disabled={parseFloat(valorEscalaInput) <= ESCALA_MIN}
                title="Reducir escala"
              >
                -
              </button>
              <input
                type="number"
                step="0.01"
                min={ESCALA_MIN}
                max={ESCALA_MAX}
                value={valorEscalaInput}
                onChange={handleEscalaInputChange}
                onKeyDown={handleEscalaKeyDown}
                className="alim-card-scale-input"
                autoFocus
              />
              <button
                type="button"
                className="alim-card-scale-pm-btn"
                onClick={handleIncrementarEscala}
                disabled={parseFloat(valorEscalaInput) >= ESCALA_MAX}
                title="Aumentar escala"
              >
                +
              </button>
            </div>
            <div className="alim-card-scale-actions">
              <button
                type="button"
                className="alim-card-scale-reset"
                onClick={handleResetearEscala}
              >
                Reset (1.0)
              </button>
            </div>
          </div>,
          document.body
        )}

      {/* Men√∫ flotante desplegable (portal) */}
      {menuAbierto &&
        createPortal(
          <div
            ref={menuRef}
            className="alim-card-menu-flotante"
            style={{
              top: `${posicionMenu.top}px`,
              left: `${posicionMenu.left}px`,
              width: `${posicionMenu.width}px`,
            }}
            onClick={(e) => e.stopPropagation()}
            onMouseDown={(e) => e.stopPropagation()}
          >
            <div className="alim-card-menu-flotante-content">
              {/* Bot√≥n de configuraci√≥n */}
              <button
                type="button"
                className="alim-card-menu-flotante-btn"
                onClick={(e) => {
                  e.stopPropagation();
                  setMenuAbierto(false);
                  onConfigClick?.();
                }}
                title="Configurar registrador"
              >
                <img src={configIcon} alt="Configurar" className="alim-card-menu-flotante-icon" />
              </button>

              {/* Bot√≥n de historial/estad√≠sticas (oculto para observadores) */}
              {onHistorialClick && !esObservador && (
                <button
                  type="button"
                  className="alim-card-menu-flotante-btn"
                  onClick={(e) => {
                    e.stopPropagation();
                    setMenuAbierto(false);
                    onHistorialClick();
                  }}
                  title="Ver historial de lecturas"
                >
                  <span className="alim-card-menu-flotante-emoji">üìà</span>
                </button>
              )}
            </div>
          </div>,
          document.body
        )}
    </div>
  );
};

export default TarjetaAlimentador;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (TarjetaAlimentador.jsx)

 - Este componente representa una tarjeta de alimentador (un registrador) con
   dos bloques de mediciones: parte superior e inferior.

 - `construirLado` se encarga de tomar el dise√±o y las lecturas de cada lado y
   devolver siempre una estructura consistente `{ titulo, boxes }`, rellenando
   con valores por defecto si falta informaci√≥n.

 - El estado local `mostrarProgresoRele` / `mostrarProgresoAnalizador` se usa
   para decidir si se dibuja la animaci√≥n de borde en `CajaMedicion`. Solo se
   activa cuando llega al menos una lectura (contador > 0) y se resetea si se
   detiene la medici√≥n o se cambia de puesto.

 - `isWide` y las clases `alim-card`, `alim-card-wide`, `alim-card-dragging`
   controlan el layout y el aspecto visual de la tarjeta en funci√≥n de cu√°ntas
   boxes tiene y si est√° siendo arrastrada.

 - Toda la l√≥gica de mediciones (periodos, contadores, timestamps) viene desde
   el contexto; esta tarjeta solo la usa para decidir qu√© mostrar y c√≥mo
   animarlo.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (TarjetaAlimentador.jsx)

0) Visi√≥n general del componente

   `TarjetaAlimentador` representa visualmente un alimentador (registrador) en la grilla:

   - Muestra un encabezado con:
       ‚Ä¢ nombre del alimentador,
       ‚Ä¢ bot√≥n de configuraci√≥n (tuerca),
       ‚Ä¢ bot√≥n de mapeo (√≠cono de mapas).

   - En el cuerpo muestra dos bloques de medici√≥n:
       ‚Ä¢ parte superior (`topSide`) ‚Üí t√≠picamente corrientes (A),
       ‚Ä¢ parte inferior (`bottomSide`) ‚Üí t√≠picamente tensiones (kV).

   - Cada bloque est√° compuesto por cajas (`CajaMedicion`) agrupadas por `GrupoMedidores`,
     y puede tener hasta 4 boxes por fila.

   - Adem√°s:
       ‚Ä¢ puede ser arrastrable (drag & drop) para reordenar tarjetas,
       ‚Ä¢ reacciona al estado de mediciones (rel√© / analizador) para animar bordes de progreso.


1) Helper construirLado

   const construirLado = (side, tituloDefault) => { ... }

   - Par√°metros:
       ‚Ä¢ `side`: objeto de configuraci√≥n del lado (sup/inf) que viene del mapeo.
       ‚Ä¢ `tituloDefault`: texto por defecto a usar como t√≠tulo si no hay uno configurado.

   - Crea primero un set de cajas por defecto:

     const cajasPorDefecto = ["R", "S", "T"].map((label) => ({
       etiqueta: label,
       valor: "--,--",
       enabled: false,
       origen: null,
     }));

     - Tres cajas con etiquetas ‚ÄúR‚Äù, ‚ÄúS‚Äù y ‚ÄúT‚Äù.

     - Valor inicial `"--,--"` para indicar que a√∫n no hay lectura.

     - `enabled: false` ‚Üí por defecto no est√°n activas.

     - `origen: null` ‚Üí todav√≠a no se defini√≥ si la lectura viene de rel√© o analizador.

   - Si `side` no existe:

     if (!side) {
       return {
         titulo: tituloDefault,
         boxes: cajasPorDefecto,
       };
     }

     - Devuelve un lado con:
         ‚Ä¢ `titulo`: el por defecto,
         ‚Ä¢ `boxes`: las 3 cajas b√°sicas R/S/T sin lecturas.

   - Si s√≠ hay `side`, se normalizan t√≠tulo y cajas:

     const titulo =
       (side.titulo && String(side.titulo).trim()) || tituloDefault;

     - Usa `side.titulo` si viene definido y no vac√≠o,
     - si no, cae en `tituloDefault`.

     let boxes = Array.isArray(side.boxes) ? side.boxes : [];
     boxes = boxes.slice(0, 4);

     - Garantiza que `boxes` sea un array.

     - Recorta a m√°ximo 4 cajas por lado (l√≠mite visual de la tarjeta).

   - Si no hay ninguna caja configurada (`boxes.length === 0`):

     boxes = cajasPorDefecto;

     - Vuelve a usar las 3 cajas R/S T por defecto.

   - Si hay cajas, se mapean y ‚Äúlimpian‚Äù:

     boxes = boxes.map((b, idx) => ({
       etiqueta:
         (b?.etiqueta && String(b.etiqueta).trim()) ||
         `Box ${idx + 1}`,
       valor:
         b?.valor == null || b.valor === ""
           ? "--,--"
           : String(b.valor),
       enabled: !!b?.enabled,
       origen: b?.origen || null,
     }));

     - `etiqueta`:
         ‚Ä¢ usa la etiqueta del mapeo si existe,
         ‚Ä¢ si no, genera ‚ÄúBox 1‚Äù, ‚ÄúBox 2‚Äù, etc.

     - `valor`:
         ‚Ä¢ si no hay valor o est√° vac√≠o ‚Üí `"--,--"`,
         ‚Ä¢ si hay valor ‚Üí lo convierte a string.

     - `enabled`:
         ‚Ä¢ fuerza a booleano con `!!b?.enabled` (true/false).

     - `origen`:
         ‚Ä¢ mantiene el origen declarado (`"rele"` / `"analizador"`),
         ‚Ä¢ o `null` si no se defini√≥.

   - Al final devuelve siempre un objeto con forma homog√©nea:

     return { titulo, boxes };

     - Esto asegura que el componente pueda renderizar un lado aunque falten
       partes de la configuraci√≥n o todav√≠a no haya lecturas.


2) Props del componente principal

   const TarjetaAlimentador = ({
     nombre,
     color,
     onConfigClick,
     onMapClick,
     topSide,
     bottomSide,
     draggable = false,
     isDragging = false,
     onDragStart,
     onDragOver,
     onDrop,
     onDragEnd,
     mideRele = false,
     mideAnalizador = false,
     periodoRele = 60,
     periodoAnalizador = 60,
     timestampInicioRele = null,
     timestampInicioAnalizador = null,
     contadorRele = 0,
     contadorAnalizador = 0,
   }) => { ... }

   - Datos b√°sicos:
       ‚Ä¢ `nombre`: texto que se muestra en el encabezado de la tarjeta.
       ‚Ä¢ `color`: color de fondo del header (identifica al alimentador).

   - Acciones de √≠conos:
       ‚Ä¢ `onConfigClick()`:
           - abre el modal de configuraci√≥n del alimentador (IP, registros, etc.).
       ‚Ä¢ `onMapClick()`:
           - abre el modal de mapeo de mediciones (definir qu√© se muestra en cada box).

   - Dise√±o y valores de los lados:
       ‚Ä¢ `topSide`: config + valores para la parte superior.
       ‚Ä¢ `bottomSide`: config + valores para la parte inferior.
       ‚Ä¢ Ambos se pasan a `construirLado` para obtener `{ titulo, boxes }`.

   - Drag & drop:
       ‚Ä¢ `draggable` (boolean):
           - indica si la tarjeta se puede arrastrar.
       ‚Ä¢ `isDragging` (boolean):
           - indica si esta tarjeta es la que est√° en arrastre (para estilo visual).
       ‚Ä¢ `onDragStart`, `onDragOver`, `onDrop`, `onDragEnd`:
           - callbacks que se conectan con el hook de drag & drop
             (`usarArrastrarSoltar`), usados por la vista.

   - Informaci√≥n de mediciones:
       ‚Ä¢ `mideRele`, `mideAnalizador`:
           - true/false seg√∫n si hay medici√≥n activa de cada equipo.
       ‚Ä¢ `periodoRele`, `periodoAnalizador`:
           - per√≠odo de actualizaci√≥n en segundos (se usa en la animaci√≥n).
       ‚Ä¢ `timestampInicioRele`, `timestampInicioAnalizador`:
           - reservados por si se quiere sincronizar animaciones en el futuro.
       ‚Ä¢ `contadorRele`, `contadorAnalizador`:
           - cu√°ntas lecturas se realizaron desde que se inici√≥ la medici√≥n.


3) Estado local y refs para animaciones

   const [mostrarProgresoRele, setMostrarProgresoRele] = useState(false);
   const [mostrarProgresoAnalizador, setMostrarProgresoAnalizador] = useState(false);

   - Controlan si se debe mostrar la animaci√≥n de borde de progreso en las cajas:
       ‚Ä¢ para el rel√© (`mostrarProgresoRele`),
       ‚Ä¢ para el analizador (`mostrarProgresoAnalizador`).

   - Empiezan en `false` porque inicialmente no hay lecturas.

   const ultimoContadorReleRef = useRef(contadorRele);
   const ultimoContadorAnalizadorRef = useRef(contadorAnalizador);

   - Guardan el √∫ltimo valor de `contadorRele` / `contadorAnalizador` sin
     provocar re-renders (porque son refs).

   - Sirven para detectar si el contador cambi√≥ (es decir, si lleg√≥ una lectura nueva).


4) useEffect para rel√©

   useEffect(() => {
     if (!mideRele) {
       setMostrarProgresoRele(false);
       ultimoContadorReleRef.current = contadorRele;
       return;
     }

     if (contadorRele !== ultimoContadorReleRef.current) {
       ultimoContadorReleRef.current = contadorRele;
       setMostrarProgresoRele(contadorRele > 0);
     }
   }, [contadorRele, mideRele]);

   - Dependencias:
       ‚Ä¢ `contadorRele`,
       ‚Ä¢ `mideRele`.

   - Si `mideRele` es false:
       ‚Ä¢ la medici√≥n est√° apagada,
       ‚Ä¢ apaga la animaci√≥n (`setMostrarProgresoRele(false)`),
       ‚Ä¢ sincroniza la ref con el contador actual.

   - Si `mideRele` es true y el contador cambi√≥:
       ‚Ä¢ actualiza la ref (`ultimoContadorReleRef.current = contadorRele`),
       ‚Ä¢ vuelve a evaluar `setMostrarProgresoRele(contadorRele > 0)`:
           - si ya hubo al menos una lectura (`> 0`), deja la animaci√≥n encendida.

   - En resumen:
       ‚Ä¢ cuando se inicia o avanza una medici√≥n de rel√©, la animaci√≥n se activa,
       ‚Ä¢ cuando se detiene, se apaga y se resetea el seguimiento.


5) useEffect para analizador

   useEffect(() => {
     if (!mideAnalizador) {
       setMostrarProgresoAnalizador(false);
       ultimoContadorAnalizadorRef.current = contadorAnalizador;
       return;
     }

     if (contadorAnalizador !== ultimoContadorAnalizadorRef.current) {
       ultimoContadorAnalizadorRef.current = contadorAnalizador;
       setMostrarProgresoAnalizador(contadorAnalizador > 0);
     }
   }, [contadorAnalizador, mideAnalizador]);

   - Mismo patr√≥n que el del rel√©, pero aplicado al analizador.

   - Permite tener animaciones independientes:
       ‚Ä¢ puede estar midiendo solo rel√©, solo analizador o ambos.


6) Preparaci√≥n de los lados y ancho de la tarjeta

   const sup = construirLado(topSide, "CONSUMO (A)");
   const inf = construirLado(bottomSide, "TENSI√ìN (kV)");

   - `sup` y `inf` quedan con forma:
       ‚Ä¢ `{ titulo: string, boxes: Array<...> }`
   - T√≠tulos por defecto:
       ‚Ä¢ ‚ÄúCONSUMO (A)‚Äù para la parte superior,
       ‚Ä¢ ‚ÄúTENSI√ìN (kV)‚Äù para la inferior.

   const maxBoxes = Math.max(sup.boxes.length, inf.boxes.length);
   const isWide = maxBoxes >= 4;

   - Calcula cu√°ntas cajas tiene el lado m√°s poblado.
	
   - Si tiene 4 o m√°s, marca la tarjeta como ‚Äúancha‚Äù (`isWide = true`) para ensancharla.

   const clasesCard = ["alim-card"];
   if (isWide) clasesCard.push("alim-card-wide");
   if (isDragging) clasesCard.push("alim-card-dragging");

   - Construye un array de clases CSS:
       ‚Ä¢ siempre incluye `"alim-card"`,
       ‚Ä¢ agrega `"alim-card-wide"` si la tarjeta debe ser m√°s ancha,
       ‚Ä¢ agrega `"alim-card-dragging"` si est√° siendo arrastrada (para cambiar estilo
         durante el drag & drop).


7) Helper renderizarCaja

   const renderizarCaja = (box, idx, zona) => (
     <CajaMedicion
       key={`${zona}-${idx}`}
       box={box}
       indice={idx}
       zona={zona}
       mideRele={mideRele}
       mideAnalizador={mideAnalizador}
       mostrarProgresoRele={mostrarProgresoRele}
       mostrarProgresoAnalizador={mostrarProgresoAnalizador}
       periodoRele={periodoRele}
       periodoAnalizador={periodoAnalizador}
       contadorRele={contadorRele}
       contadorAnalizador={contadorAnalizador}
     />
   );

   - Funci√≥n de ayuda que devuelve una `CajaMedicion` correctamente parametrizada.

   - Par√°metros:
       ‚Ä¢ `box`: objeto con la informaci√≥n de la caja (etiqueta, valor, enabled, origen),
       ‚Ä¢ `idx`: √≠ndice dentro del grupo,
       ‚Ä¢ `zona`: "sup" o "inf" (parte superior o inferior).

   - Props importantes que se pasan a `CajaMedicion`:
       ‚Ä¢ `mideRele` / `mideAnalizador` ‚Üí para saber qu√© equipos est√°n activos.
       ‚Ä¢ `mostrarProgresoRele` / `mostrarProgresoAnalizador` ‚Üí para animar bordes.
       ‚Ä¢ `periodoRele` / `periodoAnalizador` ‚Üí para sincronizar la animaci√≥n con el per√≠odo.
       ‚Ä¢ `contadorRele` / `contadorAnalizador` ‚Üí para detectar nuevos ciclos.


8) JSX principal (estructura de la tarjeta)

   // Contenedor principal de la tarjeta (card)
   return (
     <div
       className={clasesCard.join(" ")}
       style={{ cursor: draggable ? "grab" : "default" }}
       draggable={draggable}
       onDragStart={onDragStart}
       onDragOver={onDragOver}
       onDrop={onDrop}
       onDragEnd={onDragEnd}
     >
       // Header con nombre y botones de acciones
       <div
         className="alim-card-header"
         style={{ backgroundColor: color || "#0ea5e9" }}
       >
         <div className="alim-card-icons">
           <button ... onClick={onConfigClick}> [icono tuerca] </button>
           <button ... onClick={onMapClick}>   [icono mapeo]  </button>
         </div>

         <span className="alim-card-title">{nombre}</span>
       </div>

       // Cuerpo con los 2 bloques (superior / inferior)
       <div className="alim-card-body">
         <GrupoMedidores
           titulo={sup.titulo}
           boxes={sup.boxes}
           zona="sup"
           renderizarCaja={renderizarCaja}
         />

         <GrupoMedidores
           titulo={inf.titulo}
           boxes={inf.boxes}
           zona="inf"
           renderizarCaja={renderizarCaja}
         />
       </div>
     </div>
   );

   - Contenedor `<div className={clasesCard.join(" ")} ...>`:
       ‚Ä¢ envuelve toda la tarjeta,
       ‚Ä¢ `cursor: "grab"` si es arrastrable,
       ‚Ä¢ atributos `draggable`, `onDragStart`, `onDragOver`, `onDrop`, `onDragEnd`
         conectan la tarjeta con la l√≥gica de drag & drop.

   - Header:
       ‚Ä¢ fondo con `color` del alimentador (o celeste por defecto),
       ‚Ä¢ botones de:
           - configuraci√≥n (`onConfigClick`),
           - mapeo (`onMapClick`),
       ‚Ä¢ t√≠tulo con el nombre del alimentador.

   - Cuerpo:
       ‚Ä¢ dos `GrupoMedidores`, uno para la parte superior (‚Äúsup‚Äù) y otro para
         la inferior (‚Äúinf‚Äù),
       ‚Ä¢ cada grupo recibe:
           - t√≠tulo,
           - lista de `boxes`,
           - funci√≥n `renderizarCaja` para generar cada `CajaMedicion`.


9) Export

   export default TarjetaAlimentador;

   - Permite usar esta tarjeta dentro de `GrillaTarjetas` para construir la vista
     completa de alimentadores.

---------------------------------------------------------------------------*/

========== mi-app/src/paginas/PaginaAlimentadores/constantes/clavesAlmacenamiento.js ==========
// src/paginas/PaginaAlimentadores/constantes/clavesAlmacenamiento.js

/**
 * Claves para guardar datos en localStorage
 * Centralizadas ac√° para evitar typos y mantener consistencia.
 */
export const CLAVES_STORAGE = {
	PUESTOS: "rw-puestos",                    // lista completa de puestos configurados
	PUESTO_SELECCIONADO: "rw-puesto-seleccionado", // id del puesto que qued√≥ seleccionado
	CONFIGURACION_SELECCIONADA: "rw-configuracion-seleccionada", // id del workspace activo
	USUARIOS_RECORDADOS: "usuariosRecordados",     // lista de usuarios recordados (login)
	GAP_TARJETAS: "rw-gap-tarjetas",          // espaciado horizontal entre tarjetas (en px)
	GAP_FILAS: "rw-gap-filas",                // espaciado vertical entre filas (en px)
	ESCALA_GLOBAL: "rw-escala-global",        // escala global de todas las tarjetas
	ESCALA_PUESTOS: "rw-escala-puestos",      // escala por puesto { puestoId: escala }
	ESCALA_TARJETAS: "rw-escala-tarjetas",    // escala individual por tarjeta { alimId: escala }
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (clavesAlmacenamiento.js)

 - Ac√° defino todas las claves de `localStorage` que usa la pantalla de
   alimentadores (y algunas compartidas, como `USUARIOS_RECORDADOS`).

 - La idea es nunca escribir las strings a mano en el resto del c√≥digo,
   sino importar `CLAVES_STORAGE` y usar `CLAVES_STORAGE.PUESTOS`, etc., para
   evitar errores de tipeo y poder cambiar el prefijo f√°cilmente si hace falta.
---------------------------------------------------------------------------*/}


========== mi-app/src/paginas/PaginaAlimentadores/constantes/colores.js ==========
// src/paginas/PaginaAlimentadores/constantes/colores.js

/**
 * Paleta de colores del sistema
 * Usada para puestos y alimentadores (botones, tarjetas, etc.).
 */
export const COLORES_SISTEMA = [
	"#22c55e", // Verde
	"#0ea5e9", // Azul cielo
	"#3b82f6", // Azul
	"#a855f7", // P√∫rpura
	"#ec4899", // Rosa
	"#f97316", // Naranja
	"#ef4444", // Rojo
	"#eab308", // Amarillo
	"#14b8a6", // Turquesa
	"#10b981", // Verde esmeralda
	"#6366f1", // √çndigo
	"#64748b", // Gris azulado
];

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (colores.js)

 - `COLORES_SISTEMA` es la paleta central para elegir colores de puestos y
   alimentadores. En el modal de configuraci√≥n se recorre este array para
   dibujar los cuadrados de color.

 - Si en alg√∫n momento quiero cambiar el look&feel (por ejemplo, usar otros
   verdes o agregar m√°s opciones), basta con modificar esta lista sin tocar
   el resto de los componentes.
---------------------------------------------------------------------------*/}


========== mi-app/src/paginas/PaginaAlimentadores/constantes/datosBaseReles.js ==========
/**
 * Datos base de rel√©s ABB Serie 615
 *
 * Este archivo contiene la configuraci√≥n predeterminada para los rel√©s ABB.
 * El sistema es extensible: se pueden agregar nuevos modelos y configuraciones
 * sin modificar c√≥digo, solo agregando datos a estas estructuras.
 *
 * Referencia: Informe_Tecnico_Completo_Reles_CELTA1.md
 *             GUIA_REGISTROS_MODBUS_ABB615.md
 */

// ============================================================================
// MODELOS DE REL√â
// ============================================================================

export const MODELOS_RELE_BASE = {
  REF615: {
    id: "REF615",
    nombre: "REF615",
    fabricante: "ABB",
    familia: "Relion 615",
    descripcion: "Feeder Protection Relay - Protecci√≥n de Alimentadores",
    configuraciones: ["FE03", "FE06"],
    icono: "‚ö°"
  },
  RET615: {
    id: "RET615",
    nombre: "RET615",
    fabricante: "ABB",
    familia: "Relion 615",
    descripcion: "Transformer Protection Relay - Protecci√≥n de Transformadores",
    configuraciones: ["TE02"],
    icono: "üîå"
  }
};

// ============================================================================
// CONFIGURACIONES POR MODELO
// ============================================================================

export const CONFIGURACIONES_RELE_BASE = {
  // -------------------------------------------------------------------------
  // FE03 - Feeder con Autorecierre (Alimentadores sin tensi√≥n)
  // -------------------------------------------------------------------------
  FE03: {
    id: "FE03",
    nombre: "FE03",
    descripcion: "Feeder con Autorecierre",
    descripcionLarga: "Protecci√≥n de alimentadores con funciones de sobrecorriente, falla a tierra y autorecierre. Sin medici√≥n de tensi√≥n.",
    modeloId: "REF615",
    capacidades: {
      medicionCorriente: true,
      medicionTension: false,
      proteccionDireccional: false,
      autorecierre: true,
      proteccionDiferencial: false
    },
    registros: {
      corrientes: {
        inicio: 138,
        cantidad: 4,
        escala: 1000,
        variables: ["IL1", "IL2", "IL3", "Io"]
      },
      tensiones: null,
      estadoCB: {
        registro: 175,
        bitCerrado: 4,
        bitAbierto: 5,
        bitError: 6
      },
      protecciones: {
        inicio: 180,
        cantidad: 10
      }
    },
    protecciones: [
      {
        codigo: "PHLPTOC1",
        nombre: "Sobrecorriente Fase Baja",
        nombreCorto: "I> Fase",
        descripcion: "Phase Low-set Time Overcurrent (51P-1)",
        ansi: "51P-1",
        iec61850: "PHLPTOC",
        registroStart: 180,
        bitStart: 0,
        registroOperate: 180,
        bitOperate: 8,
        severidad: "media",
        categoria: "sobrecorriente"
      },
      {
        codigo: "PHHPTOC1",
        nombre: "Sobrecorriente Fase Alta",
        nombreCorto: "I>> Fase",
        descripcion: "Phase High-set Time Overcurrent (51P-2)",
        ansi: "51P-2",
        iec61850: "PHHPTOC",
        registroStart: 180,
        bitStart: 10,
        registroOperate: 181,
        bitOperate: 2,
        severidad: "alta",
        categoria: "sobrecorriente"
      },
      {
        codigo: "PHIPTOC1",
        nombre: "Sobrecorriente Instant√°nea",
        nombreCorto: "I>>> Inst",
        descripcion: "Phase Instantaneous Overcurrent (50P)",
        ansi: "50P",
        iec61850: "PHIPTOC",
        registroStart: 181,
        bitStart: 14,
        registroOperate: 182,
        bitOperate: 6,
        severidad: "critica",
        categoria: "sobrecorriente"
      },
      {
        codigo: "EFLPTOC1",
        nombre: "Falla a Tierra Baja",
        nombreCorto: "Io> Tierra",
        descripcion: "Earth Fault Low-set Time Overcurrent (51N-1)",
        ansi: "51N-1",
        iec61850: "EFLPTOC",
        registroStart: 183,
        bitStart: 4,
        registroOperate: 183,
        bitOperate: 6,
        severidad: "media",
        categoria: "falla_tierra"
      },
      {
        codigo: "EFHPTOC1",
        nombre: "Falla a Tierra Alta",
        nombreCorto: "Io>> Tierra",
        descripcion: "Earth Fault High-set Time Overcurrent (51N-2)",
        ansi: "51N-2",
        iec61850: "EFHPTOC",
        registroStart: 183,
        bitStart: 12,
        registroOperate: 183,
        bitOperate: 14,
        severidad: "alta",
        categoria: "falla_tierra"
      },
      {
        codigo: "EFIPTOC1",
        nombre: "Falla a Tierra Instant√°nea",
        nombreCorto: "Io>>> Inst",
        descripcion: "Earth Fault Instantaneous Overcurrent (50N)",
        ansi: "50N",
        iec61850: "EFIPTOC",
        registroStart: 184,
        bitStart: 0,
        registroOperate: 184,
        bitOperate: 2,
        severidad: "critica",
        categoria: "falla_tierra"
      },
      {
        codigo: "NSPTOC1",
        nombre: "Secuencia Negativa",
        nombreCorto: "I2 Sec.Neg",
        descripcion: "Negative Sequence Overcurrent (46)",
        ansi: "46",
        iec61850: "NSPTOC",
        registroStart: 184,
        bitStart: 8,
        registroOperate: 184,
        bitOperate: 10,
        severidad: "media",
        categoria: "desbalance"
      },
      {
        codigo: "T1PTTR1",
        nombre: "Sobrecarga T√©rmica",
        nombreCorto: "T√©rmica",
        descripcion: "Thermal Overload Protection (49F)",
        ansi: "49F",
        iec61850: "T1PTTR",
        registroStart: 185,
        bitStart: 0,
        registroOperate: 185,
        bitOperate: 2,
        severidad: "baja",
        categoria: "termica"
      },
      {
        codigo: "CCBRBRF1",
        nombre: "Fallo de Interruptor",
        nombreCorto: "BF",
        descripcion: "Breaker Failure Protection (50BF)",
        ansi: "50BF",
        iec61850: "CCBRBRF",
        registroStart: 186,
        bitStart: 0,
        registroOperate: 186,
        bitOperate: 2,
        severidad: "critica",
        categoria: "interruptor"
      },
      {
        codigo: "DARREC1",
        nombre: "Autorecierre",
        nombreCorto: "AR",
        descripcion: "Auto-Recloser (79)",
        ansi: "79",
        iec61850: "DARREC",
        registroStart: 187,
        bitStart: 0,
        registroOperate: 187,
        bitOperate: 2,
        severidad: "info",
        categoria: "autorecierre"
      }
    ]
  },

  // -------------------------------------------------------------------------
  // FE06 - Feeder con Tensi√≥n y Direccional (Ternas)
  // -------------------------------------------------------------------------
  FE06: {
    id: "FE06",
    nombre: "FE06",
    descripcion: "Feeder con Tensi√≥n y Direccional",
    descripcionLarga: "Protecci√≥n de alimentadores/l√≠neas con medici√≥n de tensi√≥n, protecciones direccionales, medici√≥n de potencia y frecuencia.",
    modeloId: "REF615",
    capacidades: {
      medicionCorriente: true,
      medicionTension: true,
      proteccionDireccional: true,
      autorecierre: true,
      proteccionDiferencial: false,
      medicionPotencia: true,
      medicionFrecuencia: true
    },
    registros: {
      corrientes: {
        inicio: 138,
        cantidad: 4,
        escala: 1000,
        variables: ["IL1", "IL2", "IL3", "Io"]
      },
      tensiones: {
        inicio: 152,
        cantidad: 6,
        escala: 1000,
        variables: ["VA", "VB", "VC", "VAB", "VBC", "VCA"]
      },
      frecuencia: {
        registro: 168,
        escala: 100
      },
      estadoCB: {
        registro: 175,
        bitCerrado: 4,
        bitAbierto: 5,
        bitError: 6
      },
      protecciones: {
        inicio: 180,
        cantidad: 20
      }
    },
    protecciones: [
      // Todas las protecciones de FE03
      {
        codigo: "PHLPTOC1",
        nombre: "Sobrecorriente Fase Baja",
        nombreCorto: "I> Fase",
        descripcion: "Phase Low-set Time Overcurrent (51P-1)",
        ansi: "51P-1",
        iec61850: "PHLPTOC",
        registroStart: 180,
        bitStart: 0,
        registroOperate: 180,
        bitOperate: 8,
        severidad: "media",
        categoria: "sobrecorriente"
      },
      {
        codigo: "PHHPTOC1",
        nombre: "Sobrecorriente Fase Alta",
        nombreCorto: "I>> Fase",
        descripcion: "Phase High-set Time Overcurrent (51P-2)",
        ansi: "51P-2",
        iec61850: "PHHPTOC",
        registroStart: 180,
        bitStart: 10,
        registroOperate: 181,
        bitOperate: 2,
        severidad: "alta",
        categoria: "sobrecorriente"
      },
      {
        codigo: "PHIPTOC1",
        nombre: "Sobrecorriente Instant√°nea",
        nombreCorto: "I>>> Inst",
        descripcion: "Phase Instantaneous Overcurrent (50P)",
        ansi: "50P",
        iec61850: "PHIPTOC",
        registroStart: 181,
        bitStart: 14,
        registroOperate: 182,
        bitOperate: 6,
        severidad: "critica",
        categoria: "sobrecorriente"
      },
      // Protecciones direccionales (espec√≠ficas de FE06)
      {
        codigo: "DPHLPDOC1",
        nombre: "Sobrecorriente Direccional Baja",
        nombreCorto: "67 I> Dir",
        descripcion: "Directional Phase Overcurrent Low-set (67-1)",
        ansi: "67-1",
        iec61850: "DPHLPDOC",
        registroStart: 188,
        bitStart: 0,
        registroOperate: 188,
        bitOperate: 2,
        severidad: "media",
        categoria: "direccional"
      },
      {
        codigo: "DPHHPDOC1",
        nombre: "Sobrecorriente Direccional Alta",
        nombreCorto: "67 I>> Dir",
        descripcion: "Directional Phase Overcurrent High-set (67-2)",
        ansi: "67-2",
        iec61850: "DPHHPDOC",
        registroStart: 188,
        bitStart: 8,
        registroOperate: 188,
        bitOperate: 10,
        severidad: "alta",
        categoria: "direccional"
      },
      {
        codigo: "DEFLPDEF1",
        nombre: "Falla Tierra Direccional Baja",
        nombreCorto: "67N Io> Dir",
        descripcion: "Directional Earth Fault Low-set (67N-1)",
        ansi: "67N-1",
        iec61850: "DEFLPDEF",
        registroStart: 182,
        bitStart: 8,
        registroOperate: 182,
        bitOperate: 10,
        severidad: "media",
        categoria: "direccional"
      },
      {
        codigo: "DEFHPDEF1",
        nombre: "Falla Tierra Direccional Alta",
        nombreCorto: "67N Io>> Dir",
        descripcion: "Directional Earth Fault High-set (67N-2)",
        ansi: "67N-2",
        iec61850: "DEFHPDEF",
        registroStart: 189,
        bitStart: 0,
        registroOperate: 189,
        bitOperate: 2,
        severidad: "alta",
        categoria: "direccional"
      },
      // Falla a tierra no direccional
      {
        codigo: "EFLPTOC1",
        nombre: "Falla a Tierra Baja",
        nombreCorto: "Io> Tierra",
        descripcion: "Earth Fault Low-set Time Overcurrent (51N-1)",
        ansi: "51N-1",
        iec61850: "EFLPTOC",
        registroStart: 183,
        bitStart: 4,
        registroOperate: 183,
        bitOperate: 6,
        severidad: "media",
        categoria: "falla_tierra"
      },
      {
        codigo: "EFHPTOC1",
        nombre: "Falla a Tierra Alta",
        nombreCorto: "Io>> Tierra",
        descripcion: "Earth Fault High-set Time Overcurrent (51N-2)",
        ansi: "51N-2",
        iec61850: "EFHPTOC",
        registroStart: 183,
        bitStart: 12,
        registroOperate: 183,
        bitOperate: 14,
        severidad: "alta",
        categoria: "falla_tierra"
      },
      // Protecciones de tensi√≥n (espec√≠ficas de FE06)
      {
        codigo: "PHPTUV1",
        nombre: "Subtensi√≥n Trif√°sica",
        nombreCorto: "27 U<",
        descripcion: "Three-phase Undervoltage (27)",
        ansi: "27",
        iec61850: "PHPTUV",
        registroStart: 193,
        bitStart: 0,
        registroOperate: 193,
        bitOperate: 2,
        severidad: "media",
        categoria: "tension"
      },
      {
        codigo: "PHPTOV1",
        nombre: "Sobretensi√≥n Trif√°sica",
        nombreCorto: "59 U>",
        descripcion: "Three-phase Overvoltage (59)",
        ansi: "59",
        iec61850: "PHPTOV",
        registroStart: 194,
        bitStart: 0,
        registroOperate: 194,
        bitOperate: 2,
        severidad: "media",
        categoria: "tension"
      },
      {
        codigo: "ROVPTOV1",
        nombre: "Sobretensi√≥n Residual",
        nombreCorto: "59G Uo>",
        descripcion: "Residual Overvoltage (59G)",
        ansi: "59G",
        iec61850: "ROVPTOV",
        registroStart: 195,
        bitStart: 0,
        registroOperate: 195,
        bitOperate: 2,
        severidad: "media",
        categoria: "tension"
      },
      // Otras protecciones
      {
        codigo: "NSPTOC1",
        nombre: "Secuencia Negativa",
        nombreCorto: "I2 Sec.Neg",
        descripcion: "Negative Sequence Overcurrent (46)",
        ansi: "46",
        iec61850: "NSPTOC",
        registroStart: 184,
        bitStart: 8,
        registroOperate: 184,
        bitOperate: 10,
        severidad: "media",
        categoria: "desbalance"
      },
      {
        codigo: "T1PTTR1",
        nombre: "Sobrecarga T√©rmica",
        nombreCorto: "T√©rmica",
        descripcion: "Thermal Overload Protection (49F)",
        ansi: "49F",
        iec61850: "T1PTTR",
        registroStart: 185,
        bitStart: 0,
        registroOperate: 185,
        bitOperate: 2,
        severidad: "baja",
        categoria: "termica"
      },
      {
        codigo: "CCBRBRF1",
        nombre: "Fallo de Interruptor",
        nombreCorto: "BF",
        descripcion: "Breaker Failure Protection (50BF)",
        ansi: "50BF",
        iec61850: "CCBRBRF",
        registroStart: 186,
        bitStart: 0,
        registroOperate: 186,
        bitOperate: 2,
        severidad: "critica",
        categoria: "interruptor"
      },
      {
        codigo: "SSCBR1",
        nombre: "Monitoreo de Interruptor",
        nombreCorto: "CBCM",
        descripcion: "Circuit Breaker Condition Monitoring",
        ansi: "CBCM",
        iec61850: "SSCBR",
        registroStart: 196,
        bitStart: 0,
        registroOperate: 196,
        bitOperate: 2,
        severidad: "info",
        categoria: "interruptor"
      }
    ]
  },

  // -------------------------------------------------------------------------
  // TE02 - Transformer Differential Protection
  // -------------------------------------------------------------------------
  TE02: {
    id: "TE02",
    nombre: "TE02",
    descripcion: "Protecci√≥n Diferencial de Transformador",
    descripcionLarga: "Protecci√≥n de transformadores de potencia con diferencial estabilizada, REF de baja impedancia, protecci√≥n t√©rmica y respaldos de sobrecorriente.",
    modeloId: "RET615",
    capacidades: {
      medicionCorriente: true,
      medicionTension: false,
      proteccionDireccional: false,
      autorecierre: false,
      proteccionDiferencial: true,
      ladosTransformador: 2
    },
    registros: {
      corrientes: {
        inicio: 138,
        cantidad: 7, // 4 lado AT + 3 lado BT
        escala: 1000,
        variables: ["IL1_AT", "IL2_AT", "IL3_AT", "Io_AT", "IL1_BT", "IL2_BT", "IL3_BT"]
      },
      tensiones: null,
      estadoCB: {
        registro: 175,
        bitCerrado: 4,
        bitAbierto: 5,
        bitError: 6
      },
      protecciones: {
        inicio: 180,
        cantidad: 10
      }
    },
    protecciones: [
      {
        codigo: "TR2PTDF1",
        nombre: "Diferencial Estabilizada",
        nombreCorto: "87T Dif",
        descripcion: "Transformer Differential Protection (87T)",
        ansi: "87T",
        iec61850: "TR2PTDF",
        registroStart: 180,
        bitStart: 0,
        registroOperate: 180,
        bitOperate: 2,
        severidad: "critica",
        categoria: "diferencial"
      },
      {
        codigo: "TR2PTDF_INST",
        nombre: "Diferencial Instant√°nea",
        nombreCorto: "87T Inst",
        descripcion: "Transformer Differential Instantaneous",
        ansi: "87T",
        iec61850: "TR2PTDF",
        registroStart: 180,
        bitStart: 4,
        registroOperate: 180,
        bitOperate: 6,
        severidad: "critica",
        categoria: "diferencial"
      },
      {
        codigo: "LREFPNDF1",
        nombre: "Falla Tierra Restringida",
        nombreCorto: "87N REF",
        descripcion: "Low Impedance Restricted Earth Fault (87N)",
        ansi: "87N",
        iec61850: "LREFPNDF",
        registroStart: 181,
        bitStart: 0,
        registroOperate: 181,
        bitOperate: 2,
        severidad: "critica",
        categoria: "diferencial"
      },
      {
        codigo: "PHLPTOC1_AT",
        nombre: "Sobrecorriente AT",
        nombreCorto: "51 AT",
        descripcion: "Phase Overcurrent High Voltage Side (51P AT)",
        ansi: "51P",
        iec61850: "PHLPTOC",
        registroStart: 182,
        bitStart: 0,
        registroOperate: 182,
        bitOperate: 2,
        severidad: "alta",
        categoria: "sobrecorriente"
      },
      {
        codigo: "PHLPTOC1_BT",
        nombre: "Sobrecorriente BT",
        nombreCorto: "51 BT",
        descripcion: "Phase Overcurrent Low Voltage Side (51P BT)",
        ansi: "51P",
        iec61850: "PHLPTOC",
        registroStart: 182,
        bitStart: 8,
        registroOperate: 182,
        bitOperate: 10,
        severidad: "alta",
        categoria: "sobrecorriente"
      },
      {
        codigo: "EFLPTOC1_AT",
        nombre: "Falla Tierra AT",
        nombreCorto: "51N AT",
        descripcion: "Earth Fault High Voltage Side (51N AT)",
        ansi: "51N",
        iec61850: "EFLPTOC",
        registroStart: 183,
        bitStart: 0,
        registroOperate: 183,
        bitOperate: 2,
        severidad: "alta",
        categoria: "falla_tierra"
      },
      {
        codigo: "EFLPTOC1_BT",
        nombre: "Falla Tierra BT",
        nombreCorto: "51N BT",
        descripcion: "Earth Fault Low Voltage Side (51N BT)",
        ansi: "51N",
        iec61850: "EFLPTOC",
        registroStart: 183,
        bitStart: 8,
        registroOperate: 183,
        bitOperate: 10,
        severidad: "alta",
        categoria: "falla_tierra"
      },
      {
        codigo: "T2PTTR1",
        nombre: "T√©rmica Transformador",
        nombreCorto: "49T",
        descripcion: "Transformer Thermal Overload (49T)",
        ansi: "49T",
        iec61850: "T2PTTR",
        registroStart: 184,
        bitStart: 0,
        registroOperate: 184,
        bitOperate: 2,
        severidad: "media",
        categoria: "termica"
      },
      {
        codigo: "NSPTOC1",
        nombre: "Secuencia Negativa",
        nombreCorto: "46",
        descripcion: "Negative Sequence Overcurrent (46)",
        ansi: "46",
        iec61850: "NSPTOC",
        registroStart: 184,
        bitStart: 8,
        registroOperate: 184,
        bitOperate: 10,
        severidad: "media",
        categoria: "desbalance"
      },
      {
        codigo: "CCBRBRF1",
        nombre: "Fallo de Interruptor",
        nombreCorto: "50BF",
        descripcion: "Breaker Failure Protection (50BF)",
        ansi: "50BF",
        iec61850: "CCBRBRF",
        registroStart: 185,
        bitStart: 0,
        registroOperate: 185,
        bitOperate: 2,
        severidad: "critica",
        categoria: "interruptor"
      }
    ]
  }
};

// ============================================================================
// CATEGOR√çAS DE PROTECCI√ìN (para agrupar en UI)
// ============================================================================

export const CATEGORIAS_PROTECCION = {
  sobrecorriente: {
    id: "sobrecorriente",
    nombre: "Sobrecorriente de Fase",
    icono: "‚ö°",
    color: "#f59e0b"
  },
  falla_tierra: {
    id: "falla_tierra",
    nombre: "Falla a Tierra",
    icono: "üåç",
    color: "#10b981"
  },
  direccional: {
    id: "direccional",
    nombre: "Direccional",
    icono: "‚û°Ô∏è",
    color: "#6366f1"
  },
  diferencial: {
    id: "diferencial",
    nombre: "Diferencial",
    icono: "üîÑ",
    color: "#ef4444"
  },
  tension: {
    id: "tension",
    nombre: "Tensi√≥n",
    icono: "üîå",
    color: "#8b5cf6"
  },
  termica: {
    id: "termica",
    nombre: "T√©rmica",
    icono: "üå°Ô∏è",
    color: "#f97316"
  },
  desbalance: {
    id: "desbalance",
    nombre: "Desbalance/Secuencia",
    icono: "‚öñÔ∏è",
    color: "#06b6d4"
  },
  interruptor: {
    id: "interruptor",
    nombre: "Interruptor",
    icono: "üî≤",
    color: "#64748b"
  },
  autorecierre: {
    id: "autorecierre",
    nombre: "Autorecierre",
    icono: "üîÅ",
    color: "#22c55e"
  }
};

// ============================================================================
// SEVERIDADES (para colores de alerta)
// ============================================================================

export const SEVERIDADES = {
  critica: {
    id: "critica",
    nombre: "Cr√≠tica",
    color: "#ef4444",
    colorBg: "#fef2f2",
    prioridad: 1
  },
  alta: {
    id: "alta",
    nombre: "Alta",
    color: "#f97316",
    colorBg: "#fff7ed",
    prioridad: 2
  },
  media: {
    id: "media",
    nombre: "Media",
    color: "#f59e0b",
    colorBg: "#fffbeb",
    prioridad: 3
  },
  baja: {
    id: "baja",
    nombre: "Baja",
    color: "#22c55e",
    colorBg: "#f0fdf4",
    prioridad: 4
  },
  info: {
    id: "info",
    nombre: "Informaci√≥n",
    color: "#6366f1",
    colorBg: "#eef2ff",
    prioridad: 5
  }
};

// ============================================================================
// CONFIGURACI√ìN DE CONEXI√ìN POR DEFECTO
// ============================================================================

export const CONEXION_MODBUS_DEFAULT = {
  puerto: 502,
  unitId: 1,
  timeout: 3000,
  reintentos: 3
};

// ============================================================================
// HELPERS
// ============================================================================

/**
 * Obtiene las configuraciones disponibles para un modelo de rel√©
 */
export const getConfiguracionesPorModelo = (modeloId) => {
  const modelo = MODELOS_RELE_BASE[modeloId];
  if (!modelo) return [];

  return modelo.configuraciones.map(configId => CONFIGURACIONES_RELE_BASE[configId]);
};

/**
 * Obtiene las protecciones de una configuraci√≥n
 */
export const getProteccionesPorConfiguracion = (configuracionId) => {
  const config = CONFIGURACIONES_RELE_BASE[configuracionId];
  if (!config) return [];

  return config.protecciones;
};

/**
 * Obtiene las protecciones agrupadas por categor√≠a
 */
export const getProteccionesAgrupadasPorCategoria = (configuracionId) => {
  const protecciones = getProteccionesPorConfiguracion(configuracionId);

  return protecciones.reduce((acc, prot) => {
    const categoria = prot.categoria || "otros";
    if (!acc[categoria]) {
      acc[categoria] = {
        ...CATEGORIAS_PROTECCION[categoria],
        protecciones: []
      };
    }
    acc[categoria].protecciones.push(prot);
    return acc;
  }, {});
};

/**
 * Obtiene una protecci√≥n por su c√≥digo
 */
export const getProteccionPorCodigo = (configuracionId, codigoProteccion) => {
  const protecciones = getProteccionesPorConfiguracion(configuracionId);
  return protecciones.find(p => p.codigo === codigoProteccion);
};

/**
 * Verifica si una configuraci√≥n tiene capacidad espec√≠fica
 */
export const tieneCapacidad = (configuracionId, capacidad) => {
  const config = CONFIGURACIONES_RELE_BASE[configuracionId];
  if (!config) return false;

  return config.capacidades[capacidad] === true;
};

/**
 * Obtiene todos los modelos como array para selects
 */
export const getModelosArray = () => {
  return Object.values(MODELOS_RELE_BASE);
};

/**
 * Obtiene todas las configuraciones como array para selects
 */
export const getConfiguracionesArray = () => {
  return Object.values(CONFIGURACIONES_RELE_BASE);
};

========== mi-app/src/paginas/PaginaAlimentadores/constantes/estilosGlobalesTarjeta.js ==========
/**
 * Constantes de estilos globales para las tarjetas de alimentador
 * Estos valores son los defaults que se usan si el usuario no ha personalizado nada
 */

// Lista curada de fuentes disponibles (ordenada alfab√©ticamente)
export const FUENTES_DISPONIBLES = [
  // Opci√≥n por defecto (siempre primera)
  { id: "inherit", label: "Por defecto" },
  // Resto ordenado alfab√©ticamente
  { id: "'Arial', sans-serif", label: "Arial" },
  { id: "'Barlow', sans-serif", label: "Barlow" },
  { id: "'Bebas Neue', sans-serif", label: "Bebas Neue" },
  { id: "'Cabin', sans-serif", label: "Cabin" },
  { id: "'Comfortaa', sans-serif", label: "Comfortaa" },
  { id: "'Consolas', monospace", label: "Consolas" },
  { id: "'Digital-7', 'Courier New', monospace", label: "Digital-7" },
  { id: "'Digital-7-Mono', 'Courier New', monospace", label: "Digital-7 Mono" },
  { id: "'DS-Digital', 'Courier New', monospace", label: "DS-Digital" },
  { id: "'DS-Digital-Bold', 'Courier New', monospace", label: "DS-Digital Bold" },
  { id: "'Exo 2', sans-serif", label: "Exo 2" },
  { id: "'Fira Code', monospace", label: "Fira Code" },
  { id: "'IBM Plex Sans', sans-serif", label: "IBM Plex Sans" },
  { id: "'Inconsolata', monospace", label: "Inconsolata" },
  { id: "'Inter', sans-serif", label: "Inter" },
  { id: "'JetBrains Mono', monospace", label: "JetBrains Mono" },
  { id: "'Kanit', sans-serif", label: "Kanit" },
  { id: "'Lato', sans-serif", label: "Lato" },
  { id: "'Montserrat', sans-serif", label: "Montserrat" },
  { id: "'Nunito', sans-serif", label: "Nunito" },
  { id: "'Open Sans', sans-serif", label: "Open Sans" },
  { id: "'Orbitron', sans-serif", label: "Orbitron" },
  { id: "'Oswald', sans-serif", label: "Oswald" },
  { id: "'Oxanium', sans-serif", label: "Oxanium" },
  { id: "'Play', sans-serif", label: "Play" },
  { id: "'Playfair Display', serif", label: "Playfair Display" },
  { id: "'Poppins', sans-serif", label: "Poppins" },
  { id: "'Quicksand', sans-serif", label: "Quicksand" },
  { id: "'Rajdhani', sans-serif", label: "Rajdhani" },
  { id: "'Roboto', sans-serif", label: "Roboto" },
  { id: "'Roboto Mono', monospace", label: "Roboto Mono" },
  { id: "'Rubik', sans-serif", label: "Rubik" },
  { id: "'Russo One', sans-serif", label: "Russo One" },
  { id: "'Segoe UI', sans-serif", label: "Segoe UI" },
  { id: "'Share Tech Mono', monospace", label: "Share Tech Mono" },
  { id: "'Source Sans 3', sans-serif", label: "Source Sans" },
  { id: "'Space Mono', monospace", label: "Space Mono" },
  { id: "'Teko', sans-serif", label: "Teko" },
  { id: "'Titillium Web', sans-serif", label: "Titillium Web" },
  { id: "'Ubuntu', sans-serif", label: "Ubuntu" },
  { id: "'Work Sans', sans-serif", label: "Work Sans" },
  { id: "'Zilla Slab', serif", label: "Zilla Slab" },
];

// Alias para compatibilidad (usa la misma lista)
export const FUENTES_DIGITALES = FUENTES_DISPONIBLES;

// Key para localStorage
export const ESTILOS_GLOBALES_STORAGE_KEY = "alimentadores_estilos_globales";

// Valores por defecto (extra√≠dos del CSS actual)
export const ESTILOS_GLOBALES_DEFAULT = {
  // 1. Header de la tarjeta (t√≠tulo como "TRAFO 1")
  header: {
    fontFamily: "inherit",
    fontSize: "1rem",        // ~16px
    fontWeight: 700,
  },

  // 2. T√≠tulos de zona (superior e inferior como conjunto)
  // Ej: "CORRIENTE DE L√çNEA (A) (EN 33 KV)"
  tituloZona: {
    fontFamily: "inherit",
    fontSize: "0.8rem",      // ~12.8px
  },

  // 3. T√≠tulos de los boxes (R, S, T) como conjunto
  tituloBox: {
    fontFamily: "inherit",
    fontSize: "1rem",        // ~16px
  },

  // 4. Contenido de los boxes (valores como "--,--")
  valorBox: {
    fontFamily: "'DS-Digital', 'Courier New', monospace",
    fontSize: "1.5rem",      // ~24px
    color: "#ffff00",        // amarillo
    decimales: 2,            // cantidad de decimales a mostrar (0, 1 o 2)
  },

  // 5. Configuraci√≥n del box contenedor
  box: {
    gap: "18px",                  // espacio entre boxes (igual a CSS: gap: 18px)
    width: "80px",                // ancho fijo del box
    height: "auto",               // alto del box ("auto" = se ajusta al contenido)
  },
};

// L√≠mites para los sliders de tama√±o
export const LIMITES_TAMA√ëO = {
  header: { min: 0.7, max: 1.6, step: 0.05 },           // rem
  tituloZona: { min: 0.6, max: 1.2, step: 0.05 },       // rem
  tituloBox: { min: 0.7, max: 1.4, step: 0.05 },        // rem
  valorBox: { min: 0, max: 2.5, step: 0.1 },             // rem (0 a 2.5)
  gap: { min: 5, max: 40, step: 1 },                    // px (espacio entre boxes)
  boxWidth: { min: 60, max: 120, step: 2 },             // px (ancho del box)
  boxHeight: { min: 24, max: 60, step: 2 },             // px (alto del box, 0 = auto)
};

// Opciones de decimales para los valores
export const OPCIONES_DECIMALES = [
  { valor: 2, label: "2 decimales" },
  { valor: 1, label: "1 decimal" },
  { valor: 0, label: "Sin decimales" },
];

// Colores predefinidos para el texto de los valores
export const COLORES_VALOR_PREDEFINIDOS = [
  "#ffff00", // amarillo (default)
  "#00ff00", // verde
  "#00ffff", // cyan
  "#ff9900", // naranja
  "#ff6666", // rojo claro
  "#ffffff", // blanco
  "#99ccff", // azul claro
];

========== mi-app/src/paginas/PaginaAlimentadores/constantes/historialConfig.js ==========
/**
 * Configuraci√≥n y constantes para el sistema de historial y gr√°ficos
 */

// Retenci√≥n de datos en IndexedDB (horas)
export const HORAS_RETENCION_LOCAL = 48;

// Umbral de cobertura para considerar cache v√°lido (85%)
export const UMBRAL_COBERTURA_CACHE = 0.85;

// Umbral de cobertura para complementar con datos remotos (90%)
export const UMBRAL_COBERTURA_REMOTO = 0.90;

// Margen adicional al l√≠mite de 48h para evitar edge cases (5 minutos en ms)
export const MARGEN_LIMITE_LOCAL_MS = 5 * 60 * 1000;

// Antig√ºedad m√°xima permitida para el √∫ltimo dato en cache (minutos)
// Si el √∫ltimo dato es m√°s antiguo que esto, se fuerza recarga del servidor
export const MAX_ANTIGUEDAD_CACHE_MINUTOS = 15;

// Opciones de rango de tiempo predefinidas
export const RANGOS_TIEMPO = [
  { id: "1h", label: "1h", ms: 60 * 60 * 1000 },
  { id: "2h", label: "2h", ms: 2 * 60 * 60 * 1000 },
  { id: "6h", label: "6h", ms: 6 * 60 * 60 * 1000 },
  { id: "12h", label: "12h", ms: 12 * 60 * 60 * 1000 },
  { id: "24h", label: "24h", ms: 24 * 60 * 60 * 1000 },
  { id: "48h", label: "48h", ms: 48 * 60 * 60 * 1000 },
  { id: "7d", label: "7d", ms: 7 * 24 * 60 * 60 * 1000 },
  { id: "custom", label: "Custom", ms: null },
];

// Tipos de gr√°fico disponibles
export const TIPOS_GRAFICO = [
  { id: "line", label: "L√≠nea", icon: "üìà" },
  { id: "area", label: "√Årea", icon: "üìä" },
  { id: "bar", label: "Barras", icon: "üì∂" },
];

// Intervalos de muestreo para informes (en minutos)
export const INTERVALOS_INFORME = [
  { id: 15, label: "15 min", minutos: 15 },
  { id: 30, label: "30 min", minutos: 30 },
  { id: 60, label: "1 hora", minutos: 60 },
  { id: 180, label: "3 horas", minutos: 180 },
  { id: 360, label: "6 horas", minutos: 360 },
  { id: 720, label: "12 horas", minutos: 720 },
];

// Intervalos de filtro para panel de datos (en minutos)
export const INTERVALOS_FILTRO = [
  { value: 0, label: "Todos" },
  { value: 15, label: "cada 15m" },
  { value: 30, label: "cada 30m" },
  { value: 60, label: "cada 60m" },
];

// Colores del gradiente verde-amarillo-rojo
export const COLORES_GRADIENTE = {
  verde: { r: 34, g: 197, b: 94 },     // #22c55e
  amarillo: { r: 234, g: 179, b: 8 },  // #eab308
  rojo: { r: 239, g: 68, b: 68 },      // #ef4444
};

// Configuraci√≥n de IndexedDB
export const INDEXEDDB_CONFIG = {
  nombre: "RelayWatchHistorial",
  version: 1,
  store: "lecturas",
};

// Estilos del gr√°fico base (tema oscuro)
export const ESTILOS_GRAFICO_BASE = {
  background: "#0f172a",
  foreColor: "#e2e8f0",
  gridColor: "#334155",
  labelColor: "#94a3b8",
  borderColor: "#334155",
};

// Estilos del gr√°fico para exportaci√≥n (tema claro)
export const ESTILOS_GRAFICO_EXPORT = {
  background: "#ffffff",
  foreColor: "#1a1a1a",
  gridColor: "#bbbbbb",
  labelColor: "#1a1a1a",
  borderColor: "#333333",
  fontSize: "16px",
  fontSizeTitle: "17px",
  fontWeight: 600,
  fontWeightTitle: 700,
};

========== mi-app/src/paginas/PaginaAlimentadores/constantes/titulosMediciones.js ==========
// src/paginas/PaginaAlimentadores/constantes/titulosMediciones.js

/**
 * T√≠tulos descriptivos para cada tipo de medici√≥n.
 * Aparecen en las tarjetas de alimentadores (parte superior/inferior).
 */
export const TITULOS_MEDICIONES = {
	tension_linea: "Tensi√≥n de l√≠nea (kV)",
	tension_entre_lineas: "Tensi√≥n entre l√≠neas (kV)",
	corriente_132: "Corriente de l√≠nea (A) (en 13,2 kV)",
	corriente_33: "Corriente de l√≠nea (A) (en 33 kV)",
	potencia_activa: "Potencia activa (kW)",
	potencia_reactiva: "Potencia reactiva (kVAr)",
	potencia_aparente: "Potencia aparente (kVA)",
	factor_potencia: "Factor de Potencia",
	frecuencia: "Frecuencia (Hz)",
	corriente_neutro: "Corriente de Neutro (A)",
};

/**
 * Etiquetas que aparecen en cada medidor (R, S, T, etc.),
 * organizadas por tipo de medici√≥n.
 */
export const ETIQUETAS_POR_DEFECTO = {
	corriente_132: ["R", "S", "T", "N"],
	corriente_33: ["R", "S", "T", "N"],
	tension_linea: ["R", "S", "T", "N"],
	tension_entre_lineas: ["L1-L2", "L2-L3", "L1-L3", ""],
	potencia_activa: ["L1", "L2", "L3", "Total"],
	potencia_reactiva: ["L1", "L2", "L3", "Total"],
	potencia_aparente: ["L1", "L2", "L3", "Total"],
	factor_potencia: ["L1", "L2", "L3", ""],
	frecuencia: ["L1", "L2", "L3", ""],
	corriente_neutro: ["N", "", "", ""],
};

/**
 * Dise√±o por defecto de una tarjeta de alimentador.
 * Define qu√© se muestra en la parte superior e inferior.
 */
export const DISE√ëO_TARJETA_POR_DEFECTO = {
	superior: {
		tituloId: "corriente_132", // arriba se muestran corrientes de l√≠nea (13,2 kV)
		tituloCustom: "",
		cantidad: 3,               // por defecto R, S, T
		boxes: [],
	},
	inferior: {
		tituloId: "tension_linea", // abajo se muestran tensiones de l√≠nea (kV)
		tituloCustom: "",
		cantidad: 3,
		boxes: [],
	},
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (titulosMediciones.js)

 - `TITULOS_MEDICIONES` traduce ids como `corriente_132` o `tension_linea`
   a textos legibles que aparecen como t√≠tulos en los lados de la tarjeta.

 - `ETIQUETAS_POR_DEFECTO` define las etiquetas iniciales de cada box seg√∫n
   el tipo de magnitud (por ejemplo, R/S/T/N para corrientes y L1/L2/L3/Total
   para potencias).

 - `DISE√ëO_TARJETA_POR_DEFECTO` se usa en `calculosMediciones.js` como base
   cuando todav√≠a no hay ning√∫n `cardDesign` configurado por el usuario, de
   modo que siempre exista una estructura razonable para mostrar.
---------------------------------------------------------------------------*/}


========== mi-app/src/paginas/PaginaAlimentadores/contexto/ContextoAlimentadoresSupabase.jsx ==========
// src/paginas/PaginaAlimentadores/contexto/ContextoAlimentadoresSupabase.jsx
// Contexto de alimentadores que usa Supabase para persistencia

import React, { createContext, useContext, useMemo, useEffect, useState, useCallback } from "react";

import { usePuestosSupabase } from "../hooks/usePuestosSupabase";
import { useMediciones } from "../hooks/useMediciones";
import { usePreferenciasUI } from "../hooks/usePreferenciasUI";
import { usePreferenciasVisuales } from "../hooks/usePreferenciasVisuales";
import { useCambiosPendientes } from "../hooks/useCambiosPendientes";
import { usarContextoConfiguracion } from "./ContextoConfiguracion";

import { obtenerDisenoTarjeta, calcularValoresLadoTarjeta } from "../utilidades/calculosMediciones";

const ContextoAlimentadores = createContext(null);

/**
 * Provider de alimentadores que usa Supabase.
 * Requiere estar envuelto por ProveedorConfiguracion.
 */
export const ProveedorAlimentadoresSupabase = ({ children }) => {
  // Obtener workspace activo del contexto superior
  const {
    configuracionSeleccionada,
    configuracionSeleccionadaId,
    cargando: cargandoConfig,
  } = usarContextoConfiguracion();

  // Determinar si el usuario es creador del workspace
  // IMPORTANTE: No asumir true por defecto, usar null hasta que se cargue
  // Esto evita que se apliquen valores incorrectos durante la carga inicial
  const esCreador = configuracionSeleccionada?.esCreador ?? null;

  // Hook de puestos conectado a Supabase
  const puestosHook = usePuestosSupabase(configuracionSeleccionadaId);

  // Hook de mediciones (sin cambios, funciona igual)
  const medicionesHook = useMediciones();

  // Hook de preferencias UI (gaps horizontales y verticales) - localStorage
  const preferenciasHook = usePreferenciasUI();

  // Hook de preferencias visuales persistentes en BD (para invitados)
  const preferenciasVisualesHook = usePreferenciasVisuales(
    configuracionSeleccionadaId,
    esCreador,
    puestosHook.puestos,
    puestosHook.cargarPuestos
  );

  // Hook de cambios pendientes (draft/publish pattern)
  const cambiosPendientesHook = useCambiosPendientes();

  const { registrosEnVivo } = medicionesHook;
  const { puestoSeleccionado, puestos, cargando: cargandoPuestos } = puestosHook;
  const { gapsPorTarjeta, gapsPorFila, escalasPorPuesto, escalasPorTarjeta } = preferenciasHook;
  const { guardarSnapshot, detectarCambios, sincronizarConBD, sincronizando, errorSincronizacion } = cambiosPendientesHook;

  const [lecturasTarjetas, setLecturasTarjetas] = useState({});
  const [hayCambiosPendientes, setHayCambiosPendientes] = useState(false);
  // Flag para saber si ya guardamos el snapshot inicial de BD
  const [snapshotGuardado, setSnapshotGuardado] = useState(false);

  // Estado de carga combinado
  // - Siempre esperar a que cargue la configuraci√≥n (para determinar esCreador)
  // - Siempre esperar a que carguen los puestos
  // - Para invitados (esCreador === false), tambi√©n esperamos a que carguen las preferencias personales
  // - Cuando esCreador es null, tambi√©n esperamos las preferencias para evitar mostrar datos incorrectos
  const cargando = cargandoConfig || cargandoPuestos || (esCreador !== true && preferenciasVisualesHook.cargando);

  /**
   * Para invitados: aplica las preferencias personales sobre los puestos base.
   * Esto crea una vista "merged" que el invitado ve como su configuraci√≥n inicial.
   */
  const obtenerPuestosConPreferencias = useCallback(() => {
    if (esCreador || !preferenciasVisualesHook.preferenciasUsuario) {
      return puestos;
    }

    // Aplicar preferencias personales sobre los puestos base
    return puestos.map(puesto => {
      const prefsPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puesto.id);

      // Aplicar preferencias del puesto si existen
      const puestoMerged = {
        ...puesto,
        color: prefsPuesto?.color || puesto.color,
        bgColor: prefsPuesto?.bg_color || puesto.bgColor || puesto.bg_color,
        escala: prefsPuesto?.escala ?? puesto.escala,
        gapsVerticales: {
          ...(puesto.gapsVerticales || { "0": 40 }),
          ...(prefsPuesto?.gapsVerticales || {}),
        },
        // Aplicar preferencias a los alimentadores
        alimentadores: (puesto.alimentadores || []).map(alim => {
          const prefsAlim = preferenciasVisualesHook.obtenerConfigAlimentador(alim.id, puesto.id);
          return {
            ...alim,
            color: prefsAlim?.color || alim.color,
            escala: prefsAlim?.escala ?? alim.escala,
            gapHorizontal: prefsAlim?.gapHorizontal ?? alim.gapHorizontal ?? 10,
          };
        }),
      };

      return puestoMerged;
    });
  }, [esCreador, puestos, preferenciasVisualesHook]);

  // Guardar snapshot SOLO cuando terminamos de cargar de BD (una sola vez)
  // Para invitados: esperamos tambi√©n a que carguen las preferencias personales
  // y usamos los datos merged (BASE + preferencias)
  useEffect(() => {
    // Solo guardar snapshot cuando:
    // 1. Hay puestos cargados
    // 2. Ya no estamos cargando (termin√≥ la carga de BD)
    // 3. esCreador ya tiene un valor definitivo (true o false, no null)
    // 4. Para invitados: tambi√©n termin√≥ de cargar preferencias
    // 5. No hemos guardado el snapshot a√∫n para esta sesi√≥n de carga
    if (esCreador === null) return; // Esperar a que se determine el rol

    const prefsListas = esCreador || !preferenciasVisualesHook.cargando;

    if (puestos.length > 0 && !cargandoPuestos && prefsListas && !snapshotGuardado) {
      // Para invitados, guardar snapshot con datos merged
      const puestosParaSnapshot = esCreador ? puestos : obtenerPuestosConPreferencias();
      guardarSnapshot(puestosParaSnapshot);
      setSnapshotGuardado(true);
    }
  }, [puestos, cargandoPuestos, snapshotGuardado, guardarSnapshot, esCreador, preferenciasVisualesHook.cargando, obtenerPuestosConPreferencias]);

  // Resetear flag cuando cambia el workspace (para recargar snapshot)
  useEffect(() => {
    setSnapshotGuardado(false);
  }, [configuracionSeleccionadaId]);

  // Detectar cambios cada vez que cambian los datos locales
  // Funciona igual para creadores e invitados:
  // - Creador: cambios van a BASE
  // - Invitado: cambios visuales van a preferencias_usuario
  useEffect(() => {
    // Esperar a que esCreador tenga un valor definitivo
    if (esCreador === null) return;

    if (puestos.length > 0) {
      // Para invitados, usamos datos merged (preferencias + base) para comparar con el snapshot
      // Esto evita falsos positivos cuando el snapshot tiene colores de preferencias personales
      const puestosParaDeteccion = esCreador ? puestos : obtenerPuestosConPreferencias();

      // Para gaps verticales por puesto, construimos un objeto
      // Extraemos de gapsPorFila solo los gaps de cada puesto (formato clave: "puestoId:rowIndex")
      const gapsPorFilaPorPuesto = {};
      puestosParaDeteccion.forEach((p) => {
        const gapsDelPuesto = {};
        // Buscar en gapsPorFila todas las claves que empiezan con este puestoId
        Object.entries(gapsPorFila).forEach(([clave, valor]) => {
          if (clave.startsWith(`${p.id}:`)) {
            // Extraer el rowIndex de la clave "puestoId:rowIndex"
            const rowIndex = clave.split(':')[1];
            gapsDelPuesto[rowIndex] = valor;
          }
        });
        // Combinar: BD primero, luego localStorage (localStorage tiene prioridad)
        gapsPorFilaPorPuesto[p.id] = { ...p.gapsVerticales, ...gapsDelPuesto };
      });

      const { hayCambios } = detectarCambios(puestosParaDeteccion, gapsPorTarjeta, gapsPorFilaPorPuesto, escalasPorPuesto, escalasPorTarjeta);
      setHayCambiosPendientes(hayCambios);
    }
  }, [puestos, gapsPorTarjeta, gapsPorFila, escalasPorPuesto, escalasPorTarjeta, detectarCambios, esCreador, obtenerPuestosConPreferencias]);

  /**
   * Sincroniza cambios visuales de un invitado a preferencias_usuario.
   * Solo guarda: colores, gaps, escalas (NO estructura de puestos/alimentadores).
   */
  const sincronizarCambiosInvitado = useCallback(async (cambios) => {
    try {
      // Guardar cambios de puestos en preferencias
      for (const { id, campos } of cambios.puestos) {
        const prefsToSave = {};
        if (campos.color !== undefined) prefsToSave.color = campos.color;
        if (campos.bgColor !== undefined) prefsToSave.bg_color = campos.bgColor;
        if (campos.gapsVerticales !== undefined) prefsToSave.gapsVerticales = campos.gapsVerticales;
        if (campos.escala !== undefined) prefsToSave.escala = campos.escala;

        if (Object.keys(prefsToSave).length > 0) {
          await preferenciasVisualesHook.guardarPreferenciasPuesto(id, prefsToSave);
        }
      }

      // Guardar cambios de alimentadores en preferencias
      for (const { id, campos } of cambios.alimentadores) {
        const prefsToSave = {};
        if (campos.color !== undefined) prefsToSave.color = campos.color;
        if (campos.gapHorizontal !== undefined) prefsToSave.gapHorizontal = campos.gapHorizontal;
        if (campos.escala !== undefined) prefsToSave.escala = campos.escala;

        if (Object.keys(prefsToSave).length > 0) {
          await preferenciasVisualesHook.guardarPreferenciasAlimentador(id, prefsToSave);
        }
      }

      // Nota: El orden de alimentadores (reordenarAlimentadores) NO se guarda en preferencias
      // porque afecta la estructura visual para todos. Si se quiere permitir orden personalizado,
      // habr√≠a que agregar soporte para eso en el futuro.

      return true;
    } catch (error) {
      console.error("Error sincronizando preferencias de invitado:", error);
      throw error;
    }
  }, [preferenciasVisualesHook]);

  // Funci√≥n para sincronizar cambios con BD
  // Para creadores: guarda en BASE
  // Para invitados: guarda cambios visuales en preferencias_usuario
  const sincronizarCambios = useCallback(async () => {
    if (!hayCambiosPendientes) return;

    // Para invitados, usamos datos merged para detectar cambios correctamente
    const puestosParaSync = esCreador ? puestos : obtenerPuestosConPreferencias();

    // Construir gapsPorFilaPorPuesto extrayendo solo los gaps de cada puesto
    const gapsPorFilaPorPuesto = {};
    puestosParaSync.forEach((p) => {
      const gapsDelPuesto = {};
      Object.entries(gapsPorFila).forEach(([clave, valor]) => {
        if (clave.startsWith(`${p.id}:`)) {
          const rowIndex = clave.split(':')[1];
          gapsDelPuesto[rowIndex] = valor;
        }
      });
      gapsPorFilaPorPuesto[p.id] = { ...p.gapsVerticales, ...gapsDelPuesto };
    });

    const { cambios } = detectarCambios(puestosParaSync, gapsPorTarjeta, gapsPorFilaPorPuesto, escalasPorPuesto, escalasPorTarjeta);

    if (esCreador) {
      // CREADOR: Guardar todo en BASE
      await sincronizarConBD(
        cambios,
        // onSuccess
        async () => {
          // Limpiar gaps del localStorage ya que ahora est√°n en la BD
          preferenciasHook.resetearTodosLosGaps();
          preferenciasHook.resetearTodosLosRowGaps();
          preferenciasHook.resetearTodasLasEscalasPuestos();
          preferenciasHook.resetearTodasLasEscalasTarjetas();
          // Resetear flag para que se guarde nuevo snapshot al recargar
          setSnapshotGuardado(false);
          // Recargar datos para actualizar snapshot
          await puestosHook.cargarPuestos();
        },
        (error) => {
          console.error("Error al sincronizar:", error);
        }
      );
    } else {
      // INVITADO: Guardar cambios visuales en preferencias_usuario
      try {
        await sincronizarCambiosInvitado(cambios);

        // Limpiar localStorage
        preferenciasHook.resetearTodosLosGaps();
        preferenciasHook.resetearTodosLosRowGaps();
        preferenciasHook.resetearTodasLasEscalasPuestos();
        preferenciasHook.resetearTodasLasEscalasTarjetas();

        // Recargar preferencias del usuario para actualizar snapshot
        await preferenciasVisualesHook.cargarPreferencias();
        // Resetear flag para que se guarde nuevo snapshot
        setSnapshotGuardado(false);
        // Recargar puestos tambi√©n (para que el snapshot use datos frescos)
        await puestosHook.cargarPuestos();
      } catch (error) {
        console.error("Error al sincronizar preferencias:", error);
      }
    }
  }, [hayCambiosPendientes, puestos, gapsPorTarjeta, gapsPorFila, escalasPorPuesto, escalasPorTarjeta, detectarCambios, sincronizarConBD, puestosHook, preferenciasHook, esCreador, sincronizarCambiosInvitado, preferenciasVisualesHook, obtenerPuestosConPreferencias]);

  // Funci√≥n para descartar cambios
  // Limpia localStorage y recarga datos de BD para restaurar orden original
  const descartarCambios = useCallback(async () => {
    // Limpiar localStorage de gaps
    preferenciasHook.resetearTodosLosGaps();
    preferenciasHook.resetearTodosLosRowGaps();
    // Limpiar localStorage de escalas (por puesto y por tarjeta)
    preferenciasHook.resetearTodasLasEscalasPuestos();
    preferenciasHook.resetearTodasLasEscalasTarjetas();
    // Resetear flag y recargar datos de BD para restaurar orden original
    setSnapshotGuardado(false);

    // Para invitados, tambi√©n recargar preferencias personales
    if (!esCreador) {
      await preferenciasVisualesHook.cargarPreferencias();
    }

    await puestosHook.cargarPuestos();
  }, [preferenciasHook, puestosHook, esCreador, preferenciasVisualesHook]);

  // Funci√≥n para limpiar todo el localStorage de preferencias UI (al salir)
  const limpiarPreferenciasUI = useCallback(() => {
    preferenciasHook.resetearTodosLosGaps();
    preferenciasHook.resetearTodosLosRowGaps();
  }, [preferenciasHook]);

  // ===== NOTA SOBRE GUARDADO =====
  // Tanto creadores como invitados usan localStorage para cambios locales.
  // Al hacer clic en "Guardar":
  // - Creador: sincroniza cambios a BASE (tabla puestos/alimentadores)
  // - Invitado: sincroniza cambios visuales a preferencias_usuario
  //
  // Las funciones de establecerGap, establecerRowGap, etc. del preferenciasHook
  // se usan directamente sin wrappers ya que ambos roles usan localStorage.

  /**
   * Obtiene el color del bot√≥n de un puesto.
   * - Creador: devuelve el color de la BD
   * - Invitado: devuelve preferencia personal > BD
   */
  const obtenerColorPuesto = useCallback((puestoId) => {
    const puesto = puestosHook.puestos.find(p => p.id === puestoId);
    if (!puesto) return null;

    // Para invitados, verificar si tienen preferencia personal
    if (!esCreador) {
      const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
      if (configPuesto?.color) {
        return configPuesto.color;
      }
    }

    return puesto.color;
  }, [esCreador, puestosHook.puestos, preferenciasVisualesHook]);

  /**
   * Obtiene el color de fondo de un puesto.
   * - Creador: devuelve el color de la BD
   * - Invitado: devuelve preferencia personal > BD
   */
  const obtenerBgColorPuesto = useCallback((puestoId) => {
    const puesto = puestosHook.puestos.find(p => p.id === puestoId);
    if (!puesto) return null;

    // Para invitados, verificar si tienen preferencia personal
    if (!esCreador) {
      const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
      if (configPuesto?.bg_color) {
        return configPuesto.bg_color;
      }
    }

    return puesto.bgColor || puesto.bg_color;
  }, [esCreador, puestosHook.puestos, preferenciasVisualesHook]);

  /**
   * Actualiza puestos seg√∫n el rol del usuario.
   * - Creador: guarda en BASE (tabla puestos) - puede editar nombres y colores
   * - Invitado: solo guarda colores en preferencias_usuario (no puede editar nombres)
   *
   * @param {Array} puestosEditados - Lista de puestos editados
   */
  const actualizarPuestosInteligente = useCallback(async (puestosEditados) => {
    if (esCreador) {
      // Creador: guardar todo en BASE
      await puestosHook.actualizarPuestos(puestosEditados);
    } else {
      // Invitado: solo guardar colores en preferencias_usuario
      // Los nombres NO se guardan (invitados no pueden cambiar nombres)
      // IMPORTANTE: Comparamos contra el color "merged" (preferencia actual > BD)
      // para detectar solo los cambios reales del usuario
      for (const puesto of puestosEditados) {
        const puestoBase = puestosHook.puestos.find(p => p.id === puesto.id);
        if (!puestoBase) continue;

        // Obtener el color actual considerando preferencias existentes
        const colorActual = obtenerColorPuesto(puesto.id) || puestoBase.color;
        const bgColorActual = obtenerBgColorPuesto(puesto.id) || puestoBase.bgColor || puestoBase.bg_color;

        // Detectar si cambiaron los colores respecto al estado merged
        const cambios = {};
        if (puesto.color !== colorActual) {
          cambios.color = puesto.color;
        }
        if ((puesto.bgColor || puesto.bg_color) !== bgColorActual) {
          cambios.bg_color = puesto.bgColor || puesto.bg_color;
        }

        // Si hay cambios de color, guardarlos en preferencias
        if (Object.keys(cambios).length > 0) {
          await preferenciasVisualesHook.guardarPreferenciasPuesto(puesto.id, cambios);
        }
      }
    }
  }, [esCreador, puestosHook, preferenciasVisualesHook, obtenerColorPuesto, obtenerBgColorPuesto]);

  // Recalcular lecturas de tarjetas cuando cambian los datos
  useEffect(() => {
    if (!puestoSeleccionado) {
      setLecturasTarjetas({});
      return;
    }

    setLecturasTarjetas(() => {
      const nuevo = {};

      puestoSeleccionado.alimentadores.forEach((alim) => {
        const regsDelAlim = registrosEnVivo[alim.id] || null;
        // Usar card_design (nuevo) o mapeoMediciones (legacy) para compatibilidad
        const cardDesignData = alim.card_design || alim.mapeoMediciones || {};
        const diseno = obtenerDisenoTarjeta(cardDesignData);

        const parteSuperior = calcularValoresLadoTarjeta(regsDelAlim, diseno.superior);
        const parteInferior = calcularValoresLadoTarjeta(regsDelAlim, diseno.inferior);

        nuevo[alim.id] = { parteSuperior, parteInferior };
      });

      return nuevo;
    });
  }, [puestoSeleccionado, registrosEnVivo]);

  // ===== FUNCIONES DE GAP COMBINADAS (localStorage + BD + preferencias usuario) =====
  // Prioridad para AMBOS ROLES: localStorage > preferencias_usuario > BD > default
  // localStorage tiene prioridad porque representa cambios "en progreso" antes de guardar

  /**
   * Obtiene el gap horizontal de un alimentador.
   * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > default
   * localStorage tiene prioridad porque representa cambios "en progreso" antes de guardar
   */
  const obtenerGapCombinado = useCallback((alimId) => {
    // 1. Primero mirar localStorage (cambios no guardados, aplica a ambos roles)
    const gapLocal = gapsPorTarjeta[alimId];
    if (gapLocal !== undefined) {
      return gapLocal;
    }

    // 2. Para invitados, mirar preferencias visuales persistentes (ya guardadas en BD)
    if (!esCreador) {
      const configAlim = preferenciasVisualesHook.obtenerConfigAlimentador(alimId, puestoSeleccionado?.id);
      if (configAlim?.gapHorizontal !== undefined) {
        return configAlim.gapHorizontal;
      }
    }

    // 3. Buscar en los datos de BD base
    if (puestoSeleccionado) {
      const alimentador = puestoSeleccionado.alimentadores.find(a => a.id === alimId);
      if (alimentador && alimentador.gapHorizontal !== undefined) {
        return alimentador.gapHorizontal;
      }
    }

    // 4. Default
    return preferenciasHook.GAP_DEFAULT;
  }, [esCreador, gapsPorTarjeta, puestoSeleccionado, preferenciasHook.GAP_DEFAULT, preferenciasVisualesHook]);

  /**
   * Obtiene el gap vertical de una fila en un puesto espec√≠fico.
   * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > default
   * localStorage tiene prioridad porque representa cambios "en progreso" antes de guardar
   * @param {string} puestoId - ID del puesto
   * @param {number} rowIndex - √çndice de la fila
   */
  const obtenerRowGapCombinado = useCallback((puestoId, rowIndex) => {
    // 1. Primero mirar localStorage (cambios no guardados, aplica a ambos roles)
    const claveLocal = `${puestoId}:${rowIndex}`;
    const gapLocal = gapsPorFila[claveLocal];
    if (gapLocal !== undefined) {
      return gapLocal;
    }

    // 2. Para invitados, mirar preferencias visuales persistentes (ya guardadas en BD)
    if (!esCreador) {
      const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
      if (configPuesto?.gapsVerticales?.[rowIndex] !== undefined) {
        return configPuesto.gapsVerticales[rowIndex];
      }
    }

    // 3. Buscar en los gaps verticales del puesto espec√≠fico (BD base)
    const puesto = puestos.find(p => p.id === puestoId);
    if (puesto && puesto.gapsVerticales) {
      const gapBD = puesto.gapsVerticales[rowIndex];
      if (gapBD !== undefined) {
        return gapBD;
      }
    }

    // 4. Default
    return preferenciasHook.ROW_GAP_DEFAULT;
  }, [esCreador, gapsPorFila, puestos, preferenciasHook.ROW_GAP_DEFAULT, preferenciasVisualesHook]);

  // ===== FUNCIONES DE ESCALA COMBINADAS (localStorage + BD + preferencias usuario) =====
  // Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > null

  /**
   * Obtiene la escala de un puesto.
   * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > null
   * localStorage tiene prioridad porque representa cambios "en progreso" antes de guardar
   * @param {string} puestoId - ID del puesto
   * @returns {number|null} Escala del puesto o null si no est√° definida
   */
  const obtenerEscalaPuestoCombinada = useCallback((puestoId) => {
    if (!puestoId) return null;

    // 1. Primero mirar localStorage (cambios no guardados, aplica a ambos roles)
    const escalaLocal = escalasPorPuesto[puestoId];
    if (escalaLocal !== undefined) {
      return escalaLocal;
    }

    // 2. Para invitados, mirar preferencias visuales persistentes (ya guardadas en BD)
    if (!esCreador) {
      const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
      if (configPuesto?.escala !== undefined && configPuesto?.escala !== null) {
        return configPuesto.escala;
      }
    }

    // 3. Buscar en los datos de BD base
    const puesto = puestos.find(p => String(p.id) === String(puestoId));
    if (puesto && puesto.escala !== undefined && puesto.escala !== null) {
      return puesto.escala;
    }

    // 4. No hay escala definida (usar jerarqu√≠a global)
    return null;
  }, [esCreador, escalasPorPuesto, puestos, preferenciasVisualesHook]);

  /**
   * Obtiene la escala de un alimentador (tarjeta individual).
   * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > null
   * localStorage tiene prioridad porque representa cambios "en progreso" antes de guardar
   * @param {string} alimId - ID del alimentador
   * @returns {number|null} Escala del alimentador o null si no est√° definida
   */
  const obtenerEscalaTarjetaCombinada = useCallback((alimId) => {
    if (!alimId) return null;

    // 1. Primero mirar localStorage (cambios no guardados, aplica a ambos roles)
    const escalaLocal = escalasPorTarjeta[alimId];
    // Si es null expl√≠cito, significa "ignorar escala individual" (usar puesto/global)
    if (escalaLocal === null) {
      return null;
    }
    // Si tiene un valor num√©rico, usarlo
    if (escalaLocal !== undefined) {
      return escalaLocal;
    }

    // 2. Para invitados, mirar preferencias visuales persistentes (ya guardadas en BD)
    if (!esCreador) {
      const configAlim = preferenciasVisualesHook.obtenerConfigAlimentador(alimId, puestoSeleccionado?.id);
      if (configAlim?.escala !== undefined && configAlim?.escala !== null) {
        return configAlim.escala;
      }
    }

    // 3. Buscar en los datos de BD base (en el puesto seleccionado)
    if (puestoSeleccionado) {
      const alimentador = puestoSeleccionado.alimentadores.find(a => String(a.id) === String(alimId));
      if (alimentador && alimentador.escala !== undefined && alimentador.escala !== null) {
        return alimentador.escala;
      }
    }

    // 4. No hay escala definida (usar jerarqu√≠a puesto/global)
    return null;
  }, [esCreador, escalasPorTarjeta, puestoSeleccionado, preferenciasVisualesHook]);

  /**
   * Obtiene la escala efectiva de una tarjeta considerando toda la jerarqu√≠a:
   * Individual > Por puesto > Global > Default
   * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > default
   * @param {string} alimId - ID del alimentador
   * @param {string} puestoId - ID del puesto
   * @returns {number} Escala efectiva a aplicar
   */
  const obtenerEscalaEfectivaCombinada = useCallback((alimId, puestoId) => {
    // Usar las funciones combinadas que ya consideran localStorage > preferencias > BD
    // 1. Escala individual (m√°xima prioridad)
    const escalaIndividual = obtenerEscalaTarjetaCombinada(alimId);
    if (escalaIndividual !== null) return escalaIndividual;

    // 2. Escala por puesto
    const escalaPuesto = obtenerEscalaPuestoCombinada(puestoId);
    if (escalaPuesto !== null) return escalaPuesto;

    // 3. Escala global (solo localStorage, no se guarda en BD)
    if (preferenciasHook.escalaGlobal !== preferenciasHook.ESCALA_DEFAULT) {
      return preferenciasHook.escalaGlobal;
    }

    // 4. Default
    return preferenciasHook.ESCALA_DEFAULT;
  }, [obtenerEscalaTarjetaCombinada, obtenerEscalaPuestoCombinada, preferenciasHook.escalaGlobal, preferenciasHook.ESCALA_DEFAULT]);

  // Objeto de contexto
  const valorContexto = useMemo(
    () => ({
      // Estados de carga
      cargando,
      error: puestosHook.error,

      // Workspace actual
      configuracionSeleccionada,
      configuracionSeleccionadaId,

      // Datos de puestos
      puestos: puestosHook.puestos,
      puestoSeleccionado: puestosHook.puestoSeleccionado,
      puestoSeleccionadoId: puestosHook.puestoSeleccionadoId,

      agregarPuesto: puestosHook.agregarPuesto,
      eliminarPuesto: puestosHook.eliminarPuesto,
      seleccionarPuesto: puestosHook.seleccionarPuesto,
      // actualizarPuestos: usa la versi√≥n inteligente que considera el rol
      actualizarPuestos: actualizarPuestosInteligente,
      setPuestos: puestosHook.setPuestos,
      cargarPuestos: puestosHook.cargarPuestos,

      // Getters de colores (consideran preferencias de invitados)
      obtenerColorPuesto,
      obtenerBgColorPuesto,

      // Alimentadores
      agregarAlimentador: puestosHook.agregarAlimentador,
      actualizarAlimentador: puestosHook.actualizarAlimentador,
      eliminarAlimentador: puestosHook.eliminarAlimentador,
      reordenarAlimentadores: puestosHook.reordenarAlimentadores,

      // Mediciones y lecturas
      lecturasTarjetas,
      registrosEnVivo: medicionesHook.registrosEnVivo,

      detenerMedicion: medicionesHook.detenerMedicion,
      obtenerRegistros: medicionesHook.obtenerRegistros,
      estaMidiendo: medicionesHook.estaMidiendo,
      obtenerTimestampInicio: medicionesHook.obtenerTimestampInicio,
      obtenerContadorLecturas: medicionesHook.obtenerContadorLecturas,
      actualizarRegistros: medicionesHook.actualizarRegistros,

      // Preferencias UI (gaps)
      // Las funciones obtener* combinan localStorage/preferencias + BD
      // Las funciones establecer* guardan en localStorage (se sincronizan con "Guardar")
      gapsPorTarjeta: preferenciasHook.gapsPorTarjeta,
      gapsPorFila: preferenciasHook.gapsPorFila,
      obtenerGap: obtenerGapCombinado,
      establecerGap: preferenciasHook.establecerGap,
      obtenerRowGap: obtenerRowGapCombinado,
      establecerRowGap: preferenciasHook.establecerRowGap,
      GAP_MIN: preferenciasHook.GAP_MIN,
      GAP_MAX: preferenciasHook.GAP_MAX,
      GAP_DEFAULT: preferenciasHook.GAP_DEFAULT,
      ROW_GAP_MIN: preferenciasHook.ROW_GAP_MIN,
      ROW_GAP_MAX: preferenciasHook.ROW_GAP_MAX,
      ROW_GAP_DEFAULT: preferenciasHook.ROW_GAP_DEFAULT,

      // Escala de tarjetas
      // Las funciones obtener* combinan localStorage/preferencias + BD
      // Las funciones establecer* guardan en localStorage (se sincronizan con "Guardar")
      escalaGlobal: preferenciasHook.escalaGlobal,
      establecerEscalaGlobal: preferenciasHook.establecerEscalaGlobal,
      resetearEscalaGlobal: preferenciasHook.resetearEscalaGlobal,
      escalasPorPuesto: preferenciasHook.escalasPorPuesto,
      obtenerEscalaPuesto: obtenerEscalaPuestoCombinada,
      establecerEscalaPuesto: preferenciasHook.establecerEscalaPuesto,
      resetearEscalaPuesto: preferenciasHook.resetearEscalaPuesto,
      escalasPorTarjeta: preferenciasHook.escalasPorTarjeta,
      obtenerEscalaTarjeta: obtenerEscalaTarjetaCombinada,
      establecerEscalaTarjeta: preferenciasHook.establecerEscalaTarjeta,
      resetearEscalaTarjeta: preferenciasHook.resetearEscalaTarjeta,
      obtenerEscalaEfectiva: obtenerEscalaEfectivaCombinada,
      resetearTodasLasEscalas: preferenciasHook.resetearTodasLasEscalas,
      ESCALA_MIN: preferenciasHook.ESCALA_MIN,
      ESCALA_MAX: preferenciasHook.ESCALA_MAX,
      ESCALA_DEFAULT: preferenciasHook.ESCALA_DEFAULT,

      // Cambios pendientes (draft/publish)
      hayCambiosPendientes,
      sincronizando,
      errorSincronizacion,
      sincronizarCambios,
      descartarCambios,

      // Limpieza al salir
      limpiarPreferenciasUI,

      // Info del rol del usuario en el workspace
      esCreador,

      // Preferencias visuales persistentes (para invitados)
      // Expone funciones para guardar preferencias personalizadas
      preferenciasVisuales: {
        cargando: preferenciasVisualesHook.cargando,
        guardando: preferenciasVisualesHook.guardando,
        tienePreferenciasPersonales: preferenciasVisualesHook.tienePreferenciasPersonales,
        guardarPreferencia: preferenciasVisualesHook.guardarPreferencia,
        guardarPreferenciasPuesto: preferenciasVisualesHook.guardarPreferenciasPuesto,
        guardarPreferenciasAlimentador: preferenciasVisualesHook.guardarPreferenciasAlimentador,
        resetearPreferencias: preferenciasVisualesHook.resetearPreferencias,
        obtenerConfigPuesto: preferenciasVisualesHook.obtenerConfigPuesto,
        obtenerConfigAlimentador: preferenciasVisualesHook.obtenerConfigAlimentador,
      },
    }),
    [puestosHook, medicionesHook, preferenciasHook, preferenciasVisualesHook, lecturasTarjetas, configuracionSeleccionada, cargando, hayCambiosPendientes, sincronizando, errorSincronizacion, sincronizarCambios, descartarCambios, obtenerGapCombinado, obtenerRowGapCombinado, obtenerEscalaPuestoCombinada, obtenerEscalaTarjetaCombinada, obtenerEscalaEfectivaCombinada, limpiarPreferenciasUI, esCreador, actualizarPuestosInteligente, obtenerColorPuesto, obtenerBgColorPuesto]
  );

  return (
    <ContextoAlimentadores.Provider value={valorContexto}>
      {children}
    </ContextoAlimentadores.Provider>
  );
};

export const usarContextoAlimentadores = () => {
  const contexto = useContext(ContextoAlimentadores);

  if (!contexto) {
    throw new Error(
      "usarContextoAlimentadores debe usarse dentro de ProveedorAlimentadoresSupabase"
    );
  }

  return contexto;
};

========== mi-app/src/paginas/PaginaAlimentadores/contexto/ContextoConfiguracion.jsx ==========
// src/paginas/PaginaAlimentadores/contexto/ContextoConfiguracion.jsx
// Contexto global para manejar el workspace activo del usuario y estilos globales

import React, { createContext, useContext, useMemo } from "react";
import { useConfiguracion } from "../hooks/useConfiguracion";
import useEstilosGlobales from "../hooks/useEstilosGlobales";

const ContextoConfiguracion = createContext(null);

/**
 * Provider que maneja los workspaces del usuario y los estilos globales de tarjetas.
 * Debe envolver a ProveedorAlimentadores para que este tenga acceso
 * al workspace seleccionado.
 */
export const ProveedorConfiguracion = ({ children }) => {
  const configuracionHook = useConfiguracion();
  const estilosGlobalesHook = useEstilosGlobales();

  // Combinar ambos hooks en un solo valor de contexto
  const valorContexto = useMemo(() => ({
    ...configuracionHook,
    // Estilos globales de tarjetas
    estilosGlobales: estilosGlobalesHook.estilos,
    guardarEstilosGlobales: estilosGlobalesHook.aplicarTodosEstilos,
    obtenerEstilosCSS: estilosGlobalesHook.obtenerEstilosCSS,
  }), [configuracionHook, estilosGlobalesHook]);

  return (
    <ContextoConfiguracion.Provider value={valorContexto}>
      {children}
    </ContextoConfiguracion.Provider>
  );
};

/**
 * Hook para acceder al contexto de workspace
 */
export const usarContextoConfiguracion = () => {
  const contexto = useContext(ContextoConfiguracion);

  if (!contexto) {
    throw new Error(
      "usarContextoConfiguracion debe usarse dentro de ProveedorConfiguracion"
    );
  }

  return contexto;
};

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useArrastrarSoltar.js ==========
// src/paginas/PaginaAlimentadores/hooks/usarArrastrarSoltar.js

import { useState } from "react"; // hook de React para manejar estado local

/**
 * Hook personalizado para manejar drag & drop (arrastrar y soltar).
 * Simplifica la l√≥gica de reordenamiento de alimentadores.
 *
 * @returns {Object} Estado y funciones para drag & drop.
 */
export const useArrastrarSoltar = () => {
	// ID del elemento que se est√° arrastrando actualmente (o null si ninguno)
	const [elementoArrastrandoId, setElementoArrastrandoId] = useState(null);

	/**
	 * Maneja el inicio del arrastre.
	 *
	 * @param {number} id - ID del elemento arrastrado.
	 */
	const alIniciarArrastre = (id) => {
		setElementoArrastrandoId(id);
	};

	/**
	 * Maneja el fin del arrastre.
	 * Limpia el estado interno.
	 */
	const alTerminarArrastre = () => {
		setElementoArrastrandoId(null);
	};

	/**
	 * Permite que un elemento sea un destino v√°lido de drop.
	 *
	 * @param {DragEvent} evento - Evento dragover.
	 */
	const alPasarPorEncima = (evento) => {
		evento.preventDefault(); // sin esto, el navegador no permite soltar
	};

	/**
	 * Reordena una lista moviendo un elemento a la posici√≥n de otro.
	 *
	 * @param {Array} lista - Lista original.
	 * @param {number} idOrigen - ID del elemento a mover.
	 * @param {number} idDestino - ID del elemento destino.
	 * @returns {Array} Nueva lista reordenada.
	 */
	const reordenarLista = (lista, idOrigen, idDestino) => {
		if (idOrigen === idDestino) return lista; // nada que hacer si son el mismo

		const nuevaLista = [...lista];
		const indiceOrigen = nuevaLista.findIndex((item) => item.id === idOrigen);
		const indiceDestino = nuevaLista.findIndex((item) => item.id === idDestino);

		if (indiceOrigen === -1 || indiceDestino === -1) return lista; // ids inv√°lidos

		// Remover elemento del origen
		const [elementoMovido] = nuevaLista.splice(indiceOrigen, 1);

		// Insertar en la posici√≥n destino
		nuevaLista.splice(indiceDestino, 0, elementoMovido);

		return nuevaLista;
	};

	/**
	 * Mueve un elemento al final de la lista.
	 *
	 * @param {Array} lista - Lista original.
	 * @param {number} idElemento - ID del elemento a mover.
	 * @returns {Array} Nueva lista con elemento al final.
	 */
	const moverAlFinal = (lista, idElemento) => {
		const nuevaLista = [...lista];
		const indice = nuevaLista.findIndex((item) => item.id === idElemento);

		if (indice === -1) return lista; // id no encontrado

		// Remover y agregar al final
		const [elementoMovido] = nuevaLista.splice(indice, 1);
		nuevaLista.push(elementoMovido);

		return nuevaLista;
	};

	return {
		// Estado
		elementoArrastrandoId,
		estaArrastrando: elementoArrastrandoId !== null,

		// Handlers de eventos
		alIniciarArrastre,
		alTerminarArrastre,
		alPasarPorEncima,

		// Funciones de utilidad
		reordenarLista,
		moverAlFinal,
	};
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (usarArrastrarSoltar.js)

 - Este hook concentra la l√≥gica de drag & drop usada para reordenar tarjetas
   de alimentadores en la grilla.

 - `elementoArrastrandoId` guarda el id de la tarjeta que estoy arrastrando; si
   es `null`, significa que no hay ning√∫n drag activo. La propiedad derivada
   `estaArrastrando` es simplemente un atajo (`id !== null`).

 - `alIniciarArrastre(id)` se llama en `onDragStart` de una tarjeta: marca qu√©
   tarjeta se est√° moviendo.

 - `alTerminarArrastre()` se llama en `onDragEnd` o despu√©s de soltar: limpia el
   estado y vuelve todo a "sin arrastre".

 - `alPasarPorEncima(evento)` se usa en `onDragOver` de los destinos; la llamada
   a `evento.preventDefault()` es lo que le dice al navegador "ac√° s√≠ se puede
   soltar", sin eso el drop no se dispara.

 - `reordenarLista(lista, idOrigen, idDestino)` recibe la lista actual de
   alimentadores y los ids origen/destino, calcula los √≠ndices y devuelve una
   nueva lista con el elemento movido a la posici√≥n correcta.

 - `moverAlFinal(lista, idElemento)` se usa para el √°rea de "solt√° ac√° para
   enviar al final": quita el elemento de su posici√≥n actual y lo agrega al
   final del array.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (usarArrastrarSoltar.js)

0) Visi√≥n general del hook

   Este hook encapsula toda la l√≥gica b√°sica de ‚Äúarrastrar y soltar‚Äù que se usa para reordenar tarjetas de 
	alimentadores.

   La idea es que los componentes de UI no tengan que:
     - recordar qu√© tarjeta se est√° arrastrando,
     - calcular a mano el nuevo orden,
     - ni saber c√≥mo funciona el drag & drop nativo del navegador.

   En cambio, solo usan:
     - estado: `elementoArrastrandoId` y `estaArrastrando`,
     - handlers: `alIniciarArrastre`, `alTerminarArrastre`, `alPasarPorEncima`,
     - utilidades: `reordenarLista` y `moverAlFinal`.


1) Estado: elementoArrastrandoId

   const [elementoArrastrandoId, setElementoArrastrandoId] = useState(null);

   - Guarda el id del elemento (tarjeta) que se est√° arrastrando en este momento.

   - Si vale `null`, significa que actualmente NO hay ning√∫n drag activo.

   - Es el ‚Äúmarcador‚Äù que nos permite saber:
       ‚Ä¢ qui√©n es el origen,
       ‚Ä¢ qu√© elemento hay que mover cuando se suelta sobre otro,
       ‚Ä¢ o si debemos mostrar estilos especiales cuando hay un arrastre activo.

   En el return se expone tambi√©n:

     estaArrastrando: elementoArrastrandoId !== null

   - Es un booleano derivado:
       ‚Ä¢ true  ‚Üí si hay algo en movimiento,
       ‚Ä¢ false ‚Üí si no.

   - Sirve para que la UI pueda cambiar estilos (por ejemplo, resaltar zonas de drop) sin tener que 
	  comparar directamente contra `null`.


2) alIniciarArrastre

   const alIniciarArrastre = (id) => {
     setElementoArrastrandoId(id);
   };

   - Se llama normalmente desde el evento `onDragStart` de una tarjeta.

   - Recibe el `id` del elemento que se empez√≥ a arrastrar.

   - Actualiza el estado `elementoArrastrandoId` con ese id.

   - En otras palabras:
       ‚Ä¢ marca ‚Äúesta tarjeta es la que estoy moviendo‚Äù.

   - A partir de ese momento, las funciones de reordenamiento pueden usar ese id como `idOrigen`.


3) alTerminarArrastre

   const alTerminarArrastre = () => {
     setElementoArrastrandoId(null);
   };

   - Se llama al finalizar el drag:
       ‚Ä¢ t√≠picamente en `onDragEnd`,
       ‚Ä¢ o despu√©s de procesar un drop exitoso.

   - Vuelve a poner `elementoArrastrandoId` en `null`.

   - Deja al hook en estado ‚Äúneutral‚Äù:
       ‚Ä¢ no hay arrastres activos,
       ‚Ä¢ `estaArrastrando` pasa a ser `false`.

   - Es importante para que no queden marcadas tarjetas como si siguieran en movimiento.


4) alPasarPorEncima

   const alPasarPorEncima = (evento) => {
     evento.preventDefault();
   };

   - Se usa en el evento `onDragOver` de los elementos que pueden recibir un drop 
	  (por ejemplo, otras tarjetas o una zona especial ‚Äúsoltar aqu√≠‚Äù).

   - La llamada a `evento.preventDefault()` es la clave:
       ‚Ä¢ por defecto, el navegador NO permite soltar en todos lados,
       ‚Ä¢ al hacer preventDefault() le indicamos que este elemento S√ç acepta drops.

   - Si no se llama a esto, el evento `onDrop` no se dispara en ese destino.


5) reordenarLista

   const reordenarLista = (lista, idOrigen, idDestino) => {
     if (idOrigen === idDestino) return lista;

     const nuevaLista = [...lista];
     const indiceOrigen = nuevaLista.findIndex((item) => item.id === idOrigen);
     const indiceDestino = nuevaLista.findIndex((item) => item.id === idDestino);

     if (indiceOrigen === -1 || indiceDestino === -1) return lista;

     const [elementoMovido] = nuevaLista.splice(indiceOrigen, 1);
     nuevaLista.splice(indiceDestino, 0, elementoMovido);

     return nuevaLista;
   };

   - Esta funci√≥n no toca el estado por s√≠ misma, solo calcula un NUEVO array.

   - Recibe:
       ‚Ä¢ `lista`: la lista actual de elementos (ej: alimentadores),
       ‚Ä¢ `idOrigen`: id del elemento que se est√° moviendo,
       ‚Ä¢ `idDestino`: id del elemento sobre el que se suelta.

   - Pasos que sigue:
       1) Si el origen y el destino son el mismo id, no hace nada y devuelve la lista tal cual (no tiene sentido moverlo sobre s√≠ mismo).
		 
       2) Clona la lista original con `[...]` para no mutarla directamente.

       3) Busca las posiciones (√≠ndices) de origen y destino en ese nuevo array.

       4) Si alguno de los ids no existe (`findIndex === -1`), devuelve la lista sin cambios.

       5) Usa `splice` para:
            ‚Ä¢ sacar el elemento de su posici√≥n original,
            ‚Ä¢ y volver a insertarlo en la posici√≥n del destino.

       6) Devuelve la `nuevaLista` con el elemento movido.

   - Esta funci√≥n suele usarse junto con el estado de `puestos`:
       ‚Ä¢ primero se calcula el nuevo orden de alimentadores con `reordenarLista`,
       ‚Ä¢ luego se guarda ese orden llamando a `reordenarAlimentadores` del hook `usarPuestos`.


6) moverAlFinal

   const moverAlFinal = (lista, idElemento) => {
     const nuevaLista = [...lista];
     const indice = nuevaLista.findIndex((item) => item.id === idElemento);

     if (indice === -1) return lista;

     const [elementoMovido] = nuevaLista.splice(indice, 1);
     nuevaLista.push(elementoMovido);

     return nuevaLista;
   };

   - Permite tomar un elemento de la lista y mandarlo al final.

   - Recibe:
       ‚Ä¢ `lista`: lista original,
       ‚Ä¢ `idElemento`: id del elemento que queremos mover.

   - Pasos:
       1) Clona la lista para no mutar la original.
       2) Busca el √≠ndice del elemento con ese id.
       3) Si no lo encuentra, devuelve la lista original.
       4) Usa `splice` para quitarlo de donde est√°,
       5) y luego `push` para agregarlo al final.

   - Esta funci√≥n est√° pensada para zonas como:
       ‚Ä¢ ‚Äúsolt√° ac√° para enviar al final‚Äù, donde no interesa la posici√≥n exacta del destino, solo que el elemento
       vaya al √∫ltimo lugar.


7) return del hook

   return {
     // Estado
     elementoArrastrandoId,
     estaArrastrando: elementoArrastrandoId !== null,

     // Handlers de eventos
     alIniciarArrastre,
     alTerminarArrastre,
     alPasarPorEncima,

     // Funciones de utilidad
     reordenarLista,
     moverAlFinal,
   };

   - Expone:
       ‚Ä¢ `elementoArrastrandoId`: id actual en movimiento (o null),
       ‚Ä¢ `estaArrastrando`: booleano de conveniencia para la UI.
		 
   - Y las funciones que la vista usa directamente:
       ‚Ä¢ `alIniciarArrastre`   ‚Üí se pega a `onDragStart`,
       ‚Ä¢ `alTerminarArrastre`  ‚Üí se pega a `onDragEnd` / luego de un drop,
       ‚Ä¢ `alPasarPorEncima`    ‚Üí se pega a `onDragOver`,
       ‚Ä¢ `reordenarLista` y `moverAlFinal` ‚Üí sirven para calcular el nuevo
         orden antes de actualizar el estado global de puestos/alimentadores.
---------------------------------------------------------------------------*/

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useCalculosHistorial.js ==========
/**
 * Hook para c√°lculos y transformaciones de datos del historial
 * Centraliza la l√≥gica de c√°lculo de promedios y formateo de datos para gr√°ficos
 */

import { useMemo, useCallback } from "react";
import { aplicarFormula } from "../utilidades/calculosFormulas";
import { TITULOS_MEDICIONES } from "../constantes/titulosMediciones";
import { COLORES_GRADIENTE } from "../constantes/historialConfig";

/**
 * Obtiene el t√≠tulo de una zona desde la configuraci√≥n del dise√±o
 * @param {Object} cardDesign - Configuraci√≥n del dise√±o de la tarjeta
 * @param {string} zona - "superior" o "inferior"
 * @returns {string} - T√≠tulo de la zona
 */
export const obtenerTituloZona = (cardDesign, zona) => {
  const config = cardDesign?.[zona];
  if (!config) return zona === "superior" ? "Superior" : "Inferior";
  if (config.tituloCustom?.trim()) return config.tituloCustom;
  if (config.tituloId && TITULOS_MEDICIONES[config.tituloId]) {
    return TITULOS_MEDICIONES[config.tituloId];
  }
  return zona === "superior" ? "Superior" : "Inferior";
};

/**
 * Calcula el promedio de valores para una zona espec√≠fica
 * Aplica f√≥rmulas configuradas y excluye valores nulos o cero
 * @param {Object} lectura - Datos de la lectura
 * @param {Object} zonaConfig - Configuraci√≥n de la zona
 * @returns {number|null} - Promedio calculado o null si no hay datos v√°lidos
 */
export const calcularPromedioZona = (lectura, zonaConfig) => {
  if (!lectura?.valores || !Array.isArray(lectura.valores)) return null;
  if (!zonaConfig?.boxes) return null;

  const indiceInicial = lectura.indiceInicial ?? lectura.indice_inicial ?? 0;
  const valoresCalculados = [];

  zonaConfig.boxes.forEach((box) => {
    if (!box.enabled) return;
    const registro = box.registro ?? box.indice;
    if (registro === null || registro === undefined) return;
    const indiceEnArray = registro - indiceInicial;
    if (indiceEnArray < 0 || indiceEnArray >= lectura.valores.length) return;
    const valorCrudo = lectura.valores[indiceEnArray];
    if (valorCrudo === null || valorCrudo === undefined) return;
    const valorCalculado = aplicarFormula(box.formula || "x", valorCrudo);
    if (valorCalculado !== null && !Number.isNaN(valorCalculado) && valorCalculado !== 0) {
      valoresCalculados.push(valorCalculado);
    }
  });

  if (valoresCalculados.length === 0) return null;
  const suma = valoresCalculados.reduce((a, b) => a + b, 0);
  return suma / valoresCalculados.length;
};

/**
 * Interpola color de verde a rojo basado en porcentaje (0-1)
 * 0 = verde, 0.5 = amarillo, 1 = rojo
 * @param {number} porcentaje - Valor entre 0 y 1
 * @returns {string} - Color en formato rgb()
 */
export const interpolarColorVerdeRojo = (porcentaje) => {
  const p = Math.max(0, Math.min(1, porcentaje));
  const { verde, amarillo, rojo } = COLORES_GRADIENTE;

  let r, g, b;

  if (p <= 0.5) {
    const t = p * 2;
    r = Math.round(verde.r + (amarillo.r - verde.r) * t);
    g = Math.round(verde.g + (amarillo.g - verde.g) * t);
    b = Math.round(verde.b + (amarillo.b - verde.b) * t);
  } else {
    const t = (p - 0.5) * 2;
    r = Math.round(amarillo.r + (rojo.r - amarillo.r) * t);
    g = Math.round(amarillo.g + (rojo.g - amarillo.g) * t);
    b = Math.round(amarillo.b + (rojo.b - amarillo.b) * t);
  }

  return `rgb(${r}, ${g}, ${b})`;
};

/**
 * Hook que proporciona funciones de c√°lculo y datos derivados para el historial
 * @param {Object} params - Par√°metros del hook
 * @param {Object} params.cardDesign - Configuraci√≥n del dise√±o de la tarjeta
 * @param {string} params.zonaSeleccionada - Zona actualmente seleccionada
 * @param {Array} params.datosGrafico - Datos del gr√°fico (array de {x, y})
 * @param {number} params.intervaloFiltro - Intervalo de filtrado en minutos (0 = sin filtro)
 * @returns {Object} - Funciones y datos calculados
 */
export const useCalculosHistorial = ({
  cardDesign,
  zonaSeleccionada,
  datosGrafico,
  intervaloFiltro = 0,
}) => {
  // T√≠tulos de zonas
  const tituloSuperior = useMemo(
    () => obtenerTituloZona(cardDesign, "superior"),
    [cardDesign]
  );

  const tituloInferior = useMemo(
    () => obtenerTituloZona(cardDesign, "inferior"),
    [cardDesign]
  );

  const tituloZonaActual = zonaSeleccionada === "superior" ? tituloSuperior : tituloInferior;

  // Verificar si una zona est√° disponible (tiene boxes habilitados)
  const zonaDisponible = useCallback((zona) => {
    const config = cardDesign?.[zona];
    return config?.boxes?.some((b) => b.enabled);
  }, [cardDesign]);

  // Datos filtrados por intervalo
  const datosFiltrados = useMemo(() => {
    if (intervaloFiltro === 0 || datosGrafico.length === 0) {
      return datosGrafico;
    }

    const intervaloMs = intervaloFiltro * 60 * 1000;
    let ultimoTimestamp = 0;

    return datosGrafico.filter((punto) => {
      const timestamp = new Date(punto.x).getTime();
      if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs) {
        ultimoTimestamp = timestamp;
        return true;
      }
      return false;
    });
  }, [datosGrafico, intervaloFiltro]);

  // Colores para gr√°fico de barras (verde a rojo con normalizaci√≥n min-max)
  const coloresBarras = useMemo(() => {
    if (datosFiltrados.length === 0) return [];
    const valores = datosFiltrados.map((d) => d.y);
    const minVal = Math.min(...valores);
    const maxVal = Math.max(...valores);
    const rango = maxVal - minVal;
    return valores.map((val) => {
      const porcentaje = rango > 0 ? (val - minVal) / rango : 0;
      return interpolarColorVerdeRojo(porcentaje);
    });
  }, [datosFiltrados]);

  // Datos formateados para la tabla del panel lateral
  const datosTabla = useMemo(() => {
    return datosFiltrados.map((punto) => {
      const fecha = new Date(punto.x);
      return {
        fecha: fecha.toLocaleDateString("es-AR", { day: "2-digit", month: "2-digit", year: "2-digit" }),
        hora: fecha.toLocaleTimeString("es-AR", { hour: "2-digit", minute: "2-digit", second: "2-digit" }),
        medicion: Math.ceil(punto.y * 100) / 100,
      };
    });
  }, [datosFiltrados]);

  // T√≠tulo del panel (per√≠odo de fechas)
  const tituloPanelDatos = useMemo(() => {
    if (datosGrafico.length === 0) return "Sin datos";
    const primeraFecha = new Date(datosGrafico[0].x);
    const ultimaFecha = new Date(datosGrafico[datosGrafico.length - 1].x);

    const formatoFecha = { day: "2-digit", month: "2-digit", year: "2-digit" };
    const primeraStr = primeraFecha.toLocaleDateString("es-AR", formatoFecha);
    const ultimaStr = ultimaFecha.toLocaleDateString("es-AR", formatoFecha);

    if (primeraStr === ultimaStr) {
      return primeraStr;
    }
    return `${primeraStr} - ${ultimaStr}`;
  }, [datosGrafico]);

  // Estad√≠sticas del gr√°fico
  const estadisticasGrafico = useMemo(() => {
    if (datosGrafico.length === 0) return null;
    const valores = datosGrafico.map((d) => d.y);
    const minVal = Math.min(...valores);
    const maxVal = Math.max(...valores);
    const promedio = valores.reduce((a, b) => a + b, 0) / valores.length;

    const puntoMin = datosGrafico.find((d) => d.y === minVal);
    const puntoMax = datosGrafico.find((d) => d.y === maxVal);

    const formatearFecha = (date) => {
      if (!date) return "";
      const d = new Date(date);
      const dia = d.getDate().toString().padStart(2, "0");
      const mes = (d.getMonth() + 1).toString().padStart(2, "0");
      const anio = d.getFullYear().toString().slice(-2);
      const hora = d.getHours().toString().padStart(2, "0");
      const min = d.getMinutes().toString().padStart(2, "0");
      return `${dia}/${mes}/${anio} - ${hora}:${min} hs.`;
    };

    return {
      puntos: datosGrafico.length,
      min: minVal.toFixed(2),
      minFecha: formatearFecha(puntoMin?.x),
      max: maxVal.toFixed(2),
      maxFecha: formatearFecha(puntoMax?.x),
      promedio: promedio.toFixed(2),
    };
  }, [datosGrafico]);

  // Transformar datos crudos a formato de gr√°fico
  const transformarDatosParaGrafico = useCallback((datos, zonaConfig) => {
    return datos
      .map((lectura) => {
        const promedio = calcularPromedioZona(lectura, zonaConfig);
        if (promedio === null) return null;
        return { x: new Date(lectura.timestamp), y: promedio };
      })
      .filter((d) => d !== null);
  }, []);

  return {
    // T√≠tulos
    tituloSuperior,
    tituloInferior,
    tituloZonaActual,
    tituloPanelDatos,
    // Funciones
    zonaDisponible,
    transformarDatosParaGrafico,
    // Datos calculados
    datosFiltrados,
    coloresBarras,
    datosTabla,
    estadisticasGrafico,
  };
};

export default useCalculosHistorial;

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useCambiosPendientes.js ==========
// src/paginas/PaginaAlimentadores/hooks/usarCambiosPendientes.js
// Hook para manejar cambios pendientes de sincronizaci√≥n con la BD
//
// Conceptos:
// - Pbase: Par√°metros guardados en la base de datos (snapshot)
// - Pnavegador: Par√°metros actuales en el navegador (estado local + localStorage)
//
// El bot√≥n "Guardar" se habilita cuando Pbase !== Pnavegador, incluyendo:
// - Valores diferentes (colores, gaps)
// - Elementos nuevos en Pnavegador que no existen en Pbase (alimentadores agregados)
// - Elementos eliminados de Pnavegador que s√≠ existen en Pbase (alimentadores borrados)
// - Diferente cantidad de filas (afecta gaps verticales)

import { useState, useCallback, useRef } from "react";
import {
  actualizarPuesto as actualizarPuestoAPI,
  actualizarAlimentadorAPI,
  reordenarAlimentadores as reordenarAlimentadoresAPI,
} from "../../../servicios/apiService";

/**
 * Hook para detectar y sincronizar cambios pendientes entre estado local y BD.
 *
 * Trackea:
 * - Colores de puestos (color, bgColor)
 * - Gaps verticales de puestos (por fila)
 * - Escala de puestos
 * - Colores de alimentadores
 * - Gaps horizontales de alimentadores
 * - Escala de alimentadores (individual)
 * - Orden de alimentadores
 * - Cantidad de alimentadores (elementos nuevos/eliminados)
 *
 * NO trackea (van directo a BD):
 * - Crear/eliminar puestos
 * - Crear/eliminar alimentadores
 * - Configuraci√≥n Modbus
 */
export const useCambiosPendientes = () => {
  // Snapshot original de los datos cargados de BD (Pbase)
  const snapshotRef = useRef({
    puestos: {},      // { [id]: { color, bgColor, gapsVerticales, cantidadAlimentadores, escala } }
    alimentadores: {}, // { [id]: { color, gapHorizontal, orden, puestoId, escala } }
    alimentadoresIds: new Set(), // Set de IDs de alimentadores en Pbase
  });

  // Estado de sincronizaci√≥n
  const [sincronizando, setSincronizando] = useState(false);
  const [errorSincronizacion, setErrorSincronizacion] = useState(null);

  /**
   * Guarda el snapshot original de los datos cargados de BD (Pbase).
   * Llamar despu√©s de cargar datos del backend.
   *
   * IMPORTANTE: Todos los IDs se guardan como strings para evitar
   * problemas de comparaci√≥n entre tipos (n√∫meros vs strings).
   */
  const guardarSnapshot = useCallback((puestos) => {
    const snapshot = {
      puestos: {},
      alimentadores: {},
      alimentadoresIds: new Set(), // Set de strings
    };

    puestos.forEach((puesto) => {
      const alimentadoresDelPuesto = puesto.alimentadores || [];
      const puestoIdStr = String(puesto.id);

      snapshot.puestos[puestoIdStr] = {
        color: puesto.color,
        bgColor: puesto.bgColor || puesto.bg_color,
        gapsVerticales: JSON.stringify(puesto.gapsVerticales || { "0": 40 }),
        cantidadAlimentadores: alimentadoresDelPuesto.length,
        escala: puesto.escala, // null si no est√° definida en BD
      };

      alimentadoresDelPuesto.forEach((alim, index) => {
        const alimIdStr = String(alim.id);
        snapshot.alimentadores[alimIdStr] = {
          color: alim.color,
          gapHorizontal: alim.gapHorizontal ?? 10,
          orden: index,
          puestoId: puestoIdStr, // tambi√©n string
          escala: alim.escala, // null si no est√° definida en BD
        };
        snapshot.alimentadoresIds.add(alimIdStr);
      });
    });

    snapshotRef.current = snapshot;
  }, []);

  /**
   * Detecta si hay cambios entre el estado actual (Pnavegador) y el snapshot (Pbase).
   *
   * Detecta:
   * 1. Cambios en valores existentes (colores, gaps)
   * 2. Alimentadores nuevos (en Pnavegador pero no en Pbase)
   * 3. Alimentadores eliminados (en Pbase pero no en Pnavegador)
   * 4. Cambios en cantidad de filas (afecta gaps verticales)
   *
   * @param {Array} puestosActuales - Lista actual de puestos con alimentadores
   * @param {Object} gapsPorTarjeta - Gaps horizontales de localStorage { alimId: gap }
   * @param {Object} gapsPorFilaPorPuesto - Gaps verticales de localStorage por puesto { puestoId: { "0": gap, ... } }
   * @param {Object} escalasPorPuesto - Escalas por puesto de localStorage { puestoId: escala }
   * @param {Object} escalasPorTarjeta - Escalas por tarjeta de localStorage { alimId: escala }
   * @returns {Object} { hayCambios, cambios, hayNuevosElementos, hayElementosEliminados }
   */
  const detectarCambios = useCallback((puestosActuales, gapsPorTarjeta = {}, gapsPorFilaPorPuesto = {}, escalasPorPuesto = {}, escalasPorTarjeta = {}) => {
    const cambios = {
      puestos: [],      // [{ id, campos: { color?, bgColor?, gapsVerticales?, escala? } }]
      alimentadores: [], // [{ id, campos: { color?, gapHorizontal?, escala? } }]
      ordenPorPuesto: {}, // { puestoId: [alimentadorIds en nuevo orden] }
    };

    const snapshot = snapshotRef.current;

    // Trackear IDs actuales para detectar elementos nuevos/eliminados
    // IMPORTANTE: Usamos Set de strings para comparaci√≥n consistente
    const alimentadoresActualesIds = new Set();
    let hayNuevosElementos = false;
    let hayElementosEliminados = false;

    // Comparar puestos
    puestosActuales.forEach((puesto) => {
      const puestoIdStr = String(puesto.id);
      const original = snapshot.puestos[puestoIdStr];
      const alimentadoresDelPuesto = puesto.alimentadores || [];

      // Recolectar IDs de alimentadores actuales (como strings)
      alimentadoresDelPuesto.forEach((alim) => {
        const alimIdStr = String(alim.id);
        alimentadoresActualesIds.add(alimIdStr);

        // Detectar alimentadores nuevos (no estaban en Pbase)
        if (!snapshot.alimentadoresIds.has(alimIdStr)) {
          hayNuevosElementos = true;
        }
      });

      // Detectar cambio de orden comparando arrays de IDs (todos como strings)
      const ordenActualIds = alimentadoresDelPuesto.map(a => String(a.id));
      const ordenOriginalIds = Object.entries(snapshot.alimentadores)
        .filter(([_, data]) => data.puestoId === puestoIdStr)
        .sort((a, b) => a[1].orden - b[1].orden)
        .map(([id, _]) => id); // ya es string porque es key de objeto

      // Comparar si el orden cambi√≥ (solo si tienen la misma cantidad de elementos)
      if (ordenActualIds.length === ordenOriginalIds.length && ordenActualIds.length > 0) {
        const ordenCambio = ordenActualIds.some((id, idx) => id !== ordenOriginalIds[idx]);
        if (ordenCambio) {
          cambios.ordenPorPuesto[puesto.id] = alimentadoresDelPuesto.map(a => a.id);
        }
      }

      // Si es un puesto nuevo, no comparar valores pero s√≠ registrar sus gaps
      if (!original) {
        // Puesto nuevo: considerar como cambio si tiene gaps personalizados
        const gapsFilaActuales = gapsPorFilaPorPuesto[puesto.id] || puesto.gapsVerticales || { "0": 40 };
        const gapsDefault = JSON.stringify({ "0": 40 });
        if (JSON.stringify(gapsFilaActuales) !== gapsDefault) {
          cambios.puestos.push({ id: puesto.id, campos: { gapsVerticales: gapsFilaActuales } });
        }
        return;
      }

      const cambiosPuesto = {};
      const bgColorActual = puesto.bgColor || puesto.bg_color;

      // Comparar colores
      if (puesto.color !== original.color) {
        cambiosPuesto.color = puesto.color;
      }
      if (bgColorActual !== original.bgColor) {
        cambiosPuesto.bgColor = bgColorActual;
      }

      // Gaps verticales: combinar los de la BD con los de localStorage para este puesto
      const gapsFilaActuales = gapsPorFilaPorPuesto[puesto.id] || puesto.gapsVerticales || { "0": 40 };
      const gapsFilaActualesStr = JSON.stringify(gapsFilaActuales);
      if (gapsFilaActualesStr !== original.gapsVerticales) {
        cambiosPuesto.gapsVerticales = gapsFilaActuales;
      }

      // Detectar cambio en cantidad de alimentadores
      if (alimentadoresDelPuesto.length !== original.cantidadAlimentadores) {
        // La cantidad cambi√≥, esto puede afectar los gaps verticales
        // Asegurarse de incluir los gaps actualizados
        if (!cambiosPuesto.gapsVerticales) {
          cambiosPuesto.gapsVerticales = gapsFilaActuales;
        }
      }

      // Escala del puesto: preferir localStorage, luego valor del objeto
      // Si hay escala en localStorage, usarla; si no, usar la del puesto
      const puestoIdStrLS = String(puesto.id);
      const escalaLocalPuesto = escalasPorPuesto[puestoIdStrLS] ?? escalasPorPuesto[puesto.id];
      const escalaActualPuesto = escalaLocalPuesto !== undefined ? escalaLocalPuesto : puesto.escala;
      // Comparar con el snapshot (ambos pueden ser null)
      if (escalaActualPuesto !== original.escala) {
        cambiosPuesto.escala = escalaActualPuesto;
      }

      if (Object.keys(cambiosPuesto).length > 0) {
        cambios.puestos.push({ id: puesto.id, campos: cambiosPuesto });
      }

      // Comparar alimentadores del puesto
      alimentadoresDelPuesto.forEach((alim) => {
        const alimIdStr = String(alim.id);
        const originalAlim = snapshot.alimentadores[alimIdStr];

        // Alimentador nuevo: registrar sus gaps si son diferentes al default
        if (!originalAlim) {
          const gapActual = gapsPorTarjeta[alimIdStr] ?? gapsPorTarjeta[alim.id] ?? alim.gapHorizontal ?? 10;
          if (gapActual !== 10) { // Solo si es diferente al default
            cambios.alimentadores.push({ id: alim.id, campos: { gapHorizontal: gapActual } });
          }
          return;
        }

        const cambiosAlim = {};

        // Comparar color
        if (alim.color !== originalAlim.color) {
          cambiosAlim.color = alim.color;
        }

        // Gap horizontal: preferir localStorage, luego el del objeto
        // Buscar tanto por string como por n√∫mero en gapsPorTarjeta
        const gapActual = gapsPorTarjeta[alimIdStr] ?? gapsPorTarjeta[alim.id] ?? alim.gapHorizontal ?? 10;
        if (gapActual !== originalAlim.gapHorizontal) {
          cambiosAlim.gapHorizontal = gapActual;
        }

        // Escala individual: preferir localStorage, luego valor del objeto
        const escalaLocalAlim = escalasPorTarjeta[alimIdStr] ?? escalasPorTarjeta[alim.id];
        const escalaActualAlim = escalaLocalAlim !== undefined ? escalaLocalAlim : alim.escala;
        // Comparar con el snapshot (ambos pueden ser null)
        if (escalaActualAlim !== originalAlim.escala) {
          cambiosAlim.escala = escalaActualAlim;
        }

        if (Object.keys(cambiosAlim).length > 0) {
          cambios.alimentadores.push({ id: alim.id, campos: cambiosAlim });
        }
      });
    });

    // Detectar alimentadores eliminados (estaban en Pbase pero ya no est√°n en Pnavegador)
    // Ambos Sets ahora contienen strings
    snapshot.alimentadoresIds.forEach((idBase) => {
      if (!alimentadoresActualesIds.has(idBase)) {
        hayElementosEliminados = true;
      }
    });

    // Tambi√©n detectar si hay gaps en localStorage para alimentadores que ya no existen
    // Object.keys devuelve strings, as√≠ que la comparaci√≥n funciona
    Object.keys(gapsPorTarjeta).forEach((alimIdStr) => {
      if (!alimentadoresActualesIds.has(alimIdStr) && snapshot.alimentadoresIds.has(alimIdStr)) {
        // Hay un gap guardado para un alimentador que fue eliminado
        hayElementosEliminados = true;
      }
    });

    const hayCambios =
      cambios.puestos.length > 0 ||
      cambios.alimentadores.length > 0 ||
      Object.keys(cambios.ordenPorPuesto).length > 0 ||
      hayNuevosElementos ||
      hayElementosEliminados;

    return {
      hayCambios,
      cambios,
      hayNuevosElementos,
      hayElementosEliminados,
    };
  }, []);

  /**
   * Sincroniza todos los cambios pendientes con la BD.
   * Despu√©s de sincronizar exitosamente, el snapshot se actualiza
   * al recargar datos en el callback onSuccess.
   *
   * @param {Object} cambios - Cambios detectados por detectarCambios()
   * @param {Function} onSuccess - Callback al completar exitosamente (puede ser async)
   * @param {Function} onError - Callback en caso de error
   */
  const sincronizarConBD = useCallback(async (cambios, onSuccess, onError) => {
    setSincronizando(true);
    setErrorSincronizacion(null);

    try {
      // 1. Actualizar puestos
      for (const { id, campos } of cambios.puestos) {
        const datosAPI = {};
        if (campos.color !== undefined) datosAPI.color = campos.color;
        if (campos.bgColor !== undefined) datosAPI.bg_color = campos.bgColor;
        if (campos.gapsVerticales !== undefined) datosAPI.gaps_verticales = campos.gapsVerticales;
        if (campos.escala !== undefined) datosAPI.escala = campos.escala;

        await actualizarPuestoAPI(id, datosAPI);
      }

      // 2. Actualizar alimentadores
      for (const { id, campos } of cambios.alimentadores) {
        const datosAPI = {};
        if (campos.color !== undefined) datosAPI.color = campos.color;
        if (campos.gapHorizontal !== undefined) datosAPI.gap_horizontal = campos.gapHorizontal;
        if (campos.escala !== undefined) datosAPI.escala = campos.escala;

        await actualizarAlimentadorAPI(id, datosAPI);
      }

      // 3. Reordenar alimentadores
      for (const [puestoId, ordenIds] of Object.entries(cambios.ordenPorPuesto)) {
        await reordenarAlimentadoresAPI(puestoId, ordenIds);
      }

      // El callback onSuccess debe recargar los datos de BD,
      // lo cual disparar√° guardarSnapshot() con los nuevos datos
      // IMPORTANTE: Esperamos al callback para mantener el overlay visible
      if (onSuccess) await onSuccess();
    } catch (error) {
      console.error("Error sincronizando cambios:", error);
      setErrorSincronizacion(error.message);
      if (onError) onError(error);
    } finally {
      setSincronizando(false);
    }
  }, []);

  /**
   * Descarta los cambios locales y recarga desde BD.
   * @param {Function} recargarDatos - Funci√≥n para recargar datos desde BD
   */
  const descartarCambios = useCallback(async (recargarDatos) => {
    if (recargarDatos) {
      await recargarDatos();
    }
  }, []);

  /**
   * Obtiene el snapshot actual (Pbase) para debugging o comparaci√≥n.
   */
  const obtenerSnapshot = useCallback(() => {
    return snapshotRef.current;
  }, []);

  return {
    // Funciones principales
    guardarSnapshot,
    detectarCambios,
    sincronizarConBD,
    descartarCambios,
    obtenerSnapshot,
    // Estado
    sincronizando,
    errorSincronizacion,
  };
};

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useChispas.js ==========
// src/paginas/PaginaAlimentadores/hooks/usarChispas.js

import { useState, useCallback, useRef, useEffect } from "react";
import {
	construirGrafo,
	calcularRutasDesdeEmisor,
} from "../utilidades/calculadorRutas.js";

/**
 * L√≠mite m√°ximo de chispas simult√°neas para evitar problemas de rendimiento
 */
const MAX_CHISPAS = 100;

/**
 * Hook para manejar la animaci√≥n de chispas en el diagrama unifilar.
 *
 * OPTIMIZADO: Las chispas se manejan con refs mutables, sin usar setState
 * durante la animaci√≥n. Esto elimina los re-renders de React y el GC.
 *
 * @param {Object} params - Par√°metros del hook
 * @param {Array} params.bornes - Array de bornes
 * @param {Object} params.celdas - Objeto de celdas pintadas
 * @param {Object} params.chispasConfig - Configuraci√≥n de chispas
 * @param {number} params.grosorLinea - Grosor de l√≠nea en p√≠xeles
 * @returns {Object} Estado y funciones para manejar chispas
 */
const useChispas = ({
	bornes = [],
	celdas = {},
	chispasConfig = {},
	grosorLinea = 12,
}) => {
	// Estado de animaci√≥n activa (solo este causa re-render, y solo al iniciar/detener)
	const [animando, setAnimando] = useState(false);
	const animandoRef = useRef(false);

	// *** CAMBIO CLAVE: Las chispas son un REF, no un estado ***
	// Esto evita re-renders durante la animaci√≥n
	const chispasRef = useRef([]);

	// Referencias para el loop de animaci√≥n
	const animationFrameRef = useRef(null);
	const lastTimeRef = useRef(0);

	// Referencias para timers de emisi√≥n
	const emisionTimersRef = useRef({});

	// Grafo de conectividad (se recalcula cuando cambian las celdas)
	const grafoRef = useRef({});

	// Rutas precalculadas desde cada emisor
	const rutasRef = useRef({});

	// Refs para la configuraci√≥n actual (para evitar closures obsoletos)
	const configRef = useRef(chispasConfig);
	const bornesRef = useRef(bornes);
	const grosorLineaRef = useRef(grosorLinea);

	// ID counter para chispas (evita Date.now() y Math.random())
	const chispaIdRef = useRef(0);

	// Mantener refs actualizados
	useEffect(() => {
		configRef.current = chispasConfig;
	}, [chispasConfig]);

	useEffect(() => {
		bornesRef.current = bornes;
	}, [bornes]);

	useEffect(() => {
		grosorLineaRef.current = grosorLinea;
	}, [grosorLinea]);

	/**
	 * Recalcular el grafo cuando cambian las celdas
	 */
	useEffect(() => {
		grafoRef.current = construirGrafo(celdas);
	}, [celdas]);

	/**
	 * Recalcular rutas cuando cambian bornes o celdas
	 */
	useEffect(() => {
		const emisores = bornes.filter(b => b.tipo === "EMISOR");
		const nuevasRutas = {};

		emisores.forEach(emisor => {
			nuevasRutas[emisor.id] = calcularRutasDesdeEmisor(emisor, bornes, grafoRef.current);
		});

		rutasRef.current = nuevasRutas;
	}, [bornes, celdas]);

	/**
	 * Crear una nueva chispa desde un emisor
	 */
	const crearChispa = useCallback((emisor) => {
		const rutas = rutasRef.current[emisor.id] || [];

		// Si no hay rutas a receptores, no crear chispa
		if (rutas.length === 0) {
			return null;
		}

		// Elegir una ruta aleatoria si hay varias
		const rutaElegida = rutas[Math.floor(Math.random() * rutas.length)];

		chispaIdRef.current += 1;

		return {
			id: chispaIdRef.current,
			ruta: rutaElegida.ruta,
			posicion: 0,
			progreso: 0, // 0-1 entre celdas
			emisorId: emisor.id,
			receptorId: rutaElegida.receptorId,
			estela: [], // Array mutable - se modifica in-place
		};
	}, []);

	/**
	 * Emitir una chispa desde un emisor espec√≠fico
	 * *** MODIFICADO: Agrega directamente al ref, sin setState ***
	 */
	const emitirDesdeEmisor = useCallback((emisorId) => {
		const emisor = bornesRef.current.find(b => b.id === emisorId && b.tipo === "EMISOR");
		if (!emisor || !emisor.activo) {
			return;
		}

		// Verificar l√≠mite de chispas
		if (chispasRef.current.length >= MAX_CHISPAS) {
			return;
		}

		const nuevaChispa = crearChispa(emisor);
		if (!nuevaChispa) {
			return;
		}

		// *** Agregar directamente al array del ref ***
		chispasRef.current.push(nuevaChispa);
	}, [crearChispa]);

	/**
	 * Loop de animaci√≥n - actualiza posiciones de chispas
	 * *** MODIFICADO: Modifica el ref directamente, sin setState ***
	 */
	const loopAnimacion = useCallback((timestamp) => {
		if (!animandoRef.current) {
			return;
		}

		const deltaTime = lastTimeRef.current === 0 ? 16 : timestamp - lastTimeRef.current;
		lastTimeRef.current = timestamp;

		// Velocidad en celdas por segundo
		const velocidad = configRef.current.velocidad || 8;
		const longitudEstela = configRef.current.longitudEstela || 5;

		// Calcular cu√°nto avanzar
		const avance = (velocidad * deltaTime) / 1000;

		const chispas = chispasRef.current;

		// Actualizar chispas IN-PLACE
		for (let i = chispas.length - 1; i >= 0; i--) {
			const chispa = chispas[i];
			chispa.progreso += avance;

			// Manejar m√∫ltiples avances de celda si la velocidad es muy alta
			while (chispa.progreso >= 1) {
				const estela = chispa.estela;

				// Shift estela hacia el final (in-place)
				for (let j = Math.min(estela.length, longitudEstela - 1); j > 0; j--) {
					estela[j] = estela[j - 1];
				}
				// Agregar posici√≥n actual al inicio
				estela[0] = chispa.ruta[chispa.posicion];

				// Ajustar longitud de estela
				if (estela.length < longitudEstela) {
					estela.length = Math.min(estela.length + 1, longitudEstela);
				} else if (estela.length > longitudEstela) {
					estela.length = longitudEstela;
				}

				chispa.posicion += 1;
				chispa.progreso -= 1;

				// Verificar si llegamos al final de la ruta
				if (chispa.posicion >= chispa.ruta.length - 1) {
					// Eliminar chispa del array (in-place)
					chispas.splice(i, 1);
					break;
				}
			}
		}

		// Continuar el loop
		animationFrameRef.current = requestAnimationFrame(loopAnimacion);
	}, []);

	/**
	 * Iniciar los timers de emisi√≥n para todos los emisores activos
	 */
	const iniciarEmisiones = useCallback(() => {
		// Limpiar timers anteriores
		Object.values(emisionTimersRef.current).forEach(clearInterval);
		emisionTimersRef.current = {};

		const emisores = bornesRef.current.filter(b => b.tipo === "EMISOR" && b.activo);
		const frecuencia = configRef.current.frecuenciaEmision || 2000;

		emisores.forEach(emisor => {
			// Emitir una chispa inmediatamente
			emitirDesdeEmisor(emisor.id);

			// Configurar timer para emisiones peri√≥dicas
			const timer = setInterval(() => {
				if (animandoRef.current) {
					emitirDesdeEmisor(emisor.id);
				}
			}, frecuencia);

			emisionTimersRef.current[emisor.id] = timer;
		});
	}, [emitirDesdeEmisor]);

	/**
	 * Detener todos los timers de emisi√≥n
	 */
	const detenerEmisiones = useCallback(() => {
		Object.values(emisionTimersRef.current).forEach(clearInterval);
		emisionTimersRef.current = {};
	}, []);

	/**
	 * Reiniciar timers cuando cambia la frecuencia de emisi√≥n (mientras est√° animando)
	 */
	const frecuenciaActual = chispasConfig.frecuenciaEmision || 2000;

	useEffect(() => {
		if (animandoRef.current) {
			// Limpiar timers anteriores
			Object.values(emisionTimersRef.current).forEach(clearInterval);
			emisionTimersRef.current = {};

			const emisores = bornesRef.current.filter(b => b.tipo === "EMISOR" && b.activo);

			emisores.forEach(emisor => {
				// Configurar timer con la nueva frecuencia
				const timer = setInterval(() => {
					if (animandoRef.current) {
						emitirDesdeEmisor(emisor.id);
					}
				}, frecuenciaActual);

				emisionTimersRef.current[emisor.id] = timer;
			});
		}
	}, [frecuenciaActual, emitirDesdeEmisor]);

	/**
	 * Iniciar animaci√≥n
	 */
	const iniciarAnimacion = useCallback(() => {
		// Verificar que hay emisores y receptores
		const emisores = bornesRef.current.filter(b => b.tipo === "EMISOR" && b.activo);
		const receptores = bornesRef.current.filter(b => b.tipo === "RECEPTOR");

		if (emisores.length === 0 || receptores.length === 0) {
			return;
		}

		animandoRef.current = true;
		setAnimando(true);
		lastTimeRef.current = 0;

		// Limpiar chispas anteriores
		chispasRef.current = [];

		// Iniciar emisiones
		iniciarEmisiones();

		// Iniciar loop de animaci√≥n
		animationFrameRef.current = requestAnimationFrame(loopAnimacion);
	}, [iniciarEmisiones, loopAnimacion]);

	/**
	 * Detener animaci√≥n
	 */
	const detenerAnimacion = useCallback(() => {
		animandoRef.current = false;
		setAnimando(false);
		detenerEmisiones();
		chispasRef.current = [];

		if (animationFrameRef.current) {
			cancelAnimationFrame(animationFrameRef.current);
			animationFrameRef.current = null;
		}
	}, [detenerEmisiones]);

	/**
	 * Toggle animaci√≥n
	 */
	const toggleAnimacion = useCallback(() => {
		if (animandoRef.current) {
			detenerAnimacion();
		} else {
			iniciarAnimacion();
		}
	}, [iniciarAnimacion, detenerAnimacion]);

	/**
	 * Obtener posici√≥n en p√≠xeles de una chispa para renderizado
	 * Usa interpolaci√≥n lineal para movimiento constante y fluido
	 *
	 * @param {Object} chispa - Objeto chispa con ruta, posicion y progreso
	 * @returns {Object} { x, y } posici√≥n en p√≠xeles
	 */
	const obtenerPosicionPixel = useCallback((chispa) => {
		const { ruta, posicion, progreso } = chispa;
		const grosor = grosorLineaRef.current;

		if (!ruta || ruta.length === 0) {
			return { x: 0, y: 0 };
		}

		// Posici√≥n actual
		const [x1, y1] = ruta[posicion].split(",").map(Number);

		// Si estamos al final de la ruta, retornar la √∫ltima posici√≥n
		if (posicion >= ruta.length - 1) {
			return {
				x: x1 * grosor + grosor / 2,
				y: y1 * grosor + grosor / 2,
			};
		}

		// Posici√≥n siguiente para interpolaci√≥n
		const [x2, y2] = ruta[posicion + 1].split(",").map(Number);

		// Interpolaci√≥n lineal simple - movimiento constante sin aceleraci√≥n
		const x = (x1 + (x2 - x1) * progreso) * grosor + grosor / 2;
		const y = (y1 + (y2 - y1) * progreso) * grosor + grosor / 2;

		return { x, y };
	}, []);

	/**
	 * Obtener posiciones de la estela de una chispa
	 *
	 * @param {Object} chispa - Objeto chispa
	 * @returns {Array} Array de { x, y, opacidad }
	 */
	const obtenerEstelaPixeles = useCallback((chispa) => {
		const { estela } = chispa;
		const grosor = grosorLineaRef.current;

		if (!estela || estela.length === 0) {
			return [];
		}

		const resultado = [];
		for (let i = 0; i < estela.length; i++) {
			const clave = estela[i];
			if (!clave) continue;
			const [x, y] = clave.split(",").map(Number);
			resultado.push({
				x: x * grosor + grosor / 2,
				y: y * grosor + grosor / 2,
				opacidad: 1 - (i + 1) / (estela.length + 1),
			});
		}
		return resultado;
	}, []);

	/**
	 * Limpiar al desmontar
	 */
	useEffect(() => {
		return () => {
			animandoRef.current = false;
			detenerEmisiones();
			if (animationFrameRef.current) {
				cancelAnimationFrame(animationFrameRef.current);
			}
			chispasRef.current = [];
		};
	}, [detenerEmisiones]);

	return {
		// Estado
		animando,
		// *** CAMBIO: Devolver la referencia al array de chispas ***
		// El componente que usa este hook debe leer chispasRef.current
		chispas: chispasRef.current,
		chispasRef, // Tambi√©n exponer el ref directamente

		// Acciones
		iniciarAnimacion,
		detenerAnimacion,
		toggleAnimacion,

		// Utilidades para renderizado
		obtenerPosicionPixel,
		obtenerEstelaPixeles,
	};
};

export default useChispas;

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useConfiguracion.js ==========
// src/paginas/PaginaAlimentadores/hooks/usarConfiguracion.js
// Hook para manejar workspaces del usuario en Supabase

import { useState, useEffect, useCallback } from "react";
import {
  obtenerWorkspaces,
  crearWorkspace,
  actualizarWorkspace as actualizarWorkspaceAPI,
  eliminarWorkspace as eliminarWorkspaceAPI,
  obtenerPerfil,
  actualizarWorkspaceDefault,
} from "../../../servicios/apiService";
import { CLAVES_STORAGE } from "../constantes/clavesAlmacenamiento";

/**
 * Hook para manejar workspaces del usuario.
 * Los workspaces son contenedores que agrupan puestos y alimentadores.
 *
 * @returns {Object} Estado y funciones para trabajar con workspaces.
 */
export const useConfiguracion = () => {
  // Lista de workspaces del usuario
  const [configuraciones, setConfiguraciones] = useState([]);

  // ID del workspace actualmente seleccionado (UUID string)
  const [configuracionSeleccionadaId, setConfiguracionSeleccionadaId] = useState(() => {
    const guardado = localStorage.getItem(CLAVES_STORAGE.CONFIGURACION_SELECCIONADA);
    return guardado || null;
  });

  // Estado de carga
  const [cargando, setCargando] = useState(true);

  // Error si ocurre
  const [error, setError] = useState(null);

  // Perfil del usuario (incluye rol global)
  const [perfil, setPerfil] = useState(null);

  // ID del workspace por defecto (derivado del perfil)
  const workspaceDefaultId = perfil?.workspace_default_id || null;

  // Workspace seleccionado (derivado)
  const configuracionSeleccionada = configuraciones.find(
    (c) => c.id === configuracionSeleccionadaId
  ) || configuraciones[0] || null;

  // Permisos derivados del perfil
  const puedeCrearWorkspaces = perfil?.puedeCrearWorkspaces ?? false;
  const rolGlobal = perfil?.rolGlobal ?? 'observador';

  /**
   * Carga el perfil del usuario y los workspaces desde el backend
   */
  const cargarConfiguraciones = useCallback(async () => {
    try {
      setCargando(true);
      setError(null);

      // Cargar perfil y workspaces en paralelo
      const [perfilData, workspacesData] = await Promise.all([
        obtenerPerfil(),
        obtenerWorkspaces(),
      ]);

      setPerfil(perfilData);
      setConfiguraciones(workspacesData);

      // Validar la selecci√≥n guardada contra los workspaces del usuario
      if (workspacesData.length > 0) {
        const seleccionActualValida = workspacesData.some((c) => c.id === configuracionSeleccionadaId);
        const defaultId = perfilData?.workspace_default_id;
        const defaultValido = defaultId && workspacesData.some((c) => c.id === defaultId);

        // Prioridad: 1) selecci√≥n actual v√°lida, 2) workspace default, 3) primer workspace
        if (!seleccionActualValida) {
          if (defaultValido) {
            setConfiguracionSeleccionadaId(defaultId);
          } else {
            setConfiguracionSeleccionadaId(workspacesData[0].id);
          }
        }
      } else {
        // Si el usuario no tiene workspaces, limpiar cualquier selecci√≥n guardada
        setConfiguracionSeleccionadaId(null);
      }
    } catch (err) {
      console.error("Error cargando configuraciones:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  }, [configuracionSeleccionadaId]);

  // Cargar configuraciones al montar
  useEffect(() => {
    cargarConfiguraciones();
  }, []);

  // Guardar selecci√≥n en localStorage cuando cambie
  useEffect(() => {
    if (configuracionSeleccionadaId != null) {
      localStorage.setItem(
        CLAVES_STORAGE.CONFIGURACION_SELECCIONADA,
        configuracionSeleccionadaId.toString()
      );
    } else {
      localStorage.removeItem(CLAVES_STORAGE.CONFIGURACION_SELECCIONADA);
    }
  }, [configuracionSeleccionadaId]);

  /**
   * Crea un nuevo workspace
   * @param {string} nombre - Nombre del workspace
   * @param {string} descripcion - Descripci√≥n opcional
   */
  const agregarConfiguracion = async (nombre, descripcion = "") => {
    try {
      setError(null);
      const nueva = await crearWorkspace(nombre, descripcion);
      setConfiguraciones((prev) => [...prev, nueva]);
      setConfiguracionSeleccionadaId(nueva.id);
      return nueva;
    } catch (err) {
      console.error("Error creando workspace:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Actualiza un workspace existente
   * @param {number} id - ID del workspace
   * @param {Object} datos - Datos a actualizar
   */
  const actualizarConfiguracion = async (id, datos) => {
    try {
      setError(null);
      const actualizada = await actualizarWorkspaceAPI(id, datos);
      setConfiguraciones((prev) =>
        prev.map((c) => (c.id === id ? actualizada : c))
      );
      return actualizada;
    } catch (err) {
      console.error("Error actualizando workspace:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Elimina un workspace
   * @param {number} id - ID del workspace a eliminar
   */
  const eliminarConfiguracion = async (id) => {
    try {
      setError(null);
      await eliminarWorkspaceAPI(id);
      setConfiguraciones((prev) => prev.filter((c) => c.id !== id));

      // Si se elimin√≥ el seleccionado, seleccionar otro
      if (configuracionSeleccionadaId === id) {
        const restantes = configuraciones.filter((c) => c.id !== id);
        setConfiguracionSeleccionadaId(restantes[0]?.id || null);
      }
    } catch (err) {
      console.error("Error eliminando workspace:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Selecciona un workspace como activo
   * @param {number} id - ID del workspace
   */
  const seleccionarConfiguracion = (id) => {
    setConfiguracionSeleccionadaId(id);
  };

  /**
   * Alterna el workspace por defecto con optimistic update.
   * El cambio se aplica inmediatamente en la UI y se revierte si hay error.
   * @param {string} id - UUID del workspace
   */
  const toggleWorkspaceDefault = async (id) => {
    const nuevoDefault = workspaceDefaultId === id ? null : id;
    const valorAnterior = perfil?.workspace_default_id;

    // Optimistic update: aplicar cambio inmediatamente
    setPerfil((prev) => ({ ...prev, workspace_default_id: nuevoDefault }));

    try {
      setError(null);
      await actualizarWorkspaceDefault(nuevoDefault);
    } catch (err) {
      // Revertir en caso de error
      console.error("Error cambiando workspace default:", err);
      setPerfil((prev) => ({ ...prev, workspace_default_id: valorAnterior }));
      setError(err.message);
    }
  };

  return {
    // Estados
    configuraciones,
    configuracionSeleccionada,
    configuracionSeleccionadaId,
    workspaceDefaultId,
    cargando,
    error,

    // Perfil y permisos
    perfil,
    rolGlobal,
    puedeCrearWorkspaces,

    // Funciones
    cargarConfiguraciones,
    agregarConfiguracion,
    actualizarConfiguracion,
    eliminarConfiguracion,
    seleccionarConfiguracion,
    toggleWorkspaceDefault,
  };
};

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useEstilosGlobales.js ==========
/**
 * Hook para manejar los estilos globales de las tarjetas de alimentador
 * Persiste en localStorage y proporciona funciones para actualizar cada secci√≥n
 */

import { useState, useCallback, useEffect } from "react";
import {
  ESTILOS_GLOBALES_DEFAULT,
  ESTILOS_GLOBALES_STORAGE_KEY,
} from "../constantes/estilosGlobalesTarjeta";

/**
 * Hook que maneja los estilos globales de las tarjetas
 * @returns {Object} Estado y funciones para manejar estilos globales
 */
const useEstilosGlobales = () => {
  const [estilos, setEstilos] = useState(() => {
    // Intentar cargar desde localStorage al inicializar
    try {
      const guardado = localStorage.getItem(ESTILOS_GLOBALES_STORAGE_KEY);
      if (guardado) {
        const parseado = JSON.parse(guardado);
        // Merge con defaults para asegurar que todos los campos existan
        return {
          header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...parseado.header },
          tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...parseado.tituloZona },
          tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...parseado.tituloBox },
          valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...parseado.valorBox },
          box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...parseado.box },
        };
      }
    } catch (e) {
      console.warn("[EstilosGlobales] Error cargando estilos:", e);
    }
    return ESTILOS_GLOBALES_DEFAULT;
  });

  // Guardar en localStorage cuando cambian los estilos
  useEffect(() => {
    try {
      localStorage.setItem(ESTILOS_GLOBALES_STORAGE_KEY, JSON.stringify(estilos));
    } catch (e) {
      console.warn("[EstilosGlobales] Error guardando estilos:", e);
    }
  }, [estilos]);

  /**
   * Actualiza los estilos del header
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarHeader = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      header: { ...prev.header, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos del t√≠tulo de zona (afecta superior e inferior)
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarTituloZona = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      tituloZona: { ...prev.tituloZona, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos de los t√≠tulos de box (R, S, T)
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarTituloBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      tituloBox: { ...prev.tituloBox, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos del valor dentro del box
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarValorBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      valorBox: { ...prev.valorBox, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos del contenedor del box
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      box: { ...prev.box, ...cambios },
    }));
  }, []);

  /**
   * Resetea todos los estilos a los valores por defecto
   */
  const resetearEstilos = useCallback(() => {
    setEstilos(ESTILOS_GLOBALES_DEFAULT);
  }, []);

  /**
   * Aplica un objeto completo de estilos (para guardar desde TabApariencia)
   * @param {Object} nuevosEstilos - Objeto con todos los estilos a aplicar
   */
  const aplicarTodosEstilos = useCallback((nuevosEstilos) => {
    setEstilos({
      header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...nuevosEstilos.header },
      tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...nuevosEstilos.tituloZona },
      tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...nuevosEstilos.tituloBox },
      valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...nuevosEstilos.valorBox },
      box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...nuevosEstilos.box },
    });
  }, []);

  /**
   * Genera el objeto de estilos CSS para aplicar en TarjetaAlimentador
   * @returns {Object} Objeto con estilos CSS listos para usar
   */
  const obtenerEstilosCSS = useCallback(() => {
    return {
      // Estilos para .alim-card-title
      headerTitle: {
        fontFamily: estilos.header.fontFamily,
        fontSize: estilos.header.fontSize,
        fontWeight: estilos.header.fontWeight,
      },
      // Estilos para .alim-card-section-title
      tituloZona: {
        fontFamily: estilos.tituloZona.fontFamily,
        fontSize: estilos.tituloZona.fontSize,
      },
      // Estilos para .alim-card-meter-phase
      tituloBox: {
        fontFamily: estilos.tituloBox.fontFamily,
        fontSize: estilos.tituloBox.fontSize,
      },
      // Estilos para .alim-card-meter-value
      valorBox: {
        fontFamily: estilos.valorBox.fontFamily,
        fontSize: estilos.valorBox.fontSize,
        color: estilos.valorBox.color,
      },
      // Estilos para .alim-card-meter y .alim-card-meters
      box: {
        gap: estilos.box.gap,
        width: estilos.box.width,
        height: estilos.box.height,
      },
    };
  }, [estilos]);

  return {
    estilos,
    actualizarHeader,
    actualizarTituloZona,
    actualizarTituloBox,
    actualizarValorBox,
    actualizarBox,
    resetearEstilos,
    aplicarTodosEstilos,
    obtenerEstilosCSS,
  };
};

export default useEstilosGlobales;

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useGestorModales.js ==========
// src/paginas/PaginaAlimentadores/hooks/useGestorModales.js

import { useState, useCallback } from "react"; // estado y memoizaci√≥n de callbacks de React

/**
 * Gestor simple de modales identificados por una clave.
 * Permite abrir/cerrar y guardar datos asociados al modal.
 *
 * Estructura interna:
 *   estadoModales = {
 *     [idModal]: { abierto: boolean, datos: any }
 *   }
 */
export const useGestorModales = () => {
	const [estadoModales, setEstadoModales] = useState({});        // mapa de estados por id de modal

	const abrirModal = useCallback((idModal, datos = null) => {
		setEstadoModales((prev) => ({
			...prev,
			[idModal]: { abierto: true, datos },           // marca el modal como abierto y guarda datos opcionales
		}));
	}, []);

	const cerrarModal = useCallback((idModal) => {
		setEstadoModales((prev) => ({
			...prev,
			[idModal]: { abierto: false, datos: null },     // lo marca como cerrado y limpia datos
		}));
	}, []);

	const obtenerEstado = useCallback(
		(idModal) => estadoModales[idModal] || { abierto: false, datos: null }, // estado por defecto si nunca se abri√≥
		[estadoModales]
	);

	return { abrirModal, cerrarModal, obtenerEstado, estadoModales };
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (useGestorModales.js)

 - Este hook es un "mini gestor de ventanas": centraliza el estado de todos los modales usando una 
   clave (`idModal`) para cada uno.

 - `abrirModal(id, datos)` abre el modal con esa clave y opcionalmente le asocia un objeto `datos` 
   (por ejemplo, el alimentador que se est√° editando).

 - `cerrarModal(id)` cierra el modal y descarta cualquier dato previo asociado.

 - `obtenerEstado(id)` devuelve siempre un objeto con la forma `{ abierto: boolean, datos: any }`, 
   aunque ese modal nunca se haya abierto.

 - Al usar este hook en `VistaAlimentadores`, cada modal (nuevo puesto, editar puestos, configuraci√≥n 
   de alimentador, mapeo) simplemente pide su estado con `obtenerEstado("clave")` y lo abre/cierra 
	llamando a `abrirModal` o `cerrarModal`.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (useGestorModales.js)

0) Visi√≥n general del hook

   Este hook es un ‚Äúmini centro de control de modales‚Äù. Sirve para manejar
   varios modales a la vez usando una clave de texto (idModal) para cada uno.

   La estructura interna es:

     estadoModales = {
       [idModal]: {
         abierto: boolean,   // si el modal est√° visible o no
         datos: any          // info asociada al modal (por ejemplo, el alimentador a editar)
       }
     }

   En vez de tener un useState por cada modal (`isNuevoPuestoAbierto`, `isEditarPuestoAbierto`, etc.), 
	todo se maneja en un solo objeto y con tres funciones simples: abrir, cerrar y leer estado.


1) estadoModales (useState)

   const [estadoModales, setEstadoModales] = useState({});

   - `estadoModales` empieza como un objeto vac√≠o: no hay modales abiertos.

   - Cada vez que abrimos o cerramos un modal, vamos agregando o modificando entradas en este objeto 
	  con la forma:
       estadoModales["configAlim1"] = { abierto: true/false, datos: ... }

   - Tener todo en un solo estado hace f√°cil:
       ‚Ä¢ pasar el estado completo para debug,
       ‚Ä¢ o mostrar un panel de ‚Äúqu√© modales est√°n abiertos‚Äù si se necesitara.


2) abrirModal

   const abrirModal = useCallback((idModal, datos = null) => {
     setEstadoModales((prev) => ({
       ...prev,
       [idModal]: { abierto: true, datos },
     }));
   }, []);

   - Recibe:
       ‚Ä¢ `idModal`: una clave string que identifica al modal (ej: "nuevoPuesto", "editarAlimentador",
		   "mapeoAlim3", etc.),
       ‚Ä¢ `datos` (opcional): cualquier objeto que queramos asociar a ese modal (por ejemplo, el alimentador 
		   que se est√° editando).

   - Usa `setEstadoModales` con funci√≥n para tomar el estado anterior (`prev`) y devolver uno nuevo:
       ‚Ä¢ copia todo lo que ya exist√≠a (`...prev`),
       ‚Ä¢ reemplaza o crea la entrada para esa clave `idModal` con:
           { abierto: true, datos }.

   - Resultado: el modal queda marcado como abierto y con los datos que le pasamos.

   - Est√° envuelto en `useCallback(..., [])` para que la referencia de la funci√≥n se mantenga estable entre 
	  renders (ayuda a evitar renders extra si se pasa como prop a otros componentes).


3) cerrarModal

   const cerrarModal = useCallback((idModal) => {
     setEstadoModales((prev) => ({
       ...prev,
       [idModal]: { abierto: false, datos: null },
     }));
   }, []);

   - Recibe `idModal`, la misma clave que se us√≥ para abrir el modal.

   - Actualiza el estado:
       ‚Ä¢ mantiene el resto del objeto igual (`...prev`),
       ‚Ä¢ para esa clave, pone:
           { abierto: false, datos: null }.

   - Es decir:
       ‚Ä¢ marca el modal como cerrado,
       ‚Ä¢ y borra cualquier dato que se hubiera guardado antes.

   - Tambi√©n est√° memoizada con `useCallback` para que su referencia no cambie en cada render sin necesidad.


4) obtenerEstado

   const obtenerEstado = useCallback(
     (idModal) => estadoModales[idModal] || { abierto: false, datos: null },
     [estadoModales]
   );

   - Recibe `idModal` y devuelve SIEMPRE un objeto con esta forma:
       { abierto: boolean, datos: any }

   - Si ese modal ya fue usado antes:
       ‚Ä¢ devuelve el estado real guardado en `estadoModales[idModal]`.

   - Si ese modal nunca se abri√≥:
       ‚Ä¢ devuelve un estado ‚Äúpor defecto‚Äù:
           { abierto: false, datos: null }.

   - Esto simplifica mucho la UI porque evita tener que hacer chequeos tipo:
       if (estado && estado.abierto) ...
     En cambio, el componente puede hacer directamente:
       const { abierto, datos } = obtenerEstado("configAlim1");

   - Est√° envuelta en `useCallback` dependiente de `estadoModales` para que solo cambie la referencia 
	  de la funci√≥n cuando cambia el estado de los modales, no en cada render.


5) return del hook

   return { abrirModal, cerrarModal, obtenerEstado, estadoModales };

   - Expone cuatro cosas hacia los componentes que usan este hook:

       ‚Ä¢ `abrirModal(id, datos?)`
           ‚Üí marca el modal como abierto y asocia datos opcionales.

       ‚Ä¢ `cerrarModal(id)`
           ‚Üí marca el modal como cerrado y limpia los datos asociados.

       ‚Ä¢ `obtenerEstado(id)`
           ‚Üí devuelve siempre un objeto `{ abierto, datos }` para ese modal, aunque jam√°s se haya abierto.

       ‚Ä¢ `estadoModales`
           ‚Üí estado completo con todos los modales; √∫til para debug o para vistas que quieran mostrar 
			    un resumen general.

   - En `VistaAlimentadores`, cada modal se maneja as√≠:
       const { abierto, datos } = obtenerEstado("claveDelModal");

       y se abre/cierra con:
         abrirModal("claveDelModal", datosOpcionales);
         cerrarModal("claveDelModal");

   - De esta forma, no se acumula l√≥gica de ‚Äúqu√© modal est√° abierto‚Äù en cada
     componente: todo pasa por este hook centralizado.
---------------------------------------------------------------------------*/



========== mi-app/src/paginas/PaginaAlimentadores/hooks/useGrillaUnifilar.js ==========
// src/paginas/PaginaAlimentadores/hooks/usarGrillaUnifilar.js

import { useState, useCallback, useEffect, useRef } from "react";

/**
 * Clave base para localStorage - cada puesto tendr√° su propio dibujo
 */
const CLAVE_BASE = "rw-grilla-unifilar";

/**
 * Colores predefinidos para dibujar el diagrama unifiliar
 */
export const COLORES_UNIFILAR = [
	{ id: "rojo", color: "#dc2626", nombre: "Rojo" },
	{ id: "azul", color: "#2563eb", nombre: "Azul" },
	{ id: "verde", color: "#16a34a", nombre: "Verde" },
	{ id: "amarillo", color: "#ca8a04", nombre: "Amarillo" },
	{ id: "naranja", color: "#ea580c", nombre: "Naranja" },
	{ id: "rosa", color: "#db2777", nombre: "Rosa" },
	{ id: "violeta", color: "#7c3aed", nombre: "Violeta" },
	{ id: "celeste", color: "#0891b2", nombre: "Celeste" },
	{ id: "blanco", color: "#ffffff", nombre: "Blanco" },
	{ id: "negro", color: "#000000", nombre: "Negro" },
];

/**
 * Fuentes disponibles para texto
 */
export const FUENTES_DISPONIBLES = [
	{ id: "arial", nombre: "Arial", familia: "Arial, sans-serif" },
	{ id: "helvetica", nombre: "Helvetica", familia: "Helvetica, Arial, sans-serif" },
	{ id: "times", nombre: "Times New Roman", familia: "Times New Roman, serif" },
	{ id: "courier", nombre: "Courier", familia: "Courier New, monospace" },
	{ id: "georgia", nombre: "Georgia", familia: "Georgia, serif" },
	{ id: "verdana", nombre: "Verdana", familia: "Verdana, sans-serif" },
];

/**
 * Tama√±os de fuente disponibles
 */
export const TAMANOS_FUENTE = [10, 12, 14, 16, 18, 20, 24, 28, 32, 36, 42, 48];

/**
 * Grosores de l√≠nea disponibles (en p√≠xeles)
 */
export const GROSORES_LINEA = [
	{ id: "fino", valor: 8, nombre: "Fino" },
	{ id: "normal", valor: 12, nombre: "Normal" },
	{ id: "medio", valor: 16, nombre: "Medio" },
	{ id: "grueso", valor: 20, nombre: "Grueso" },
	{ id: "extra", valor: 28, nombre: "Extra" },
];

/**
 * Tipos de bornes para el sistema de chispas
 */
export const TIPOS_BORNE = {
	EMISOR: "EMISOR",
	RECEPTOR: "RECEPTOR",
};

/**
 * Configuraci√≥n por defecto de chispas
 */
export const CONFIG_CHISPAS_DEFAULT = {
	velocidad: 8,        // celdas por segundo
	tamano: 4,           // radio en p√≠xeles
	color: "#fef08a",    // amarillo brillante
	estela: true,        // mostrar estela
	longitudEstela: 5,   // cantidad de posiciones en la estela
	frecuenciaEmision: 2000, // ms entre emisiones
};

/**
 * Hook para manejar la grilla de dibujo unifiliar
 *
 * @param {string} puestoId - ID del puesto actual
 * @param {string} workspaceId - ID del workspace actual
 * @returns {Object} Estado y funciones para manejar la grilla
 */
const useGrillaUnifilar = (puestoId, workspaceId) => {
	// Estado del dibujo: objeto con claves "x,y" y valores de color
	const [celdas, setCeldas] = useState({});
	// Textos: array de { id, x, y, texto, color, fuente, tamano, negrita, cursiva }
	const [textos, setTextos] = useState([]);
	// Modo edici√≥n activo
	const [modoEdicion, setModoEdicion] = useState(false);
	// Color seleccionado para pintar
	const [colorSeleccionado, setColorSeleccionado] = useState(COLORES_UNIFILAR[0].color);
	// Herramienta activa: "pincel", "borrador", "texto", "balde" o "mover"
	const [herramienta, setHerramienta] = useState("pincel");
	// Grosor de l√≠nea seleccionado (tama√±o de celda en p√≠xeles)
	const [grosorLinea, setGrosorLinea] = useState(GROSORES_LINEA[1].valor); // Normal por defecto
	// Estado de pintando (mouse presionado)
	const [estaPintando, setEstaPintando] = useState(false);
	// Punto inicial para l√≠neas rectas con Shift
	const puntoInicialRef = useRef(null);
	// Direcci√≥n bloqueada para Shift (null, "horizontal", "vertical")
	const direccionBloqueadaRef = useRef(null);

	// Configuraci√≥n de texto
	const [configTexto, setConfigTexto] = useState({
		fuente: FUENTES_DISPONIBLES[0].familia,
		tamano: 16,
		negrita: false,
		cursiva: false,
	});

	// Texto seleccionado para editar/eliminar
	const [textoSeleccionadoId, setTextoSeleccionadoId] = useState(null);

	// === SISTEMA DE BORNES Y CHISPAS ===
	// Bornes: array de { id, tipo, x, y, color, activo, frecuenciaMs, nombre }
	const [bornes, setBornes] = useState([]);
	// Configuraci√≥n de chispas
	const [chispasConfig, setChispasConfig] = useState(CONFIG_CHISPAS_DEFAULT);

	/**
	 * Genera la clave √∫nica de localStorage para este puesto/workspace
	 */
	const obtenerClave = useCallback(() => {
		if (!puestoId || !workspaceId) return null;
		return `${CLAVE_BASE}-${workspaceId}-${puestoId}`;
	}, [puestoId, workspaceId]);

	/**
	 * Cargar datos del localStorage al montar o cambiar de puesto
	 */
	useEffect(() => {
		const clave = obtenerClave();
		if (!clave) {
			setCeldas({});
			setTextos([]);
			setGrosorLinea(GROSORES_LINEA[1].valor);
			setBornes([]);
			setChispasConfig(CONFIG_CHISPAS_DEFAULT);
			return;
		}

		try {
			const datos = localStorage.getItem(clave);
			if (datos) {
				const parsed = JSON.parse(datos);
				// Compatibilidad: si es objeto plano (formato antiguo), son solo celdas
				if (parsed && typeof parsed === "object" && !parsed.celdas) {
					setCeldas(parsed);
					setTextos([]);
					setGrosorLinea(GROSORES_LINEA[1].valor);
					setBornes([]);
					setChispasConfig(CONFIG_CHISPAS_DEFAULT);
				} else {
					// Formato nuevo con celdas, textos, grosor, bornes y chispasConfig
					setCeldas(parsed.celdas || {});
					setTextos(parsed.textos || []);
					setGrosorLinea(parsed.grosor || GROSORES_LINEA[1].valor);
					setBornes(parsed.bornes || []);
					setChispasConfig(parsed.chispasConfig || CONFIG_CHISPAS_DEFAULT);
				}
			} else {
				setCeldas({});
				setTextos([]);
				setGrosorLinea(GROSORES_LINEA[1].valor);
				setBornes([]);
				setChispasConfig(CONFIG_CHISPAS_DEFAULT);
			}
		} catch (error) {
			console.error("Error al cargar grilla unifiliar:", error);
			setCeldas({});
			setTextos([]);
			setGrosorLinea(GROSORES_LINEA[1].valor);
			setBornes([]);
			setChispasConfig(CONFIG_CHISPAS_DEFAULT);
		}
	}, [obtenerClave]);

	/**
	 * Guardar en localStorage (celdas, textos, grosor, bornes y chispasConfig)
	 */
	const guardarDatos = useCallback((nuevasCeldas, nuevosTextos, nuevoGrosor = null, nuevosBornes = null, nuevaChispasConfig = null) => {
		const clave = obtenerClave();
		if (!clave) return;

		try {
			const sinCeldas = Object.keys(nuevasCeldas).length === 0;
			const sinTextos = nuevosTextos.length === 0;
			const bornesAGuardar = nuevosBornes !== null ? nuevosBornes : bornes;
			const sinBornes = bornesAGuardar.length === 0;

			if (sinCeldas && sinTextos && sinBornes) {
				localStorage.removeItem(clave);
			} else {
				localStorage.setItem(clave, JSON.stringify({
					celdas: nuevasCeldas,
					textos: nuevosTextos,
					grosor: nuevoGrosor !== null ? nuevoGrosor : grosorLinea,
					bornes: bornesAGuardar,
					chispasConfig: nuevaChispasConfig !== null ? nuevaChispasConfig : chispasConfig,
				}));
			}
		} catch (error) {
			console.error("Error al guardar grilla unifiliar:", error);
		}
	}, [obtenerClave, grosorLinea, bornes, chispasConfig]);

	/**
	 * Pintar una celda con el color seleccionado
	 * @param {number} x - Coordenada X de la celda
	 * @param {number} y - Coordenada Y de la celda
	 * @param {boolean} shiftPresionado - Si Shift est√° presionado para l√≠nea recta
	 */
	const pintarCelda = useCallback((x, y, shiftPresionado = false) => {
		let xFinal = x;
		let yFinal = y;

		// Si Shift est√° presionado, restringir a l√≠nea recta
		if (shiftPresionado && puntoInicialRef.current) {
			const { x: xInicial, y: yInicial } = puntoInicialRef.current;
			const deltaX = Math.abs(x - xInicial);
			const deltaY = Math.abs(y - yInicial);

			// Determinar direcci√≥n si no est√° bloqueada
			if (direccionBloqueadaRef.current === null && (deltaX > 1 || deltaY > 1)) {
				direccionBloqueadaRef.current = deltaX > deltaY ? "horizontal" : "vertical";
			}

			// Aplicar restricci√≥n seg√∫n direcci√≥n
			if (direccionBloqueadaRef.current === "horizontal") {
				yFinal = yInicial;
			} else if (direccionBloqueadaRef.current === "vertical") {
				xFinal = xInicial;
			}
		}

		const claveCelda = `${xFinal},${yFinal}`;

		setCeldas(prev => {
			let nuevasCeldas;

			if (herramienta === "borrador") {
				// Borrar celda
				nuevasCeldas = { ...prev };
				delete nuevasCeldas[claveCelda];
			} else {
				// Pintar celda con el color seleccionado
				nuevasCeldas = {
					...prev,
					[claveCelda]: colorSeleccionado
				};
			}

			// Guardar inmediatamente (usamos textos actuales)
			setTextos(currentTextos => {
				guardarDatos(nuevasCeldas, currentTextos);
				return currentTextos;
			});
			return nuevasCeldas;
		});
	}, [colorSeleccionado, herramienta, guardarDatos]);

	/**
	 * Limpiar todo el dibujo (celdas y textos)
	 */
	const limpiarTodo = useCallback(() => {
		setCeldas({});
		setTextos([]);
		guardarDatos({}, []);
	}, [guardarDatos]);

	/**
	 * Activar modo edici√≥n
	 */
	const activarEdicion = useCallback(() => {
		setModoEdicion(true);
	}, []);

	/**
	 * Desactivar modo edici√≥n
	 */
	const desactivarEdicion = useCallback(() => {
		setModoEdicion(false);
		setEstaPintando(false);
	}, []);

	/**
	 * Toggle modo edici√≥n
	 */
	const toggleEdicion = useCallback(() => {
		if (modoEdicion) {
			desactivarEdicion();
		} else {
			activarEdicion();
		}
	}, [modoEdicion, activarEdicion, desactivarEdicion]);

	/**
	 * Iniciar pintado (mouse down)
	 * @param {number} x - Coordenada X inicial
	 * @param {number} y - Coordenada Y inicial
	 */
	const iniciarPintado = useCallback((x, y) => {
		setEstaPintando(true);
		// Guardar punto inicial para l√≠neas rectas con Shift
		puntoInicialRef.current = { x, y };
		direccionBloqueadaRef.current = null;
	}, []);

	/**
	 * Detener pintado (mouse up)
	 */
	const detenerPintado = useCallback(() => {
		setEstaPintando(false);
		// Limpiar punto inicial
		puntoInicialRef.current = null;
		direccionBloqueadaRef.current = null;
	}, []);

	/**
	 * Seleccionar herramienta pincel
	 */
	const seleccionarPincel = useCallback(() => {
		setHerramienta("pincel");
	}, []);

	/**
	 * Seleccionar herramienta borrador
	 */
	const seleccionarBorrador = useCallback(() => {
		setHerramienta("borrador");
		setTextoSeleccionadoId(null);
	}, []);

	/**
	 * Seleccionar herramienta texto
	 */
	const seleccionarTexto = useCallback(() => {
		setHerramienta("texto");
	}, []);

	/**
	 * Seleccionar herramienta balde (flood fill)
	 */
	const seleccionarBalde = useCallback(() => {
		setHerramienta("balde");
		setTextoSeleccionadoId(null);
	}, []);

	/**
	 * Seleccionar herramienta mover (arrastrar l√≠neas conectadas)
	 */
	const seleccionarMover = useCallback(() => {
		setHerramienta("mover");
		setTextoSeleccionadoId(null);
	}, []);

	/**
	 * Obtener todas las celdas conectadas a una celda dada (BFS)
	 * Retorna un array de claves "x,y" de las celdas conectadas del mismo color
	 * @param {number} x - Coordenada X de la celda inicial
	 * @param {number} y - Coordenada Y de la celda inicial
	 * @param {Object} celdasActuales - Objeto de celdas actual
	 * @returns {Array<string>} Array de claves de celdas conectadas
	 */
	const obtenerCeldasConectadas = useCallback((x, y, celdasActuales) => {
		const claveCelda = `${x},${y}`;
		const colorOriginal = celdasActuales[claveCelda];

		if (!colorOriginal) return []; // No hay celda pintada en esa posici√≥n

		const visitadas = new Set();
		const cola = [[x, y]];
		const celdasConectadas = [];

		while (cola.length > 0) {
			const [cx, cy] = cola.shift();
			const claveActual = `${cx},${cy}`;

			if (visitadas.has(claveActual)) continue;
			visitadas.add(claveActual);

			// Solo incluir celdas que tengan el mismo color
			if (celdasActuales[claveActual] !== colorOriginal) continue;

			celdasConectadas.push(claveActual);

			// Agregar vecinos a la cola (arriba, abajo, izquierda, derecha)
			cola.push([cx, cy - 1]); // arriba
			cola.push([cx, cy + 1]); // abajo
			cola.push([cx - 1, cy]); // izquierda
			cola.push([cx + 1, cy]); // derecha
		}

		return celdasConectadas;
	}, []);

	/**
	 * Mover todas las celdas conectadas por un delta
	 * @param {Array<string>} celdasAMover - Array de claves "x,y" a mover
	 * @param {number} deltaX - Desplazamiento en X (en unidades de celda)
	 * @param {number} deltaY - Desplazamiento en Y (en unidades de celda)
	 */
	const moverCeldasConectadas = useCallback((celdasAMover, deltaX, deltaY) => {
		if (deltaX === 0 && deltaY === 0) return;
		if (celdasAMover.length === 0) return;

		setCeldas(prev => {
			const nuevasCeldas = { ...prev };

			// Primero, remover todas las celdas que vamos a mover
			const coloresOriginales = {};
			celdasAMover.forEach(clave => {
				coloresOriginales[clave] = prev[clave];
				delete nuevasCeldas[clave];
			});

			// Luego, agregar las celdas en sus nuevas posiciones
			celdasAMover.forEach(clave => {
				const [x, y] = clave.split(",").map(Number);
				const nuevaClave = `${x + deltaX},${y + deltaY}`;
				nuevasCeldas[nuevaClave] = coloresOriginales[clave];
			});

			// Guardar
			setTextos(currentTextos => {
				guardarDatos(nuevasCeldas, currentTextos);
				return currentTextos;
			});

			return nuevasCeldas;
		});
	}, [guardarDatos]);

	/**
	 * Borrar todas las celdas dentro de un √°rea rectangular
	 * @param {number} x1 - Coordenada X de la esquina inicial
	 * @param {number} y1 - Coordenada Y de la esquina inicial
	 * @param {number} x2 - Coordenada X de la esquina final
	 * @param {number} y2 - Coordenada Y de la esquina final
	 */
	const borrarArea = useCallback((x1, y1, x2, y2) => {
		// Normalizar coordenadas (asegurar que min <= max)
		const minX = Math.min(x1, x2);
		const maxX = Math.max(x1, x2);
		const minY = Math.min(y1, y2);
		const maxY = Math.max(y1, y2);

		setCeldas(prev => {
			const nuevasCeldas = { ...prev };
			let huboCambios = false;

			// Iterar sobre todas las celdas del √°rea y eliminarlas
			for (let x = minX; x <= maxX; x++) {
				for (let y = minY; y <= maxY; y++) {
					const clave = `${x},${y}`;
					if (nuevasCeldas[clave]) {
						delete nuevasCeldas[clave];
						huboCambios = true;
					}
				}
			}

			if (!huboCambios) return prev;

			// Guardar
			setTextos(currentTextos => {
				guardarDatos(nuevasCeldas, currentTextos);
				return currentTextos;
			});

			return nuevasCeldas;
		});
	}, [guardarDatos]);

	/**
	 * Rellenar todas las celdas conectadas con el color seleccionado (flood fill)
	 * Busca celdas adyacentes (arriba, abajo, izquierda, derecha) del mismo color original
	 * @param {number} x - Coordenada X de la celda inicial
	 * @param {number} y - Coordenada Y de la celda inicial
	 */
	const rellenarConectadas = useCallback((x, y) => {
		const claveCelda = `${x},${y}`;

		setCeldas(prev => {
			// Verificar que la celda inicial existe y tiene un color
			const colorOriginal = prev[claveCelda];
			if (!colorOriginal) return prev; // No hay celda pintada en esa posici√≥n

			// Si el color original es igual al seleccionado, no hacer nada
			if (colorOriginal === colorSeleccionado) return prev;

			// Conjunto de celdas visitadas
			const visitadas = new Set();
			// Cola para BFS (Breadth-First Search)
			const cola = [[x, y]];
			// Celdas a cambiar
			const celdasARellenar = [];

			while (cola.length > 0) {
				const [cx, cy] = cola.shift();
				const claveActual = `${cx},${cy}`;

				// Si ya visitamos esta celda, saltar
				if (visitadas.has(claveActual)) continue;
				visitadas.add(claveActual);

				// Si la celda no existe o no tiene el color original, saltar
				if (prev[claveActual] !== colorOriginal) continue;

				// Agregar a la lista de celdas a rellenar
				celdasARellenar.push(claveActual);

				// Agregar vecinos a la cola (arriba, abajo, izquierda, derecha)
				cola.push([cx, cy - 1]); // arriba
				cola.push([cx, cy + 1]); // abajo
				cola.push([cx - 1, cy]); // izquierda
				cola.push([cx + 1, cy]); // derecha
			}

			// Crear nuevo objeto de celdas con las celdas rellenadas
			const nuevasCeldas = { ...prev };
			celdasARellenar.forEach(clave => {
				nuevasCeldas[clave] = colorSeleccionado;
			});

			// Guardar
			setTextos(currentTextos => {
				guardarDatos(nuevasCeldas, currentTextos);
				return currentTextos;
			});

			return nuevasCeldas;
		});
	}, [colorSeleccionado, guardarDatos]);

	/**
	 * Agregar un nuevo texto
	 * @param {number} x - Coordenada X en p√≠xeles
	 * @param {number} y - Coordenada Y en p√≠xeles
	 * @param {string} contenido - Texto a mostrar
	 */
	const agregarTexto = useCallback((x, y, contenido) => {
		if (!contenido.trim()) return;

		const nuevoTexto = {
			id: `texto-${Date.now()}`,
			x,
			y,
			texto: contenido,
			color: colorSeleccionado,
			fuente: configTexto.fuente,
			tamano: configTexto.tamano,
			negrita: configTexto.negrita,
			cursiva: configTexto.cursiva,
		};

		setTextos(prev => {
			const nuevosTextos = [...prev, nuevoTexto];
			setCeldas(currentCeldas => {
				guardarDatos(currentCeldas, nuevosTextos);
				return currentCeldas;
			});
			return nuevosTextos;
		});
	}, [colorSeleccionado, configTexto, guardarDatos]);

	/**
	 * Actualizar un texto existente
	 */
	const actualizarTexto = useCallback((id, cambios) => {
		setTextos(prev => {
			const nuevosTextos = prev.map(t =>
				t.id === id ? { ...t, ...cambios } : t
			);
			setCeldas(currentCeldas => {
				guardarDatos(currentCeldas, nuevosTextos);
				return currentCeldas;
			});
			return nuevosTextos;
		});
	}, [guardarDatos]);

	/**
	 * Eliminar un texto
	 */
	const eliminarTexto = useCallback((id) => {
		setTextos(prev => {
			const nuevosTextos = prev.filter(t => t.id !== id);
			setCeldas(currentCeldas => {
				guardarDatos(currentCeldas, nuevosTextos);
				return currentCeldas;
			});
			return nuevosTextos;
		});
		setTextoSeleccionadoId(null);
	}, [guardarDatos]);

	/**
	 * Cambiar el grosor de l√≠nea y guardar
	 */
	const cambiarGrosor = useCallback((nuevoGrosor) => {
		setGrosorLinea(nuevoGrosor);
		// Guardar inmediatamente con el nuevo grosor
		setCeldas(currentCeldas => {
			setTextos(currentTextos => {
				guardarDatos(currentCeldas, currentTextos, nuevoGrosor);
				return currentTextos;
			});
			return currentCeldas;
		});
	}, [guardarDatos]);

	// === FUNCIONES CRUD PARA BORNES ===

	/**
	 * Seleccionar herramienta borne
	 * @param {string} tipo - "EMISOR" o "RECEPTOR"
	 */
	const seleccionarBorne = useCallback((tipo) => {
		setHerramienta("borne");
		// El tipo se pasa como par√°metro a agregarBorne
	}, []);

	/**
	 * Agregar un nuevo borne en una celda
	 * @param {number} x - Coordenada X de la celda
	 * @param {number} y - Coordenada Y de la celda
	 * @param {string} tipo - "EMISOR" o "RECEPTOR"
	 * @returns {boolean} - true si se agreg√≥ correctamente
	 */
	const agregarBorne = useCallback((x, y, tipo) => {
		const claveCelda = `${x},${y}`;

		// Verificar que la celda tenga una l√≠nea pintada
		if (!celdas[claveCelda]) {
			console.warn("Solo se pueden colocar bornes sobre l√≠neas pintadas");
			return false;
		}

		// Verificar que no haya otro borne en la misma posici√≥n
		if (bornes.some(b => b.x === x && b.y === y)) {
			console.warn("Ya existe un borne en esta posici√≥n");
			return false;
		}

		const contadorTipo = bornes.filter(b => b.tipo === tipo).length + 1;
		const nuevoBorne = {
			id: `borne-${Date.now()}`,
			tipo,
			x,
			y,
			color: tipo === TIPOS_BORNE.EMISOR ? "#22d3ee" : "#f97316",
			activo: true,
			frecuenciaMs: chispasConfig.frecuenciaEmision,
			nombre: `${tipo === TIPOS_BORNE.EMISOR ? "E" : "R"}${contadorTipo}`,
		};

		const nuevosBornes = [...bornes, nuevoBorne];
		setBornes(nuevosBornes);

		// Guardar inmediatamente
		setCeldas(currentCeldas => {
			setTextos(currentTextos => {
				guardarDatos(currentCeldas, currentTextos, grosorLinea, nuevosBornes);
				return currentTextos;
			});
			return currentCeldas;
		});

		return true;
	}, [celdas, bornes, chispasConfig.frecuenciaEmision, grosorLinea, guardarDatos]);

	/**
	 * Eliminar un borne por su ID
	 * @param {string} borneId - ID del borne a eliminar
	 */
	const eliminarBorne = useCallback((borneId) => {
		const nuevosBornes = bornes.filter(b => b.id !== borneId);
		setBornes(nuevosBornes);

		// Guardar inmediatamente
		setCeldas(currentCeldas => {
			setTextos(currentTextos => {
				guardarDatos(currentCeldas, currentTextos, grosorLinea, nuevosBornes);
				return currentTextos;
			});
			return currentCeldas;
		});
	}, [bornes, grosorLinea, guardarDatos]);

	/**
	 * Eliminar borne en una posici√≥n espec√≠fica
	 * @param {number} x - Coordenada X
	 * @param {number} y - Coordenada Y
	 * @returns {boolean} - true si se elimin√≥ un borne
	 */
	const eliminarBorneEnPosicion = useCallback((x, y) => {
		const borneEnPosicion = bornes.find(b => b.x === x && b.y === y);
		if (borneEnPosicion) {
			eliminarBorne(borneEnPosicion.id);
			return true;
		}
		return false;
	}, [bornes, eliminarBorne]);

	/**
	 * Actualizar propiedades de un borne
	 * @param {string} borneId - ID del borne
	 * @param {Object} cambios - Propiedades a actualizar
	 */
	const actualizarBorne = useCallback((borneId, cambios) => {
		const nuevosBornes = bornes.map(b =>
			b.id === borneId ? { ...b, ...cambios } : b
		);
		setBornes(nuevosBornes);

		// Guardar inmediatamente
		setCeldas(currentCeldas => {
			setTextos(currentTextos => {
				guardarDatos(currentCeldas, currentTextos, grosorLinea, nuevosBornes);
				return currentTextos;
			});
			return currentCeldas;
		});
	}, [bornes, grosorLinea, guardarDatos]);

	/**
	 * Actualizar configuraci√≥n de chispas
	 * @param {Object} nuevaConfig - Nueva configuraci√≥n (parcial o completa)
	 */
	const actualizarChispasConfig = useCallback((nuevaConfig) => {
		const configActualizada = { ...chispasConfig, ...nuevaConfig };
		setChispasConfig(configActualizada);

		// Guardar inmediatamente
		setCeldas(currentCeldas => {
			setTextos(currentTextos => {
				guardarDatos(currentCeldas, currentTextos, grosorLinea, bornes, configActualizada);
				return currentTextos;
			});
			return currentCeldas;
		});
	}, [chispasConfig, grosorLinea, bornes, guardarDatos]);

	/**
	 * Obtener borne en una posici√≥n espec√≠fica
	 * @param {number} x - Coordenada X
	 * @param {number} y - Coordenada Y
	 * @returns {Object|null} - Borne encontrado o null
	 */
	const obtenerBorneEnPosicion = useCallback((x, y) => {
		return bornes.find(b => b.x === x && b.y === y) || null;
	}, [bornes]);

	/**
	 * Exportar el dibujo a un archivo JSON
	 */
	const exportarAArchivo = useCallback(() => {
		const datos = {
			version: 1,
			celdas,
			textos,
			grosor: grosorLinea,
			exportadoEn: new Date().toISOString(),
		};

		const blob = new Blob([JSON.stringify(datos, null, 2)], { type: "application/json" });
		const url = URL.createObjectURL(blob);
		const link = document.createElement("a");
		link.href = url;
		link.download = `diagrama-unifiliar-${puestoId || "sin-puesto"}.json`;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
		URL.revokeObjectURL(url);
	}, [celdas, textos, grosorLinea, puestoId]);

	/**
	 * Importar un dibujo desde un archivo JSON
	 * @param {File} archivo - Archivo JSON a importar
	 * @returns {Promise<boolean>} - true si se import√≥ correctamente
	 */
	const importarDesdeArchivo = useCallback((archivo) => {
		return new Promise((resolve) => {
			const reader = new FileReader();

			reader.onload = (e) => {
				try {
					const datos = JSON.parse(e.target.result);

					// Validar estructura b√°sica
					if (!datos || typeof datos !== "object") {
						console.error("Archivo inv√°lido: no es un objeto JSON");
						resolve(false);
						return;
					}

					// Extraer datos (compatible con formato antiguo y nuevo)
					const nuevasCeldas = datos.celdas || (datos.version ? {} : datos);
					const nuevosTextos = datos.textos || [];
					const nuevoGrosor = datos.grosor || GROSORES_LINEA[1].valor;

					// Validar que celdas sea un objeto
					if (typeof nuevasCeldas !== "object" || Array.isArray(nuevasCeldas)) {
						console.error("Archivo inv√°lido: celdas no es un objeto");
						resolve(false);
						return;
					}

					// Aplicar los datos importados
					setCeldas(nuevasCeldas);
					setTextos(nuevosTextos);
					setGrosorLinea(nuevoGrosor);
					guardarDatos(nuevasCeldas, nuevosTextos, nuevoGrosor);

					resolve(true);
				} catch (error) {
					console.error("Error al parsear archivo JSON:", error);
					resolve(false);
				}
			};

			reader.onerror = () => {
				console.error("Error al leer archivo");
				resolve(false);
			};

			reader.readAsText(archivo);
		});
	}, [guardarDatos]);

	/**
	 * Verificar si hay celdas o textos dibujados
	 */
	const tieneDibujo = Object.keys(celdas).length > 0 || textos.length > 0;

	return {
		// Estado
		celdas,
		textos,
		modoEdicion,
		colorSeleccionado,
		herramienta,
		estaPintando,
		tieneDibujo,
		grosorLinea,

		// Configuraci√≥n de texto
		configTexto,
		setConfigTexto,
		textoSeleccionadoId,
		setTextoSeleccionadoId,

		// Colores, fuentes y grosores disponibles
		coloresDisponibles: COLORES_UNIFILAR,
		fuentesDisponibles: FUENTES_DISPONIBLES,
		tamanosDisponibles: TAMANOS_FUENTE,
		grosoresDisponibles: GROSORES_LINEA,

		// Acciones de edici√≥n
		toggleEdicion,
		activarEdicion,
		desactivarEdicion,

		// Acciones de pintado
		pintarCelda,
		limpiarTodo,
		iniciarPintado,
		detenerPintado,
		rellenarConectadas,
		borrarArea,

		// Acciones de texto
		agregarTexto,
		actualizarTexto,
		eliminarTexto,

		// Selecci√≥n de herramientas
		setColorSeleccionado,
		seleccionarPincel,
		seleccionarBorrador,
		seleccionarTexto,
		seleccionarBalde,
		seleccionarMover,

		// Funciones para mover l√≠neas conectadas
		obtenerCeldasConectadas,
		moverCeldasConectadas,

		// Grosor de l√≠nea
		cambiarGrosor,

		// Importar/Exportar archivo
		exportarAArchivo,
		importarDesdeArchivo,

		// === SISTEMA DE BORNES Y CHISPAS ===
		bornes,
		chispasConfig,
		tiposBorne: TIPOS_BORNE,

		// Acciones de bornes
		seleccionarBorne,
		agregarBorne,
		eliminarBorne,
		eliminarBorneEnPosicion,
		actualizarBorne,
		obtenerBorneEnPosicion,

		// Configuraci√≥n de chispas
		actualizarChispasConfig,
	};
};

export default useGrillaUnifilar;

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useHistorialLocal.js ==========
/**
 * Hook para manejar el historial local de lecturas
 * Usa IndexedDB como cach√© inteligente que se auto-alimenta:
 * - Guarda lecturas del polling en tiempo real
 * - Cachea datos remotos cuando se consultan por primera vez
 * - Evita duplicados por timestamp
 */

import { useState, useCallback, useRef, useEffect } from "react";
import {
  abrirDB,
  guardarLectura,
  obtenerLecturasRango,
  limpiarLecturasAntiguas,
  obtenerEstadisticas,
  cachearLecturasRemotas,
  limpiarTodo,
} from "../utilidades/indexedDBHelper";
import { obtenerLecturasHistoricasPorRegistrador } from "@/servicios/apiService";
import {
  HORAS_RETENCION_LOCAL,
  UMBRAL_COBERTURA_CACHE,
  UMBRAL_COBERTURA_REMOTO,
  MARGEN_LIMITE_LOCAL_MS,
  MAX_ANTIGUEDAD_CACHE_MINUTOS,
} from "../constantes/historialConfig";

export const useHistorialLocal = () => {
  const [cargando, setCargando] = useState(false);
  const [error, setError] = useState(null);
  const [estadisticas, setEstadisticas] = useState(null);
  const [dbLista, setDbLista] = useState(false); // Indica cuando IndexedDB est√° lista

  // Estado de precarga de 48h
  const [precargaProgreso, setPrecargaProgreso] = useState(0); // 0-100
  const [precargaCompleta, setPrecargaCompleta] = useState(false);
  const [precargando, setPrecargando] = useState(false);
  const [datosDeBD, setDatosDeBD] = useState(false); // Indica si los datos fueron descargados de la BD
  const precargaAbortRef = useRef(false);

  const dbRef = useRef(null);

  // Inicializar IndexedDB
  useEffect(() => {
    const init = async () => {
      // Si ya tenemos conexi√≥n, marcar como lista
      if (dbRef.current) {
        setDbLista(true);
        return;
      }

      try {
        dbRef.current = await abrirDB();

        // Limpiar datos antiguos al iniciar
        const eliminados = await limpiarLecturasAntiguas(
          dbRef.current,
          HORAS_RETENCION_LOCAL
        );
        if (eliminados > 0) {
          console.log(`[Historial] Limpiados ${eliminados} registros antiguos`);
        }

        // Obtener estad√≠sticas
        const stats = await obtenerEstadisticas(dbRef.current);
        setEstadisticas(stats);

        // Marcar como lista
        setDbLista(true);

      } catch (err) {
        console.error("[Historial] Error inicializando IndexedDB:", err);
      }
    };

    init();
  }, []);

  /**
   * Guarda una lectura en IndexedDB (llamado desde el polling)
   */
  const guardarLecturaLocal = useCallback(
    async (alimentadorId, registradorId, zona, lectura) => {
      if (!dbRef.current) return;

      try {
        await guardarLectura(dbRef.current, {
          alimentadorId,
          registradorId,
          zona,
          timestamp: lectura.timestamp || Date.now(),
          valores: lectura.valores,
          indiceInicial: lectura.indice_inicial ?? lectura.indiceInicial ?? 0,
          exito: lectura.exito !== false,
        });
      } catch (err) {
        // No logueamos errores de guardado para no saturar la consola
        // ya que el polling es frecuente
      }
    },
    []
  );

  /**
   * Consulta datos remotos y los cachea en IndexedDB
   * @returns {Array} Datos remotos ya normalizados
   */
  const consultarYCachearRemoto = useCallback(
    async (alimentadorId, registradorId, zona, desde, hasta) => {
      // Consultar al backend
      const datosRemotos = await obtenerLecturasHistoricasPorRegistrador(
        registradorId,
        new Date(desde).toISOString(),
        new Date(hasta).toISOString()
      );

      if (!datosRemotos || datosRemotos.length === 0) {
        return [];
      }

      // Cachear los datos remotos antes de devolverlos
      // Esto asegura que consultas posteriores m√°s cortas encuentren los datos en local
      if (dbRef.current) {
        try {
          const guardadas = await cachearLecturasRemotas(
            dbRef.current,
            alimentadorId,
            registradorId,
            zona,
            datosRemotos
          );
          console.log("[Historial] CACHEO COMPLETADO:", {
            alimentadorId,
            registradorId,
            zona,
            lecturasRecibidas: datosRemotos.length,
            lecturasGuardadas: guardadas,
            rangoGuardado: datosRemotos.length > 0 ? {
              desde: new Date(Math.min(...datosRemotos.map(d =>
                typeof d.timestamp === 'string' ? new Date(d.timestamp).getTime() : d.timestamp
              ))).toISOString(),
              hasta: new Date(Math.max(...datosRemotos.map(d =>
                typeof d.timestamp === 'string' ? new Date(d.timestamp).getTime() : d.timestamp
              ))).toISOString()
            } : null
          });
        } catch (err) {
          console.error("[Historial] Error en cacheo:", err);
        }
      }

      // Normalizar timestamps a milisegundos para consistencia
      return datosRemotos.map((l) => ({
        ...l,
        timestamp:
          typeof l.timestamp === "string"
            ? new Date(l.timestamp).getTime()
            : l.timestamp,
        indiceInicial: l.indice_inicial ?? l.indiceInicial ?? 0,
      }));
    },
    []
  );

  /**
   * Obtiene datos para el gr√°fico (l√≥gica h√≠brida con cache inteligente)
   *
   * Estrategia:
   * - Si precargaCompleta = true, SIEMPRE usar solo local (sin verificaci√≥n de cobertura)
   * - Si no hay precarga completa:
   *   1. Intentar local primero
   *   2. Si local est√° vac√≠o o incompleto, ir a remoto
   *   3. Cachear datos remotos para futuras consultas
   *
   * @param {boolean} forzarSoloLocal - Si true, fuerza usar solo datos locales sin ir a remoto
   */
  const obtenerDatosGrafico = useCallback(
    async (alimentadorId, registradorId, zona, desde, hasta, forzarSoloLocal = false) => {
      setCargando(true);
      setError(null);

      try {
        const ahora = Date.now();
        // A√±adir margen al l√≠mite para evitar edge cases
        // cuando el usuario selecciona exactamente 48h
        const limiteLocal = ahora - (HORAS_RETENCION_LOCAL * 60 * 60 * 1000) - MARGEN_LIMITE_LOCAL_MS;

        // Calcular si el rango solicitado est√° dentro de las 48h de retenci√≥n local
        const rangoSolicitadoMs = hasta - desde;
        const rangoMaximoLocalMs = HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
        const rangoExcede48h = rangoSolicitadoMs > rangoMaximoLocalMs;

        // MODO PRECARGA COMPLETA: usar SOLO datos locales, pero solo si el rango es ‚â§ 48h
        // Para rangos > 48h, SIEMPRE ir a remoto
        if (forzarSoloLocal && !rangoExcede48h) {
          let datosLocales = [];
          if (dbRef.current) {
            datosLocales = await obtenerLecturasRango(
              dbRef.current,
              alimentadorId,
              registradorId,
              zona,
              desde,
              hasta
            );
          }

          console.log("[Historial] MODO SOLO LOCAL (precarga completa):", {
            alimentadorId,
            registradorId,
            zona,
            rangoBuscado: {
              desde: new Date(desde).toISOString(),
              hasta: new Date(hasta).toISOString(),
              horasSolicitadas: rangoSolicitadoMs / (1000 * 60 * 60)
            },
            datosEncontrados: datosLocales.length,
          });

          return { datos: datosLocales, fuente: "local" };
        }

        // Para rangos > 48h, ir directo a remoto
        if (rangoExcede48h) {
          console.log("[Historial] Rango excede 48h, consultando remoto:", {
            horasSolicitadas: rangoSolicitadoMs / (1000 * 60 * 60),
          });

          const datosRemotos = await consultarYCachearRemoto(
            alimentadorId,
            registradorId,
            zona,
            desde,
            hasta
          );
          return { datos: datosRemotos, fuente: "remoto" };
        }

        // MODO NORMAL (h√≠brido): verificar cobertura y complementar con remoto si es necesario

        // Caso 1: Todo el rango est√° dentro del periodo local (48h + margen)
        if (desde >= limiteLocal) {
          // Intentar obtener de local si est√° disponible
          let datosLocales = [];
          if (dbRef.current) {
            datosLocales = await obtenerLecturasRango(
              dbRef.current,
              alimentadorId,
              registradorId,
              zona,
              desde,
              hasta
            );
          }

          console.log("[Historial] CONSULTA LOCAL:", {
            alimentadorId,
            registradorId,
            zona,
            rangoBuscado: {
              desde: new Date(desde).toISOString(),
              hasta: new Date(hasta).toISOString(),
              horasSolicitadas: (hasta - desde) / (1000 * 60 * 60)
            },
            datosEncontrados: datosLocales.length,
            rangoEncontrado: datosLocales.length > 0 ? {
              primero: new Date(Math.min(...datosLocales.map(d => d.timestamp))).toISOString(),
              ultimo: new Date(Math.max(...datosLocales.map(d => d.timestamp))).toISOString()
            } : null
          });

          // Verificar si los datos locales cubren el rango solicitado
          if (datosLocales.length > 0) {
            const primerTimestamp = Math.min(...datosLocales.map((d) => d.timestamp));

            // Calcular cu√°nto tiempo de datos tenemos vs cu√°nto pedimos
            const rangoSolicitadoMs = hasta - desde;
            const rangoCubiertoMs = hasta - primerTimestamp;
            const porcentajeCubierto = rangoCubiertoMs / rangoSolicitadoMs;

            console.log("[Historial] COBERTURA:", {
              rangoSolicitadoHoras: rangoSolicitadoMs / (1000 * 60 * 60),
              rangoCubiertoHoras: rangoCubiertoMs / (1000 * 60 * 60),
              porcentaje: (porcentajeCubierto * 100).toFixed(1) + "%",
              decision: porcentajeCubierto < UMBRAL_COBERTURA_REMOTO ? "IR A REMOTO" : "USAR LOCAL"
            });

            // Si cubrimos menos del umbral, consultar remoto para completar
            if (porcentajeCubierto < UMBRAL_COBERTURA_REMOTO) {
              const datosRemotos = await consultarYCachearRemoto(
                alimentadorId,
                registradorId,
                zona,
                desde,
                hasta
              );

              // Combinar remotos + locales y deduplicar
              const mapaTimestamps = new Map();
              for (const dato of datosRemotos) {
                mapaTimestamps.set(dato.timestamp, dato);
              }
              for (const dato of datosLocales) {
                mapaTimestamps.set(dato.timestamp, dato);
              }
              const datosCombinados = Array.from(mapaTimestamps.values());
              datosCombinados.sort((a, b) => a.timestamp - b.timestamp);

              return { datos: datosCombinados, fuente: "mixto" };
            }

            return { datos: datosLocales, fuente: "local" };
          }

          // FALLBACK: Si no hay datos locales o IndexedDB no disponible, consultar remoto
          const datosRemotos = await consultarYCachearRemoto(
            alimentadorId,
            registradorId,
            zona,
            desde,
            hasta
          );
          return { datos: datosRemotos, fuente: "remoto" };
        }

        // Caso 2: Todo el rango est√° fuera del periodo local (>48h atr√°s)
        if (hasta < limiteLocal) {
          // Primero intentar local (por si ya cacheamos antes)
          let datosLocales = [];
          if (dbRef.current) {
            datosLocales = await obtenerLecturasRango(
              dbRef.current,
              alimentadorId,
              registradorId,
              zona,
              desde,
              hasta
            );
          }

          // Si hay datos locales (cacheados previamente), usarlos
          if (datosLocales.length > 0) {
            return { datos: datosLocales, fuente: "local" };
          }

          // Si no, ir a remoto y cachear
          const datosRemotos = await consultarYCachearRemoto(
            alimentadorId,
            registradorId,
            zona,
            desde,
            hasta
          );
          return { datos: datosRemotos, fuente: "remoto" };
        }

        // Caso 3: Rango mixto (parte antigua, parte reciente)
        // Primero intentar obtener TODO desde local (por si ya cacheamos)
        let datosLocalesCompletos = [];
        if (dbRef.current) {
          datosLocalesCompletos = await obtenerLecturasRango(
            dbRef.current,
            alimentadorId,
            registradorId,
            zona,
            desde,
            hasta
          );
        }

        // Si hay suficientes datos locales, usarlos
        // (Heur√≠stica: si hay al menos algunos puntos, probablemente tenemos todo)
        if (datosLocalesCompletos.length > 0) {
          // Verificar si cubrimos el rango consultando el primer timestamp
          const primerTimestamp = Math.min(...datosLocalesCompletos.map((d) => d.timestamp));

          // Si el primer dato est√° cerca del inicio del rango (dentro de 5 min), asumir completo
          if (primerTimestamp <= desde + 5 * 60 * 1000) {
            return { datos: datosLocalesCompletos, fuente: "local" };
          }
        }

        // Necesitamos combinar: remoto para la parte antigua + local para reciente
        const datosRemotosAntiguos = await consultarYCachearRemoto(
          alimentadorId,
          registradorId,
          zona,
          desde,
          limiteLocal
        );

        // Obtener datos locales frescos (desde el l√≠mite hasta ahora)
        let datosLocalesRecientes = [];
        if (dbRef.current) {
          datosLocalesRecientes = await obtenerLecturasRango(
            dbRef.current,
            alimentadorId,
            registradorId,
            zona,
            limiteLocal,
            hasta
          );
        }

        // Si no hay datos locales recientes, intentar remoto tambi√©n para esa parte
        if (datosLocalesRecientes.length === 0) {
          const datosRemotosRecientes = await consultarYCachearRemoto(
            alimentadorId,
            registradorId,
            zona,
            limiteLocal,
            hasta
          );
          datosLocalesRecientes = datosRemotosRecientes;
        }

        // Combinar y deduplicar por timestamp
        const mapaTimestamps = new Map();

        // Primero agregar remotos antiguos
        for (const dato of datosRemotosAntiguos) {
          mapaTimestamps.set(dato.timestamp, dato);
        }

        // Luego agregar locales recientes (sobrescriben si hay duplicados)
        for (const dato of datosLocalesRecientes) {
          mapaTimestamps.set(dato.timestamp, dato);
        }

        // Convertir a array y ordenar
        const datosCombinados = Array.from(mapaTimestamps.values());
        datosCombinados.sort((a, b) => a.timestamp - b.timestamp);

        return { datos: datosCombinados, fuente: "mixto" };
      } catch (err) {
        console.error("[Historial] Error obteniendo datos:", err);
        setError(err.message);
        return { datos: [], fuente: "error" };
      } finally {
        setCargando(false);
      }
    },
    [consultarYCachearRemoto]
  );

  /**
   * Verifica si ya hay datos suficientes y recientes en cache para un registrador/zona
   * @returns {Promise<boolean>} true si el cache ya tiene datos suficientes y recientes
   */
  const verificarCacheExistente = useCallback(
    async (alimentadorId, registradorId, zona) => {
      if (!dbRef.current || !registradorId) return false;

      const ahora = Date.now();
      const desde = ahora - HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
      const hasta = ahora;

      try {
        const datosLocales = await obtenerLecturasRango(
          dbRef.current,
          alimentadorId,
          registradorId,
          zona,
          desde,
          hasta
        );

        if (datosLocales.length === 0) return false;

        // Verificar cobertura temporal
        const primerTimestamp = Math.min(...datosLocales.map((d) => d.timestamp));
        const ultimoTimestamp = Math.max(...datosLocales.map((d) => d.timestamp));
        const rangoSolicitadoMs = hasta - desde;
        const rangoCubiertoMs = hasta - primerTimestamp;
        const porcentajeCubierto = rangoCubiertoMs / rangoSolicitadoMs;

        // Verificar antig√ºedad del √∫ltimo dato
        const antiguedadUltimoDatoMs = ahora - ultimoTimestamp;
        const maxAntiguedadMs = MAX_ANTIGUEDAD_CACHE_MINUTOS * 60 * 1000;
        const datosRecientes = antiguedadUltimoDatoMs <= maxAntiguedadMs;

        // El cache es v√°lido si cubre el porcentaje requerido Y los datos son recientes
        const coberturaOK = porcentajeCubierto >= UMBRAL_COBERTURA_CACHE;
        const cacheValido = coberturaOK && datosRecientes;

        console.log(`[Historial] Cache existente para ${zona}:`, {
          registradorId,
          datosEncontrados: datosLocales.length,
          porcentajeCubierto: (porcentajeCubierto * 100).toFixed(1) + "%",
          antiguedadUltimoDato: Math.round(antiguedadUltimoDatoMs / 60000) + " min",
          maxAntiguedadPermitida: MAX_ANTIGUEDAD_CACHE_MINUTOS + " min",
          datosRecientes,
          cacheValido,
        });

        return cacheValido;
      } catch (err) {
        console.error("[Historial] Error verificando cache:", err);
        return false;
      }
    },
    []
  );

  /**
   * Precarga las √∫ltimas 48h de datos para ambas zonas
   * Se ejecuta de forma independiente al seleccionar el rango
   * Verifica primero si ya hay datos en cache para evitar recargas innecesarias
   *
   * IMPORTANTE: Cuando ambas zonas usan el mismo registrador pero diferentes
   * √≠ndices de registro, igual se debe guardar en cache para AMBAS zonas,
   * porque IndexedDB indexa por [alimentadorId, zona, timestamp]
   *
   * @param {string} alimentadorId - ID del alimentador
   * @param {string} registradorIdSuperior - ID del registrador de zona superior
   * @param {string} registradorIdInferior - ID del registrador de zona inferior
   * @returns {Promise<boolean>} - true si la precarga fue exitosa
   */
  const precargar48h = useCallback(
    async (alimentadorId, registradorIdSuperior, registradorIdInferior) => {
      // Resetear estado
      setPrecargaProgreso(0);
      setPrecargaCompleta(false);
      setPrecargando(true);
      setDatosDeBD(false);
      precargaAbortRef.current = false;

      const ahora = Date.now();
      const desde = ahora - HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
      const hasta = ahora;

      // Verificar si ya hay cache v√°lido para las zonas
      const cacheSuperiorOK = await verificarCacheExistente(
        alimentadorId,
        registradorIdSuperior,
        "superior"
      );
      const cacheInferiorOK = await verificarCacheExistente(
        alimentadorId,
        registradorIdInferior,
        "inferior"
      );

      // Si ambas zonas tienen cache v√°lido, no hacer nada
      if (cacheSuperiorOK && cacheInferiorOK) {
        console.log("[Historial] Cache ya v√°lido para ambas zonas, omitiendo precarga");
        setPrecargaProgreso(100);
        setPrecargaCompleta(true);
        setPrecargando(false);
        return true;
      }

      // Determinar qu√© zonas cargar y de qu√© registrador
      // IMPORTANTE: Si ambas zonas usan el mismo registrador, solo consultamos
      // una vez pero guardamos para AMBAS zonas
      const mismoRegistrador = registradorIdSuperior === registradorIdInferior;

      // Lista de tareas de consulta a la API (evitar duplicados cuando mismo registrador)
      const tareasConsulta = [];

      if (registradorIdSuperior && !cacheSuperiorOK) {
        tareasConsulta.push({ registradorId: registradorIdSuperior, zonas: ["superior"] });
      }

      if (registradorIdInferior && !cacheInferiorOK) {
        if (mismoRegistrador) {
          // Mismo registrador: agregar zona inferior a la consulta existente o crear nueva
          const consultaExistente = tareasConsulta.find(t => t.registradorId === registradorIdInferior);
          if (consultaExistente) {
            consultaExistente.zonas.push("inferior");
          } else {
            // Superior ya tiene cache, pero inferior no - consultar y guardar solo para inferior
            tareasConsulta.push({ registradorId: registradorIdInferior, zonas: ["inferior"] });
          }
        } else {
          // Diferente registrador: consulta independiente
          tareasConsulta.push({ registradorId: registradorIdInferior, zonas: ["inferior"] });
        }
      }

      if (tareasConsulta.length === 0) {
        console.log("[Historial] No hay registradores configurados para precargar");
        setPrecargando(false);
        setPrecargaCompleta(true);
        setPrecargaProgreso(100);
        return true;
      }

      // Calcular total de operaciones para el progreso
      const totalZonas = tareasConsulta.reduce((sum, t) => sum + t.zonas.length, 0);
      const progresoPorZona = 100 / totalZonas;
      let progresoActual = 0;

      try {
        for (const tarea of tareasConsulta) {
          if (precargaAbortRef.current) {
            console.log("[Historial] Precarga abortada");
            setPrecargando(false);
            return false;
          }

          console.log(`[Historial] Precargando registrador ${tarea.registradorId} para zonas: ${tarea.zonas.join(", ")}...`);

          // Actualizar progreso al iniciar
          setPrecargaProgreso(Math.round(progresoActual + progresoPorZona * 0.1));

          // Consultar datos remotos (una sola vez por registrador)
          const datosRemotos = await obtenerLecturasHistoricasPorRegistrador(
            tarea.registradorId,
            new Date(desde).toISOString(),
            new Date(hasta).toISOString()
          );

          if (precargaAbortRef.current) {
            setPrecargando(false);
            return false;
          }

          // Actualizar progreso al 50%
          setPrecargaProgreso(Math.round(progresoActual + (progresoPorZona * tarea.zonas.length) * 0.5));

          if (datosRemotos && datosRemotos.length > 0 && dbRef.current) {
            // Marcar que los datos vinieron de la BD
            setDatosDeBD(true);
            // Cachear datos para CADA zona que lo necesita
            for (const zona of tarea.zonas) {
              const guardadas = await cachearLecturasRemotas(
                dbRef.current,
                alimentadorId,
                tarea.registradorId,
                zona,
                datosRemotos
              );

              console.log(`[Historial] Precarga ${zona} completada:`, {
                registradorId: tarea.registradorId,
                lecturasRecibidas: datosRemotos.length,
                lecturasGuardadas: guardadas,
              });

              progresoActual += progresoPorZona;
              setPrecargaProgreso(Math.round(progresoActual));
            }
          } else {
            console.log(`[Historial] No hay datos remotos para registrador ${tarea.registradorId}`);
            progresoActual += progresoPorZona * tarea.zonas.length;
            setPrecargaProgreso(Math.round(progresoActual));
          }
        }

        // Completado
        setPrecargaProgreso(100);
        setPrecargaCompleta(true);
        setPrecargando(false);

        console.log("[Historial] Precarga de 48h completada exitosamente");
        return true;
      } catch (err) {
        console.error("[Historial] Error en precarga:", err);
        setPrecargando(false);
        setPrecargaProgreso(0);
        // A√∫n as√≠ marcar como completa para que el componente pueda mostrar "sin datos"
        // en lugar de quedarse cargando infinitamente
        setPrecargaCompleta(true);
        return false;
      }
    },
    [verificarCacheExistente]
  );

  /**
   * Cancela la precarga en curso
   */
  const cancelarPrecarga = useCallback(() => {
    precargaAbortRef.current = true;
  }, []);

  /**
   * Resetea el estado de precarga (al cerrar modal)
   */
  const resetearPrecarga = useCallback(() => {
    precargaAbortRef.current = true;
    setPrecargaProgreso(0);
    setPrecargaCompleta(false);
    setPrecargando(false);
    setDatosDeBD(false);
  }, []);

  /**
   * Precarga datos para todos los alimentadores de un puesto
   * Se llama una sola vez cuando se abre cualquier ventana de historial del puesto
   * Beneficia a todas las dem√°s cards del mismo puesto
   *
   * @param {Array} alimentadores - Lista de alimentadores del puesto
   * @returns {Promise<boolean>} - true si la precarga fue exitosa
   */
  const precargarPuesto = useCallback(
    async (alimentadores) => {
      if (!alimentadores || alimentadores.length === 0) return true;

      // Resetear estado
      setPrecargaProgreso(0);
      setPrecargaCompleta(false);
      setPrecargando(true);
      setDatosDeBD(false);
      precargaAbortRef.current = false;

      const ahora = Date.now();
      const desde = ahora - HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
      const hasta = ahora;

      // Recopilar todas las tareas de precarga necesarias
      const tareasPendientes = [];

      for (const alimentador of alimentadores) {
        if (precargaAbortRef.current) break;

        const cardDesign = alimentador.card_design || {};

        // Obtener registradores de ambas zonas
        const regSuperior = cardDesign.superior?.registrador_id || alimentador.registrador_id;
        const regInferior = cardDesign.inferior?.registrador_id || alimentador.registrador_id;

        // Verificar cache para zona superior
        if (regSuperior) {
          const cacheSuperiorOK = await verificarCacheExistente(alimentador.id, regSuperior, "superior");
          if (!cacheSuperiorOK) {
            tareasPendientes.push({
              alimentadorId: alimentador.id,
              registradorId: regSuperior,
              zona: "superior",
            });
          }
        }

        // Verificar cache para zona inferior (si es diferente registrador)
        if (regInferior && regInferior !== regSuperior) {
          const cacheInferiorOK = await verificarCacheExistente(alimentador.id, regInferior, "inferior");
          if (!cacheInferiorOK) {
            tareasPendientes.push({
              alimentadorId: alimentador.id,
              registradorId: regInferior,
              zona: "inferior",
            });
          }
        } else if (regInferior && regInferior === regSuperior) {
          // Mismo registrador pero verificar si zona inferior necesita datos
          const cacheInferiorOK = await verificarCacheExistente(alimentador.id, regInferior, "inferior");
          if (!cacheInferiorOK) {
            tareasPendientes.push({
              alimentadorId: alimentador.id,
              registradorId: regInferior,
              zona: "inferior",
            });
          }
        }
      }

      // Si no hay tareas pendientes, ya est√° todo cacheado y reciente
      if (tareasPendientes.length === 0) {
        console.log("[Historial] Cache del puesto ya est√° actualizado");
        setPrecargaProgreso(100);
        setPrecargaCompleta(true);
        setPrecargando(false);
        return true;
      }

      console.log(`[Historial] Precargando puesto: ${tareasPendientes.length} tareas pendientes`);

      // Agrupar tareas por registrador para evitar consultas duplicadas
      const tareasPorRegistrador = {};
      for (const tarea of tareasPendientes) {
        if (!tareasPorRegistrador[tarea.registradorId]) {
          tareasPorRegistrador[tarea.registradorId] = [];
        }
        tareasPorRegistrador[tarea.registradorId].push(tarea);
      }

      const totalRegistradores = Object.keys(tareasPorRegistrador).length;
      let registradoresProcesados = 0;

      try {
        for (const [registradorId, tareas] of Object.entries(tareasPorRegistrador)) {
          if (precargaAbortRef.current) {
            console.log("[Historial] Precarga de puesto abortada");
            setPrecargando(false);
            return false;
          }

          // Consultar datos remotos una vez por registrador
          const datosRemotos = await obtenerLecturasHistoricasPorRegistrador(
            registradorId,
            new Date(desde).toISOString(),
            new Date(hasta).toISOString()
          );

          if (datosRemotos && datosRemotos.length > 0 && dbRef.current) {
            // Marcar que los datos vinieron de la BD
            setDatosDeBD(true);
            // Cachear para todas las zonas/alimentadores que usan este registrador
            for (const tarea of tareas) {
              await cachearLecturasRemotas(
                dbRef.current,
                tarea.alimentadorId,
                tarea.registradorId,
                tarea.zona,
                datosRemotos
              );
            }
          }

          registradoresProcesados++;
          setPrecargaProgreso(Math.round((registradoresProcesados / totalRegistradores) * 100));
        }

        setPrecargaProgreso(100);
        setPrecargaCompleta(true);
        setPrecargando(false);
        console.log("[Historial] Precarga de puesto completada");
        return true;
      } catch (err) {
        console.error("[Historial] Error en precarga de puesto:", err);
        setPrecargando(false);
        setPrecargaProgreso(0);
        // A√∫n as√≠ marcar como completa para que el componente pueda mostrar "sin datos"
        // en lugar de quedarse cargando infinitamente
        setPrecargaCompleta(true);
        return false;
      }
    },
    [verificarCacheExistente]
  );

  /**
   * Limpia lecturas antiguas manualmente
   */
  const limpiarHistorial = useCallback(async () => {
    if (!dbRef.current) return 0;

    try {
      const eliminados = await limpiarLecturasAntiguas(
        dbRef.current,
        HORAS_RETENCION_LOCAL
      );
      const stats = await obtenerEstadisticas(dbRef.current);
      setEstadisticas(stats);
      return eliminados;
    } catch (err) {
      console.error("[Historial] Error limpiando historial:", err);
      return 0;
    }
  }, []);

  /**
   * Limpia TODO el cache local (para testing o reset completo)
   * @returns {Promise<boolean>} true si se limpi√≥ correctamente
   */
  const limpiarCacheCompleto = useCallback(async () => {
    if (!dbRef.current) return false;

    try {
      await limpiarTodo(dbRef.current);
      const stats = await obtenerEstadisticas(dbRef.current);
      setEstadisticas(stats);
      // Resetear estado de precarga
      setPrecargaProgreso(0);
      setPrecargaCompleta(false);
      setDatosDeBD(false);
      console.log("[Historial] Cache local limpiado completamente");
      return true;
    } catch (err) {
      console.error("[Historial] Error limpiando cache completo:", err);
      return false;
    }
  }, []);

  /**
   * Actualiza estad√≠sticas
   */
  const actualizarEstadisticas = useCallback(async () => {
    if (!dbRef.current) return;

    try {
      const stats = await obtenerEstadisticas(dbRef.current);
      setEstadisticas(stats);
    } catch (err) {
      console.error("[Historial] Error actualizando estad√≠sticas:", err);
    }
  }, []);

  return {
    guardarLecturaLocal,
    obtenerDatosGrafico,
    limpiarHistorial,
    limpiarCacheCompleto,
    actualizarEstadisticas,
    // Precarga 48h
    precargar48h,
    precargarPuesto,
    cancelarPrecarga,
    resetearPrecarga,
    precargaProgreso,
    precargaCompleta,
    precargando,
    datosDeBD, // Indica si los datos fueron descargados de la BD remota
    // Estado general
    dbLista, // Indica cuando IndexedDB est√° lista para usar
    cargando,
    error,
    estadisticas,
    horasRetencion: HORAS_RETENCION_LOCAL,
  };
};

export default useHistorialLocal;

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useMediciones.js ==========
// src/paginas/PaginaAlimentadores/hooks/usarMediciones.js

import { useState, useCallback } from "react";

/**
 * Hook para manejar el estado de registros/mediciones de alimentadores.
 *
 * Este hook gestiona el estado de los registros le√≠dos desde Supabase (via polling)
 * y provee funciones auxiliares para consultar el estado de las mediciones.
 *
 * NOTA: El flujo anterior de lectura directa Modbus (simulado/real con timers internos)
 * fue eliminado. Ahora las lecturas vienen del polling en VistaAlimentadores que
 * consulta la tabla `lecturas` de Supabase.
 */
export const useMediciones = () => {
	// Registros le√≠dos en vivo por alimentador
	// Estructura: { [alimId]: { rele: [{index, address, value}], analizador: [...] } }
	const [registrosEnVivo, setRegistrosEnVivo] = useState({});

	// Timestamps de √∫ltima actualizaci√≥n por alimentador/equipo
	// Estructura: { [alimId]: { rele: timestamp, analizador: timestamp } }
	const [timestampsInicio, setTimestampsInicio] = useState({});

	// Contador de lecturas por alimentador/equipo
	// Estructura: { [alimId]: { rele: number, analizador: number } }
	const [contadorLecturas, setContadorLecturas] = useState({});

	/**
	 * Actualiza los registros de un alimentador.
	 * Usado por el polling de Supabase para cargar nuevas lecturas.
	 *
	 * @param {string} alimId - ID del alimentador.
	 * @param {Object|Function} nuevosDatosOFuncion - Datos nuevos o funci√≥n actualizadora.
	 */
	const actualizarRegistros = useCallback((alimId, nuevosDatosOFuncion) => {
		const ahora = Date.now();

		setRegistrosEnVivo((anteriores) => {
			const registrosAnteriores = anteriores[alimId] || {};
			const nuevosDatos = typeof nuevosDatosOFuncion === 'function'
				? nuevosDatosOFuncion(registrosAnteriores)
				: nuevosDatosOFuncion;

			return {
				...anteriores,
				[alimId]: {
					...registrosAnteriores,
					...nuevosDatos,
				},
			};
		});

		// Actualizar timestamp
		setTimestampsInicio((anteriores) => ({
			...anteriores,
			[alimId]: {
				...(anteriores[alimId] || {}),
				rele: ahora, // Por ahora usamos rele como default
			},
		}));

		// Incrementar contador
		setContadorLecturas((anteriores) => ({
			...anteriores,
			[alimId]: {
				...(anteriores[alimId] || {}),
				rele: (anteriores[alimId]?.rele || 0) + 1,
			},
		}));
	}, []);

	/**
	 * Obtiene los registros de un alimentador y equipo.
	 */
	const obtenerRegistros = useCallback((alimId, equipo) => {
		return registrosEnVivo[alimId]?.[equipo] || [];
	}, [registrosEnVivo]);

	/**
	 * Verifica si un alimentador tiene datos cargados (est√° "midiendo").
	 * En el nuevo flujo, esto indica si hay datos de polling disponibles.
	 */
	const estaMidiendo = useCallback((alimId, equipo) => {
		const registros = registrosEnVivo[alimId]?.[equipo];
		return Array.isArray(registros) && registros.length > 0;
	}, [registrosEnVivo]);

	/**
	 * Obtiene el timestamp de la √∫ltima actualizaci√≥n.
	 */
	const obtenerTimestampInicio = useCallback((alimId, equipo) => {
		return timestampsInicio[alimId]?.[equipo] || null;
	}, [timestampsInicio]);

	/**
	 * Obtiene el contador de lecturas.
	 */
	const obtenerContadorLecturas = useCallback((alimId, equipo) => {
		return contadorLecturas[alimId]?.[equipo] || 0;
	}, [contadorLecturas]);

	/**
	 * Limpia los datos de un alimentador (usado al eliminar).
	 */
	const detenerMedicion = useCallback((alimId, equipo) => {
		// Limpiar registros del equipo
		setRegistrosEnVivo((anteriores) => {
			if (!anteriores[alimId]) return anteriores;

			const nuevo = { ...anteriores };
			if (nuevo[alimId]?.[equipo]) {
				delete nuevo[alimId][equipo];
				if (Object.keys(nuevo[alimId]).length === 0) {
					delete nuevo[alimId];
				}
			}
			return nuevo;
		});

		// Limpiar timestamp
		setTimestampsInicio((anteriores) => {
			if (!anteriores[alimId]) return anteriores;

			const nuevo = { ...anteriores };
			if (nuevo[alimId]?.[equipo]) {
				delete nuevo[alimId][equipo];
				if (Object.keys(nuevo[alimId]).length === 0) {
					delete nuevo[alimId];
				}
			}
			return nuevo;
		});

		// Limpiar contador
		setContadorLecturas((anteriores) => {
			if (!anteriores[alimId]) return anteriores;

			const nuevo = { ...anteriores };
			if (nuevo[alimId]?.[equipo]) {
				delete nuevo[alimId][equipo];
				if (Object.keys(nuevo[alimId]).length === 0) {
					delete nuevo[alimId];
				}
			}
			return nuevo;
		});
	}, []);

	return {
		// Estado
		registrosEnVivo,

		// Funciones
		actualizarRegistros,
		obtenerRegistros,
		estaMidiendo,
		obtenerTimestampInicio,
		obtenerContadorLecturas,
		detenerMedicion,
	};
};

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useModelosRele.js ==========
import { useState, useEffect, useCallback } from "react";
import { CATEGORIAS_PROTECCION } from "../constantes/datosBaseReles";

const STORAGE_KEY_MODELOS = "relaywatch_modelos_rele";
const STORAGE_KEY_CONFIGURACIONES = "relaywatch_configuraciones_rele";

/**
 * Hook para gestionar modelos de rel√© y sus configuraciones.
 * Solo usa datos personalizados del usuario guardados en localStorage.
 * No incluye modelos base precargados.
 */
export const useModelosRele = () => {
  // Estado para modelos del usuario
  const [modelosPersonalizados, setModelosPersonalizados] = useState({});

  // Estado para configuraciones del usuario
  const [configuracionesPersonalizadas, setConfiguracionesPersonalizadas] = useState({});

  // Cargar datos personalizados de localStorage al iniciar
  useEffect(() => {
    try {
      const modelosGuardados = localStorage.getItem(STORAGE_KEY_MODELOS);
      if (modelosGuardados) {
        setModelosPersonalizados(JSON.parse(modelosGuardados));
      }

      const configsGuardadas = localStorage.getItem(STORAGE_KEY_CONFIGURACIONES);
      if (configsGuardadas) {
        setConfiguracionesPersonalizadas(JSON.parse(configsGuardadas));
      }
    } catch (error) {
      console.error("Error al cargar modelos/configuraciones de localStorage:", error);
    }
  }, []);

  // Guardar modelos personalizados en localStorage
  useEffect(() => {
    if (Object.keys(modelosPersonalizados).length > 0) {
      localStorage.setItem(STORAGE_KEY_MODELOS, JSON.stringify(modelosPersonalizados));
    }
  }, [modelosPersonalizados]);

  // Guardar configuraciones personalizadas en localStorage
  useEffect(() => {
    if (Object.keys(configuracionesPersonalizadas).length > 0) {
      localStorage.setItem(STORAGE_KEY_CONFIGURACIONES, JSON.stringify(configuracionesPersonalizadas));
    }
  }, [configuracionesPersonalizadas]);

  // ============================================================================
  // MODELOS (Solo los del usuario)
  // ============================================================================

  const todosLosModelos = modelosPersonalizados;
  const todasLasConfiguraciones = configuracionesPersonalizadas;

  // ============================================================================
  // GETTERS
  // ============================================================================

  /**
   * Obtiene todos los modelos como array
   */
  const getModelos = useCallback(() => {
    return Object.values(todosLosModelos);
  }, [todosLosModelos]);

  /**
   * Obtiene un modelo por ID
   */
  const getModelo = useCallback(
    (modeloId) => {
      return todosLosModelos[modeloId] || null;
    },
    [todosLosModelos]
  );

  /**
   * Obtiene todas las configuraciones como array
   */
  const getConfiguraciones = useCallback(() => {
    return Object.values(todasLasConfiguraciones);
  }, [todasLasConfiguraciones]);

  /**
   * Obtiene una configuraci√≥n por ID
   */
  const getConfiguracion = useCallback(
    (configId) => {
      return todasLasConfiguraciones[configId] || null;
    },
    [todasLasConfiguraciones]
  );

  /**
   * Obtiene configuraciones disponibles para un modelo
   */
  const getConfiguracionesDeModelo = useCallback(
    (modeloId) => {
      const modelo = todosLosModelos[modeloId];
      if (!modelo) return [];

      return modelo.configuraciones
        .map((configId) => todasLasConfiguraciones[configId])
        .filter(Boolean);
    },
    [todosLosModelos, todasLasConfiguraciones]
  );

  /**
   * Obtiene protecciones de una configuraci√≥n
   */
  const getProtecciones = useCallback(
    (configId) => {
      const config = todasLasConfiguraciones[configId];
      if (!config) return [];
      return config.protecciones || [];
    },
    [todasLasConfiguraciones]
  );

  /**
   * Obtiene protecciones agrupadas por categor√≠a
   */
  const getProteccionesAgrupadas = useCallback(
    (configId) => {
      const config = todasLasConfiguraciones[configId];
      if (!config) return {};

      const protecciones = config.protecciones || [];

      return protecciones.reduce((acc, prot) => {
        const categoria = prot.categoria || "otros";
        if (!acc[categoria]) {
          acc[categoria] = {
            ...(CATEGORIAS_PROTECCION[categoria] || { id: categoria, nombre: categoria, icono: "‚öôÔ∏è", color: "#64748b" }),
            protecciones: []
          };
        }
        acc[categoria].protecciones.push(prot);
        return acc;
      }, {});
    },
    [todasLasConfiguraciones]
  );

  /**
   * Verifica si una configuraci√≥n tiene una capacidad espec√≠fica
   */
  const tieneCapacidad = useCallback(
    (configId, capacidad) => {
      const config = todasLasConfiguraciones[configId];
      if (!config) return false;
      return config.capacidades?.[capacidad] === true;
    },
    [todasLasConfiguraciones]
  );

  // ============================================================================
  // CRUD MODELOS
  // ============================================================================

  /**
   * Agrega un nuevo modelo
   */
  const agregarModelo = useCallback((modelo) => {
    if (!modelo.id || !modelo.nombre) {
      throw new Error("El modelo debe tener id y nombre");
    }

    setModelosPersonalizados((prev) => ({
      ...prev,
      [modelo.id]: {
        ...modelo,
        configuraciones: modelo.configuraciones || [],
      },
    }));

    return modelo;
  }, []);

  /**
   * Actualiza un modelo
   */
  const actualizarModelo = useCallback((modeloId, datosActualizados) => {
    setModelosPersonalizados((prev) => {
      if (!prev[modeloId]) {
        throw new Error("Modelo no encontrado");
      }

      return {
        ...prev,
        [modeloId]: {
          ...prev[modeloId],
          ...datosActualizados,
        },
      };
    });
  }, []);

  /**
   * Elimina un modelo
   */
  const eliminarModelo = useCallback((modeloId) => {
    setModelosPersonalizados((prev) => {
      const { [modeloId]: _eliminado, ...resto } = prev;
      return resto;
    });

    // Tambi√©n eliminar configuraciones asociadas
    setConfiguracionesPersonalizadas((prev) => {
      const nuevasConfigs = {};
      for (const [configId, config] of Object.entries(prev)) {
        if (config.modeloId !== modeloId) {
          nuevasConfigs[configId] = config;
        }
      }
      return nuevasConfigs;
    });
  }, []);

  // ============================================================================
  // CRUD CONFIGURACIONES
  // ============================================================================

  /**
   * Agrega una nueva configuraci√≥n
   */
  const agregarConfiguracion = useCallback((configuracion) => {
    if (!configuracion.id || !configuracion.nombre || !configuracion.modeloId) {
      throw new Error("La configuraci√≥n debe tener id, nombre y modeloId");
    }

    setConfiguracionesPersonalizadas((prev) => ({
      ...prev,
      [configuracion.id]: {
        ...configuracion,
        protecciones: configuracion.protecciones || [],
        capacidades: configuracion.capacidades || {},
        registros: configuracion.registros || {},
      },
    }));

    // Agregar la configuraci√≥n al modelo correspondiente
    // Usamos el setter funcional para asegurar que tenemos el estado m√°s reciente
    setModelosPersonalizados((prev) => {
      // Si el modelo existe y la configuraci√≥n no est√° ya en la lista
      if (prev[configuracion.modeloId]) {
        const configuracionesActuales = prev[configuracion.modeloId].configuraciones || [];
        if (!configuracionesActuales.includes(configuracion.id)) {
          return {
            ...prev,
            [configuracion.modeloId]: {
              ...prev[configuracion.modeloId],
              configuraciones: [...configuracionesActuales, configuracion.id],
            },
          };
        }
      }
      return prev;
    });

    return configuracion;
  }, []);

  /**
   * Actualiza una configuraci√≥n
   */
  const actualizarConfiguracion = useCallback((configId, datosActualizados) => {
    setConfiguracionesPersonalizadas((prev) => {
      if (!prev[configId]) {
        throw new Error("Configuraci√≥n no encontrada");
      }

      return {
        ...prev,
        [configId]: {
          ...prev[configId],
          ...datosActualizados,
        },
      };
    });
  }, []);

  /**
   * Elimina una configuraci√≥n
   */
  const eliminarConfiguracion = useCallback((configId) => {
    setConfiguracionesPersonalizadas((prev) => {
      const { [configId]: _eliminada, ...resto } = prev;
      return resto;
    });

    // Remover de la lista de configuraciones del modelo
    setModelosPersonalizados((prev) => {
      const nuevosModelos = {};
      for (const [modeloId, modelo] of Object.entries(prev)) {
        nuevosModelos[modeloId] = {
          ...modelo,
          configuraciones: (modelo.configuraciones || []).filter((id) => id !== configId),
        };
      }
      return nuevosModelos;
    });
  }, []);

  // ============================================================================
  // CRUD PROTECCIONES (dentro de una configuraci√≥n)
  // ============================================================================

  /**
   * Agrega una protecci√≥n a una configuraci√≥n
   */
  const agregarProteccion = useCallback((configId, proteccion) => {
    if (!proteccion.codigo || !proteccion.nombre) {
      throw new Error("La protecci√≥n debe tener c√≥digo y nombre");
    }

    setConfiguracionesPersonalizadas((prev) => {
      if (!prev[configId]) {
        throw new Error("Configuraci√≥n no encontrada");
      }

      const proteccionesActuales = prev[configId].protecciones || [];

      // Verificar que no exista ya
      if (proteccionesActuales.some((p) => p.codigo === proteccion.codigo)) {
        throw new Error("Ya existe una protecci√≥n con ese c√≥digo");
      }

      return {
        ...prev,
        [configId]: {
          ...prev[configId],
          protecciones: [...proteccionesActuales, proteccion],
        },
      };
    });
  }, []);

  /**
   * Actualiza una protecci√≥n en una configuraci√≥n
   */
  const actualizarProteccion = useCallback((configId, codigoProteccion, datosActualizados) => {
    setConfiguracionesPersonalizadas((prev) => {
      if (!prev[configId]) {
        throw new Error("Configuraci√≥n no encontrada");
      }

      const proteccionesActualizadas = (prev[configId].protecciones || []).map((p) =>
        p.codigo === codigoProteccion ? { ...p, ...datosActualizados } : p
      );

      return {
        ...prev,
        [configId]: {
          ...prev[configId],
          protecciones: proteccionesActualizadas,
        },
      };
    });
  }, []);

  /**
   * Elimina una protecci√≥n de una configuraci√≥n
   */
  const eliminarProteccion = useCallback((configId, codigoProteccion) => {
    setConfiguracionesPersonalizadas((prev) => {
      if (!prev[configId]) {
        throw new Error("Configuraci√≥n no encontrada");
      }

      return {
        ...prev,
        [configId]: {
          ...prev[configId],
          protecciones: (prev[configId].protecciones || []).filter(
            (p) => p.codigo !== codigoProteccion
          ),
        },
      };
    });
  }, []);

  // ============================================================================
  // UTILIDADES
  // ============================================================================

  /**
   * Resetea todos los datos (elimina todos los modelos y configuraciones)
   */
  const resetearDatos = useCallback(() => {
    setModelosPersonalizados({});
    setConfiguracionesPersonalizadas({});
    localStorage.removeItem(STORAGE_KEY_MODELOS);
    localStorage.removeItem(STORAGE_KEY_CONFIGURACIONES);
  }, []);

  /**
   * Exporta todos los datos como JSON
   */
  const exportarDatos = useCallback(() => {
    return {
      modelos: modelosPersonalizados,
      configuraciones: configuracionesPersonalizadas,
      exportadoEn: new Date().toISOString(),
    };
  }, [modelosPersonalizados, configuracionesPersonalizadas]);

  /**
   * Importa datos desde JSON
   */
  const importarDatos = useCallback((datos) => {
    if (datos.modelos) {
      setModelosPersonalizados(datos.modelos);
    }
    if (datos.configuraciones) {
      setConfiguracionesPersonalizadas(datos.configuraciones);
    }
  }, []);

  return {
    // Datos
    modelos: todosLosModelos,
    configuraciones: todasLasConfiguraciones,

    // Getters
    getModelos,
    getModelo,
    getConfiguraciones,
    getConfiguracion,
    getConfiguracionesDeModelo,
    getProtecciones,
    getProteccionesAgrupadas,
    tieneCapacidad,

    // CRUD Modelos
    agregarModelo,
    actualizarModelo,
    eliminarModelo,

    // CRUD Configuraciones
    agregarConfiguracion,
    actualizarConfiguracion,
    eliminarConfiguracion,

    // CRUD Protecciones
    agregarProteccion,
    actualizarProteccion,
    eliminarProteccion,

    // Utilidades
    resetearDatos,
    exportarDatos,
    importarDatos,
  };
};

export default useModelosRele;

========== mi-app/src/paginas/PaginaAlimentadores/hooks/usePreferenciasUI.js ==========
// src/paginas/PaginaAlimentadores/hooks/usarPreferenciasUI.js

import { useState, useEffect, useCallback } from "react";
import { CLAVES_STORAGE } from "../constantes/clavesAlmacenamiento";

// Valores por defecto - Gaps horizontales (entre tarjetas)
const GAP_DEFAULT = 10;
const GAP_MIN = 0;
const GAP_MAX = 500;

// Valores por defecto - Gaps verticales (entre filas)
const ROW_GAP_DEFAULT = 40;
const ROW_GAP_MIN = 0;
const ROW_GAP_MAX = 400;

// Valores por defecto - Escala de tarjetas
const ESCALA_DEFAULT = 1.0;
const ESCALA_MIN = 0.5;
const ESCALA_MAX = 2.0;

/**
 * Hook para manejar preferencias de UI:
 * - Espaciado horizontal individual por tarjeta
 * - Espaciado vertical por fila (√≠ndice de fila + puestoId)
 * - Escala de tarjetas (global, por puesto, individual)
 *
 * Persiste autom√°ticamente en localStorage.
 *
 * Gaps horizontales: { "alimId1": 10, "alimId2": 50, ... }
 * Gaps verticales: { "puestoId:rowIndex": 20, ... } (combinaci√≥n puesto+fila como key)
 * Escala global: n√∫mero (ej: 1.0)
 * Escala por puesto: { "puestoId": 0.8, ... }
 * Escala por tarjeta: { "alimId": 1.2, ... }
 * Prioridad: Individual > Por puesto > Global > Default (1.0)
 */
export const usePreferenciasUI = () => {
	// ===== GAPS HORIZONTALES (entre tarjetas) =====
	const [gapsPorTarjeta, setGapsPorTarjetaState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.GAP_TARJETAS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.GAP_TARJETAS, JSON.stringify(gapsPorTarjeta));
	}, [gapsPorTarjeta]);

	const obtenerGap = useCallback((alimId) => {
		const gap = gapsPorTarjeta[alimId];
		return gap !== undefined ? gap : GAP_DEFAULT;
	}, [gapsPorTarjeta]);

	const establecerGap = useCallback((alimId, nuevoGap) => {
		const gapValidado = Math.max(GAP_MIN, Math.min(GAP_MAX, nuevoGap));
		setGapsPorTarjetaState(prev => ({
			...prev,
			[alimId]: gapValidado
		}));
	}, []);

	const resetearGap = useCallback((alimId) => {
		setGapsPorTarjetaState(prev => {
			const nuevo = { ...prev };
			delete nuevo[alimId];
			return nuevo;
		});
	}, []);

	const resetearTodosLosGaps = useCallback(() => {
		setGapsPorTarjetaState({});
	}, []);

	// ===== GAPS VERTICALES (entre filas) =====
	const [gapsPorFila, setGapsPorFilaState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.GAP_FILAS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.GAP_FILAS, JSON.stringify(gapsPorFila));
	}, [gapsPorFila]);

	// Generar clave √∫nica para un gap de fila (combinando puestoId y rowIndex)
	const generarClaveRowGap = (puestoId, rowIndex) => `${puestoId}:${rowIndex}`;

	// Obtener el gap de una fila espec√≠fica en un puesto espec√≠fico
	const obtenerRowGap = useCallback((puestoId, rowIndex) => {
		if (!puestoId) return ROW_GAP_DEFAULT;
		const clave = generarClaveRowGap(puestoId, rowIndex);
		const gap = gapsPorFila[clave];
		return gap !== undefined ? gap : ROW_GAP_DEFAULT;
	}, [gapsPorFila]);

	// Establecer el gap de una fila espec√≠fica en un puesto espec√≠fico
	const establecerRowGap = useCallback((puestoId, rowIndex, nuevoGap) => {
		if (!puestoId) return;
		const clave = generarClaveRowGap(puestoId, rowIndex);
		const gapValidado = Math.max(ROW_GAP_MIN, Math.min(ROW_GAP_MAX, nuevoGap));
		setGapsPorFilaState(prev => ({
			...prev,
			[clave]: gapValidado
		}));
	}, []);

	// Resetear gap de una fila al valor por defecto
	const resetearRowGap = useCallback((puestoId, rowIndex) => {
		if (!puestoId) return;
		const clave = generarClaveRowGap(puestoId, rowIndex);
		setGapsPorFilaState(prev => {
			const nuevo = { ...prev };
			delete nuevo[clave];
			return nuevo;
		});
	}, []);

	// Resetear todos los gaps de filas
	const resetearTodosLosRowGaps = useCallback(() => {
		setGapsPorFilaState({});
	}, []);

	// ===== ESCALA GLOBAL =====
	const [escalaGlobal, setEscalaGlobalState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.ESCALA_GLOBAL);
		if (guardado) {
			const valor = parseFloat(guardado);
			if (!isNaN(valor)) return valor;
		}
		return ESCALA_DEFAULT;
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.ESCALA_GLOBAL, escalaGlobal.toString());
	}, [escalaGlobal]);

	const establecerEscalaGlobal = useCallback((nuevaEscala) => {
		const escalaValidada = Math.max(ESCALA_MIN, Math.min(ESCALA_MAX, nuevaEscala));
		setEscalaGlobalState(escalaValidada);
	}, []);

	const resetearEscalaGlobal = useCallback(() => {
		setEscalaGlobalState(ESCALA_DEFAULT);
	}, []);

	// ===== ESCALA POR PUESTO =====
	const [escalasPorPuesto, setEscalasPorPuestoState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.ESCALA_PUESTOS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.ESCALA_PUESTOS, JSON.stringify(escalasPorPuesto));
	}, [escalasPorPuesto]);

	const obtenerEscalaPuesto = useCallback((puestoId) => {
		if (!puestoId) return null;
		return escalasPorPuesto[puestoId];
	}, [escalasPorPuesto]);

	const establecerEscalaPuesto = useCallback((puestoId, nuevaEscala) => {
		if (!puestoId) return;
		const escalaValidada = Math.max(ESCALA_MIN, Math.min(ESCALA_MAX, nuevaEscala));
		setEscalasPorPuestoState(prev => ({
			...prev,
			[puestoId]: escalaValidada
		}));
	}, []);

	const resetearEscalaPuesto = useCallback((puestoId) => {
		if (!puestoId) return;
		setEscalasPorPuestoState(prev => {
			const nuevo = { ...prev };
			delete nuevo[puestoId];
			return nuevo;
		});
	}, []);

	const resetearTodasLasEscalasPuestos = useCallback(() => {
		setEscalasPorPuestoState({});
	}, []);

	// ===== ESCALA POR TARJETA (individual) =====
	const [escalasPorTarjeta, setEscalasPorTarjetaState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.ESCALA_TARJETAS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.ESCALA_TARJETAS, JSON.stringify(escalasPorTarjeta));
	}, [escalasPorTarjeta]);

	const obtenerEscalaTarjeta = useCallback((alimId) => {
		if (!alimId) return null;
		return escalasPorTarjeta[alimId];
	}, [escalasPorTarjeta]);

	const establecerEscalaTarjeta = useCallback((alimId, nuevaEscala) => {
		if (!alimId) return;
		const escalaValidada = Math.max(ESCALA_MIN, Math.min(ESCALA_MAX, nuevaEscala));
		setEscalasPorTarjetaState(prev => ({
			...prev,
			[alimId]: escalaValidada
		}));
	}, []);

	const resetearEscalaTarjeta = useCallback((alimId) => {
		if (!alimId) return;
		// Guardamos null para indicar "ignorar escala individual (incluso de BD)"
		// Esto permite que la escala del puesto tenga efecto
		setEscalasPorTarjetaState(prev => ({
			...prev,
			[alimId]: null
		}));
	}, []);

	const resetearTodasLasEscalasTarjetas = useCallback(() => {
		setEscalasPorTarjetaState({});
	}, []);

	/**
	 * Obtiene la escala efectiva de una tarjeta considerando la jerarqu√≠a:
	 * Individual > Por puesto > Global > Default
	 * @param {string} alimId - ID del alimentador
	 * @param {string} puestoId - ID del puesto (opcional, para escala por puesto)
	 * @returns {number} Escala efectiva a aplicar
	 */
	const obtenerEscalaEfectiva = useCallback((alimId, puestoId) => {
		// 1. Escala individual (m√°xima prioridad)
		const escalaIndividual = escalasPorTarjeta[alimId];
		if (escalaIndividual !== undefined) return escalaIndividual;

		// 2. Escala por puesto
		if (puestoId) {
			const escalaPuesto = escalasPorPuesto[puestoId];
			if (escalaPuesto !== undefined) return escalaPuesto;
		}

		// 3. Escala global
		if (escalaGlobal !== ESCALA_DEFAULT) return escalaGlobal;

		// 4. Default
		return ESCALA_DEFAULT;
	}, [escalasPorTarjeta, escalasPorPuesto, escalaGlobal]);

	// Resetear todas las escalas
	const resetearTodasLasEscalas = useCallback(() => {
		setEscalaGlobalState(ESCALA_DEFAULT);
		setEscalasPorPuestoState({});
		setEscalasPorTarjetaState({});
	}, []);

	return {
		// Gaps horizontales
		gapsPorTarjeta,
		obtenerGap,
		establecerGap,
		resetearGap,
		resetearTodosLosGaps,
		GAP_MIN,
		GAP_MAX,
		GAP_DEFAULT,
		// Gaps verticales
		gapsPorFila,
		obtenerRowGap,
		establecerRowGap,
		resetearRowGap,
		resetearTodosLosRowGaps,
		ROW_GAP_MIN,
		ROW_GAP_MAX,
		ROW_GAP_DEFAULT,
		// Escala global
		escalaGlobal,
		establecerEscalaGlobal,
		resetearEscalaGlobal,
		// Escala por puesto
		escalasPorPuesto,
		obtenerEscalaPuesto,
		establecerEscalaPuesto,
		resetearEscalaPuesto,
		resetearTodasLasEscalasPuestos,
		// Escala por tarjeta (individual)
		escalasPorTarjeta,
		obtenerEscalaTarjeta,
		establecerEscalaTarjeta,
		resetearEscalaTarjeta,
		resetearTodasLasEscalasTarjetas,
		// Escala efectiva (combina jerarqu√≠a)
		obtenerEscalaEfectiva,
		resetearTodasLasEscalas,
		// Constantes de escala
		ESCALA_MIN,
		ESCALA_MAX,
		ESCALA_DEFAULT,
	};
};

========== mi-app/src/paginas/PaginaAlimentadores/hooks/usePreferenciasVisuales.js ==========
// src/paginas/PaginaAlimentadores/hooks/usePreferenciasVisuales.js
// Hook para manejar preferencias visuales personalizadas por usuario
// Implementa el patr√≥n "User Preferences Override":
// - Creador: guarda en BASE (tablas puestos/alimentadores)
// - Invitado: guarda en preferencias_usuario (solo √©l lo ve)

import { useState, useEffect, useCallback, useMemo } from "react";
import {
  obtenerPreferencias,
  guardarPreferencias,
  actualizarPuesto,
  actualizarAlimentadorAPI,
} from "../../../servicios/apiService";

// Valores por defecto
const DEFAULTS = {
  escalaGlobal: 1.0,
  GAP_DEFAULT: 10,
  ROW_GAP_DEFAULT: 40,
};

/**
 * Hook para manejar preferencias visuales con patr√≥n de override.
 *
 * Flujo de lectura:
 * 1. Carga config BASE de puestos/alimentadores
 * 2. Carga preferencias personales del usuario
 * 3. Hace merge (preferencia personal > base)
 * 4. Limpia preferencias hu√©rfanas
 *
 * Flujo de escritura:
 * - esCreador=true: guarda en BASE (todos ven el cambio)
 * - esCreador=false: guarda en preferencias_usuario (solo √©l lo ve)
 *
 * @param {string} workspaceId - ID del workspace activo
 * @param {boolean} esCreador - Si el usuario es creador del workspace
 * @param {Array} puestos - Lista de puestos con alimentadores (config BASE)
 * @param {Function} recargarPuestos - Funci√≥n para recargar puestos despu√©s de guardar en BASE
 */
export const usePreferenciasVisuales = (workspaceId, esCreador, puestos, recargarPuestos) => {
  // Preferencias personales del usuario (override)
  const [preferenciasUsuario, setPreferenciasUsuario] = useState(null);
  const [cargando, setCargando] = useState(true);
  const [error, setError] = useState(null);
  const [guardando, setGuardando] = useState(false);
  // Flag para evitar que limpiarHuerfanos se ejecute durante/despu√©s de un guardado
  const [saltarLimpiezaHuerfanos, setSaltarLimpiezaHuerfanos] = useState(false);

  // Estructura de preferenciasUsuario:
  // {
  //   escalaGlobal: 1.0,
  //   puestos: {
  //     "uuid-puesto": { color, bg_color, escala, gapsVerticales }
  //   },
  //   alimentadores: {
  //     "uuid-alim": { color, escala, gapHorizontal }
  //   }
  // }

  /**
   * Carga las preferencias del usuario desde la BD
   */
  const cargarPreferencias = useCallback(async () => {
    if (!workspaceId) {
      setPreferenciasUsuario(null);
      setCargando(false);
      return;
    }

    try {
      setCargando(true);
      setError(null);
      const response = await obtenerPreferencias(workspaceId);
      const prefs = response?.preferencias || {};
      setPreferenciasUsuario(prefs);
    } catch (err) {
      console.error("Error cargando preferencias:", err);
      setError(err.message);
      setPreferenciasUsuario({});
    } finally {
      setCargando(false);
    }
  }, [workspaceId, esCreador]);

  // Cargar preferencias cuando cambie el workspace
  // Nota: cargarPreferencias depende de workspaceId, as√≠ que se recrea cuando cambia
  useEffect(() => {
    cargarPreferencias();
  }, [cargarPreferencias]);

  /**
   * Limpia preferencias hu√©rfanas (referencias a puestos/alimentadores que ya no existen)
   * IMPORTANTE: Solo ejecutar cuando puestos ya est√° cargado para evitar borrar todo
   * IMPORTANTE: Solo ejecutar si los puestos pertenecen al workspace actual
   */
  const limpiarHuerfanos = useCallback(async () => {
    // Verificar que hay datos para comparar
    if (!preferenciasUsuario || !puestos || puestos.length === 0) {
      return;
    }

    // Verificar que hay preferencias que limpiar
    const prefsPuestos = preferenciasUsuario.puestos || {};
    const prefsAlimentadores = preferenciasUsuario.alimentadores || {};
    if (Object.keys(prefsPuestos).length === 0 && Object.keys(prefsAlimentadores).length === 0) {
      return;
    }

    // CR√çTICO: Verificar que los puestos pertenecen al workspace actual
    // Si los puestos tienen un workspace_id diferente, NO ejecutar la limpieza
    // porque significar√≠a que estamos comparando preferencias de un workspace
    // con puestos de otro workspace (durante el cambio de workspace)
    const primerPuesto = puestos[0];
    if (primerPuesto && primerPuesto.workspace_id && primerPuesto.workspace_id !== workspaceId) {
      return;
    }

    // Verificar que al menos uno de los puestos con preferencias existe en la lista actual
    // Si NINGUNO existe, probablemente los puestos son de otro workspace (cambio en progreso)
    const idsPuestos = new Set(puestos.map(p => p.id));
    const prefsPuestosIds = Object.keys(prefsPuestos);
    const algunoPuestoExiste = prefsPuestosIds.some(id => idsPuestos.has(id));

    // Si hay preferencias de puestos pero NINGUNO est√° en la lista actual,
    // es probable que estemos en medio de un cambio de workspace
    if (prefsPuestosIds.length > 0 && !algunoPuestoExiste) {
      return;
    }

    const idsAlimentadores = new Set(
      puestos.flatMap(p => (p.alimentadores || []).map(a => a.id))
    );

    let hayHuerfanos = false;
    const nuevasPrefs = { ...preferenciasUsuario };

    // Limpiar puestos hu√©rfanos
    if (nuevasPrefs.puestos) {
      const puestosLimpios = {};
      for (const [id, prefs] of Object.entries(nuevasPrefs.puestos)) {
        if (idsPuestos.has(id)) {
          puestosLimpios[id] = prefs;
        } else {
          hayHuerfanos = true;
        }
      }
      nuevasPrefs.puestos = puestosLimpios;
    }

    // Limpiar alimentadores hu√©rfanos
    if (nuevasPrefs.alimentadores) {
      const alimentadoresLimpios = {};
      for (const [id, prefs] of Object.entries(nuevasPrefs.alimentadores)) {
        if (idsAlimentadores.has(id)) {
          alimentadoresLimpios[id] = prefs;
        } else {
          hayHuerfanos = true;
        }
      }
      nuevasPrefs.alimentadores = alimentadoresLimpios;
    }

    // Si hubo limpieza, guardar en BD
    if (hayHuerfanos) {
      try {
        await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        setPreferenciasUsuario(nuevasPrefs);
      } catch (err) {
        console.error("Error limpiando preferencias hu√©rfanas:", err);
      }
    }
  }, [preferenciasUsuario, puestos, workspaceId]);

  // Ejecutar limpieza de hu√©rfanos cuando cambian los puestos
  // IMPORTANTE: Solo ejecutar si puestos tiene elementos para evitar borrar preferencias v√°lidas
  // IMPORTANTE: Saltar si estamos en medio de un guardado para evitar race conditions
  useEffect(() => {
    if (saltarLimpiezaHuerfanos) {
      return;
    }
    if (!cargando && preferenciasUsuario && puestos && puestos.length > 0) {
      limpiarHuerfanos();
    }
  }, [puestos, cargando, limpiarHuerfanos, saltarLimpiezaHuerfanos]);

  /**
   * Obtiene la configuraci√≥n visual de un puesto (merge base + override)
   */
  const obtenerConfigPuesto = useCallback((puestoId) => {
    const puesto = puestos.find(p => p.id === puestoId);
    if (!puesto) return null;

    // Config base del puesto
    const base = {
      color: puesto.color,
      bg_color: puesto.bg_color || puesto.bgColor,
      escala: puesto.escala,
      gapsVerticales: puesto.gapsVerticales || { "0": DEFAULTS.ROW_GAP_DEFAULT },
    };

    // Override del usuario (si no es creador)
    const override = preferenciasUsuario?.puestos?.[puestoId] || {};

    // Merge: override tiene prioridad
    return {
      ...base,
      ...override,
      // Para gapsVerticales, hacer merge a nivel de keys
      gapsVerticales: {
        ...base.gapsVerticales,
        ...(override.gapsVerticales || {}),
      },
    };
  }, [puestos, preferenciasUsuario, esCreador]);

  /**
   * Obtiene la configuraci√≥n visual de un alimentador (merge base + override)
   */
  const obtenerConfigAlimentador = useCallback((alimentadorId, puestoId) => {
    const puesto = puestos.find(p => p.id === puestoId);
    const alimentador = puesto?.alimentadores?.find(a => a.id === alimentadorId);
    if (!alimentador) return null;

    // Config base del alimentador
    const base = {
      color: alimentador.color,
      escala: alimentador.escala,
      gapHorizontal: alimentador.gapHorizontal ?? DEFAULTS.GAP_DEFAULT,
    };

    // Override del usuario
    const override = preferenciasUsuario?.alimentadores?.[alimentadorId] || {};

    return { ...base, ...override };
  }, [puestos, preferenciasUsuario]);

  /**
   * Obtiene la escala global (override > default)
   */
  const escalaGlobal = useMemo(() => {
    return preferenciasUsuario?.escalaGlobal ?? DEFAULTS.escalaGlobal;
  }, [preferenciasUsuario]);

  /**
   * Guarda una preferencia visual.
   * - Si esCreador: guarda en BASE (tabla puestos/alimentadores)
   * - Si es invitado: guarda en preferencias_usuario
   *
   * @param {string} tipo - 'puesto' | 'alimentador' | 'global'
   * @param {string} id - ID del elemento (null para global)
   * @param {string} campo - Nombre del campo (color, escala, etc.)
   * @param {any} valor - Nuevo valor
   * @param {string} puestoId - ID del puesto (solo para alimentadores)
   */
  const guardarPreferencia = useCallback(async (tipo, id, campo, valor, puestoId = null) => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      setError(null);

      if (esCreador) {
        // === CREADOR: Guardar en BASE ===
        if (tipo === 'puesto') {
          await actualizarPuesto(id, { [campo]: valor });
          // Recargar para reflejar cambios
          if (recargarPuestos) await recargarPuestos();
        } else if (tipo === 'alimentador') {
          // Mapear campos frontend a backend
          const campoBackend = campo === 'gapHorizontal' ? 'gap_horizontal' : campo;
          await actualizarAlimentadorAPI(id, { [campoBackend]: valor });
          if (recargarPuestos) await recargarPuestos();
        } else if (tipo === 'global') {
          // La escala global no tiene tabla base, se guarda en preferencias
          const nuevasPrefs = {
            ...preferenciasUsuario,
            escalaGlobal: valor,
          };
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
          setPreferenciasUsuario(nuevasPrefs);
        }
      } else {
        // === INVITADO: Guardar en preferencias_usuario ===
        // Activar flag para evitar que limpiarHuerfanos se ejecute durante el guardado
        setSaltarLimpiezaHuerfanos(true);

        // Optimistic update: actualizar estado local primero para evitar lag
        const nuevasPrefs = { ...preferenciasUsuario };

        if (tipo === 'puesto') {
          nuevasPrefs.puestos = nuevasPrefs.puestos || {};
          nuevasPrefs.puestos[id] = nuevasPrefs.puestos[id] || {};
          nuevasPrefs.puestos[id][campo] = valor;
        } else if (tipo === 'alimentador') {
          nuevasPrefs.alimentadores = nuevasPrefs.alimentadores || {};
          nuevasPrefs.alimentadores[id] = nuevasPrefs.alimentadores[id] || {};
          nuevasPrefs.alimentadores[id][campo] = valor;
        } else if (tipo === 'global') {
          nuevasPrefs.escalaGlobal = valor;
        }

        setPreferenciasUsuario(nuevasPrefs);
        // Luego guardar en BD (con await para asegurar que se complete)
        try {
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        } catch (err) {
          console.error("Error guardando preferencia:", err);
          setError(err.message);
        } finally {
          setTimeout(() => {
            setSaltarLimpiezaHuerfanos(false);
          }, 500);
        }
      }
    } catch (err) {
      console.error("Error guardando preferencia:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId, esCreador, preferenciasUsuario, recargarPuestos]);

  /**
   * Guarda m√∫ltiples preferencias de un puesto de una vez
   */
  const guardarPreferenciasPuesto = useCallback(async (puestoId, cambios) => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      setError(null);

      if (esCreador) {
        // Mapear campos frontend a backend
        const cambiosBackend = {};
        for (const [campo, valor] of Object.entries(cambios)) {
          if (campo === 'bgColor') {
            cambiosBackend.bg_color = valor;
          } else if (campo === 'gapsVerticales') {
            cambiosBackend.gaps_verticales = valor;
          } else {
            cambiosBackend[campo] = valor;
          }
        }
        await actualizarPuesto(puestoId, cambiosBackend);
        if (recargarPuestos) await recargarPuestos();
      } else {
        // Activar flag para evitar que limpiarHuerfanos se ejecute durante el guardado
        setSaltarLimpiezaHuerfanos(true);

        // Optimistic update: actualizar estado local primero para evitar lag
        const nuevasPrefs = { ...preferenciasUsuario };
        nuevasPrefs.puestos = nuevasPrefs.puestos || {};
        nuevasPrefs.puestos[puestoId] = {
          ...(nuevasPrefs.puestos[puestoId] || {}),
          ...cambios,
        };
        setPreferenciasUsuario(nuevasPrefs);
        // Luego guardar en BD (con await para asegurar que se complete antes de permitir limpiezaHuerfanos)
        try {
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        } catch (err) {
          console.error("Error guardando preferencias puesto:", err);
          setError(err.message);
        } finally {
          // Reactivar limpiezaHuerfanos despu√©s de un delay para evitar race condition
          setTimeout(() => {
            setSaltarLimpiezaHuerfanos(false);
          }, 500);
        }
      }
    } catch (err) {
      console.error("Error guardando preferencias puesto:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId, esCreador, preferenciasUsuario, recargarPuestos]);

  /**
   * Guarda m√∫ltiples preferencias de un alimentador de una vez
   */
  const guardarPreferenciasAlimentador = useCallback(async (alimentadorId, cambios) => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      setError(null);

      if (esCreador) {
        // Mapear campos frontend a backend
        const cambiosBackend = {};
        for (const [campo, valor] of Object.entries(cambios)) {
          if (campo === 'gapHorizontal') {
            cambiosBackend.gap_horizontal = valor;
          } else {
            cambiosBackend[campo] = valor;
          }
        }
        await actualizarAlimentadorAPI(alimentadorId, cambiosBackend);
        if (recargarPuestos) await recargarPuestos();
      } else {
        // Activar flag para evitar que limpiarHuerfanos se ejecute durante el guardado
        setSaltarLimpiezaHuerfanos(true);

        // Optimistic update: actualizar estado local primero para evitar lag
        const nuevasPrefs = { ...preferenciasUsuario };
        nuevasPrefs.alimentadores = nuevasPrefs.alimentadores || {};
        nuevasPrefs.alimentadores[alimentadorId] = {
          ...(nuevasPrefs.alimentadores[alimentadorId] || {}),
          ...cambios,
        };
        setPreferenciasUsuario(nuevasPrefs);
        // Luego guardar en BD (con await para asegurar que se complete)
        try {
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        } catch (err) {
          console.error("Error guardando preferencias alimentador:", err);
          setError(err.message);
        } finally {
          setTimeout(() => {
            setSaltarLimpiezaHuerfanos(false);
          }, 500);
        }
      }
    } catch (err) {
      console.error("Error guardando preferencias alimentador:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId, esCreador, preferenciasUsuario, recargarPuestos]);

  /**
   * Resetea las preferencias personales (vuelve a usar la config base)
   */
  const resetearPreferencias = useCallback(async () => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      await guardarPreferencias(workspaceId, { preferencias: {} });
      setPreferenciasUsuario({});
    } catch (err) {
      console.error("Error reseteando preferencias:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId]);

  /**
   * Obtiene la escala efectiva de un alimentador considerando la jerarqu√≠a:
   * Individual > Por puesto > Global > Default
   */
  const obtenerEscalaEfectiva = useCallback((alimentadorId, puestoId) => {
    // 1. Escala individual del alimentador
    const configAlim = obtenerConfigAlimentador(alimentadorId, puestoId);
    if (configAlim?.escala != null) return configAlim.escala;

    // 2. Escala del puesto
    const configPuesto = obtenerConfigPuesto(puestoId);
    if (configPuesto?.escala != null) return configPuesto.escala;

    // 3. Escala global
    if (escalaGlobal !== DEFAULTS.escalaGlobal) return escalaGlobal;

    // 4. Default
    return DEFAULTS.escalaGlobal;
  }, [obtenerConfigAlimentador, obtenerConfigPuesto, escalaGlobal]);

  /**
   * Verifica si el usuario tiene preferencias personales para este workspace
   */
  const tienePreferenciasPersonales = useMemo(() => {
    if (!preferenciasUsuario) return false;
    return (
      preferenciasUsuario.escalaGlobal != null ||
      Object.keys(preferenciasUsuario.puestos || {}).length > 0 ||
      Object.keys(preferenciasUsuario.alimentadores || {}).length > 0
    );
  }, [preferenciasUsuario]);

  return {
    // Estado
    preferenciasUsuario,
    cargando,
    error,
    guardando,
    esCreador,
    tienePreferenciasPersonales,

    // Getters (con merge base+override)
    obtenerConfigPuesto,
    obtenerConfigAlimentador,
    obtenerEscalaEfectiva,
    escalaGlobal,

    // Setters (guardan en base o preferencias seg√∫n rol)
    guardarPreferencia,
    guardarPreferenciasPuesto,
    guardarPreferenciasAlimentador,
    resetearPreferencias,

    // Utilidades
    cargarPreferencias,
    limpiarHuerfanos,

    // Constantes
    DEFAULTS,
  };
};

========== mi-app/src/paginas/PaginaAlimentadores/hooks/usePuestosSupabase.js ==========
// src/paginas/PaginaAlimentadores/hooks/usarPuestosSupabase.js
// Hook para manejar puestos y alimentadores usando Supabase

import { useState, useEffect, useCallback } from "react";
import {
  obtenerPuestos,
  crearPuesto,
  actualizarPuesto,
  eliminarPuesto as eliminarPuestoAPI,
  reordenarPuestos,
  obtenerAlimentadores,
  crearAlimentador,
  actualizarAlimentadorAPI,
  eliminarAlimentadorAPI,
  reordenarAlimentadores as reordenarAlimentadoresAPI,
} from "../../../servicios/apiService";
import { CLAVES_STORAGE } from "../constantes/clavesAlmacenamiento";
import { COLORES_SISTEMA } from "../constantes/colores";

/**
 * Hook para manejar puestos y alimentadores conectados a Supabase.
 * Requiere un workspace seleccionado para funcionar.
 *
 * @param {number|null} workspaceId - ID del workspace activo
 * @returns {Object} Estado y funciones para trabajar con puestos y alimentadores.
 */
export const usePuestosSupabase = (workspaceId) => {
  const COLOR_FONDO_POR_DEFECTO = "#e5e7eb";

  // Estado: lista de puestos (cada uno con sus alimentadores)
  const [puestos, setPuestos] = useState([]);

  // Estado de carga
  const [cargando, setCargando] = useState(false);

  // Error si ocurre
  const [error, setError] = useState(null);

  // Estado: ID del puesto actualmente seleccionado
  const [puestoSeleccionadoId, setPuestoSeleccionadoId] = useState(() => {
    const idGuardado = localStorage.getItem(CLAVES_STORAGE.PUESTO_SELECCIONADO);
    return idGuardado ? Number(idGuardado) : null;
  });

  // Derivado: objeto completo del puesto seleccionado
  const puestoSeleccionado =
    puestos.find((p) => p.id === puestoSeleccionadoId) ||
    puestos[0] ||
    null;

  /**
   * Transforma un puesto de la DB al formato del frontend
   * Convierte snake_case a camelCase para consistencia
   */
  function transformarPuestoDeDB(puesto) {
    // Parsear gaps_verticales si viene como string JSON
    let gapsVerticales = { "0": 40 };
    if (puesto.gaps_verticales) {
      if (typeof puesto.gaps_verticales === "string") {
        try {
          gapsVerticales = JSON.parse(puesto.gaps_verticales);
        } catch {
          gapsVerticales = { "0": 40 };
        }
      } else {
        gapsVerticales = puesto.gaps_verticales;
      }
    }

    return {
      ...puesto,
      bgColor: puesto.bg_color || "#e5e7eb",
      // Mantener bg_color por compatibilidad con c√≥digo existente
      bg_color: puesto.bg_color || "#e5e7eb",
      // Gaps verticales por fila
      gapsVerticales,
      // Escala del puesto (puede ser null si no est√° definida)
      escala: puesto.escala != null ? puesto.escala : null,
    };
  }

  /**
   * Carga los puestos y sus alimentadores desde el backend
   */
  const cargarPuestos = useCallback(async () => {
    if (!workspaceId) {
      setPuestos([]);
      return;
    }

    try {
      setCargando(true);
      setError(null);

      // Obtener puestos del workspace
      const puestosData = await obtenerPuestos(workspaceId);

      // Para cada puesto, cargar sus alimentadores
      const puestosConAlimentadores = await Promise.all(
        puestosData.map(async (puesto) => {
          try {
            const alimentadores = await obtenerAlimentadores(puesto.id);
            return {
              ...transformarPuestoDeDB(puesto),
              alimentadores: alimentadores.map(transformarAlimentadorDeDB),
            };
          } catch (err) {
            console.error(`Error cargando alimentadores del puesto ${puesto.id}:`, err);
            return { ...transformarPuestoDeDB(puesto), alimentadores: [] };
          }
        })
      );

      setPuestos(puestosConAlimentadores);

      // Auto-seleccionar primer puesto si no hay selecci√≥n v√°lida
      if (puestosConAlimentadores.length > 0) {
        const seleccionValida = puestosConAlimentadores.some(
          (p) => p.id === puestoSeleccionadoId
        );
        if (!seleccionValida) {
          setPuestoSeleccionadoId(puestosConAlimentadores[0].id);
        }
      }
    } catch (err) {
      console.error("Error cargando puestos:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  }, [workspaceId, puestoSeleccionadoId]);

  // Cargar puestos cuando cambie el workspace
  useEffect(() => {
    cargarPuestos();
  }, [workspaceId]);

  // Guardar selecci√≥n de puesto en localStorage
  useEffect(() => {
    if (puestoSeleccionadoId != null) {
      localStorage.setItem(CLAVES_STORAGE.PUESTO_SELECCIONADO, puestoSeleccionadoId.toString());
    } else {
      localStorage.removeItem(CLAVES_STORAGE.PUESTO_SELECCIONADO);
    }
  }, [puestoSeleccionadoId]);

  /**
   * Transforma un alimentador de la DB al formato del frontend
   * Genera el formato con objetos rele/analizador que espera el modal
   * Tambi√©n soporta el nuevo formato con registrador_id, intervalo_consulta_ms y card_design
   */
  function transformarAlimentadorDeDB(alim) {
    // Para campos num√©ricos opcionales: si no hay valor en DB, devolver null/undefined
    // para que el modal muestre el placeholder en lugar de un valor por defecto
    const releConfig = alim.config_rele || {};
    const analizadorConfig = alim.config_analizador || {};

    return {
      id: alim.id,
      nombre: alim.nombre,
      color: alim.color || COLORES_SISTEMA[0],
      tipoDispositivo: alim.tipo || "rele",
      // Gap horizontal a la derecha de esta tarjeta
      gapHorizontal: alim.gap_horizontal != null ? alim.gap_horizontal : 0,
      // Escala individual de la tarjeta (puede ser null si no est√° definida)
      escala: alim.escala != null ? alim.escala : null,

      // === NUEVOS CAMPOS para el modal v2 ===
      registrador_id: alim.registrador_id || null,
      intervalo_consulta_ms: alim.intervalo_consulta_ms || 60000,
      card_design: alim.card_design || {},

      // Formato nuevo que espera el modal
      // Si no hay valor guardado, dejamos null para que se muestre el placeholder
      rele: {
        ip: releConfig.ip || "",
        puerto: releConfig.puerto != null ? releConfig.puerto : null,
        unitId: releConfig.unitId || 1,
        indiceInicial: releConfig.indiceInicial != null ? releConfig.indiceInicial : null,
        cantRegistros: releConfig.cantRegistros != null ? releConfig.cantRegistros : null,
      },
      periodoSegundos: releConfig.periodoLectura != null ? releConfig.periodoLectura : 60,
      analizador: {
        ip: analizadorConfig.ip || "",
        puerto: analizadorConfig.puerto != null ? analizadorConfig.puerto : null,
        unitId: analizadorConfig.unitId || 2,
        indiceInicial: analizadorConfig.indiceInicial != null ? analizadorConfig.indiceInicial : null,
        cantRegistros: analizadorConfig.cantRegistros != null ? analizadorConfig.cantRegistros : null,
        periodoSegundos: analizadorConfig.periodoLectura != null ? analizadorConfig.periodoLectura : 60,
      },
      // Campos legacy para compatibilidad con otras partes del c√≥digo
      ip: releConfig.ip || "",
      puerto: releConfig.puerto != null ? releConfig.puerto : null,
      unitId: releConfig.unitId || 1,
      periodoLectura: releConfig.periodoLectura != null ? releConfig.periodoLectura : 60,
      indiceInicio: releConfig.indiceInicial != null ? releConfig.indiceInicial : null,
      indiceFin: releConfig.indiceInicial != null && releConfig.cantRegistros != null
        ? releConfig.indiceInicial + releConfig.cantRegistros
        : null,
      ipAnalizador: analizadorConfig.ip || "",
      puertoAnalizador: analizadorConfig.puerto != null ? analizadorConfig.puerto : null,
      unitIdAnalizador: analizadorConfig.unitId || 2,
      periodoLecturaAnalizador: analizadorConfig.periodoLectura != null ? analizadorConfig.periodoLectura : 60,
      indiceInicioAnalizador: analizadorConfig.indiceInicial != null ? analizadorConfig.indiceInicial : null,
      indiceFinAnalizador: analizadorConfig.indiceInicial != null && analizadorConfig.cantRegistros != null
        ? analizadorConfig.indiceInicial + analizadorConfig.cantRegistros
        : null,
      mapeoMediciones: alim.mapeo_mediciones || {},
    };
  }

  /**
   * Transforma un alimentador del frontend al formato de la DB
   * Acepta tanto el formato plano (legacy) como el formato con objetos rele/analizador anidados
   * Tambi√©n soporta el nuevo formato con registrador_id, intervalo_consulta_ms y card_design
   */
  function transformarAlimentadorADB(alim) {
    // Base com√∫n para todos los formatos
    const base = {
      nombre: alim.nombre,
      color: alim.color,
    };

    // === NUEVO FORMATO: con registrador_id y card_design ===
    // El nuevo modal env√≠a: { nombre, color, registrador_id, intervalo_consulta_ms, card_design }
    if (alim.registrador_id !== undefined || alim.card_design !== undefined || alim.intervalo_consulta_ms !== undefined) {
      return {
        ...base,
        registrador_id: alim.registrador_id || null,
        intervalo_consulta_ms: alim.intervalo_consulta_ms || 60000,
        card_design: alim.card_design || {},
        gap_horizontal: alim.gapHorizontal != null ? alim.gapHorizontal : 0,
        mapeo_mediciones: alim.mapeoMediciones || {},
      };
    }

    // === FORMATO LEGACY: con objetos rele/analizador ===
    const tieneFormatoNuevo = alim.rele || alim.analizador;

    if (tieneFormatoNuevo) {
      // Formato nuevo del modal: { rele: {...}, analizador: {...} }
      // Preservar null para campos num√©ricos opcionales (puerto, indiceInicial, cantRegistros)
      // para que al cargar se muestren los placeholders en lugar de valores por defecto
      return {
        ...base,
        tipo: alim.tipoDispositivo || "rele",
        gap_horizontal: alim.gapHorizontal != null ? alim.gapHorizontal : 10,
        config_rele: alim.rele ? {
          ip: alim.rele.ip || "",
          puerto: alim.rele.puerto != null ? alim.rele.puerto : null,
          unitId: alim.rele.unitId || 1,
          periodoLectura: alim.periodoSegundos || 60,
          indiceInicial: alim.rele.indiceInicial != null ? alim.rele.indiceInicial : null,
          cantRegistros: alim.rele.cantRegistros != null ? alim.rele.cantRegistros : null,
        } : null,
        config_analizador: alim.analizador ? {
          ip: alim.analizador.ip || "",
          puerto: alim.analizador.puerto != null ? alim.analizador.puerto : null,
          unitId: alim.analizador.unitId || 2,
          periodoLectura: alim.analizador.periodoSegundos || 60,
          indiceInicial: alim.analizador.indiceInicial != null ? alim.analizador.indiceInicial : null,
          cantRegistros: alim.analizador.cantRegistros != null ? alim.analizador.cantRegistros : null,
        } : null,
        mapeo_mediciones: alim.mapeoMediciones || {},
      };
    }

    // Formato plano (legacy)
    // Preservar null para campos num√©ricos opcionales
    return {
      ...base,
      tipo: alim.tipoDispositivo || "rele",
      gap_horizontal: alim.gapHorizontal != null ? alim.gapHorizontal : 10,
      config_rele: {
        ip: alim.ip || "",
        puerto: alim.puerto != null ? alim.puerto : null,
        unitId: alim.unitId || 1,
        periodoLectura: alim.periodoLectura || 60,
        indiceInicial: alim.indiceInicio != null ? alim.indiceInicio : null,
        cantRegistros: alim.indiceFin != null && alim.indiceInicio != null
          ? (alim.indiceFin - alim.indiceInicio)
          : null,
      },
      config_analizador: {
        ip: alim.ipAnalizador || "",
        puerto: alim.puertoAnalizador != null ? alim.puertoAnalizador : null,
        unitId: alim.unitIdAnalizador || 2,
        periodoLectura: alim.periodoLecturaAnalizador || 60,
        indiceInicial: alim.indiceInicioAnalizador != null ? alim.indiceInicioAnalizador : null,
        cantRegistros: alim.indiceFinAnalizador != null && alim.indiceInicioAnalizador != null
          ? (alim.indiceFinAnalizador - alim.indiceInicioAnalizador)
          : null,
      },
      mapeo_mediciones: alim.mapeoMediciones || {},
    };
  }

  /**
   * Agrega un nuevo puesto
   */
  const agregarPuesto = async (nombrePuesto, colorPuesto) => {
    if (!workspaceId) return;

    try {
      setError(null);
      const nuevoPuesto = await crearPuesto(workspaceId, {
        nombre: nombrePuesto.trim(),
        color: colorPuesto || COLORES_SISTEMA[0],
        bg_color: COLOR_FONDO_POR_DEFECTO,
      });

      const puestoConAlimentadores = { ...nuevoPuesto, alimentadores: [] };
      setPuestos((prev) => [...prev, puestoConAlimentadores]);
      setPuestoSeleccionadoId(nuevoPuesto.id);

      return nuevoPuesto;
    } catch (err) {
      console.error("Error creando puesto:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Actualiza la lista completa de puestos (para edici√≥n masiva)
   */
  const actualizarPuestos = async (nuevaListaPuestos) => {
    const sinVacios = nuevaListaPuestos.filter((p) => p.nombre.trim() !== "");

    // Actualizar cada puesto en el backend
    try {
      setError(null);

      for (const puesto of sinVacios) {
        await actualizarPuesto(puesto.id, {
          nombre: puesto.nombre,
          color: puesto.color,
          bg_color: puesto.bgColor || puesto.bg_color,
        });
      }

      setPuestos(sinVacios);

      // Si el seleccionado se elimin√≥, seleccionar el primero
      const seleccionExiste = sinVacios.some((p) => p.id === puestoSeleccionadoId);
      if (!seleccionExiste) {
        setPuestoSeleccionadoId(sinVacios[0]?.id || null);
      }
    } catch (err) {
      console.error("Error actualizando puestos:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Elimina un puesto
   */
  const eliminarPuesto = async (idPuesto) => {
    try {
      setError(null);
      await eliminarPuestoAPI(idPuesto);
      setPuestos((prev) => prev.filter((p) => p.id !== idPuesto));

      // Si se elimin√≥ el seleccionado, seleccionar otro
      if (puestoSeleccionadoId === idPuesto) {
        const restantes = puestos.filter((p) => p.id !== idPuesto);
        setPuestoSeleccionadoId(restantes[0]?.id || null);
      }
    } catch (err) {
      console.error("Error eliminando puesto:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Selecciona un puesto como activo
   */
  const seleccionarPuesto = (idPuesto) => {
    setPuestoSeleccionadoId(idPuesto);
  };

  /**
   * Agrega un alimentador al puesto seleccionado
   */
  const agregarAlimentador = async (datosAlimentador) => {
    if (!puestoSeleccionado) return;

    try {
      setError(null);
      const datosDB = transformarAlimentadorADB(datosAlimentador);
      const nuevoAlimentador = await crearAlimentador(puestoSeleccionado.id, datosDB);

      const alimentadorFrontend = transformarAlimentadorDeDB(nuevoAlimentador);

      setPuestos((prev) =>
        prev.map((p) =>
          p.id === puestoSeleccionado.id
            ? { ...p, alimentadores: [...p.alimentadores, alimentadorFrontend] }
            : p
        )
      );

      return alimentadorFrontend;
    } catch (err) {
      console.error("Error creando alimentador:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Actualiza un alimentador existente
   */
  const actualizarAlimentador = async (idPuesto, idAlimentador, nuevosDatos) => {
    try {
      setError(null);
      const datosDB = transformarAlimentadorADB(nuevosDatos);
      const actualizado = await actualizarAlimentadorAPI(idAlimentador, datosDB);

      const alimentadorFrontend = transformarAlimentadorDeDB(actualizado);

      setPuestos((prev) =>
        prev.map((p) =>
          p.id === idPuesto
            ? {
                ...p,
                alimentadores: p.alimentadores.map((a) =>
                  a.id === idAlimentador ? alimentadorFrontend : a
                ),
              }
            : p
        )
      );

      return alimentadorFrontend;
    } catch (err) {
      console.error("Error actualizando alimentador:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Elimina un alimentador
   */
  const eliminarAlimentador = async (idPuesto, idAlimentador) => {
    try {
      setError(null);
      await eliminarAlimentadorAPI(idAlimentador);

      setPuestos((prev) =>
        prev.map((p) =>
          p.id === idPuesto
            ? { ...p, alimentadores: p.alimentadores.filter((a) => a.id !== idAlimentador) }
            : p
        )
      );
    } catch (err) {
      console.error("Error eliminando alimentador:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Reordena los alimentadores de un puesto (solo estado local).
   * La sincronizaci√≥n con BD se hace al presionar "Guardar cambios".
   */
  const reordenarAlimentadores = (idPuesto, nuevoOrdenAlimentadores) => {
    // Solo actualizar estado local - la sincronizaci√≥n con BD
    // se hace mediante el bot√≥n "Guardar cambios" (draft/publish pattern)
    setPuestos((prev) =>
      prev.map((p) =>
        p.id === idPuesto ? { ...p, alimentadores: nuevoOrdenAlimentadores } : p
      )
    );
  };

  return {
    // Estados
    puestos,
    puestoSeleccionado,
    puestoSeleccionadoId,
    cargando,
    error,

    // Funciones de puestos
    cargarPuestos,
    agregarPuesto,
    eliminarPuesto,
    seleccionarPuesto,
    actualizarPuestos,
    setPuestos,

    // Funciones de alimentadores
    agregarAlimentador,
    actualizarAlimentador,
    eliminarAlimentador,
    reordenarAlimentadores,
  };
};

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useVentanaConfigAgente.js ==========
/**
 * Hook para gestionar el estado de la ventana flotante de configuraci√≥n de agentes
 * Gestiona: abrir, cerrar, minimizar, maximizar, mover, redimensionar
 */

import { useState, useCallback, useRef } from "react";

// Z-index base para la ventana de config agente
const Z_INDEX_BASE = 1100;

export const useVentanaConfigAgente = () => {
  // Estado de la ventana
  const [ventana, setVentana] = useState({
    abierta: false,
    minimizada: false,
    maximizada: false,
    posicion: { x: 100, y: 50 },
    zIndex: Z_INDEX_BASE,
    workspaceId: null,
  });

  // Contador para z-index (para traer al frente)
  const zIndexCounterRef = useRef(Z_INDEX_BASE);

  /**
   * Obtiene el siguiente z-index y lo incrementa
   */
  const getNextZIndex = useCallback(() => {
    zIndexCounterRef.current += 1;
    return zIndexCounterRef.current;
  }, []);

  /**
   * Abre la ventana de configuraci√≥n de agentes
   */
  const abrirVentana = useCallback((workspaceId) => {
    setVentana((prev) => ({
      ...prev,
      abierta: true,
      minimizada: false,
      workspaceId,
      zIndex: getNextZIndex(),
    }));
  }, [getNextZIndex]);

  /**
   * Cierra la ventana
   */
  const cerrarVentana = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      abierta: false,
      minimizada: false,
      maximizada: false,
    }));
  }, []);

  /**
   * Minimiza/restaura la ventana
   */
  const toggleMinimizar = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      minimizada: !prev.minimizada,
    }));
  }, []);

  /**
   * Maximiza/restaura la ventana
   */
  const toggleMaximizar = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      maximizada: !prev.maximizada,
      zIndex: getNextZIndex(),
    }));
  }, [getNextZIndex]);

  /**
   * Trae la ventana al frente (actualiza z-index)
   */
  const enfocarVentana = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      minimizada: false,
      zIndex: getNextZIndex(),
    }));
  }, [getNextZIndex]);

  /**
   * Actualiza la posici√≥n de la ventana (al arrastrar)
   */
  const moverVentana = useCallback((nuevaPosicion) => {
    setVentana((prev) => ({
      ...prev,
      posicion: nuevaPosicion,
    }));
  }, []);

  return {
    ventana,
    abrirVentana,
    cerrarVentana,
    toggleMinimizar,
    toggleMaximizar,
    enfocarVentana,
    moverVentana,
  };
};

export default useVentanaConfigAgente;

========== mi-app/src/paginas/PaginaAlimentadores/hooks/useVentanasHistorial.js ==========
/**
 * Hook para gestionar m√∫ltiples ventanas de historial flotantes
 * Permite abrir, minimizar, maximizar y cerrar ventanas de historial
 * Solo permite una ventana por alimentador
 */

import { useState, useCallback, useRef } from "react";

// Z-index base para ventanas flotantes
const Z_INDEX_BASE = 1000;

export const useVentanasHistorial = () => {
  // Map de ventanas abiertas: { [alimentadorId]: estadoVentana }
  const [ventanas, setVentanas] = useState({});

  // Contador para z-index de ventanas (foco) - useRef para persistir sin re-renders
  const zIndexCounterRef = useRef(Z_INDEX_BASE);

  /**
   * Obtiene el siguiente z-index y lo incrementa
   */
  const getNextZIndex = useCallback(() => {
    zIndexCounterRef.current += 1;
    return zIndexCounterRef.current;
  }, []);

  /**
   * Estado inicial de una ventana
   */
  const crearEstadoVentana = useCallback((alimentador, cardDesign, posicionInicial) => ({
    id: alimentador.id,
    alimentador,
    cardDesign,
    minimizada: false,
    maximizada: false,
    posicion: posicionInicial || { x: 100 + Math.random() * 100, y: 50 + Math.random() * 50 },
    tama√±o: { width: 900, height: 600 },
    zIndex: getNextZIndex(),
  }), [getNextZIndex]);

  /**
   * Abre una ventana de historial para un alimentador
   * Si ya existe, la trae al frente y la restaura si estaba minimizada
   */
  const abrirVentana = useCallback((alimentador, cardDesign) => {
    setVentanas((prev) => {
      // Si ya existe la ventana para este alimentador
      if (prev[alimentador.id]) {
        // Traer al frente y restaurar si estaba minimizada
        return {
          ...prev,
          [alimentador.id]: {
            ...prev[alimentador.id],
            minimizada: false,
            zIndex: getNextZIndex(),
          },
        };
      }

      // Calcular posici√≥n escalonada basada en n√∫mero de ventanas
      const numVentanas = Object.keys(prev).length;
      const posicionInicial = {
        x: 50 + (numVentanas % 5) * 30,
        y: 50 + (numVentanas % 5) * 30,
      };

      // Crear nueva ventana
      return {
        ...prev,
        [alimentador.id]: crearEstadoVentana(alimentador, cardDesign, posicionInicial),
      };
    });
  }, [crearEstadoVentana, getNextZIndex]);

  /**
   * Cierra una ventana de historial
   */
  const cerrarVentana = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      const { [alimentadorId]: _, ...rest } = prev;
      return rest;
    });
  }, []);

  /**
   * Minimiza/restaura una ventana
   */
  const toggleMinimizar = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          minimizada: !prev[alimentadorId].minimizada,
        },
      };
    });
  }, []);

  /**
   * Maximiza/restaura una ventana
   */
  const toggleMaximizar = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          maximizada: !prev[alimentadorId].maximizada,
          zIndex: getNextZIndex(),
        },
      };
    });
  }, [getNextZIndex]);

  /**
   * Trae una ventana al frente (actualiza z-index)
   */
  const enfocarVentana = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          minimizada: false,
          zIndex: getNextZIndex(),
        },
      };
    });
  }, [getNextZIndex]);

  /**
   * Actualiza la posici√≥n de una ventana (al arrastrar)
   */
  const moverVentana = useCallback((alimentadorId, nuevaPosicion) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          posicion: nuevaPosicion,
        },
      };
    });
  }, []);

  /**
   * Actualiza el tama√±o de una ventana
   */
  const redimensionarVentana = useCallback((alimentadorId, nuevoTama√±o) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          tama√±o: nuevoTama√±o,
        },
      };
    });
  }, []);

  /**
   * Verifica si hay una ventana abierta para un alimentador
   */
  const tieneVentanaAbierta = useCallback(
    (alimentadorId) => {
      return !!ventanas[alimentadorId];
    },
    [ventanas]
  );

  /**
   * Obtiene la lista de ventanas como array (para renderizar)
   */
  const listaVentanas = Object.values(ventanas);

  /**
   * Obtiene las ventanas minimizadas (para barra de tareas)
   */
  const ventanasMinimizadas = listaVentanas.filter((v) => v.minimizada);

  return {
    ventanas,
    listaVentanas,
    ventanasMinimizadas,
    abrirVentana,
    cerrarVentana,
    toggleMinimizar,
    toggleMaximizar,
    enfocarVentana,
    moverVentana,
    redimensionarVentana,
    tieneVentanaAbierta,
  };
};

export default useVentanasHistorial;

========== mi-app/src/paginas/PaginaAlimentadores/PaginaAlimentadoresSupabase.jsx ==========
// src/paginas/PaginaAlimentadores/PaginaAlimentadoresSupabase.jsx
// Versi√≥n de la p√°gina que usa Supabase para persistencia

import React from "react";

import { ProveedorConfiguracion } from "./contexto/ContextoConfiguracion";
import { ProveedorAlimentadoresSupabase } from "./contexto/ContextoAlimentadoresSupabase";

import VistaAlimentadores from "./componentes/layout/VistaAlimentadores.jsx";

/**
 * P√°gina de alimentadores conectada a Supabase.
 *
 * Estructura de providers:
 * - ProveedorConfiguracion: maneja los workspaces del usuario
 * - ProveedorAlimentadoresSupabase: maneja puestos y alimentadores con Supabase
 */
const PaginaAlimentadoresSupabase = () => {
  return (
    <ProveedorConfiguracion>
      <ProveedorAlimentadoresSupabase>
        <VistaAlimentadores />
      </ProveedorAlimentadoresSupabase>
    </ProveedorConfiguracion>
  );
};

export default PaginaAlimentadoresSupabase;

========== mi-app/src/paginas/PaginaAlimentadores/utilidades/calculadorRutas.js ==========
// src/paginas/PaginaAlimentadores/utilidades/calculadorRutas.js

/**
 * Utilidades para calcular rutas en el diagrama unifilar.
 * Las chispas viajan desde bornes emisores hasta bornes receptores
 * siguiendo las l√≠neas (celdas adyacentes) del diagrama.
 */

/**
 * Construye un grafo de adyacencia a partir de las celdas pintadas.
 * Cada celda puede conectarse con sus 4 vecinos (arriba, abajo, izquierda, derecha)
 * si estos tambi√©n est√°n pintados (sin importar el color).
 *
 * @param {Object} celdas - Objeto con claves "x,y" y valores de color
 * @returns {Object} Grafo de adyacencia { "x,y": ["x1,y1", "x2,y2", ...] }
 */
export function construirGrafo(celdas) {
	const grafo = {};
	const clavesCeldas = Object.keys(celdas);

	// Para b√∫squeda r√°pida
	const celdasSet = new Set(clavesCeldas);

	clavesCeldas.forEach(clave => {
		const [x, y] = clave.split(",").map(Number);
		const vecinos = [];

		// Verificar los 4 vecinos
		const posiblesVecinos = [
			`${x},${y - 1}`, // arriba
			`${x},${y + 1}`, // abajo
			`${x - 1},${y}`, // izquierda
			`${x + 1},${y}`, // derecha
		];

		posiblesVecinos.forEach(vecino => {
			if (celdasSet.has(vecino)) {
				vecinos.push(vecino);
			}
		});

		grafo[clave] = vecinos;
	});

	return grafo;
}

/**
 * Calcula todas las rutas posibles desde un emisor hasta cualquier receptor.
 * Usa BFS para encontrar el camino m√°s corto a cada receptor.
 *
 * @param {Object} emisor - Borne emisor { x, y, id, ... }
 * @param {Array} bornes - Array de todos los bornes
 * @param {Object} grafo - Grafo de adyacencia
 * @returns {Array} Array de rutas [{ receptorId, ruta: ["x,y", ...] }, ...]
 */
export function calcularRutasDesdeEmisor(emisor, bornes, grafo) {
	const claveEmisor = `${emisor.x},${emisor.y}`;
	const receptores = bornes.filter(b => b.tipo === "RECEPTOR");

	// Si no hay grafo o el emisor no est√° en el grafo, retornar vac√≠o
	if (!grafo[claveEmisor]) {
		return [];
	}

	// Crear mapa de posici√≥n a borne para b√∫squeda r√°pida
	const posicionAReceptor = {};
	receptores.forEach(r => {
		posicionAReceptor[`${r.x},${r.y}`] = r;
	});

	// BFS para encontrar rutas a todos los receptores
	const rutas = [];
	const visitados = new Set([claveEmisor]);
	const cola = [[claveEmisor, [claveEmisor]]]; // [posici√≥n, rutaHastaAqu√≠]

	while (cola.length > 0) {
		const [posActual, rutaActual] = cola.shift();

		// Si llegamos a un receptor, guardar la ruta
		if (posActual !== claveEmisor && posicionAReceptor[posActual]) {
			rutas.push({
				receptorId: posicionAReceptor[posActual].id,
				ruta: rutaActual,
			});
			// Continuamos buscando para encontrar otros receptores
		}

		// Explorar vecinos
		const vecinos = grafo[posActual] || [];
		vecinos.forEach(vecino => {
			if (!visitados.has(vecino)) {
				visitados.add(vecino);
				cola.push([vecino, [...rutaActual, vecino]]);
			}
		});
	}

	return rutas;
}

/**
 * Verifica si desde una celda se puede llegar a alg√∫n receptor
 * (usado para decisiones en bifurcaciones).
 *
 * @param {string} celda - Clave de la celda "x,y"
 * @param {Set} receptoresSet - Set de claves de receptores
 * @param {Object} grafo - Grafo de adyacencia
 * @param {Set} visitados - Celdas ya visitadas (para evitar ciclos)
 * @returns {boolean} true si se puede llegar a un receptor
 */
export function llegaAReceptor(celda, receptoresSet, grafo, visitados = new Set()) {
	if (receptoresSet.has(celda)) {
		return true;
	}

	if (visitados.has(celda)) {
		return false;
	}

	visitados.add(celda);

	const vecinos = grafo[celda] || [];
	for (const vecino of vecinos) {
		if (!visitados.has(vecino)) {
			if (llegaAReceptor(vecino, receptoresSet, grafo, visitados)) {
				return true;
			}
		}
	}

	return false;
}

/**
 * Dado el estado actual de una chispa en una bifurcaci√≥n,
 * determina hacia qu√© caminos debe continuar.
 *
 * Reglas:
 * - Si ambos caminos llevan a receptores: la chispa se divide (retorna ambos)
 * - Si ambos caminos llevan a emisores: la chispa desaparece (retorna vac√≠o)
 * - Si hay mezcla: sigue solo hacia el receptor (retorna solo el camino correcto)
 *
 * @param {string} posicionActual - Clave de la celda actual
 * @param {string} posicionAnterior - Clave de la celda anterior (de donde viene)
 * @param {Object} grafo - Grafo de adyacencia
 * @param {Array} bornes - Array de todos los bornes
 * @returns {Array} Array de claves de celdas hacia donde continuar
 */
export function decidirDireccionEnBifurcacion(posicionActual, posicionAnterior, grafo, bornes) {
	const vecinos = grafo[posicionActual] || [];

	// Filtrar el vecino de donde venimos
	const posiblesCaminos = vecinos.filter(v => v !== posicionAnterior);

	// Si solo hay un camino o ninguno, no hay decisi√≥n
	if (posiblesCaminos.length <= 1) {
		return posiblesCaminos;
	}

	// Crear sets para b√∫squeda r√°pida
	const emisoresSet = new Set(
		bornes.filter(b => b.tipo === "EMISOR").map(b => `${b.x},${b.y}`)
	);
	const receptoresSet = new Set(
		bornes.filter(b => b.tipo === "RECEPTOR").map(b => `${b.x},${b.y}`)
	);

	// Verificar cada camino si lleva a receptor
	const caminosAReceptor = [];
	const caminosAEmisor = [];

	posiblesCaminos.forEach(camino => {
		// Clonar visitados para cada exploraci√≥n
		const visitados = new Set([posicionActual, posicionAnterior]);

		if (llegaAReceptor(camino, receptoresSet, grafo, visitados)) {
			caminosAReceptor.push(camino);
		} else {
			// Si no llega a receptor, asumimos que lleva a emisor o callej√≥n sin salida
			caminosAEmisor.push(camino);
		}
	});

	// Aplicar reglas de bifurcaci√≥n
	if (caminosAReceptor.length > 0) {
		// Si hay caminos a receptores, seguir todos ellos (dividir chispa)
		return caminosAReceptor;
	} else {
		// Todos llevan a emisores o callejones: la chispa desaparece
		return [];
	}
}

/**
 * Precalcula todas las rutas desde todos los emisores a todos los receptores.
 * √ötil para inicializar el sistema de chispas.
 *
 * @param {Array} bornes - Array de todos los bornes
 * @param {Object} celdas - Objeto de celdas pintadas
 * @returns {Object} Mapa { emisorId: [{ receptorId, ruta }, ...] }
 */
export function precalcularTodasLasRutas(bornes, celdas) {
	const grafo = construirGrafo(celdas);
	const emisores = bornes.filter(b => b.tipo === "EMISOR");
	const resultado = {};

	emisores.forEach(emisor => {
		resultado[emisor.id] = calcularRutasDesdeEmisor(emisor, bornes, grafo);
	});

	return resultado;
}

/**
 * Obtiene el siguiente paso para una chispa en movimiento.
 * Maneja bifurcaciones seg√∫n las reglas del sistema.
 *
 * @param {Object} chispa - Estado de la chispa { ruta, posicion, ... }
 * @param {Object} grafo - Grafo de adyacencia
 * @param {Array} bornes - Array de todos los bornes
 * @returns {Object} { continuar: boolean, nuevasPosiciones: [clave, ...] }
 */
export function obtenerSiguientePaso(chispa, grafo, bornes) {
	const { ruta, posicion } = chispa;

	// Si ya llegamos al final de la ruta
	if (posicion >= ruta.length - 1) {
		return { continuar: false, nuevasPosiciones: [] };
	}

	const posActual = ruta[posicion];
	const posSiguiente = ruta[posicion + 1];

	// Verificar si hay bifurcaci√≥n en el siguiente paso
	const vecinosSiguiente = grafo[posSiguiente] || [];

	if (vecinosSiguiente.length > 2) {
		// Hay bifurcaci√≥n - decidir hacia d√≥nde ir
		const direcciones = decidirDireccionEnBifurcacion(posSiguiente, posActual, grafo, bornes);

		if (direcciones.length === 0) {
			// La chispa desaparece
			return { continuar: false, nuevasPosiciones: [] };
		}

		// Retornar las posibles direcciones (para dividir chispa si hay m√°s de una)
		return { continuar: true, nuevasPosiciones: direcciones };
	}

	// Sin bifurcaci√≥n - continuar normalmente
	return { continuar: true, nuevasPosiciones: [posSiguiente] };
}

========== mi-app/src/paginas/PaginaAlimentadores/utilidades/calculosFormulas.js ==========
// src/paginas/PaginaAlimentadores/utilidades/calculosFormulas.js

/**
 * Aplica una f√≥rmula matem√°tica a un valor 'x'.
 * Ejemplo: aplicarFormula("x * 2 + 10", 5) => 20.
 *
 * NOTA EDUCATIVA: Usamos new Function() solo para ambiente de aprendizaje.
 * En producci√≥n se usar√≠a una librer√≠a como mathjs para mayor seguridad.
 *
 * @param {string} textoFormula - F√≥rmula en texto, ej: "x / 100".
 * @param {number} x - Valor al que aplicar la f√≥rmula.
 * @returns {number|null} Resultado o null si hay error.
 */
export const aplicarFormula = (textoFormula, x) => {
	const formulaLimpia = (textoFormula || "").trim(); // quita espacios y maneja null/undefined

	// Si no hay f√≥rmula, devolver el valor sin cambios
	if (!formulaLimpia) return x;

	try {
		// Crear funci√≥n din√°mica (solo para ambiente educativo)
		const funcionCalcular = new Function("x", `return ${formulaLimpia};`);
		const resultado = funcionCalcular(x);          // eval√∫a la f√≥rmula con el valor x

		// Verificar que sea n√∫mero v√°lido
		return typeof resultado === "number" && !Number.isNaN(resultado)
			 ? resultado
		 : null;
	} catch (error) {
		console.error("Error al aplicar f√≥rmula:", error);
		return null;                                   // ante error sint√°ctico o ejecuci√≥n, devolvemos null
	}
};

/**
 * Formatea un n√∫mero para mostrarlo en la interfaz.
 * Ejemplos:
 *   - 123.456 => "123,46"
 *   - null => "ERROR"
 *   - NaN => "ERROR"
 *
 * @param {number} valor - N√∫mero a formatear.
 * @returns {string} Valor formateado con 2 decimales y coma.
 */
export const formatearValor = (valor) => {
	// Si es inv√°lido, mostrar ERROR
	if (valor == null || Number.isNaN(valor)) {
		return "ERROR";
	}

	// Convertir a 2 decimales y cambiar punto por coma
	return valor.toFixed(2).replace(".", ",");
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (calculosFormulas.js)

 - `aplicarFormula(textoFormula, x)` permite que cada box de medici√≥n tenga una
   f√≥rmula configurable en texto (por ejemplo, "x * 500 / 1000") que se eval√∫a
   sobre el valor crudo le√≠do del registro Modbus.

 - Para mantenerlo simple se usa `new Function("x", "return ...")`, lo que es
   suficiente en este proyecto educativo pero no ser√≠a adecuado en un entorno
   productivo sin sandboxing.

 - `formatearValor(valor)` toma el n√∫mero ya calculado y lo convierte a un
   string con 2 decimales y coma como separador, o "ERROR" si el valor no es
   v√°lido. Es la salida final que se ve en cada caja de la tarjeta.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (calculosFormulas.js)

0) Visi√≥n general del m√≥dulo

   Este archivo concentra dos utilidades relacionadas con el c√°lculo y
   presentaci√≥n de valores num√©ricos en las tarjetas de medici√≥n:

   - `aplicarFormula`: toma un valor crudo (x) y le aplica una f√≥rmula
     configurable en texto.

   - `formatearValor`: toma el n√∫mero ya calculado y lo convierte a un string
     listo para mostrar en pantalla.


1) aplicarFormula(textoFormula, x)

   export const aplicarFormula = (textoFormula, x) => {
     const formulaLimpia = (textoFormula || "").trim();
     if (!formulaLimpia) return x;

     try {
       const funcionCalcular = new Function("x", `return ${formulaLimpia};`);
       const resultado = funcionCalcular(x);

       return typeof resultado === "number" && !Number.isNaN(resultado)
         ? resultado
         : null;
     } catch (error) {
       console.error("Error al aplicar f√≥rmula:", error);
       return null;
     }
   };

   - Par√°metros:
       ‚Ä¢ `textoFormula`: string con la expresi√≥n matem√°tica, por ejemplo
         "x * 500 / 1000" o "x / 100".
       ‚Ä¢ `x`: valor num√©rico crudo que viene del registro Modbus.

   - Flujo:
       1) Limpia el texto con `trim()` y maneja null/undefined.
       2) Si la f√≥rmula queda vac√≠a, devuelve directamente `x` sin cambios
          (equivale a "no hay f√≥rmula").
       3) Construye din√°micamente una funci√≥n con `new Function("x", ...)` que
          devuelve el resultado de la expresi√≥n.
       4) Llama a esa funci√≥n pasando `x` y guarda el resultado.
       5) Si el resultado es un n√∫mero v√°lido, lo devuelve; si no, devuelve null.

   - Seguridad / contexto educativo:
       ‚Ä¢ `new Function` y cualquier ejecuci√≥n de c√≥digo din√°mico deben evitarse
         en producci√≥n (riesgo de inyecci√≥n de c√≥digo).
       ‚Ä¢ En este proyecto se usa con fines did√°cticos; en un sistema real ser√≠a
         preferible usar una librer√≠a como mathjs o un parser de expresiones
         controlado.


2) formatearValor(valor)

   export const formatearValor = (valor) => {
     if (valor == null || Number.isNaN(valor)) {
       return "ERROR";
     }
     return valor.toFixed(2).replace(".", ",");
   };

   - Par√°metro:
       ‚Ä¢ `valor`: n√∫mero ya procesado (por ejemplo, despu√©s de aplicar la
         f√≥rmula), que se quiere mostrar en la UI.

   - Flujo:
       1) Si `valor` es null, undefined o NaN, devuelve el string "ERROR".
          Esto permite a la interfaz diferenciar claramente un problema de
          c√°lculo de un dato v√°lido.

       2) Si es un n√∫mero v√°lido, usa `toFixed(2)` para dejarlo con dos
          decimales.

       3) Cambia el punto decimal por coma para seguir el formato
          habitual "123,45".

   - Resultado t√≠pico:
       ‚Ä¢ 123.456  ‚Üí "123,46"
       ‚Ä¢ 7        ‚Üí "7,00"
       ‚Ä¢ null     ‚Üí "ERROR"


3) Uso dentro del flujo de mediciones

   - Normalmente, el pipeline es:
       1) Leer registro Modbus ‚Üí valor crudo.

       2) Aplicar `aplicarFormula` con la f√≥rmula definida en el mapeo
          (si falla o devuelve null, se considera error).
			 
       3) Pasar el resultado num√©rico por `formatearValor` para obtener el
          texto final que se mostrar√° en la `CajaMedicion`.

   - Al centralizar estas operaciones en un m√≥dulo, se garantiza un criterio
     uniforme de c√°lculo y de formato a lo largo de toda la app.

---------------------------------------------------------------------------*/
========== mi-app/src/paginas/PaginaAlimentadores/utilidades/calculosMediciones.js ==========
// src/paginas/PaginaAlimentadores/utilidades/calculosMediciones.js

import { aplicarFormula, formatearValor } from "./calculosFormulas"; // helpers para f√≥rmulas y formato de n√∫meros
import {
	TITULOS_MEDICIONES,
	ETIQUETAS_POR_DEFECTO,
	DISE√ëO_TARJETA_POR_DEFECTO,
} from "../constantes/titulosMediciones";

/**
 * Obtiene la lista de registros seg√∫n el origen (rele o analizador).
 *
 * @param {Object} registrosPorOrigen - { rele: [...], analizador: [...] }.
 * @param {string} origen - "rele" o "analizador".
 * @returns {Array|null} Lista de registros o null.
 */
export const obtenerListaRegistros = (registrosPorOrigen, origen) => {
	if (!registrosPorOrigen) return null;
	const clave = origen === "analizador" ? "analizador" : "rele"; // default: rele
	const lista = registrosPorOrigen[clave];
	return Array.isArray(lista) ? lista : null;
};

/**
 * Obtiene el dise√±o de la tarjeta desde card_design o mapeoMediciones (legacy).
 * Si no hay configuraci√≥n, devuelve el dise√±o por defecto.
 *
 * @param {Object} cardDesign - Configuraci√≥n directa de card_design (nuevo formato)
 *                              o mapeoMediciones.cardDesign (legacy).
 * @returns {Object} Dise√±o con estructura { superior: {...}, inferior: {...} }.
 */
export const obtenerDisenoTarjeta = (cardDesign) => {
	// Si no hay dise√±o, usar por defecto
	if (!cardDesign || Object.keys(cardDesign).length === 0) {
		return DISE√ëO_TARJETA_POR_DEFECTO;
	}

	// Nuevo formato: card_design ya tiene { superior, inferior } directamente
	// Legacy: mapeoMediciones ten√≠a cardDesign.superior/inferior
	const dise√±o = cardDesign.cardDesign || cardDesign;

	// Si el dise√±o tiene superior/inferior, usarlo
	if (dise√±o.superior || dise√±o.inferior) {
		return {
			superior: normalizarLadoDiseno(dise√±o.superior, DISE√ëO_TARJETA_POR_DEFECTO.superior),
			inferior: normalizarLadoDiseno(dise√±o.inferior, DISE√ëO_TARJETA_POR_DEFECTO.inferior),
		};
	}

	return DISE√ëO_TARJETA_POR_DEFECTO;
};

/**
 * Normaliza un lado del dise√±o, convirtiendo el formato del modal al formato esperado.
 * El modal guarda: { tituloId, tituloCustom, cantidad, boxes: [{ enabled, label, indice, formula }] }
 * El c√°lculo espera: { tituloId, tituloCustom, cantidad, boxes: [{ enabled, label, registro, formula, origen }] }
 */
const normalizarLadoDiseno = (lado, ladoDefault) => {
	if (!lado) return ladoDefault;

	// Normalizar los boxes: convertir 'indice' a 'registro' si es necesario
	const boxesNormalizados = (lado.boxes || []).map((box) => ({
		enabled: !!box.enabled,
		label: box.label || "",
		// El modal guarda 'indice', el c√°lculo espera 'registro'
		registro: box.registro !== undefined ? box.registro : box.indice,
		formula: box.formula || "",
		origen: box.origen || "rele", // por defecto rel√©
	}));

	return {
		...ladoDefault,
		...lado,
		boxes: boxesNormalizados,
		oculto: !!lado.oculto, // preservar si la zona est√° marcada como oculta
	};
};

/**
 * Resuelve el t√≠tulo de un lado de la tarjeta.
 * Puede ser un t√≠tulo predefinido o uno personalizado.
 *
 * @param {Object} dise√±oLado - { tituloId, tituloCustom, ... }.
 * @returns {string} T√≠tulo a mostrar.
 */
export const resolverTituloLado = (dise√±oLado) => {
	if (!dise√±oLado) return "";

	// Si es custom, usar el t√≠tulo personalizado
	if (dise√±oLado.tituloId === "custom") {
		return (dise√±oLado.tituloCustom || "").trim();
	}

	// Sino, buscar en la lista de t√≠tulos predefinidos
	return TITULOS_MEDICIONES[dise√±oLado.tituloId] || "";
};

/**
 * Calcula los valores para mostrar en un lado de la tarjeta (superior o inferior).
 * Aplica f√≥rmulas, formatea valores y maneja errores.
 *
 * @param {Object} registrosPorOrigen - { rele: [...], analizador: [...] }.
 * @param {Object} dise√±oLado - Configuraci√≥n del lado de la tarjeta.
 * @returns {Object} { titulo: string, boxes: [{ etiqueta, valor, enabled, origen }] }.
 */
export const calcularValoresLadoTarjeta = (registrosPorOrigen, dise√±oLado) => {
	if (!dise√±oLado) {
		return {
			titulo: "",
			boxes: [],
		};
	}

	const titulo = resolverTituloLado(dise√±oLado); // texto que va arriba del grupo
	const cantidad = Math.min(
		4,
		Math.max(1, Number(dise√±oLado.cantidad) || 1)
	); // fuerza cantidad a [1,4]
	const boxesSalida = [];

	const etiquetasDefault = ETIQUETAS_POR_DEFECTO[dise√±oLado.tituloId] || [];

	for (let i = 0; i < cantidad; i++) {
		const configuracion = dise√±oLado.boxes?.[i] || {};
		const etiqueta =
			(configuracion.label || "").trim() ||
			etiquetasDefault[i] ||
			`Box ${i + 1}`; // etiqueta efectiva que se ver√°

		let valorMostrado = "--,--"; // placeholder por defecto

		if (configuracion.enabled) {
			const numeroRegistro = Number(configuracion.registro);

			// Si hay registro configurado (n√∫mero v√°lido o 0, y no string vac√≠o)
			if (
				(Number.isFinite(numeroRegistro) || numeroRegistro === 0) &&
				configuracion.registro !== ""
			) {
				const origen = configuracion.origen || "rele"; // default: rele
				const listaRegistros = obtenerListaRegistros(
					registrosPorOrigen,
					origen
				);

				if (listaRegistros && listaRegistros.length > 0) {
					// Buscar el registro por su direcci√≥n (address)
					const registroEncontrado = listaRegistros.find(
						(r) => r.address === numeroRegistro
					);

					if (!registroEncontrado) {
						valorMostrado = "ERROR"; // no se encontr√≥ el registro
					} else {
						// Aplicar f√≥rmula al valor del registro
						const valorCalculado = aplicarFormula(
							configuracion.formula || "x",
							registroEncontrado.value
						);

						if (
							valorCalculado == null ||
							Number.isNaN(valorCalculado)
						) {
							valorMostrado = "ERROR";
						} else {
							valorMostrado = formatearValor(valorCalculado);
						}
					}
				}
			}
		}

		boxesSalida.push({
			etiqueta,
			valor: valorMostrado,
			enabled: !!configuracion.enabled,
			origen: configuracion.origen || "rele",
		});
	}

	return { titulo, boxes: boxesSalida, oculto: !!dise√±oLado.oculto };
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (calculosMediciones.js)

 - Este m√≥dulo es el "traductor" entre los registros Modbus crudos y lo que
   termina viendo la tarjeta en pantalla.

 - Flujo general:
     * `obtenerListaRegistros` elige la lista correcta (`rele` o `analizador`)
       dentro del objeto `{ rele, analizador }`.

     * `obtenerDisenoTarjeta` fusiona el `cardDesign` guardado en el mapeo con
       `DISE√ëO_TARJETA_POR_DEFECTO` para garantizar que siempre haya estructura
       v√°lida para superior e inferior.

     * `resolverTituloLado` convierte `tituloId` en un texto legible, o usa
       el `tituloCustom` si se eligi√≥ la opci√≥n "custom".

     * `calcularValoresLadoTarjeta` recorre cada box configurado:
         - busca el registro por `address`,
         - aplica la f√≥rmula configurada (con `aplicarFormula`),
         - formatea el resultado (`formatearValor`),
         - o deja "ERROR" / "--,--" seg√∫n corresponda.

 - El resultado de `calcularValoresLadoTarjeta` es lo que consume la
   `TarjetaAlimentador` para pintar etiquetas y valores en cada caja.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (calculosMediciones.js)

0) Visi√≥n general del m√≥dulo

   Este archivo es el "traductor" entre:
   - los registros Modbus crudos que vienen del rel√© / analizador, y
   - la estructura amigable que necesita la tarjeta para dibujar cada box
     (etiqueta, valor formateado, enabled, origen).

   Se apoya en:
     ‚Ä¢ `calculosFormulas.js` para aplicar f√≥rmulas y formatear n√∫meros,
     ‚Ä¢ las constantes de `titulosMediciones` para t√≠tulos y etiquetas por defecto.


1) obtenerListaRegistros(registrosPorOrigen, origen)

   export const obtenerListaRegistros = (registrosPorOrigen, origen) => {
     if (!registrosPorOrigen) return null;
     const clave = origen === "analizador" ? "analizador" : "rele";
     const lista = registrosPorOrigen[clave];
     return Array.isArray(lista) ? lista : null;
   };

   - Par√°metros:
       ‚Ä¢ `registrosPorOrigen`: objeto con las listas de lecturas, por ejemplo
         `{ rele: [...], analizador: [...] }`.
       ‚Ä¢ `origen`: string `"rele"` o `"analizador"`.

   - Comportamiento:
       ‚Ä¢ Si el origen es `"analizador"`, usa la clave `"analizador"`;
         en cualquier otro caso cae a `"rele"` como valor por defecto.
       ‚Ä¢ Si encuentra una lista y es un array, la devuelve; si no, devuelve null.

   - Uso t√≠pico:
       ‚Ä¢ Desde `calcularValoresLadoTarjeta` para obtener la lista correcta
         antes de buscar un registro por direcci√≥n.


2) obtenerDisenoTarjeta(mapeoMediciones)

   export const obtenerDisenoTarjeta = (mapeoMediciones) => {
     const dise√±o = mapeoMediciones?.cardDesign;
     if (!dise√±o) return DISE√ëO_TARJETA_POR_DEFECTO;

     return {
       superior: {
         ...DISE√ëO_TARJETA_POR_DEFECTO.superior,
         ...(dise√±o.superior || {}),
       },
       inferior: {
         ...DISE√ëO_TARJETA_POR_DEFECTO.inferior,
         ...(dise√±o.inferior || {}),
       },
     };
   };

   - Toma el `cardDesign` guardado en el mapeo (si existe) y lo fusiona con
     `DISE√ëO_TARJETA_POR_DEFECTO`.

   - Objetivo:
       ‚Ä¢ garantizar que siempre haya un objeto bien formado para `superior` e
         `inferior`, con campos y estructuras m√≠nimas aunque falten datos.

   - Si `mapeoMediciones` no tiene `cardDesign`, devuelve directamente el
     dise√±o por defecto (corriente arriba, tensi√≥n abajo, etc.).


3) resolverTituloLado(dise√±oLado)

   export const resolverTituloLado = (dise√±oLado) => {
     if (!dise√±oLado) return "";

     if (dise√±oLado.tituloId === "custom") {
       return (dise√±oLado.tituloCustom || "").trim();
     }

     return TITULOS_MEDICIONES[dise√±oLado.tituloId] || "";
   };

   - Si el `tituloId` es `"custom"`, usa el texto libre `tituloCustom`.

   - En caso contrario, busca el t√≠tulo en `TITULOS_MEDICIONES` usando
     `tituloId` como clave (ej: `"tension_linea"`, `"corriente_132"`, etc.).

   - Si no encuentra nada, devuelve string vac√≠o.


4) calcularValoresLadoTarjeta(registrosPorOrigen, dise√±oLado)

   export const calcularValoresLadoTarjeta = (registrosPorOrigen, dise√±oLado) => {
     if (!dise√±oLado) {
       return { titulo: "", boxes: [] };
     }

     const titulo = resolverTituloLado(dise√±oLado);
     const cantidad = Math.min(4, Math.max(1, Number(dise√±oLado.cantidad) || 1));
     const boxesSalida = [];
     const etiquetasDefault = ETIQUETAS_POR_DEFECTO[dise√±oLado.tituloId] || [];

     for (let i = 0; i < cantidad; i++) {
       const configuracion = dise√±oLado.boxes?.[i] || {};
       const etiqueta =
         (configuracion.label || "").trim() ||
         etiquetasDefault[i] ||
         `Box ${i + 1}`;

       let valorMostrado = "--,--";

       if (configuracion.enabled) {
         const numeroRegistro = Number(configuracion.registro);

         if (
           (Number.isFinite(numeroRegistro) || numeroRegistro === 0) &&
           configuracion.registro !== ""
         ) {
           const origen = configuracion.origen || "rele";
           const listaRegistros = obtenerListaRegistros(registrosPorOrigen, origen);

           if (listaRegistros && listaRegistros.length > 0) {
             const registroEncontrado = listaRegistros.find(
               (r) => r.address === numeroRegistro
             );

             if (!registroEncontrado) {
               valorMostrado = "ERROR";
             } else {
               const valorCalculado = aplicarFormula(
                 configuracion.formula || "x",
                 registroEncontrado.value
               );

               if (valorCalculado == null || Number.isNaN(valorCalculado)) {
                 valorMostrado = "ERROR";
               } else {
                 valorMostrado = formatearValor(valorCalculado);
               }
             }
           }
         }
       }

       boxesSalida.push({
         etiqueta,
         valor: valorMostrado,
         enabled: !!configuracion.enabled,
         origen: configuracion.origen || "rele",
       });
     }

     return { titulo, boxes: boxesSalida };
   };

   - Paso a paso para cada box:

       1) Determina la etiqueta efectiva:
            ‚Ä¢ primero `configuracion.label` (si existe y no est√° vac√≠o),
            ‚Ä¢ si no, una etiqueta por defecto seg√∫n magnitud (R, S, T, Total),
            ‚Ä¢ si tampoco hay, usa "Box 1", "Box 2", etc.

       2) Inicializa `valorMostrado` en `"--,--"` como placeholder.

       3) Si el box est√° habilitado (`enabled === true`):
            ‚Ä¢ Valida el n√∫mero de registro (`configuracion.registro`).
            ‚Ä¢ Determina el origen (`rele` o `analizador`).
            ‚Ä¢ Obtiene la lista de registros correspondiente con
              `obtenerListaRegistros`.
            ‚Ä¢ Busca el registro cuyo `address` coincida con el n√∫mero
              configurado.

       4) Si encuentra el registro:
            ‚Ä¢ Aplica la f√≥rmula de ese box con `aplicarFormula` (o "x" si
              no se defini√≥ f√≥rmula).
            ‚Ä¢ Si el resultado es inv√°lido ‚Üí `"ERROR"`.
            ‚Ä¢ Si es v√°lido ‚Üí lo pasa por `formatearValor` para obtener un
              string "amigable" (dos decimales, coma, etc.).

       5) Agrega al array `boxesSalida` un objeto con:
            ‚Ä¢ `etiqueta`: texto visible en la tarjeta,
            ‚Ä¢ `valor`: texto formateado o "ERROR"/"--,--",
            ‚Ä¢ `enabled`: booleano,
            ‚Ä¢ `origen`: "rele" o "analizador".


5) C√≥mo se integra con el resto de la app

   - `ModalMapeoMediciones` define el `cardDesign` (qu√© boxes hay, qu√©
     registro leen, f√≥rmula, origen, etc.) y lo guarda en `mapeoMediciones`
     dentro de cada alimentador.

   - Cuando llegan lecturas nuevas desde los equipos:

       1) Se arma un objeto `{ rele: [...], analizador: [...] }` con registros
          crudos (`index`, `address`, `value`).

       2) Se obtiene el dise√±o de tarjeta con `obtenerDisenoTarjeta`.

       3) Para cada lado (superior / inferior) se llama a
          `calcularValoresLadoTarjeta` y se obtienen `{ titulo, boxes }`.
			 
       4) Esa estructura es la que consume `TarjetaAlimentador` para renderizar
          cada `CajaMedicion` con su etiqueta, valor y comportamiento visual.

   - De esta forma, todo el c√°lculo num√©rico + mapeo queda concentrado en este
     m√≥dulo y las tarjetas se enfocan s√≥lo en mostrar datos.

---------------------------------------------------------------------------*/

========== mi-app/src/paginas/PaginaAlimentadores/utilidades/exportarCSV.js ==========
/**
 * Utilidad para exportar datos a formato CSV
 */

/**
 * Exporta datos a un archivo CSV descargable
 * @param {Array} datos - Array de objetos con los datos
 * @param {string} nombreArchivo - Nombre del archivo (sin extensi√≥n)
 * @param {Object} opciones - Opciones de configuraci√≥n
 * @param {Array<string>} opciones.columnas - Columnas a incluir (orden)
 * @param {Object} opciones.etiquetas - Mapeo de nombres de columnas a etiquetas
 */
export const exportarCSV = (datos, nombreArchivo, opciones = {}) => {
  if (!datos || datos.length === 0) {
    console.warn("No hay datos para exportar");
    return;
  }

  const {
    columnas = ["timestamp", "valor"],
    etiquetas = {
      timestamp: "Fecha/Hora",
      valor: "Valor",
      valorCrudo: "Valor Crudo",
      variable: "Variable",
    },
  } = opciones;

  // Crear header con etiquetas
  const header = columnas.map((col) => etiquetas[col] || col);

  // Crear filas de datos
  const filas = datos.map((d) => {
    return columnas
      .map((col) => {
        let valor = obtenerValorColumna(d, col);

        // Escapar valores que contienen separadores
        if (typeof valor === "string" && (valor.includes(";") || valor.includes('"'))) {
          valor = `"${valor.replace(/"/g, '""')}"`;
        }

        return valor;
      })
      .join(";");
  });

  // Unir header y filas
  const contenidoCSV = [header.join(";"), ...filas].join("\n");

  // Crear blob con BOM para Excel
  const BOM = "\uFEFF";
  const blob = new Blob([BOM + contenidoCSV], {
    type: "text/csv;charset=utf-8;",
  });

  // Crear y ejecutar descarga
  descargarBlob(blob, `${nombreArchivo}.csv`);
};

/**
 * Obtiene el valor formateado para una columna espec√≠fica
 * @param {Object} dato - Objeto con los datos
 * @param {string} columna - Nombre de la columna
 * @returns {string} - Valor formateado
 */
const obtenerValorColumna = (dato, columna) => {
  switch (columna) {
    case "timestamp":
      // Formatear timestamp a fecha legible
      const fecha = dato.x instanceof Date ? dato.x : new Date(dato.timestamp || dato.x);
      return formatearFecha(fecha);

    case "valor":
      // Valor calculado con f√≥rmula
      const val = dato.y ?? dato.valor;
      return val != null ? val.toFixed(4).replace(".", ",") : "";

    case "valorCrudo":
      // Valor sin procesar
      const raw = dato.raw ?? dato.valorCrudo;
      return raw != null ? String(raw).replace(".", ",") : "";

    case "variable":
      return dato.variable || dato.etiqueta || "";

    default:
      const v = dato[columna];
      if (v == null) return "";
      if (typeof v === "number") return v.toString().replace(".", ",");
      return String(v);
  }
};

/**
 * Formatea una fecha para el CSV
 * @param {Date} fecha - Fecha a formatear
 * @returns {string} - Fecha formateada DD/MM/YYYY HH:mm:ss
 */
const formatearFecha = (fecha) => {
  if (!(fecha instanceof Date) || isNaN(fecha.getTime())) {
    return "";
  }

  const pad = (n) => String(n).padStart(2, "0");

  const dia = pad(fecha.getDate());
  const mes = pad(fecha.getMonth() + 1);
  const anio = fecha.getFullYear();
  const hora = pad(fecha.getHours());
  const min = pad(fecha.getMinutes());
  const seg = pad(fecha.getSeconds());

  return `${dia}/${mes}/${anio} ${hora}:${min}:${seg}`;
};

/**
 * Descarga un blob como archivo
 * @param {Blob} blob - Blob a descargar
 * @param {string} nombreArchivo - Nombre del archivo
 */
const descargarBlob = (blob, nombreArchivo) => {
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");

  link.href = url;
  link.download = nombreArchivo;
  link.style.display = "none";

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  // Liberar memoria
  URL.revokeObjectURL(url);
};

/**
 * Exporta m√∫ltiples series de datos a CSV
 * @param {Array} series - Array de series [{nombre, datos}]
 * @param {string} nombreArchivo - Nombre del archivo
 */
export const exportarSeriesCSV = (series, nombreArchivo) => {
  if (!series || series.length === 0) return;

  // Combinar todas las series en un formato tabular
  const datosUnificados = [];

  series.forEach((serie) => {
    serie.datos.forEach((punto) => {
      datosUnificados.push({
        variable: serie.nombre,
        x: punto.x,
        y: punto.y,
        raw: punto.raw,
      });
    });
  });

  // Ordenar por timestamp
  datosUnificados.sort((a, b) => {
    const ta = a.x instanceof Date ? a.x.getTime() : a.x;
    const tb = b.x instanceof Date ? b.x.getTime() : b.x;
    return ta - tb;
  });

  exportarCSV(datosUnificados, nombreArchivo, {
    columnas: ["timestamp", "variable", "valor", "valorCrudo"],
    etiquetas: {
      timestamp: "Fecha/Hora",
      variable: "Variable",
      valor: "Valor Calculado",
      valorCrudo: "Valor Crudo",
    },
  });
};

========== mi-app/src/paginas/PaginaAlimentadores/utilidades/exportarInformePDF.js ==========
/**
 * Utilidad para exportar informes profesionales en formato PDF
 * Usa pdfmake para generar archivos .pdf con tablas, gr√°ficos e informaci√≥n
 */

import pdfMake from "pdfmake/build/pdfmake";
import pdfFonts from "pdfmake/build/vfs_fonts";

// Configurar fuentes de pdfmake
if (pdfFonts.pdfMake) {
  pdfMake.vfs = pdfFonts.pdfMake.vfs;
} else if (pdfFonts.vfs) {
  pdfMake.vfs = pdfFonts.vfs;
}

// Colores del tema (en formato hex para pdfmake)
const COLORES = {
  primario: "#1E3A5F", // Azul oscuro
  secundario: "#0EA5E9", // Azul claro
  fondo: "#F8FAFC", // Gris muy claro
  texto: "#1E293B", // Gris oscuro
  borde: "#CBD5E1", // Gris medio
  minimo: "#DCFCE7", // Verde claro (para valor m√≠nimo)
  maximo: "#FED7AA", // Naranja claro (para valor m√°ximo)
  blanco: "#FFFFFF",
};

/**
 * Formatea una fecha para mostrar en el informe
 * @param {Date|number|string} fecha - Fecha a formatear
 * @returns {string} - Fecha formateada
 */
const formatearFecha = (fecha) => {
  const d = fecha instanceof Date ? fecha : new Date(fecha);
  if (isNaN(d.getTime())) return "--";

  const pad = (n) => String(n).padStart(2, "0");
  return `${pad(d.getDate())}/${pad(d.getMonth() + 1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
};

/**
 * Formatea solo la fecha (sin hora)
 * @param {Date|number|string} fecha - Fecha a formatear
 * @returns {string} - Fecha formateada
 */
const formatearSoloFecha = (fecha) => {
  const d = fecha instanceof Date ? fecha : new Date(fecha);
  if (isNaN(d.getTime())) return "--";

  const pad = (n) => String(n).padStart(2, "0");
  return `${pad(d.getDate())}/${pad(d.getMonth() + 1)}/${d.getFullYear()}`;
};

/**
 * Genera la definici√≥n del documento PDF
 * @param {Object} config - Configuraci√≥n del informe
 * @returns {Object} - Definici√≥n del documento para pdfmake
 */
const generarDefinicionPDF = (config) => {
  const {
    datos,
    tituloMedicion,
    nombreAlimentador,
    fechaDesde,
    fechaHasta,
    solicitadoPor,
    imagenGrafico,
    intervalo,
  } = config;

  // Calcular estad√≠sticas
  let minimo = 0,
    maximo = 0,
    promedio = 0;
  let fechaMinimo = null,
    fechaMaximo = null;

  if (datos.length > 0) {
    const valores = datos.map((d) => d.y).filter((v) => v != null && !isNaN(v));
    minimo = Math.min(...valores);
    maximo = Math.max(...valores);
    promedio = valores.reduce((a, b) => a + b, 0) / valores.length;

    // Encontrar las fechas de los valores m√≠nimo y m√°ximo
    const puntoMin = datos.find((d) => d.y === minimo);
    const puntoMax = datos.find((d) => d.y === maximo);
    fechaMinimo = puntoMin?.x ? formatearFecha(puntoMin.x) : null;
    fechaMaximo = puntoMax?.x ? formatearFecha(puntoMax.x) : null;
  }

  // Texto del intervalo
  const textoIntervalo = intervalo
    ? intervalo === 0
      ? " (todos)"
      : ` (cada ${intervalo} min)`
    : "";

  // Construir contenido del PDF
  const contenido = [];

  // === T√çTULO PRINCIPAL CON FONDO AZUL (estilo Excel) ===
  contenido.push({
    table: {
      widths: ["*"],
      body: [
        [
          {
            text: "INFORME DE MEDICIONES",
            fontSize: 16,
            bold: true,
            color: COLORES.blanco,
            fillColor: COLORES.primario,
            alignment: "center",
          },
        ],
      ],
    },
    layout: {
      hLineWidth: () => 0.5,
      vLineWidth: () => 0.5,
      hLineColor: () => COLORES.borde,
      vLineColor: () => COLORES.borde,
      paddingTop: () => 12,
      paddingBottom: () => 12,
    },
    margin: [0, 0, 0, 0],
  });

  // === INFORMACI√ìN Y ESTAD√çSTICAS EN COLUMNAS (con borde exterior) ===
  contenido.push({
    table: {
      widths: ["*"],
      body: [
        [
          {
            columns: [
              // Columna izquierda: Informaci√≥n del informe
              {
                width: "55%",
                table: {
                  widths: ["auto", "*"],
                  body: [
                    [
                      { text: "Registros para:", style: "etiqueta" },
                      { text: nombreAlimentador, style: "valor" },
                    ],
                    [
                      { text: "Medici√≥n:", style: "etiqueta" },
                      { text: tituloMedicion, style: "valor" },
                    ],
                    [
                      { text: "Fecha de creaci√≥n:", style: "etiqueta" },
                      { text: formatearFecha(new Date()), style: "valor" },
                    ],
                    [
                      { text: "Solicitado por:", style: "etiqueta" },
                      { text: solicitadoPor || "No especificado", style: "valor" },
                    ],
                    [
                      { text: "Per√≠odo desde:", style: "etiqueta" },
                      { text: formatearFecha(fechaDesde), style: "valor" },
                    ],
                    [
                      { text: "Per√≠odo hasta:", style: "etiqueta" },
                      { text: formatearFecha(fechaHasta), style: "valor" },
                    ],
                    [
                      { text: "Total de registros:", style: "etiqueta" },
                      { text: `${datos.length}${textoIntervalo}`, style: "valor" },
                    ],
                  ],
                },
                layout: {
                  hLineWidth: () => 0,
                  vLineWidth: () => 0,
                  paddingTop: () => 3,
                  paddingBottom: () => 3,
                },
              },
              // Columna derecha: Estad√≠sticas
              {
                width: "45%",
                stack: [
                  {
                    text: "ESTAD√çSTICAS",
                    style: "subtitulo",
                    alignment: "center",
                    margin: [0, 0, 0, 8],
                  },
                  {
                    table: {
                      widths: ["auto", "*"],
                      body: [
                        [
                          { text: "Valor m√≠nimo:", style: "etiqueta", alignment: "right" },
                          {
                            stack: [
                              { text: minimo.toFixed(2), style: "valorEstadistica", alignment: "center" },
                              fechaMinimo
                                ? { text: fechaMinimo, fontSize: 8, color: COLORES.texto, alignment: "center" }
                                : null,
                            ].filter(Boolean),
                            fillColor: COLORES.minimo,
                          },
                        ],
                        [
                          { text: "Valor m√°ximo:", style: "etiqueta", alignment: "right" },
                          {
                            stack: [
                              { text: maximo.toFixed(2), style: "valorEstadistica", alignment: "center" },
                              fechaMaximo
                                ? { text: fechaMaximo, fontSize: 8, color: COLORES.texto, alignment: "center" }
                                : null,
                            ].filter(Boolean),
                            fillColor: COLORES.maximo,
                          },
                        ],
                        [
                          { text: "Valor promedio:", style: "etiqueta", alignment: "right" },
                          { text: promedio.toFixed(2), style: "valorEstadistica", alignment: "center" },
                        ],
                      ],
                    },
                    layout: {
                      hLineWidth: () => 0.5,
                      vLineWidth: () => 0.5,
                      hLineColor: () => COLORES.borde,
                      vLineColor: () => COLORES.borde,
                      paddingTop: () => 4,
                      paddingBottom: () => 4,
                      paddingLeft: () => 8,
                      paddingRight: () => 8,
                    },
                  },
                ],
              },
            ],
            columnGap: 15,
          },
        ],
      ],
    },
    layout: {
      hLineWidth: () => 0.5,
      vLineWidth: () => 0.5,
      hLineColor: () => COLORES.borde,
      vLineColor: () => COLORES.borde,
      paddingTop: () => 10,
      paddingBottom: () => 10,
      paddingLeft: () => 10,
      paddingRight: () => 10,
    },
    margin: [0, 0, 0, 20],
  });

  // === GR√ÅFICO (en p√°gina 2) ===
  if (imagenGrafico) {
    contenido.push({
      text: "GR√ÅFICO DE MEDICIONES",
      style: "subtitulo",
      alignment: "center",
      margin: [0, 10, 0, 10],
      pageBreak: "before",
    });

    contenido.push({
      image: imagenGrafico,
      width: 500,
      alignment: "center",
      margin: [0, 0, 0, 20],
    });
  }

  // === TABLA DE DATOS (en p√°gina 3+) ===
  if (datos.length > 0) {
    contenido.push({
      text: "DATOS DE MEDICIONES",
      style: "subtitulo",
      alignment: "center",
      margin: [0, 10, 0, 10],
      pageBreak: "before",
    });

    // Crear filas de la tabla
    const filasTabla = [
      // Encabezados
      [
        { text: "Fecha/Hora", style: "encabezadoTabla" },
        { text: "Valor de Medici√≥n", style: "encabezadoTabla" },
      ],
    ];

    // Datos
    datos.forEach((punto, index) => {
      const fecha = punto.x instanceof Date ? punto.x : new Date(punto.x);

      // Determinar color de fondo (comparar por valor, no por √≠ndice)
      let fillColor = index % 2 === 0 ? COLORES.fondo : COLORES.blanco;
      if (punto.y === minimo && minimo !== maximo) {
        fillColor = COLORES.minimo;
      } else if (punto.y === maximo && minimo !== maximo) {
        fillColor = COLORES.maximo;
      }

      filasTabla.push([
        {
          text: formatearFecha(fecha),
          style: "celdaTabla",
          fillColor,
        },
        {
          text: punto.y.toFixed(2),
          style: "celdaTabla",
          alignment: "center",
          fillColor,
        },
      ]);
    });

    contenido.push({
      table: {
        headerRows: 1,
        widths: ["*", "*"],
        body: filasTabla,
      },
      layout: {
        hLineWidth: () => 0.5,
        vLineWidth: () => 0.5,
        hLineColor: () => COLORES.borde,
        vLineColor: () => COLORES.borde,
        paddingTop: () => 6,
        paddingBottom: () => 6,
        paddingLeft: () => 8,
        paddingRight: () => 8,
      },
    });
  }

  // Definici√≥n completa del documento
  return {
    pageSize: "A4",
    pageOrientation: "portrait",
    pageMargins: [40, 60, 40, 60],

    // Encabezado de cada p√°gina
    header: {
      columns: [
        {
          text: "RelayWatch - Informe de Mediciones",
          style: "header",
          alignment: "left",
          margin: [40, 20, 0, 0],
        },
        {
          text: formatearSoloFecha(new Date()),
          style: "header",
          alignment: "right",
          margin: [0, 20, 40, 0],
        },
      ],
    },

    // Pie de cada p√°gina
    footer: (currentPage, pageCount) => ({
      columns: [
        {
          text: `${nombreAlimentador} - ${tituloMedicion}`,
          style: "footer",
          alignment: "left",
          margin: [40, 0, 0, 0],
        },
        {
          text: `P√°gina ${currentPage} de ${pageCount}`,
          style: "footer",
          alignment: "right",
          margin: [0, 0, 40, 0],
        },
      ],
    }),

    content: contenido,

    // Estilos
    styles: {
      header: {
        fontSize: 9,
        color: COLORES.texto,
      },
      footer: {
        fontSize: 9,
        color: COLORES.texto,
      },
      tituloPrincipal: {
        fontSize: 16,
        bold: true,
        color: COLORES.blanco,
        fillColor: COLORES.primario,
      },
      titulo: {
        fontSize: 18,
        bold: true,
        color: COLORES.primario,
      },
      subtitulo: {
        fontSize: 14,
        bold: true,
        color: COLORES.primario,
      },
      etiqueta: {
        fontSize: 10,
        bold: true,
        color: COLORES.texto,
      },
      valor: {
        fontSize: 10,
        color: COLORES.texto,
      },
      valorEstadistica: {
        fontSize: 11,
        color: COLORES.texto,
        alignment: "center",
      },
      encabezadoTabla: {
        fontSize: 10,
        bold: true,
        color: COLORES.blanco,
        fillColor: COLORES.primario,
        alignment: "center",
      },
      celdaTabla: {
        fontSize: 9,
        color: COLORES.texto,
      },
    },

    // Configuraci√≥n por defecto
    defaultStyle: {
      font: "Roboto",
    },
  };
};

/**
 * Genera y descarga un informe PDF con los datos de mediciones
 * @param {Object} config - Configuraci√≥n del informe
 * @param {string} config.nombreAlimentador - Nombre del alimentador
 * @param {string} config.tituloMedicion - T√≠tulo de la medici√≥n
 * @param {Array} config.datos - Datos de la zona actual [{x, y}]
 * @param {Date} config.fechaInicio - Fecha del primer registro
 * @param {Date} config.fechaFin - Fecha del √∫ltimo registro
 * @param {string} config.solicitadoPor - Nombre del solicitante
 * @param {string|null} config.imagenGrafico - Data URI de la imagen del gr√°fico
 * @param {number} config.intervalo - Intervalo de filtrado (0, 15, 30, 60 minutos)
 * @returns {Promise<string|null>} - Nombre del archivo o null si se cancel√≥
 */
export const generarInformePDF = async (config) => {
  const {
    nombreAlimentador,
    tituloMedicion,
    datos,
    fechaInicio,
    fechaFin,
    solicitadoPor,
    imagenGrafico,
    intervalo,
  } = config;

  // Si no hay datos, no generar
  if (!datos || datos.length === 0) {
    console.warn("No hay datos para generar el informe PDF");
    return null;
  }

  // Generar definici√≥n del documento
  const docDefinition = generarDefinicionPDF({
    datos,
    tituloMedicion: tituloMedicion || "Mediciones",
    nombreAlimentador,
    fechaDesde: fechaInicio,
    fechaHasta: fechaFin,
    solicitadoPor,
    imagenGrafico,
    intervalo,
  });

  // Generar nombre de archivo
  const fechaArchivo = formatearSoloFecha(new Date()).replace(/\//g, "-");
  const nombreArchivo = `Informe_${nombreAlimentador}_${tituloMedicion}_${fechaArchivo}.pdf`;

  // Crear PDF y descargar
  return new Promise((resolve) => {
    const pdfDoc = pdfMake.createPdf(docDefinition);

    // Intentar usar File System Access API (Chrome/Edge) para elegir ubicaci√≥n
    if ("showSaveFilePicker" in window) {
      pdfDoc.getBlob(async (blob) => {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: nombreArchivo,
            types: [
              {
                description: "Archivo PDF",
                accept: { "application/pdf": [".pdf"] },
              },
            ],
          });

          const writable = await handle.createWritable();
          await writable.write(blob);
          await writable.close();

          resolve(handle.name);
        } catch (err) {
          if (err.name === "AbortError") {
            resolve(null); // Usuario cancel√≥
          } else {
            // Fallback a descarga directa
            pdfDoc.download(nombreArchivo);
            resolve(nombreArchivo);
          }
        }
      });
    } else {
      // Fallback: descarga directa
      pdfDoc.download(nombreArchivo);
      resolve(nombreArchivo);
    }
  });
};

========== mi-app/src/paginas/PaginaAlimentadores/utilidades/generarGraficoInforme.js ==========
/**
 * Genera un gr√°fico temporal con ApexCharts y captura su imagen
 * para incluir en informes Excel.
 *
 * Crea un gr√°fico invisible, lo renderiza con los datos proporcionados,
 * captura la imagen y lo destruye.
 */

import ApexCharts from "apexcharts";

/**
 * Genera una imagen de gr√°fico a partir de datos de series temporales
 * @param {Array} datos - Array de puntos [{x: timestamp, y: valor}]
 * @param {Object} opciones - Opciones de configuraci√≥n
 * @param {string} opciones.tipo - Tipo de gr√°fico (line, area, bar)
 * @param {string} opciones.titulo - T√≠tulo del gr√°fico (opcional)
 * @param {number} opciones.width - Ancho en p√≠xeles (default: 1100)
 * @param {number} opciones.height - Alto en p√≠xeles (default: 450)
 * @param {number} opciones.scale - Escala de la imagen (default: 2)
 * @returns {Promise<string|null>} - Data URI de la imagen o null si falla
 */
export const generarImagenGrafico = async (datos, opciones = {}) => {
  if (!datos || datos.length === 0) {
    return null;
  }

  const {
    tipo = "line",
    titulo = "",
    width = 1100,
    height = 450,
    scale = 2,
  } = opciones;

  // Crear contenedor temporal - usar visibility:hidden para que ApexCharts
  // pueda calcular las dimensiones pero no sea visible
  const tempContainer = document.createElement("div");
  tempContainer.style.cssText = `
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: ${width}px;
    height: ${height}px;
    visibility: hidden;
  `;
  document.body.appendChild(tempContainer);

  // Forzar un reflow para asegurar que el contenedor tenga dimensiones
  tempContainer.offsetHeight;

  // Preparar series para ApexCharts
  const seriesData = datos.map((punto) => ({
    x: punto.x instanceof Date ? punto.x.getTime() : new Date(punto.x).getTime(),
    y: punto.y,
  }));

  // Calcular min/max para el eje Y con margen
  const valores = datos.map((d) => d.y).filter((v) => v != null && !isNaN(v));
  const minY = Math.min(...valores);
  const maxY = Math.max(...valores);
  const rangoY = maxY - minY || 1;
  const margen = rangoY * 0.1;

  // Configuraci√≥n del gr√°fico simplificada para evitar errores de ApexCharts
  const chartConfig = {
    chart: {
      id: `informe-temp-${Date.now()}`,
      type: tipo,
      width: "100%",
      height: "100%",
      background: "#ffffff",
      foreColor: "#1a1a1a",
      animations: { enabled: false },
      toolbar: { show: false },
      zoom: { enabled: false },
      offsetX: 0,
      offsetY: 0,
      sparkline: { enabled: false },
    },
    series: [
      {
        name: titulo || "Medici√≥n",
        data: seriesData,
      },
    ],
    stroke: {
      curve: "smooth",
      width: tipo === "bar" ? 0 : 3,
    },
    colors: ["#0EA5E9"],
    markers: {
      size: datos.length <= 30 ? 4 : 0,
    },
    xaxis: {
      type: "datetime",
      labels: {
        datetimeUTC: false,
        format: "dd/MM HH:mm",
        style: {
          fontSize: "12px",
        },
      },
    },
    yaxis: {
      min: Math.floor(minY - margen),
      max: Math.ceil(maxY + margen),
      labels: {
        formatter: (val) => val.toFixed(2),
      },
    },
    grid: {
      borderColor: "#e0e0e0",
    },
    tooltip: { enabled: false },
    dataLabels: { enabled: false },
    legend: { show: false },
  };

  let tempChart = null;

  try {
    // Crear y renderizar gr√°fico temporal
    tempChart = new ApexCharts(tempContainer, chartConfig);
    await tempChart.render();

    // Esperar a que el gr√°fico se renderice completamente
    await new Promise((resolve) => setTimeout(resolve, 300));

    // Capturar imagen
    const result = await tempChart.dataURI({ scale });

    // dataURI puede devolver { imgURI } o directamente el string
    const imgURI = result?.imgURI || result;

    if (!imgURI || typeof imgURI !== "string") {
      console.warn("dataURI no devolvi√≥ una imagen v√°lida:", result);
      return null;
    }

    return imgURI;
  } catch (err) {
    console.warn("Error generando imagen de gr√°fico para informe:", err);
    return null;
  } finally {
    // Limpiar: destruir gr√°fico y remover contenedor
    if (tempChart) {
      try {
        tempChart.destroy();
      } catch {
        // Ignorar errores de destrucci√≥n
      }
    }
    if (tempContainer.parentNode) {
      tempContainer.parentNode.removeChild(tempContainer);
    }
  }
};

========== mi-app/src/paginas/PaginaAlimentadores/utilidades/indexedDBHelper.js ==========
/**
 * Helper para operaciones con IndexedDB
 * Almacena lecturas de los √∫ltimos 48 horas para acceso r√°pido local
 */

const DB_NAME = "RelayWatchHistorial";
const DB_VERSION = 1;
const STORE_NAME = "lecturas";

/**
 * Abre la conexi√≥n a IndexedDB y crea el schema si es necesario
 * @returns {Promise<IDBDatabase>}
 */
export const abrirDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => {
      console.error("Error abriendo IndexedDB:", request.error);
      reject(request.error);
    };

    request.onsuccess = () => {
      resolve(request.result);
    };

    request.onupgradeneeded = (event) => {
      const db = event.target.result;

      // Crear object store con √≠ndices
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        const store = db.createObjectStore(STORE_NAME, {
          keyPath: "id",
          autoIncrement: true,
        });

        // √çndices para consultas eficientes
        store.createIndex("alimentadorId", "alimentadorId", { unique: false });
        store.createIndex("registradorId", "registradorId", { unique: false });
        store.createIndex("zona", "zona", { unique: false });
        store.createIndex("timestamp", "timestamp", { unique: false });

        // √çndice compuesto para b√∫squedas por alimentador + zona + tiempo
        store.createIndex(
          "alimZonaTimestamp",
          ["alimentadorId", "zona", "timestamp"],
          { unique: false }
        );
      }
    };
  });
};

/**
 * Guarda una lectura en IndexedDB
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {Object} lectura - Datos de la lectura
 * @returns {Promise<number>} - ID de la lectura insertada
 */
export const guardarLectura = async (db, lectura) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);

    const registro = {
      alimentadorId: lectura.alimentadorId,
      registradorId: lectura.registradorId,
      zona: lectura.zona,
      timestamp: lectura.timestamp || Date.now(),
      valores: lectura.valores,
      indiceInicial: lectura.indiceInicial,
      exito: lectura.exito,
      createdAt: Date.now(),
    };

    const request = store.add(registro);

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

/**
 * Obtiene lecturas en un rango de tiempo para un alimentador/zona espec√≠ficos
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @param {string} registradorId - ID del registrador (opcional, para filtrar)
 * @param {string} zona - "superior" o "inferior"
 * @param {number} desde - Timestamp inicial (ms)
 * @param {number} hasta - Timestamp final (ms)
 * @returns {Promise<Array>} - Array de lecturas
 */
export const obtenerLecturasRango = async (
  db,
  alimentadorId,
  registradorId,
  zona,
  desde,
  hasta
) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("alimZonaTimestamp");

    // Rango de b√∫squeda usando √≠ndice compuesto
    const rango = IDBKeyRange.bound(
      [alimentadorId, zona, desde],
      [alimentadorId, zona, hasta]
    );

    const request = index.getAll(rango);

    request.onsuccess = () => {
      let resultados = request.result;

      // Filtrar por registradorId si se especifica
      if (registradorId) {
        resultados = resultados.filter((r) => r.registradorId === registradorId);
      }

      // Ordenar por timestamp ascendente
      resultados.sort((a, b) => a.timestamp - b.timestamp);

      resolve(resultados);
    };

    request.onerror = () => reject(request.error);
  });
};

/**
 * Elimina lecturas m√°s antiguas que el tiempo de retenci√≥n
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {number} horasRetencion - Horas de datos a mantener (default: 48)
 * @returns {Promise<number>} - Cantidad de registros eliminados
 */
export const limpiarLecturasAntiguas = async (db, horasRetencion = 48) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("timestamp");

    const limite = Date.now() - horasRetencion * 60 * 60 * 1000;
    const rango = IDBKeyRange.upperBound(limite);

    let eliminados = 0;
    const request = index.openCursor(rango);

    request.onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor) {
        cursor.delete();
        eliminados++;
        cursor.continue();
      } else {
        resolve(eliminados);
      }
    };

    request.onerror = () => reject(request.error);
  });
};

/**
 * Cuenta el n√∫mero de lecturas para un alimentador
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @returns {Promise<number>} - Cantidad de lecturas
 */
export const contarLecturas = async (db, alimentadorId) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("alimentadorId");

    const request = index.count(alimentadorId);

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

/**
 * Obtiene estad√≠sticas del almacenamiento
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @returns {Promise<Object>} - Estad√≠sticas
 */
export const obtenerEstadisticas = async (db) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);

    const countRequest = store.count();

    countRequest.onsuccess = () => {
      resolve({
        totalLecturas: countRequest.result,
      });
    };

    countRequest.onerror = () => reject(countRequest.error);
  });
};

/**
 * Elimina todas las lecturas (para testing o reset)
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @returns {Promise<void>}
 */
export const limpiarTodo = async (db) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);

    const request = store.clear();

    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
};

/**
 * Obtiene los timestamps existentes en un rango para evitar duplicados
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @param {string} zona - "superior" o "inferior"
 * @param {number} desde - Timestamp inicial (ms)
 * @param {number} hasta - Timestamp final (ms)
 * @returns {Promise<Set<number>>} - Set de timestamps existentes
 */
export const obtenerTimestampsExistentes = async (
  db,
  alimentadorId,
  zona,
  desde,
  hasta
) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("alimZonaTimestamp");

    const rango = IDBKeyRange.bound(
      [alimentadorId, zona, desde],
      [alimentadorId, zona, hasta]
    );

    const request = index.getAll(rango);

    request.onsuccess = () => {
      const timestamps = new Set(request.result.map((r) => r.timestamp));
      resolve(timestamps);
    };

    request.onerror = () => reject(request.error);
  });
};

/**
 * Cachea datos remotos en IndexedDB, evitando duplicados por timestamp
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @param {string} registradorId - ID del registrador
 * @param {string} zona - "superior" o "inferior"
 * @param {Array} lecturas - Array de lecturas remotas a cachear
 * @returns {Promise<number>} - Cantidad de lecturas nuevas guardadas
 */
export const cachearLecturasRemotas = async (
  db,
  alimentadorId,
  registradorId,
  zona,
  lecturas
) => {
  if (!lecturas || lecturas.length === 0) return 0;

  // Obtener rango de timestamps de las lecturas a cachear
  const timestamps = lecturas.map((l) =>
    typeof l.timestamp === "string" ? new Date(l.timestamp).getTime() : l.timestamp
  );
  const desde = Math.min(...timestamps);
  const hasta = Math.max(...timestamps);

  // Obtener timestamps que ya existen en local
  const existentes = await obtenerTimestampsExistentes(
    db,
    alimentadorId,
    zona,
    desde,
    hasta
  );

  // Filtrar solo las lecturas nuevas
  const lecturasNuevas = lecturas.filter((l) => {
    const ts = typeof l.timestamp === "string" ? new Date(l.timestamp).getTime() : l.timestamp;
    return !existentes.has(ts);
  });

  if (lecturasNuevas.length === 0) return 0;

  // Guardar las nuevas en una transacci√≥n
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);
    let guardadas = 0;

    tx.oncomplete = () => resolve(guardadas);
    tx.onerror = () => reject(tx.error);

    for (const lectura of lecturasNuevas) {
      const ts = typeof lectura.timestamp === "string"
        ? new Date(lectura.timestamp).getTime()
        : lectura.timestamp;

      const registro = {
        alimentadorId,
        registradorId,
        zona,
        timestamp: ts,
        valores: lectura.valores,
        indiceInicial: lectura.indice_inicial ?? lectura.indiceInicial ?? 0,
        exito: lectura.exito !== false,
        createdAt: Date.now(),
        fromCache: true, // Marca para identificar datos cacheados
      };

      const request = store.add(registro);
      request.onsuccess = () => guardadas++;
    }
  });
};

========== mi-app/src/paginas/PaginaLogin/PaginaLogin.jsx ==========
// src/paginas/PaginaLogin/PaginaLogin.jsx

import React, { useState, useEffect, useRef } from "react";
import { Link, useNavigate } from "react-router-dom";
import { useAuth } from "../../contextos/AuthContext";
import { Capacitor } from "@capacitor/core";
import { BiometricAuth } from "@aparajita/capacitor-biometric-auth";
import "./PaginaLogin.css";
import logoApp from "../../assets/imagenes/logo 2 rw.png";

const STORAGE_KEY = "relaywatch_recordarme";

// Icono ojo abierto
const EyeIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
    <circle cx="12" cy="12" r="3"/>
  </svg>
);

// Icono ojo tachado
const EyeOffIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
    <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a21.8 21.8 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a21.8 21.8 0 0 1-2.16 3.19M1 1l22 22"/>
  </svg>
);

const PaginaLogin = () => {
  const [email, setEmail] = useState("");
  const [contrasena, setContrasena] = useState("");
  const [mostrarContrasena, setMostrarContrasena] = useState(false);
  const [recordarme, setRecordarme] = useState(false);
  const [alerta, setAlerta] = useState({ mensaje: "", tipo: "" });
  const [cargando, setCargando] = useState(false);

  // Ref para saber si las credenciales vienen del localStorage (precargadas)
  const credencialesPrecargadas = useRef(false);
  const biometriaYaIntentada = useRef(false);

  const { login } = useAuth();
  const navigate = useNavigate();

  // Cargar credenciales guardadas al montar
  useEffect(() => {
    const guardado = localStorage.getItem(STORAGE_KEY);
    if (guardado) {
      try {
        const { email: emailGuardado, contrasena: contrasenaGuardada } = JSON.parse(guardado);
        if (emailGuardado && contrasenaGuardada) {
          setEmail(emailGuardado);
          setContrasena(contrasenaGuardada);
          setRecordarme(true);
          credencialesPrecargadas.current = true;
        }
      } catch {
        localStorage.removeItem(STORAGE_KEY);
      }
    }
  }, []);

  // Mostrar alerta temporal
  const mostrarAlerta = (mensaje, tipo = "error") => {
    setAlerta({ mensaje, tipo });
    setTimeout(() => {
      setAlerta({ mensaje: "", tipo: "" });
    }, 4000);
  };

  // Mostrar prompt de biometr√≠a autom√°ticamente SOLO si hay credenciales precargadas
  useEffect(() => {
    const intentarBiometria = async () => {
      // Solo ejecutar si:
      // 1. Las credenciales vienen precargadas del localStorage
      // 2. No se ha intentado ya la biometr√≠a
      // 3. Estamos en plataforma nativa
      if (!credencialesPrecargadas.current || biometriaYaIntentada.current) return;
      if (!Capacitor.isNativePlatform()) return;

      biometriaYaIntentada.current = true;

      try {
        const info = await BiometricAuth.checkBiometry();
        if (!info.isAvailable) return;

        await BiometricAuth.authenticate({
          reason: "Inicia sesi√≥n con tu huella digital",
          cancelTitle: "Cancelar",
          allowDeviceCredential: true,
        });

        // Biometr√≠a exitosa, hacer login autom√°tico
        setCargando(true);
        const { exito, error } = await login(email.trim(), contrasena);
        setCargando(false);

        if (!exito) {
          mostrarAlerta(error || "Error al iniciar sesi√≥n", "error");
          return;
        }

        localStorage.setItem(STORAGE_KEY, JSON.stringify({ email: email.trim(), contrasena }));
        mostrarAlerta("¬°Bienvenido!", "exito");

        setTimeout(() => {
          navigate("/alimentadores");
        }, 1200);
      } catch {
        // Usuario cancel√≥ o error de biometr√≠a - no mostrar error
      }
    };

    // Peque√±o delay para que la UI se renderice primero
    const timer = setTimeout(intentarBiometria, 500);
    return () => clearTimeout(timer);
  }, [email, contrasena, login, navigate]);

  // Manejo del submit del formulario
  const handleSubmit = async (event) => {
    event.preventDefault();

    if (!email.trim() || !contrasena.trim()) {
      mostrarAlerta("Por favor completa todos los campos", "error");
      return;
    }

    setCargando(true);

    const { exito, error } = await login(email.trim(), contrasena);

    setCargando(false);

    if (!exito) {
      mostrarAlerta(error || "Error al iniciar sesi√≥n", "error");
      return;
    }

    // Guardar o limpiar credenciales seg√∫n checkbox
    if (recordarme) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ email: email.trim(), contrasena }));
    } else {
      localStorage.removeItem(STORAGE_KEY);
    }

    mostrarAlerta("¬°Bienvenido!", "exito");

    setTimeout(() => {
      navigate("/alimentadores");
    }, 1200);
  };

  return (
    <form onSubmit={handleSubmit} className="login-form">
      <div className="container">
        <div className="izquierda">
          <img
            src={logoApp}
            alt="logoApp"
            className="logo"
          />
        </div>

        <div className="derecha">
          <div className="login">
            <h3 className="usuario">EMAIL</h3>

            <input
              className="input"
              type="email"
              placeholder="Ingrese su email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              autoComplete="email"
              disabled={cargando}
            />

            <h3 className="usuario">CONTRASE√ëA</h3>
            <div className="input-contrase√±a">
              <input
                className="input"
                type={mostrarContrasena ? "text" : "password"}
                placeholder="Ingrese su contrase√±a"
                value={contrasena}
                onChange={(e) => setContrasena(e.target.value)}
                autoComplete="current-password"
                disabled={cargando}
              />
              <span
                onClick={() => setMostrarContrasena(!mostrarContrasena)}
                className='ojito'
              >
                {mostrarContrasena ? <EyeIcon /> : <EyeOffIcon />}
              </span>
            </div>

            <label className="checkbox-recordarme">
              <input
                type="checkbox"
                checked={recordarme}
                onChange={(e) => setRecordarme(e.target.checked)}
                disabled={cargando}
              />
              <span>Recordarme</span>
            </label>

            <div className="acciones">
              <button
                type="submit"
                className="boton"
                disabled={cargando}
              >
                {cargando ? "Iniciando sesi√≥n..." : "Iniciar sesi√≥n"}
              </button>

              <Link to="/recuperarContrase√±a" className="recordarme">
                ¬øOlvidaste tu contrase√±a?
              </Link>

              <Link to="/registro" className="registrarse">
                ¬øNo tienes cuenta? reg√≠strate
              </Link>
            </div>
          </div>
        </div>
      </div>

      {alerta.mensaje && (
        <div className={`alerta alerta-${alerta.tipo}`}>
          {alerta.mensaje}
        </div>
      )}
    </form>
  );
};

export default PaginaLogin;

========== mi-app/src/paginas/PaginaRecuperar/recuperarContrase√±a.jsx ==========
// src/paginas/PaginaRecuperar/recuperarContrase√±a.jsx

import { useState } from "react";                  // hook para manejar estado local (email y alertas)
import { useNavigate } from "react-router-dom";    // navegaci√≥n: volver a /login u otras rutas
import "./recuperarContrase√±a.css";                // estilos espec√≠ficos de la pantalla de recuperaci√≥n
import logoApp from "../../assets/imagenes/logo 2 rw.png";

const RecuperarContrasena = () => {
   const [email, setEmail] = useState("");         // email que escribe el usuario
   const [alerta, setAlerta] = useState({
      mensaje: "",
      tipo: "",
   });                                             // alerta de √©xito o error (controla color y texto)

   const navigate = useNavigate();                 // hook para redirigir de vuelta al login

   const mostrarAlerta = (mensaje, tipo = "exito") => {
      setAlerta({ mensaje, tipo });                // muestra alerta con mensaje y tipo
      setTimeout(() => setAlerta({ mensaje: "", tipo: "" }), 5000); // la oculta a los 5 segundos
   };

   const handleSubmit = (e) => {
      e.preventDefault();                          // evita recarga completa de la p√°gina

      if (!email.trim()) {
         // Validaci√≥n: campo vac√≠o
         mostrarAlerta("Por favor escrib√≠ tu email", "error");
         return;
      }

      if (!email.includes("@") || !email.includes(".")) {
         // Validaci√≥n muy b√°sica de formato de email
         mostrarAlerta("El email no parece v√°lido", "error");
         return;
      }

      mostrarAlerta(`Listo! Te enviamos un enlace a ${email}`, "exito");

      setTimeout(() => {
         navigate("/");                            // despu√©s de 3 segundos volvemos al login
      }, 3000);
   };

   return (
      <div className="recuperar-fondo">
         <div className="recuperar-caja">
            <button
               className="btn-volver"
               onClick={() => navigate("/")}       // vuelve a la pantalla de inicio de sesi√≥n
            >
               ‚Üê Volver al inicio de sesi√≥n
            </button>

            <img
               src={logoApp}
               alt="Logo"
               className="logo-recuperar"
            />

            <h2 className="h2-Recuperar">Recuperar contrase√±a</h2>

            <p className="texto-ayuda">
               Ingres√° tu email y te enviaremos un enlace para crear una nueva
               contrase√±a.
            </p>

            <form onSubmit={handleSubmit}>
               <input
                  type="text"
                  placeholder="tuemail@ejemplo.com"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)} // actualiza el estado con lo que escribe el usuario
                  className="input-recuperar"
               />
               <button type="submit" className="btn-enviar">
                  Enviar enlace
               </button>
            </form>

            {alerta.mensaje && (
               <div className={`alerta alerta-${alerta.tipo}`}>
                  {alerta.mensaje}
               </div>
            )}
         </div>
      </div>
   );
};

export default RecuperarContrasena;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (recuperarContrase√±a.jsx)

 - Pantalla sencilla para simular el flujo de "Recuperar contrase√±a". No
   env√≠a correos reales, s√≥lo muestra un mensaje de confirmaci√≥n.

 - `email` guarda lo que escribe el usuario; `alerta` controla el texto y el
   color (√©xito/error) del mensaje que aparece debajo del formulario.

 - `handleSubmit` valida que el email no est√© vac√≠o y tenga al menos un "@" y
   un ".", luego muestra una alerta de √©xito y, tras 3 segundos, vuelve al
   login (`navigate("/")`).

 - El bot√≥n "‚Üê Volver al inicio de sesi√≥n" permite regresar al login sin
   enviar nada, usando tambi√©n `navigate("/")`.

 - Todo el aspecto visual (fondo, caja, colores de alerta, etc.) se define en
   `recuperarContrase√±a.css`.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (recuperarContrase√±a.jsx)

0) Visi√≥n general de la pantalla

   - RecuperarContrasena implementa una pantalla sencilla para simular el
     flujo de ‚ÄúRecuperar contrase√±a‚Äù.

   - No env√≠a correos reales: valida m√≠nimamente el email, muestra un mensaje
     de confirmaci√≥n y luego redirige de vuelta al login.

   - Toda la parte visual (fondo, caja central, colores de alerta, etc.)
     se define en el archivo de estilos `recuperarContrase√±a.css`.

1) Imports y setup b√°sico

   import { useState } from "react";
   import { Link, useNavigate } from "react-router-dom";
   import "./recuperarContrase√±a.css";

   - useState:
       ‚Ä¢ se usa para manejar el email escrito por el usuario y la estructura
         de alerta (mensaje + tipo).

   - useNavigate:
       ‚Ä¢ permite redirigir program√°ticamente a otra ruta (en este caso, al
         inicio de sesi√≥n "/").

   - El CSS asociado encapsula el look & feel de esta pantalla (fondo difuminado,
     caja centrada, tama√±os de fuente, colores de botones, etc.).

2) Estado interno del componente

   const [email, setEmail] = useState("");
   const [alerta, setAlerta] = useState({ mensaje: "", tipo: "" });

   - email:
       ‚Ä¢ refleja el contenido del input de texto donde el usuario escribe
         su direcci√≥n de correo.
       ‚Ä¢ se actualiza en cada pulsaci√≥n mediante onChange.

   - alerta:
       ‚Ä¢ es un objeto con dos propiedades:
           - mensaje: texto que se muestra al usuario (por ejemplo,
             ‚ÄúPor favor escrib√≠ tu email‚Äù, ‚ÄúListo! Te enviamos un enlace a ...‚Äù).
           - tipo: ‚Äúexito‚Äù o ‚Äúerror‚Äù, que luego se usa como sufijo en la clase
             CSS (alerta-exito / alerta-error).
       ‚Ä¢ cuando mensaje est√° vac√≠o, la alerta no se muestra en la interfaz.

3) Navegaci√≥n con useNavigate

   const navigate = useNavigate();

   - navigate:
       ‚Ä¢ funci√≥n que permite cambiar de ruta desde c√≥digo.
       ‚Ä¢ ac√° se usa para volver al login ("/") tanto desde el bot√≥n de ‚ÄúVolver‚Äù
         como despu√©s de un env√≠o exitoso del formulario.

4) Helper mostrarAlerta(mensaje, tipo)

   const mostrarAlerta = (mensaje, tipo = "exito") => {
      setAlerta({ mensaje, tipo });
      setTimeout(() => setAlerta({ mensaje: "", tipo: "" }), 5000);
   };

   - Recibe un texto y un tipo (‚Äúexito‚Äù por defecto).

   - Actualiza el estado alerta para que la UI muestre un cartel de feedback.

   - Luego de 5 segundos, limpia el estado para ocultar ese cartel
     autom√°ticamente, sin que el usuario tenga que cerrarlo.

5) Manejo del submit del formulario (handleSubmit)

   const handleSubmit = (e) => {
      e.preventDefault();
      ...
   };

   5.1) Evitar recarga de p√°gina

   - e.preventDefault() cancela el comportamiento por defecto del formulario
     (recargar la p√°gina completa).

   5.2) Validaciones b√°sicas

   - Primera validaci√≥n: campo vac√≠o
       if (!email.trim()) {
         mostrarAlerta("Por favor escrib√≠ tu email", "error");
         return;
       }

       ‚Ä¢ trim() elimina espacios al principio y al final.
       ‚Ä¢ Si el resultado queda vac√≠o, se muestra un mensaje de error pidiendo
         que el usuario escriba su email.

   - Segunda validaci√≥n: formato muy b√°sico
       if (!email.includes("@") || !email.includes(".")) {
         mostrarAlerta("El email no parece v√°lido", "error");
         return;
       }

       ‚Ä¢ No es una validaci√≥n ‚Äúreal‚Äù de RFC, s√≥lo verifica que exista ‚Äú@‚Äù
         y un punto, suficiente para un TP o demo.

   5.3) Simulaci√≥n de env√≠o y redirecci√≥n

   - Si pasa las validaciones:
       mostrarAlerta(`Listo! Te enviamos un enlace a ${email}`, "exito");

       ‚Ä¢ Se muestra un mensaje de √©xito usando el email que escribi√≥ el usuario.
       ‚Ä¢ No se hace ning√∫n request real; el env√≠o es puramente simulado.

   - Luego:
       setTimeout(() => {
         navigate("/");
       }, 3000);

       ‚Ä¢ Espera 3 segundos y redirige al login (ruta "/").
       ‚Ä¢ Da tiempo a que el usuario lea la confirmaci√≥n antes de regresar.

6) Estructura visual del componente (render)

   return (
      <div className="recuperar-fondo">
         <div className="recuperar-caja">
            ...
         </div>
      </div>
   );

   - recuperar-fondo:
       ‚Ä¢ contenedor que suele ocupar toda la pantalla, con un fondo de color
         o imagen. Centra la caja principal en el viewport.

   - recuperar-caja:
       ‚Ä¢ tarjeta o panel donde se muestra el contenido de recuperaci√≥n.

   6.1) Bot√≥n ‚ÄúVolver al inicio de sesi√≥n‚Äù

   <button
     className="btn-volver"
     onClick={() => navigate("/")}
   >
     ‚Üê Volver al inicio de sesi√≥n
   </button>

   - Permite regresar inmediatamente al login sin enviar el formulario.

   - Usa navigate("/") para cambiar de ruta.

   6.2) Logo y t√≠tulos

   <img src={logoApp} ... />
   <h2 className="h2-Recuperar">Recuperar contrase√±a</h2>
   <p className="texto-ayuda">...</p>

   - Refuerzan la identidad visual de la app y explican brevemente qu√© debe
     hacer el usuario (ingresar su email para recibir un enlace).

   6.3) Formulario de email

   <form onSubmit={handleSubmit}>
      <input
         type="text"
         placeholder="tuemail@ejemplo.com"
         value={email}
         onChange={(e) => setEmail(e.target.value)}
         className="input-recuperar"
      />
      <button type="submit" className="btn-enviar">
         Enviar enlace
      </button>
   </form>

   - El input est√° controlado por el estado email.

   - Cada pulsaci√≥n dispara setEmail con el nuevo valor.

   - Al presionar el bot√≥n ‚ÄúEnviar enlace‚Äù:
       ‚Ä¢ se dispara handleSubmit,
       ‚Ä¢ se ejecutan las validaciones,
       ‚Ä¢ se muestra la alerta adecuada,
       ‚Ä¢ eventualmente se redirige al login.

   6.4) Alerta de feedback

   {alerta.mensaje && (
      <div className={`alerta alerta-${alerta.tipo}`}>
         {alerta.mensaje}
      </div>
   )}

   - S√≥lo se renderiza si alerta.mensaje no est√° vac√≠o.
	
   - Usa dos clases:
       ‚Ä¢ alerta: estilos comunes (posici√≥n, padding, borde, etc.),
       ‚Ä¢ alerta-{tipo}: variaciones seg√∫n ‚Äúexito‚Äù o ‚Äúerror‚Äù
         (colores verde/rojo, iconos distintos, etc.).

7) Resumen conceptual

   - Este componente representa un paso ‚Äúligero‚Äù de recuperaci√≥n de contrase√±a:
       ‚Ä¢ Comprueba que el usuario introduzca un email con un formato m√≠nimo.
       ‚Ä¢ Muestra un mensaje de feedback claro (√©xito o error).
       ‚Ä¢ No gestiona credenciales reales ni integra un backend de correo,
         sino que sirve como maqueta funcional para el flujo de UX.

   - Su responsabilidad se limita a:
       ‚Ä¢ controlar el estado del input,
       ‚Ä¢ validar ese estado,
       ‚Ä¢ mostrar feedback al usuario,
       ‚Ä¢ decidir cu√°ndo y ad√≥nde navegar.
---------------------------------------------------------------------------*/
========== mi-app/src/paginas/PaginaRegistro/PaginaRegistro.jsx ==========
// src/paginas/PaginaRegistro/PaginaRegistro.jsx

import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../contextos/AuthContext";
import "../PaginaLogin/PaginaLogin.css";
import "./PaginaRegistro.css";
import logoApp from "../../assets/imagenes/logo 2 rw.png";

const PaginaRegistro = () => {
  const [nombre, setNombre] = useState("");
  const [email, setEmail] = useState("");
  const [contrasena, setContrasena] = useState("");
  const [confirmar, setConfirmar] = useState("");
  const [errores, setErrores] = useState({});
  const [alerta, setAlerta] = useState({ mensaje: "", tipo: "" });
  const [cargando, setCargando] = useState(false);

  const { registro } = useAuth();
  const navigate = useNavigate();

  // Mostrar alerta temporal
  const mostrarAlerta = (mensaje, tipo = "error") => {
    setAlerta({ mensaje, tipo });
    setTimeout(() => {
      setAlerta({ mensaje: "", tipo: "" });
    }, 5000);
  };

  // Validaci√≥n por campo
  const validarCampo = (campo) => {
    let mensaje = "";

    switch (campo) {
      case "nombre":
        if (!nombre.trim()) {
          mensaje = "El nombre es obligatorio.";
        } else if (nombre.trim().length < 3) {
          mensaje = "El nombre debe tener al menos 3 caracteres.";
        }
        break;

      case "email":
        if (!email.trim()) {
          mensaje = "El email es obligatorio.";
        } else {
          const regexEmail = /^\S+@\S+\.\S+$/;
          if (!regexEmail.test(email)) {
            mensaje = "El formato de email no es v√°lido.";
          }
        }
        break;

      case "contrasena":
        if (!contrasena) {
          mensaje = "La contrase√±a es obligatoria.";
        } else if (contrasena.length < 6) {
          mensaje = "La contrase√±a debe tener al menos 6 caracteres.";
        }
        break;

      case "confirmar":
        if (!confirmar) {
          mensaje = "Debes confirmar la contrase√±a.";
        } else if (confirmar !== contrasena) {
          mensaje = "Las contrase√±as no coinciden.";
        }
        break;

      default:
        break;
    }

    setErrores((prev) => {
      const next = { ...prev };
      if (mensaje) {
        next[campo] = mensaje;
      } else {
        delete next[campo];
      }
      return next;
    });

    return mensaje;
  };

  // Validaci√≥n al salir de cada input
  const handleBlur = (campo) => {
    validarCampo(campo);
  };

  // Validaci√≥n global del formulario
  const validarTodo = () => {
    const campos = ["nombre", "email", "contrasena", "confirmar"];
    const mensajes = campos.map((c) => validarCampo(c));
    return mensajes.every((m) => m === "");
  };

  // Env√≠o del formulario
  const handleSubmit = async (event) => {
    event.preventDefault();

    if (!validarTodo()) {
      return;
    }

    setCargando(true);

    const { exito, error, requiereConfirmacion } = await registro(
      email.trim().toLowerCase(),
      contrasena,
      nombre.trim()
    );

    setCargando(false);

    if (!exito) {
      mostrarAlerta(error || "Error al crear la cuenta", "error");
      return;
    }

    if (requiereConfirmacion) {
      mostrarAlerta(
        "¬°Cuenta creada! Revisa tu email para confirmar tu cuenta antes de iniciar sesi√≥n.",
        "exito"
      );
    } else {
      mostrarAlerta("¬°Cuenta creada con √©xito!", "exito");
    }

    // Limpiar formulario
    setNombre("");
    setEmail("");
    setContrasena("");
    setConfirmar("");
    setErrores({});

    // Volver al login despu√©s de un momento
    setTimeout(() => {
      navigate("/");
    }, 3000);
  };

  // Bot√≥n "Volver"
  const handleVolver = () => {
    navigate("/");
  };

  return (
    <form onSubmit={handleSubmit} className="login-form registro-page">
      <div className="container">
        <div className="izquierda">
          <img
            src={logoApp}
            alt="logoApp"
            className="logo"
          />
        </div>

        <div className="derecha">
          <div className="login">
            <button
              type="button"
              className="btn-volver"
              onClick={handleVolver}
              disabled={cargando}
            >
              ‚Üê Volver
            </button>

            <h2 className="titulo-registro">REGISTRO</h2>

            <h3 className="label-registro">Nombre completo</h3>
            <input
              className={`input ${errores.nombre ? "input-error" : ""}`}
              type="text"
              placeholder="Ingrese su nombre"
              value={nombre}
              onChange={(e) => setNombre(e.target.value)}
              onBlur={() => handleBlur("nombre")}
              disabled={cargando}
            />
            {errores.nombre && (
              <p className="error-text">{errores.nombre}</p>
            )}

            <h3 className="label-registro">Email</h3>
            <input
              className={`input ${errores.email ? "input-error" : ""}`}
              type="email"
              placeholder="Ingrese su email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              onBlur={() => handleBlur("email")}
              disabled={cargando}
            />
            {errores.email && (
              <p className="error-text">{errores.email}</p>
            )}

            <h3 className="label-registro">Contrase√±a</h3>
            <input
              className={`input ${errores.contrasena ? "input-error" : ""}`}
              type="password"
              placeholder="Ingrese su contrase√±a (m√≠n. 6 caracteres)"
              value={contrasena}
              onChange={(e) => setContrasena(e.target.value)}
              onBlur={() => handleBlur("contrasena")}
              disabled={cargando}
            />
            {errores.contrasena && (
              <p className="error-text">{errores.contrasena}</p>
            )}

            <h3 className="label-registro">Confirmar contrase√±a</h3>
            <input
              className={`input ${errores.confirmar ? "input-error" : ""}`}
              type="password"
              placeholder="Repita su contrase√±a"
              value={confirmar}
              onChange={(e) => setConfirmar(e.target.value)}
              onBlur={() => handleBlur("confirmar")}
              disabled={cargando}
            />
            {errores.confirmar && (
              <p className="error-text">{errores.confirmar}</p>
            )}

            <div className="acciones">
              <button
                type="submit"
                className="boton"
                disabled={cargando}
              >
                {cargando ? "Creando cuenta..." : "Crear cuenta"}
              </button>
            </div>
          </div>
        </div>
      </div>

      {alerta.mensaje && (
        <div className={`alerta alerta-${alerta.tipo}`}>
          {alerta.mensaje}
        </div>
      )}
    </form>
  );
};

export default PaginaRegistro;

========== mi-app/src/servicios/apiService.js ==========
// src/servicios/apiService.js
// Servicio para comunicaci√≥n con el backend API

import { supabase } from '../lib/supabase';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

/**
 * Obtiene el token de autenticaci√≥n actual
 */
async function obtenerToken() {
  const { data: { session } } = await supabase.auth.getSession();
  return session?.access_token || null;
}

/**
 * Realiza una petici√≥n al backend con autenticaci√≥n
 */
async function fetchConAuth(endpoint, opciones = {}) {
  const token = await obtenerToken();

  if (!token) {
    throw new Error('No hay sesi√≥n activa');
  }

  const respuesta = await fetch(`${API_URL}${endpoint}`, {
    ...opciones,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
      ...opciones.headers,
    },
  });

  const datos = await respuesta.json();

  if (!respuesta.ok) {
    throw new Error(datos.error || 'Error en la petici√≥n');
  }

  return datos;
}

// ============================================
// USUARIOS
// ============================================

/**
 * Obtiene el perfil del usuario autenticado (incluye rol global)
 */
export async function obtenerPerfil() {
  return fetchConAuth('/api/usuarios/perfil');
}

/**
 * Crea el perfil del usuario despu√©s del registro en Supabase Auth
 * Se debe llamar inmediatamente despu√©s de signUp exitoso
 * @param {string} nombre - Nombre del usuario
 */
export async function crearPerfilUsuario(nombre) {
  return fetchConAuth('/api/usuarios/perfil', {
    method: 'POST',
    body: JSON.stringify({ nombre }),
  });
}

/**
 * Actualiza el workspace por defecto del usuario
 * @param {string|null} workspaceId - ID del workspace o null para quitar el default
 */
export async function actualizarWorkspaceDefault(workspaceId) {
  return fetchConAuth('/api/usuarios/workspace-default', {
    method: 'PUT',
    body: JSON.stringify({ workspaceId }),
  });
}

// ============================================
// WORKSPACES
// ============================================

/**
 * Obtiene todos los workspaces del usuario
 */
export async function obtenerWorkspaces() {
  return fetchConAuth('/api/workspaces');
}

/**
 * Crea un nuevo workspace
 */
export async function crearWorkspace(nombre, descripcion = '') {
  return fetchConAuth('/api/workspaces', {
    method: 'POST',
    body: JSON.stringify({ nombre, descripcion }),
  });
}

/**
 * Actualiza un workspace
 */
export async function actualizarWorkspace(id, datos) {
  return fetchConAuth(`/api/workspaces/${id}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un workspace
 */
export async function eliminarWorkspace(id) {
  return fetchConAuth(`/api/workspaces/${id}`, {
    method: 'DELETE',
  });
}

// ============================================
// PUESTOS
// ============================================

/**
 * Obtiene los puestos de un workspace
 */
export async function obtenerPuestos(workspaceId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/puestos`);
}

/**
 * Crea un nuevo puesto
 */
export async function crearPuesto(workspaceId, datos) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/puestos`, {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

/**
 * Actualiza un puesto
 */
export async function actualizarPuesto(puestoId, datos) {
  return fetchConAuth(`/api/puestos/${puestoId}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un puesto
 */
export async function eliminarPuesto(puestoId) {
  return fetchConAuth(`/api/puestos/${puestoId}`, {
    method: 'DELETE',
  });
}

/**
 * Reordena los puestos
 */
export async function reordenarPuestos(workspaceId, ordenIds) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/puestos/reordenar`, {
    method: 'PUT',
    body: JSON.stringify({ orden: ordenIds }),
  });
}

// ============================================
// ALIMENTADORES
// ============================================

/**
 * Obtiene los alimentadores de un puesto
 */
export async function obtenerAlimentadores(puestoId) {
  return fetchConAuth(`/api/puestos/${puestoId}/alimentadores`);
}

/**
 * Crea un nuevo alimentador
 */
export async function crearAlimentador(puestoId, datos) {
  return fetchConAuth(`/api/puestos/${puestoId}/alimentadores`, {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

/**
 * Actualiza un alimentador
 */
export async function actualizarAlimentadorAPI(alimentadorId, datos) {
  return fetchConAuth(`/api/alimentadores/${alimentadorId}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un alimentador
 */
export async function eliminarAlimentadorAPI(alimentadorId) {
  return fetchConAuth(`/api/alimentadores/${alimentadorId}`, {
    method: 'DELETE',
  });
}

/**
 * Reordena los alimentadores de un puesto
 * @param {number} puestoId - ID del puesto
 * @param {number[]} ordenIds - Array de IDs de alimentadores en el nuevo orden
 */
export async function reordenarAlimentadores(puestoId, ordenIds) {
  // El backend espera { ordenes: [{ id, orden }, ...] }
  const ordenes = ordenIds.map((id, index) => ({ id, orden: index }));

  return fetchConAuth(`/api/puestos/${puestoId}/alimentadores/reordenar`, {
    method: 'PUT',
    body: JSON.stringify({ ordenes }),
  });
}

/**
 * Mueve un alimentador a otro puesto
 */
export async function moverAlimentador(alimentadorId, nuevoPuestoId) {
  return fetchConAuth(`/api/alimentadores/${alimentadorId}/mover`, {
    method: 'PUT',
    body: JSON.stringify({ nuevo_puesto_id: nuevoPuestoId }),
  });
}

// ============================================
// LECTURAS
// ============================================

/**
 * Obtiene las √∫ltimas lecturas de un alimentador
 */
export async function obtenerUltimasLecturas(alimentadorId, tipo = null, limite = 1) {
  let url = `/api/alimentadores/${alimentadorId}/lecturas?limite=${limite}`;
  if (tipo) {
    url += `&tipo=${tipo}`;
  }
  return fetchConAuth(url);
}

/**
 * Obtiene lecturas hist√≥ricas de un alimentador
 */
export async function obtenerLecturasHistoricas(alimentadorId, desde, hasta, tipo = null) {
  let url = `/api/alimentadores/${alimentadorId}/lecturas/historico?desde=${desde}&hasta=${hasta}`;
  if (tipo) {
    url += `&tipo=${tipo}`;
  }
  return fetchConAuth(url);
}

/**
 * Obtiene las √∫ltimas lecturas de un registrador
 * @param {string} registradorId - ID del registrador
 * @param {number} limite - Cantidad de lecturas a obtener (default 1)
 */
export async function obtenerUltimasLecturasPorRegistrador(registradorId, limite = 1) {
  return fetchConAuth(`/api/registradores/${registradorId}/lecturas?limite=${limite}`);
}

/**
 * Obtiene lecturas hist√≥ricas de un registrador en un rango de tiempo
 * @param {string} registradorId - ID del registrador
 * @param {string} desde - Fecha ISO de inicio del rango
 * @param {string} hasta - Fecha ISO de fin del rango
 * @returns {Promise<Array>} Array de lecturas con indice_inicial incluido
 */
export async function obtenerLecturasHistoricasPorRegistrador(registradorId, desde, hasta) {
  return fetchConAuth(`/api/registradores/${registradorId}/lecturas/historico?desde=${desde}&hasta=${hasta}`);
}

// ============================================
// PREFERENCIAS
// ============================================

/**
 * Obtiene las preferencias del usuario para un workspace
 */
export async function obtenerPreferencias(workspaceId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/preferencias`);
}

/**
 * Guarda las preferencias del usuario
 */
export async function guardarPreferencias(workspaceId, preferencias) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/preferencias`, {
    method: 'POST',
    body: JSON.stringify(preferencias),
  });
}

// ============================================
// AGENTES (Legacy - mantener por compatibilidad)
// ============================================

/**
 * Obtiene el estado de vinculaci√≥n del workspace con un agente
 * @deprecated Usar listarAgentesWorkspace
 */
export async function obtenerEstadoAgente(workspaceId) {
  return fetchConAuth(`/api/agentes/estado?workspaceId=${workspaceId}`);
}

/**
 * Solicita un c√≥digo de vinculaci√≥n para conectar el workspace con un agente
 * @deprecated Usar vincularAgenteWorkspace
 */
export async function solicitarVinculacionAgente(workspaceId) {
  return fetchConAuth('/api/agentes/solicitar-vinculacion', {
    method: 'POST',
    body: JSON.stringify({ workspaceId }),
  });
}

/**
 * Desvincula el agente del workspace
 * @deprecated Usar desvincularAgenteWorkspace
 */
export async function desvincularAgente(workspaceId) {
  return fetchConAuth('/api/agentes/desvincular', {
    method: 'POST',
    body: JSON.stringify({ workspaceId }),
  });
}

/**
 * Rota la clave del agente (genera nueva, mantiene anterior por 24h)
 * @deprecated Usar rotarClaveAgentePorId
 */
export async function rotarClaveAgente(workspaceId) {
  return fetchConAuth('/api/agentes/rotar-clave', {
    method: 'POST',
    body: JSON.stringify({ workspaceId }),
  });
}

// ============================================
// AGENTES (Nueva arquitectura N:M)
// ============================================

// --- Panel Admin (solo superadmin) ---

/**
 * Lista todos los agentes del sistema (solo superadmin)
 */
export async function listarTodosLosAgentes() {
  return fetchConAuth('/api/admin/agentes');
}

/**
 * Crea un nuevo agente (solo superadmin)
 */
export async function crearAgente(nombre, descripcion = '') {
  return fetchConAuth('/api/admin/agentes', {
    method: 'POST',
    body: JSON.stringify({ nombre, descripcion }),
  });
}

/**
 * Actualiza un agente (solo superadmin)
 */
export async function actualizarAgente(agenteId, datos) {
  return fetchConAuth(`/api/admin/agentes/${agenteId}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un agente (solo superadmin)
 */
export async function eliminarAgente(agenteId) {
  return fetchConAuth(`/api/admin/agentes/${agenteId}`, {
    method: 'DELETE',
  });
}

/**
 * Rota la clave de un agente (solo superadmin)
 */
export async function rotarClaveAgentePorId(agenteId) {
  return fetchConAuth(`/api/admin/agentes/${agenteId}/rotar-clave`, {
    method: 'POST',
  });
}

// --- Agentes disponibles (admin+) ---

/**
 * Lista agentes disponibles para vincular (admin+)
 */
export async function listarAgentesDisponibles() {
  return fetchConAuth('/api/agentes/disponibles');
}

// --- Vinculaci√≥n workspace-agente (N:M) ---

/**
 * Lista agentes vinculados a un workspace
 */
export async function listarAgentesWorkspace(workspaceId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/agentes`);
}

/**
 * Vincula un agente a un workspace (admin+)
 */
export async function vincularAgenteWorkspace(workspaceId, agenteId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/agentes`, {
    method: 'POST',
    body: JSON.stringify({ agenteId }),
  });
}

/**
 * Desvincula un agente de un workspace (admin+)
 */
export async function desvincularAgenteWorkspace(workspaceId, agenteId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/agentes/${agenteId}`, {
    method: 'DELETE',
  });
}

// --- Registradores de un agente (solo superadmin) ---

/**
 * Lista registradores de un agente espec√≠fico
 */
export async function listarRegistradoresAgente(agenteId) {
  return fetchConAuth(`/api/agentes/${agenteId}/registradores`);
}

/**
 * Crea un registrador para un agente (solo superadmin)
 */
export async function crearRegistradorAgente(agenteId, datos) {
  return fetchConAuth(`/api/agentes/${agenteId}/registradores`, {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

/**
 * Actualiza un registrador de un agente (solo superadmin)
 */
export async function actualizarRegistradorAgente(agenteId, registradorId, datos) {
  return fetchConAuth(`/api/agentes/${agenteId}/registradores/${registradorId}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un registrador de un agente (solo superadmin)
 */
export async function eliminarRegistradorAgente(agenteId, registradorId) {
  return fetchConAuth(`/api/agentes/${agenteId}/registradores/${registradorId}`, {
    method: 'DELETE',
  });
}

/**
 * Toggle activo de un registrador (solo superadmin)
 */
export async function toggleRegistradorAgente(agenteId, registradorId) {
  return fetchConAuth(`/api/agentes/${agenteId}/registradores/${registradorId}/toggle`, {
    method: 'POST',
  });
}

/**
 * Solicita un test de conexi√≥n para un registrador (ejecutado por el agente)
 * @param {string} agenteId - ID del agente que ejecutar√° el test
 * @param {object} datos - Datos del test: ip, puerto, unitId, indiceInicial, cantidadRegistros
 * @returns {Promise<{testId: string, mensaje: string, timeoutSegundos: number}>}
 */
export async function solicitarTestRegistrador(agenteId, datos) {
  return fetchConAuth(`/api/agentes/${agenteId}/test-registrador`, {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

/**
 * Consulta el estado/resultado de un test de registrador
 * @param {string} agenteId - ID del agente
 * @param {string} testId - ID del test
 * @returns {Promise<{estado: string, valores?: number[], error_mensaje?: string, tiempo_respuesta_ms?: number}>}
 */
export async function consultarTestRegistrador(agenteId, testId) {
  return fetchConAuth(`/api/agentes/${agenteId}/test-registrador/${testId}`);
}

/**
 * Solicita un test de lectura de coils (Modbus funci√≥n 01)
 * Para leer estados de protecciones como bits individuales
 * @param {string} agenteId - ID del agente que ejecutar√° el test
 * @param {object} datos - Datos del test: ip, puerto, unitId, direccionCoil, cantidadBits
 * @returns {Promise<{testId: string, mensaje: string, timeoutSegundos: number}>}
 */
export async function solicitarTestCoils(agenteId, datos) {
  return fetchConAuth(`/api/agentes/${agenteId}/test-coils`, {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

// ============================================
// TEST DE CONEXI√ìN MODBUS
// ============================================

/**
 * Prueba la conexi√≥n a un dispositivo Modbus y lee registros
 * @param {string} ip - Direcci√≥n IP del dispositivo
 * @param {number} puerto - Puerto Modbus (usualmente 502)
 * @param {number} unitId - ID de unidad Modbus (por defecto 1)
 * @param {number} indiceInicial - Primer registro a leer (por defecto 0)
 * @param {number} cantRegistros - Cantidad de registros a leer (por defecto 10)
 * @returns {Promise<{exito: boolean, mensaje?: string, error?: string, registros?: Array, tiempoMs?: number}>}
 */
export async function testConexionModbus(ip, puerto, unitId = 1, indiceInicial = 0, cantRegistros = 10) {
  return fetchConAuth('/api/test-conexion', {
    method: 'POST',
    body: JSON.stringify({ ip, puerto, unitId, indiceInicial, cantRegistros }),
  });
}

// ============================================
// REGISTRADORES
// ============================================

/**
 * Obtiene los registradores del workspace
 */
export async function obtenerRegistradores(workspaceId) {
  return fetchConAuth(`/api/registradores?workspaceId=${workspaceId}`);
}

/**
 * Crea un nuevo registrador
 */
export async function crearRegistrador(datos) {
  return fetchConAuth('/api/registradores', {
    method: 'POST',
    body: JSON.stringify(datos),
  });
}

/**
 * Actualiza un registrador
 */
export async function actualizarRegistrador(registradorId, datos) {
  return fetchConAuth(`/api/registradores/${registradorId}`, {
    method: 'PUT',
    body: JSON.stringify(datos),
  });
}

/**
 * Elimina un registrador
 */
export async function eliminarRegistrador(registradorId, workspaceId) {
  return fetchConAuth(`/api/registradores/${registradorId}?workspaceId=${workspaceId}`, {
    method: 'DELETE',
  });
}

/**
 * Activa o desactiva la medici√≥n de un registrador
 */
export async function toggleActivoRegistrador(registradorId, workspaceId, activo) {
  return fetchConAuth(`/api/registradores/${registradorId}/toggle-activo`, {
    method: 'POST',
    body: JSON.stringify({ workspaceId, activo }),
  });
}

/**
 * Prueba la conexi√≥n Modbus de un registrador
 */
export async function testConexionRegistrador(ip, puerto, indiceInicial, cantidadRegistros, unitId = 1) {
  return fetchConAuth('/api/registradores/test-conexion', {
    method: 'POST',
    body: JSON.stringify({ ip, puerto, indiceInicial, cantidadRegistros, unitId }),
  });
}

// ============================================
// ADMINISTRACI√ìN DE USUARIOS (solo superadmin)
// ============================================

/**
 * Lista todos los usuarios del sistema (excepto superadmins)
 * @returns {Promise<Array>} Lista de usuarios con sus permisos de agentes
 */
export async function listarUsuariosAdmin() {
  return fetchConAuth('/api/admin/usuarios');
}

/**
 * Cambia el rol global de un usuario
 * @param {string} usuarioId - ID del usuario
 * @param {string} rolCodigo - C√≥digo del rol ('admin', 'operador', 'observador')
 * @returns {Promise<Object>} Usuario actualizado
 */
export async function cambiarRolUsuarioAdmin(usuarioId, rolCodigo) {
  return fetchConAuth(`/api/admin/usuarios/${usuarioId}/rol`, {
    method: 'PUT',
    body: JSON.stringify({ rolCodigo }),
  });
}

/**
 * Actualiza los agentes a los que un usuario tiene acceso
 * @param {string} usuarioId - ID del usuario
 * @param {boolean} accesoTotal - Si es true, tiene acceso a todos los agentes
 * @param {string[]} agentesIds - Array de IDs de agentes (ignorado si accesoTotal es true)
 * @returns {Promise<Object>} Permisos actualizados
 */
export async function actualizarAgentesUsuarioAdmin(usuarioId, accesoTotal, agentesIds = []) {
  return fetchConAuth(`/api/admin/usuarios/${usuarioId}/agentes`, {
    method: 'PUT',
    body: JSON.stringify({ accesoTotal, agentesIds }),
  });
}

/**
 * Lista todos los agentes disponibles para asignar permisos
 * @returns {Promise<Array>} Lista de agentes con id, nombre y activo
 */
export async function listarAgentesParaPermisos() {
  return fetchConAuth('/api/admin/agentes-disponibles');
}

/**
 * Obtiene detalles completos de un usuario (workspaces, puestos, agentes, invitados)
 * @param {string} usuarioId - ID del usuario
 * @returns {Promise<Object>} Detalles del usuario con workspaces propios e invitado
 */
export async function obtenerDetallesUsuarioAdmin(usuarioId) {
  return fetchConAuth(`/api/admin/usuarios/${usuarioId}/detalles`);
}

// ============================================
// DISPOSITIVOS (Push Notifications)
// ============================================

/**
 * Registra el token FCM del dispositivo para recibir push notifications
 * @param {string} fcmToken - Token FCM del dispositivo
 * @param {string} plataforma - Plataforma del dispositivo ('android' o 'ios')
 * @returns {Promise<Object>} Dispositivo registrado
 */
export async function registrarTokenDispositivo(fcmToken, plataforma = 'android') {
  return fetchConAuth('/api/dispositivos/registrar', {
    method: 'POST',
    body: JSON.stringify({ fcmToken, plataforma }),
  });
}

/**
 * Desregistra el token FCM del dispositivo
 * @param {string} fcmToken - Token FCM a desregistrar
 * @returns {Promise<Object>} Confirmaci√≥n
 */
export async function desregistrarTokenDispositivo(fcmToken) {
  return fetchConAuth('/api/dispositivos/desregistrar', {
    method: 'DELETE',
    body: JSON.stringify({ fcmToken }),
  });
}

// ============================================
// PERMISOS DE WORKSPACE
// ============================================

/**
 * Obtiene los usuarios con acceso a un workspace
 * @param {string} workspaceId - ID del workspace
 * @returns {Promise<Array>} Lista de permisos con datos de usuario y rol
 */
export async function obtenerPermisosWorkspace(workspaceId) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/permisos`);
}

/**
 * Invita/agrega un usuario a un workspace
 * @param {string} workspaceId - ID del workspace
 * @param {string} email - Email del usuario a invitar
 * @param {string} rol - Rol a asignar ('observador', 'operador', 'admin')
 * @returns {Promise<Object>} Permiso creado
 */
export async function agregarPermisoWorkspace(workspaceId, email, rol) {
  return fetchConAuth(`/api/workspaces/${workspaceId}/permisos`, {
    method: 'POST',
    body: JSON.stringify({ email, rol }),
  });
}

/**
 * Actualiza el rol de un usuario en un workspace
 * @param {string} permisoId - ID del permiso a actualizar
 * @param {string} rol - Nuevo rol ('observador', 'operador', 'admin')
 * @returns {Promise<Object>} Permiso actualizado
 */
export async function actualizarPermisoWorkspace(permisoId, rol) {
  return fetchConAuth(`/api/permisos/${permisoId}`, {
    method: 'PUT',
    body: JSON.stringify({ rol }),
  });
}

/**
 * Elimina el acceso de un usuario a un workspace
 * @param {string} permisoId - ID del permiso a eliminar
 * @returns {Promise<Object>} Mensaje de confirmaci√≥n
 */
export async function eliminarPermisoWorkspace(permisoId) {
  return fetchConAuth(`/api/permisos/${permisoId}`, {
    method: 'DELETE',
  });
}

export default {
  // Usuarios
  obtenerPerfil,
  crearPerfilUsuario,
  actualizarWorkspaceDefault,
  // Workspaces
  obtenerWorkspaces,
  crearWorkspace,
  actualizarWorkspace,
  eliminarWorkspace,
  // Puestos
  obtenerPuestos,
  crearPuesto,
  actualizarPuesto,
  eliminarPuesto,
  reordenarPuestos,
  // Alimentadores
  obtenerAlimentadores,
  crearAlimentador,
  actualizarAlimentadorAPI,
  eliminarAlimentadorAPI,
  reordenarAlimentadores,
  moverAlimentador,
  // Lecturas
  obtenerUltimasLecturas,
  obtenerLecturasHistoricas,
  obtenerUltimasLecturasPorRegistrador,
  obtenerLecturasHistoricasPorRegistrador,
  // Preferencias
  obtenerPreferencias,
  guardarPreferencias,
  // Agentes (legacy)
  obtenerEstadoAgente,
  solicitarVinculacionAgente,
  desvincularAgente,
  rotarClaveAgente,
  // Agentes (nueva arquitectura)
  listarTodosLosAgentes,
  crearAgente,
  actualizarAgente,
  eliminarAgente,
  rotarClaveAgentePorId,
  listarAgentesDisponibles,
  listarAgentesWorkspace,
  vincularAgenteWorkspace,
  desvincularAgenteWorkspace,
  listarRegistradoresAgente,
  crearRegistradorAgente,
  actualizarRegistradorAgente,
  eliminarRegistradorAgente,
  toggleRegistradorAgente,
  solicitarTestRegistrador,
  consultarTestRegistrador,
  solicitarTestCoils,
  // Test conexi√≥n Modbus
  testConexionModbus,
  // Registradores
  obtenerRegistradores,
  crearRegistrador,
  actualizarRegistrador,
  eliminarRegistrador,
  toggleActivoRegistrador,
  testConexionRegistrador,
  // Permisos de workspace
  obtenerPermisosWorkspace,
  agregarPermisoWorkspace,
  actualizarPermisoWorkspace,
  eliminarPermisoWorkspace,
  // Administraci√≥n de usuarios (superadmin)
  listarUsuariosAdmin,
  cambiarRolUsuarioAdmin,
  actualizarAgentesUsuarioAdmin,
  listarAgentesParaPermisos,
  obtenerDetallesUsuarioAdmin,
  // Dispositivos (Push Notifications)
  registrarTokenDispositivo,
  desregistrarTokenDispositivo,
};

========== mi-app/src/servicios/authService.js ==========
// src/servicios/authService.js
// Servicio de autenticaci√≥n usando Supabase
// NOTA: Las operaciones de supabase.auth.* van directas a Supabase (correcto)
//       Los datos de usuario van por el backend (crearPerfilUsuario, obtenerPerfil)

import { supabase } from '../lib/supabase';
import { crearPerfilUsuario, obtenerPerfil } from './apiService';

/**
 * Iniciar sesi√≥n con email y contrase√±a
 * @param {string} email
 * @param {string} password
 * @returns {Promise<{user, error}>}
 */
export async function iniciarSesion(email, password) {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    return { user: null, error: traducirError(error.message) };
  }

  return { user: data.user, error: null };
}

/**
 * Registrar nuevo usuario
 * @param {string} email
 * @param {string} password
 * @param {string} nombre
 * @returns {Promise<{user, error}>}
 */
export async function registrarUsuario(email, password, nombre) {
  // 1. Crear usuario en Supabase Auth (directo - esto es correcto)
  const { data: authData, error: authError } = await supabase.auth.signUp({
    email,
    password,
    options: {
      data: {
        nombre: nombre,
      },
    },
  });

  if (authError) {
    return { user: null, error: traducirError(authError.message) };
  }

  // 2. Crear perfil en tabla usuarios VIA BACKEND
  // El backend usa SERVICE_ROLE y valida la creaci√≥n
  if (authData.user && authData.session) {
    try {
      await crearPerfilUsuario(nombre);
    } catch (dbError) {
      console.error('Error al crear perfil en DB:', dbError);
      // No retornamos error porque el usuario ya se cre√≥ en Auth
      // El backend puede crear el perfil despu√©s en obtenerPerfil
    }
  }

  return { user: authData.user, error: null };
}

/**
 * Cerrar sesi√≥n
 * Limpia tambi√©n los datos de localStorage para evitar que persistan entre usuarios
 * @returns {Promise<{error}>}
 */
export async function cerrarSesion() {
  // Limpiar datos de sesi√≥n del localStorage
  // Esto evita que al loguearse otro usuario se intente acceder a workspaces del anterior
  localStorage.removeItem('rw-configuracion-seleccionada');
  localStorage.removeItem('rw-puesto-seleccionado');
  localStorage.removeItem('rw-gap-tarjetas');
  localStorage.removeItem('rw-gap-filas');

  const { error } = await supabase.auth.signOut();
  return { error: error ? traducirError(error.message) : null };
}

/**
 * Obtener sesi√≥n actual
 * @returns {Promise<{session, user}>}
 */
export async function obtenerSesion() {
  const { data: { session } } = await supabase.auth.getSession();
  return {
    session,
    user: session?.user || null,
  };
}

/**
 * Obtener datos del usuario actual desde nuestra tabla
 * Usa el backend para obtener el perfil (incluye rol global y permisos)
 * @returns {Promise<{usuario, error}>}
 */
export async function obtenerUsuarioActual() {
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { usuario: null, error: 'No hay sesi√≥n activa' };
  }

  try {
    // Obtener perfil VIA BACKEND
    // El backend crea el usuario si no existe (auto-provisioning)
    const perfil = await obtenerPerfil();
    return { usuario: perfil, error: null };
  } catch (error) {
    return { usuario: null, error: error.message };
  }
}

/**
 * Enviar email para recuperar contrase√±a
 * @param {string} email
 * @returns {Promise<{error}>}
 */
export async function recuperarContrasena(email) {
  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${window.location.origin}/cambiar-contrasena`,
  });

  return { error: error ? traducirError(error.message) : null };
}

/**
 * Suscribirse a cambios de autenticaci√≥n
 * @param {Function} callback
 * @returns {Function} funci√≥n para desuscribirse
 */
export function suscribirseACambiosAuth(callback) {
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    (event, session) => {
      callback(event, session);
    }
  );

  return () => subscription.unsubscribe();
}

/**
 * Traducir mensajes de error de Supabase al espa√±ol
 * @param {string} mensaje
 * @returns {string}
 */
function traducirError(mensaje) {
  const traducciones = {
    'Invalid login credentials': 'Usuario o contrase√±a incorrectos',
    'Email not confirmed': 'Debes confirmar tu email antes de iniciar sesi√≥n',
    'User already registered': 'Este email ya est√° registrado',
    'Password should be at least 6 characters': 'La contrase√±a debe tener al menos 6 caracteres',
    'Unable to validate email address: invalid format': 'El formato del email no es v√°lido',
    'Email rate limit exceeded': 'Demasiados intentos. Intenta m√°s tarde',
  };

  return traducciones[mensaje] || mensaje;
}

========== mi-app/src/servicios/pushNotifications.js ==========
// src/servicios/pushNotifications.js
// Servicio para gestionar Push Notifications con Capacitor + Firebase

import { PushNotifications } from '@capacitor/push-notifications';
import { Capacitor } from '@capacitor/core';

/**
 * Verifica si estamos en plataforma nativa (Android/iOS)
 */
export const esPlataformaNativa = () => {
  return Capacitor.isNativePlatform();
};

/**
 * Registra el dispositivo para recibir push notifications
 * @param {Function} onTokenRecibido - Callback cuando se obtiene el token FCM
 * @param {Function} onNotificacionRecibida - Callback cuando llega una notificaci√≥n (app en primer plano)
 * @param {Function} onNotificacionTocada - Callback cuando el usuario toca la notificaci√≥n
 * @returns {Promise<boolean>} true si se registr√≥ correctamente
 */
export const registrarPushNotifications = async (
  onTokenRecibido,
  onNotificacionRecibida = null,
  onNotificacionTocada = null
) => {
  if (!esPlataformaNativa()) {
    console.log('[Push] Solo disponible en app nativa, ignorando en web');
    return null;
  }

  try {
    // Verificar/solicitar permisos
    let permStatus = await PushNotifications.checkPermissions();
    console.log('[Push] Estado de permisos:', permStatus.receive);

    if (permStatus.receive === 'prompt') {
      console.log('[Push] Solicitando permisos...');
      permStatus = await PushNotifications.requestPermissions();
    }

    if (permStatus.receive !== 'granted') {
      console.log('[Push] Permisos denegados por el usuario');
      return null;
    }

    // Registrar en FCM
    await PushNotifications.register();
    console.log('[Push] Registro en FCM iniciado');

    // Listener: Token recibido
    PushNotifications.addListener('registration', (token) => {
      console.log('[Push] Token FCM recibido:', token.value);
      if (onTokenRecibido) {
        onTokenRecibido(token.value);
      }
    });

    // Listener: Error de registro
    PushNotifications.addListener('registrationError', (error) => {
      console.error('[Push] Error en registro:', error);
    });

    // Listener: Notificaci√≥n recibida (app en primer plano)
    PushNotifications.addListener('pushNotificationReceived', (notification) => {
      console.log('[Push] Notificaci√≥n recibida:', notification);
      if (onNotificacionRecibida) {
        onNotificacionRecibida({
          titulo: notification.title,
          cuerpo: notification.body,
          datos: notification.data,
        });
      }
    });

    // Listener: Usuario toc√≥ la notificaci√≥n
    PushNotifications.addListener('pushNotificationActionPerformed', (action) => {
      console.log('[Push] Notificaci√≥n tocada:', action);
      if (onNotificacionTocada) {
        onNotificacionTocada({
          actionId: action.actionId,
          datos: action.notification.data,
        });
      }
    });

    return true;
  } catch (error) {
    console.error('[Push] Error configurando push notifications:', error);
    return null;
  }
};

/**
 * Desregistra todos los listeners de push notifications
 * Llamar al desmontar el componente principal
 */
export const desregistrarPushNotifications = async () => {
  if (!esPlataformaNativa()) return;

  try {
    await PushNotifications.removeAllListeners();
    console.log('[Push] Listeners removidos');
  } catch (error) {
    console.error('[Push] Error removiendo listeners:', error);
  }
};

/**
 * Obtiene la lista de notificaciones entregadas (en el centro de notificaciones)
 */
export const obtenerNotificacionesPendientes = async () => {
  if (!esPlataformaNativa()) return [];

  try {
    const { notifications } = await PushNotifications.getDeliveredNotifications();
    return notifications;
  } catch (error) {
    console.error('[Push] Error obteniendo notificaciones:', error);
    return [];
  }
};

/**
 * Limpia todas las notificaciones del centro de notificaciones
 */
export const limpiarNotificaciones = async () => {
  if (!esPlataformaNativa()) return;

  try {
    await PushNotifications.removeAllDeliveredNotifications();
    console.log('[Push] Notificaciones limpiadas');
  } catch (error) {
    console.error('[Push] Error limpiando notificaciones:', error);
  }
};

