]633;E;{   echo "=== ESTRUCTURA ==="\x3b   find ./src -type f \\( -name "*.js" -o -name "*.jsx" \\) | sort\x3b   echo -e "\\n\\n=== C√ìDIGO ==="\x3b   find ./src -type f \\( -name "*.js" -o -name "*.jsx" \\) -exec echo -e "\\n// ===== {} =====\\n" \\\x3b -exec cat {} \\\x3b\x3b } > frontend_refactorizado.txt;68e4f5c5-f138-4b0e-a8c7-60852bd282fd]633;C=== ESTRUCTURA ===
./src/App.jsx
./src/componentes/comunes/ApexChartWrapper.jsx
./src/componentes/comunes/index.js
./src/componentes/comunes/SelectorFecha.jsx
./src/contextos/AuthContext.jsx
./src/hooks/usePushNotifications.js
./src/lib/supabase.js
./src/main.jsx
./src/paginas/PaginaAlimentadores/componentes/historial/BarraControlesHistorial.jsx
./src/paginas/PaginaAlimentadores/componentes/historial/BarraTituloVentana.jsx
./src/paginas/PaginaAlimentadores/componentes/historial/ControlEscalaY.jsx
./src/paginas/PaginaAlimentadores/componentes/historial/EstadisticasHistorial.jsx
./src/paginas/PaginaAlimentadores/componentes/historial/EstadoGrafico.jsx
./src/paginas/PaginaAlimentadores/componentes/historial/index.js
./src/paginas/PaginaAlimentadores/componentes/historial/PanelDatosHistorial.jsx
./src/paginas/PaginaAlimentadores/componentes/layout/EstadoCarga.jsx
./src/paginas/PaginaAlimentadores/componentes/layout/EstadoVacio.jsx
./src/paginas/PaginaAlimentadores/componentes/layout/ModalesVista.jsx
./src/paginas/PaginaAlimentadores/componentes/layout/OverlayConexion.jsx
./src/paginas/PaginaAlimentadores/componentes/layout/OverlayGuardando.jsx
./src/paginas/PaginaAlimentadores/componentes/layout/VistaAlimentadores.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/apariencia/ColorPickerBoton.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/apariencia/index.js
./src/paginas/PaginaAlimentadores/componentes/modales/apariencia/PreviewTarjeta.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/apariencia/SelectorFuente.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/apariencia/SliderConFlechas.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/comunes/ColorPickerSimple.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/comunes/index.js
./src/paginas/PaginaAlimentadores/componentes/modales/comunes/ModalConfirmacion.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/comunes/TabApariencia.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/configuracion-alimentador/constantes.js
./src/paginas/PaginaAlimentadores/componentes/modales/configuracion-alimentador/index.js
./src/paginas/PaginaAlimentadores/componentes/modales/configuracion-alimentador/SeccionCardDesign.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/configuracion-alimentador/SelectorColor.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/configuracion-alimentador/useConfigAlimentador.js
./src/paginas/PaginaAlimentadores/componentes/modales/configurar-agente/FormularioRegistrador.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/configurar-agente/index.js
./src/paginas/PaginaAlimentadores/componentes/modales/configurar-agente/ListaRegistradores.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/configurar-agente/ModalResultadoTest.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/configurar-agente/TarjetaAgente.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/historial/ContenedorVentanasHistorial.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/historial/index.js
./src/paginas/PaginaAlimentadores/componentes/modales/historial/ModalConfigInforme.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/historial/VentanaHistorial.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionAlimentador.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigurarAgente.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/FormularioEdicion.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/index.js
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/ListaUsuarios.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/PanelDetalles.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/PanelDetallesVacio.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/WorkspacesGrid.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/hooks/index.js
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/hooks/useArrastrarModal.js
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/hooks/useDatosPermisos.js
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/hooks/useEdicionPermisos.js
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/hooks/useEstadoVentana.js
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/index.js
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/ModalGestionarAccesos.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/permisos/ModalPanelPermisos.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/puesto/index.js
./src/paginas/PaginaAlimentadores/componentes/modales/puesto/ModalConfiguracionPuesto.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/puesto/ModalEditarPuestos.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/puesto/ModalNuevoPuesto.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/rele/ConfiguracionRele.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/rele/DropdownTransformador.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/rele/index.js
./src/paginas/PaginaAlimentadores/componentes/modales/rele/ModalPlantillasRele.jsx
./src/paginas/PaginaAlimentadores/componentes/modales/rele/ModalTransformadores.jsx
./src/paginas/PaginaAlimentadores/componentes/navegacion/BarraNavegacion.jsx
./src/paginas/PaginaAlimentadores/componentes/navegacion/BotonGuardarCambios.jsx
./src/paginas/PaginaAlimentadores/componentes/navegacion/componentes/index.js
./src/paginas/PaginaAlimentadores/componentes/navegacion/componentes/SeccionAcciones.jsx
./src/paginas/PaginaAlimentadores/componentes/navegacion/componentes/SeccionEscala.jsx
./src/paginas/PaginaAlimentadores/componentes/navegacion/componentes/SeccionPuestos.jsx
./src/paginas/PaginaAlimentadores/componentes/navegacion/componentes/SeccionWorkspace.jsx
./src/paginas/PaginaAlimentadores/componentes/navegacion/MenuLateral.jsx
./src/paginas/PaginaAlimentadores/componentes/navegacion/SelectorConfiguracion.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/CajaMedicion.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/componentes/BotonesUnifilar.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/componentes/index.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/componentes/MenuFlotante.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/componentes/PopoverEscala.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/GapResizer.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaTarjetas.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaUnifilar.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/BarraHerramientas.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/CanvasChispas.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/EditorTexto.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/index.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/MenuContextual.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/PanelConfigChispas.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/GrillaUnifilar.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/hooks/index.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/hooks/useAreaBorrador.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/hooks/useDragLines.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/hooks/useKeyboardShortcuts.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/hooks/useTextEditor.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/index.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/utilidades/coordenadas.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/utilidades/dibujarFormas.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/utilidades/index.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrupoMedidores.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/hooks/index.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/hooks/useDeteccionFilas.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/hooks/useModoMobile.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/RowGapResizer.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/SkeletonCard.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/TarjetaAlimentador.jsx
./src/paginas/PaginaAlimentadores/componentes/tarjetas/utilidades/constantesGrilla.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/utilidades/index.js
./src/paginas/PaginaAlimentadores/componentes/tarjetas/utilidades/validacionPolling.js
./src/paginas/PaginaAlimentadores/constantes/clavesAlmacenamiento.js
./src/paginas/PaginaAlimentadores/constantes/colores.js
./src/paginas/PaginaAlimentadores/constantes/escalas.js
./src/paginas/PaginaAlimentadores/constantes/estilosGlobalesTarjeta.js
./src/paginas/PaginaAlimentadores/constantes/funcionalidadesRele.js
./src/paginas/PaginaAlimentadores/constantes/historialConfig.js
./src/paginas/PaginaAlimentadores/constantes/index.js
./src/paginas/PaginaAlimentadores/constantes/titulosMediciones.js
./src/paginas/PaginaAlimentadores/contexto/ContextoAlimentadoresSupabase.jsx
./src/paginas/PaginaAlimentadores/contexto/ContextoConfiguracion.jsx
./src/paginas/PaginaAlimentadores/hooks/agentes/index.js
./src/paginas/PaginaAlimentadores/hooks/agentes/useAgentesConfig.js
./src/paginas/PaginaAlimentadores/hooks/agentes/useConsolaTest.js
./src/paginas/PaginaAlimentadores/hooks/agentes/useRegistradoresConfig.js
./src/paginas/PaginaAlimentadores/hooks/agentes/useRegistradoresWorkspace.js
./src/paginas/PaginaAlimentadores/hooks/agentes/useVentanaConfigAgente.js
./src/paginas/PaginaAlimentadores/hooks/grilla-unifilar/algoritmos.js
./src/paginas/PaginaAlimentadores/hooks/grilla-unifilar/constantes.js
./src/paginas/PaginaAlimentadores/hooks/grilla-unifilar/index.js
./src/paginas/PaginaAlimentadores/hooks/grilla-unifilar/persistencia.js
./src/paginas/PaginaAlimentadores/hooks/grilla-unifilar/useGrillaUnifilar.js
./src/paginas/PaginaAlimentadores/hooks/historial/index.js
./src/paginas/PaginaAlimentadores/hooks/historial/logicaFuenteDatos.js
./src/paginas/PaginaAlimentadores/hooks/historial/logicaPrecarga.js
./src/paginas/PaginaAlimentadores/hooks/historial/useHistorialLocal.js
./src/paginas/PaginaAlimentadores/hooks/historial/useVentanaHistorialLogica.js
./src/paginas/PaginaAlimentadores/hooks/mediciones/index.js
./src/paginas/PaginaAlimentadores/hooks/mediciones/useConfiguracion.js
./src/paginas/PaginaAlimentadores/hooks/mediciones/useMediciones.js
./src/paginas/PaginaAlimentadores/hooks/mediciones/usePollingLecturas.js
./src/paginas/PaginaAlimentadores/hooks/mediciones/useTarjetaAlimentador.js
./src/paginas/PaginaAlimentadores/hooks/mediciones/useTransformadores.js
./src/paginas/PaginaAlimentadores/hooks/preferencias/index.js
./src/paginas/PaginaAlimentadores/hooks/preferencias/useColoresPuesto.js
./src/paginas/PaginaAlimentadores/hooks/preferencias/useEscalasCombinadas.js
./src/paginas/PaginaAlimentadores/hooks/preferencias/useEstilosApariencia.js
./src/paginas/PaginaAlimentadores/hooks/preferencias/useEstilosGlobales.js
./src/paginas/PaginaAlimentadores/hooks/preferencias/useGapsCombinados.js
./src/paginas/PaginaAlimentadores/hooks/preferencias/usePreferenciasUI.js
./src/paginas/PaginaAlimentadores/hooks/preferencias/usePreferenciasVisuales.js
./src/paginas/PaginaAlimentadores/hooks/preferencias/useSincronizacionCambios.js
./src/paginas/PaginaAlimentadores/hooks/puestos/index.js
./src/paginas/PaginaAlimentadores/hooks/puestos/useArrastrarSoltar.js
./src/paginas/PaginaAlimentadores/hooks/puestos/useCambiosPendientes.js
./src/paginas/PaginaAlimentadores/hooks/puestos/useDragDropAlimentadores.js
./src/paginas/PaginaAlimentadores/hooks/puestos/useGestionAlimentadores.js
./src/paginas/PaginaAlimentadores/hooks/puestos/useGestionPuestos.js
./src/paginas/PaginaAlimentadores/hooks/puestos/usePreferenciasVisualesPuestos.js
./src/paginas/PaginaAlimentadores/hooks/puestos/usePuestosSupabase.js
./src/paginas/PaginaAlimentadores/hooks/rele/index.js
./src/paginas/PaginaAlimentadores/hooks/rele/useConfigRele.js
./src/paginas/PaginaAlimentadores/hooks/rele/useEtiquetasBits.js
./src/paginas/PaginaAlimentadores/hooks/rele/useFuncionalidadesPlantilla.js
./src/paginas/PaginaAlimentadores/hooks/rele/usePlantillasRele.js
./src/paginas/PaginaAlimentadores/hooks/ui/index.js
./src/paginas/PaginaAlimentadores/hooks/ui/useArrastrarVentana.js
./src/paginas/PaginaAlimentadores/hooks/ui/useChispas.js
./src/paginas/PaginaAlimentadores/hooks/ui/useGestorModales.js
./src/paginas/PaginaAlimentadores/hooks/ui/useModoCompacto.js
./src/paginas/PaginaAlimentadores/hooks/ui/useVentanaFlotante.js
./src/paginas/PaginaAlimentadores/hooks/ui/useVentanasHistorial.js
./src/paginas/PaginaAlimentadores/PaginaAlimentadoresSupabase.jsx
./src/paginas/PaginaAlimentadores/utilidades/calculadorRutas.js
./src/paginas/PaginaAlimentadores/utilidades/calculosFormulas.js
./src/paginas/PaginaAlimentadores/utilidades/calculosHistorial.js
./src/paginas/PaginaAlimentadores/utilidades/calculosMediciones.js
./src/paginas/PaginaAlimentadores/utilidades/coloresGrafico.js
./src/paginas/PaginaAlimentadores/utilidades/configGraficoHistorial.js
./src/paginas/PaginaAlimentadores/utilidades/exportarCSV.js
./src/paginas/PaginaAlimentadores/utilidades/exportarInformePDF.js
./src/paginas/PaginaAlimentadores/utilidades/generarGraficoInforme.js
./src/paginas/PaginaAlimentadores/utilidades/index.js
./src/paginas/PaginaAlimentadores/utilidades/indexedDBHelper.js
./src/paginas/PaginaAlimentadores/utilidades/interpreteRegistrosREF615.js
./src/paginas/PaginaLogin/PaginaLogin.jsx
./src/paginas/PaginaRecuperar/RecuperarContrasena.jsx
./src/paginas/PaginaRegistro/PaginaRegistro.jsx
./src/servicios/api/admin.js
./src/servicios/api/agentes.js
./src/servicios/api/alimentadores.js
./src/servicios/api/base.js
./src/servicios/api/dispositivos.js
./src/servicios/api/index.js
./src/servicios/api/lecturas.js
./src/servicios/api/permisos.js
./src/servicios/api/preferencias.js
./src/servicios/api/puestos.js
./src/servicios/api/registradores.js
./src/servicios/api/usuarios.js
./src/servicios/api/workspaces.js
./src/servicios/apiService.js
./src/servicios/authService.js
./src/servicios/pushNotifications.js
./src/tipos/index.js


=== C√ìDIGO ===

// ===== ./src/App.jsx =====

// src/App.jsx
import React from "react";
import { Routes, Route, Navigate } from "react-router-dom";                // componentes de enrutado declarativo
import PaginaLogin from "./paginas/PaginaLogin/PaginaLogin.jsx";           // pantalla de login (ruta "/")
import PaginaRegistro from "./paginas/PaginaRegistro/PaginaRegistro.jsx";  // pantalla de registro (ruta "/registro")
import PaginaAlimentadoresSupabase from "./paginas/PaginaAlimentadores/PaginaAlimentadoresSupabase.jsx"; // panel principal conectado a Supabase
import RecuperarContrasena from "./paginas/PaginaRecuperar/RecuperarContrasena.jsx";

function App() {                                         // componente ra√≠z que define el mapa de rutas
	return (
		<Routes>                                           {/* contenedor de todas las <Route> */}
			<Route                                           
				path="/"                                     
				element={<PaginaLogin />}                    // ruta principal: muestra login
			/>

			<Route                                           
				path="/registro"                            
				element={<PaginaRegistro />}                 // ruta para crear un nuevo usuario
			/>

			<Route
				path="/recuperarContrase√±a"
				element={<RecuperarContrasena/>}            // ruta para recuperar contrase√±a
			/>

			<Route
				path="/alimentadores"
				element={<PaginaAlimentadoresSupabase />}    // ruta del panel de alimentadores conectado a Supabase
			/>

			<Route                                           
				path="*"                                    
				element={<Navigate to="/" replace />}       // cualquier otra URL redirige al login
			/>
		</Routes>
	);
}

export default App;                                          // se importa en main.jsx como componente principal


// ===== ./src/componentes/comunes/ApexChartWrapper.jsx =====

/**
 * Wrapper personalizado para ApexCharts que maneja correctamente
 * el ciclo de vida con React 18 StrictMode.
 *
 * Soluciona el problema conocido de react-apexcharts donde el doble montaje
 * de StrictMode causa errores "parentNode is null" y "Element not found".
 *
 * Usa ApexCharts directamente en lugar del wrapper react-apexcharts.
 */

import { useEffect, useRef, useImperativeHandle, forwardRef, memo } from "react";
import ApexCharts from "apexcharts";

const ApexChartWrapper = forwardRef(({ options, series, type, height, width }, ref) => {
  const containerRef = useRef(null);
  const chartInstanceRef = useRef(null);

  // Exponer el chart instance y m√©todos √∫tiles al componente padre via ref
  useImperativeHandle(ref, () => ({
    get chart() {
      return chartInstanceRef.current;
    },
    /**
     * Captura la imagen del gr√°fico con estilo optimizado para informes
     * (fondo blanco, texto negro, fuentes m√°s grandes)
     * Crea un gr√°fico temporal oculto para la captura, sin afectar el visible.
     * @param {Object} exportOptions - Opciones adicionales para dataURI
     * @returns {Promise<{imgURI: string}>} - Imagen en formato data URI
     */
    async captureForReport(exportOptions = {}) {
      const chart = chartInstanceRef.current;
      if (!chart) {
        return { imgURI: null };
      }

      // Crear un contenedor temporal oculto para el gr√°fico de exportaci√≥n
      const tempContainer = document.createElement("div");
      tempContainer.style.cssText = "position:absolute;left:-9999px;top:-9999px;width:1200px;height:600px;";
      document.body.appendChild(tempContainer);

      // Opciones optimizadas para exportaci√≥n a informe (fondo blanco, texto negro, fuentes grandes)
      const opcionesExport = {
        ...options,
        chart: {
          ...options.chart,
          id: `export-temp-${Date.now()}`,
          background: "#ffffff",
          foreColor: "#1a1a1a",
          animations: { enabled: false },
          toolbar: { show: false },
          width: 1200,
          height: 600,
        },
        states: {
          hover: { filter: { type: "none" } },
          active: { filter: { type: "none" } },
        },
        markers: {
          ...options.markers,
          hover: { size: 0 },
        },
        tooltip: { enabled: false },
        xaxis: {
          ...options.xaxis,
          crosshairs: { show: false },
          labels: {
            ...options.xaxis?.labels,
            style: {
              ...options.xaxis?.labels?.style,
              colors: "#1a1a1a",
              fontSize: "16px",
              fontWeight: 600,
            },
          },
          axisBorder: { color: "#333333", show: true },
          axisTicks: { color: "#333333", show: true },
        },
        yaxis: {
          ...options.yaxis,
          crosshairs: { show: false },
          labels: {
            ...options.yaxis?.labels,
            style: {
              ...options.yaxis?.labels?.style,
              colors: "#1a1a1a",
              fontSize: "16px",
              fontWeight: 600,
            },
          },
        },
        grid: {
          ...options.grid,
          borderColor: "#bbbbbb",
        },
      };

      let tempChart = null;
      try {
        // Crear gr√°fico temporal con las opciones de exportaci√≥n
        tempChart = new ApexCharts(tempContainer, {
          ...opcionesExport,
          series: chart.w.config.series, // Usar las series actuales
        });
        await tempChart.render();

        // Peque√±a pausa para asegurar que el gr√°fico se renderice
        await new Promise(resolve => setTimeout(resolve, 150));

        // Capturar imagen del gr√°fico temporal
        const result = await tempChart.dataURI({ scale: exportOptions.scale || 2 });

        return result;
      } catch (err) {
        console.warn("Error capturando gr√°fico para informe:", err);
        return { imgURI: null };
      } finally {
        // Limpiar: destruir gr√°fico temporal y remover contenedor
        if (tempChart) {
          try {
            tempChart.destroy();
          } catch {
            // Ignorar errores de destrucci√≥n
          }
        }
        if (tempContainer.parentNode) {
          tempContainer.parentNode.removeChild(tempContainer);
        }
      }
    }
  }), [options]);

  // Refs para valores iniciales (evita re-crear el chart cuando cambian)
  const initialOptionsRef = useRef(options);
  const initialSeriesRef = useRef(series);
  const initialTypeRef = useRef(type);
  const initialHeightRef = useRef(height);
  const initialWidthRef = useRef(width);

  // Efecto principal: crear/destruir el chart (solo al montar/desmontar)
  useEffect(() => {
    // Si no hay contenedor, salir
    if (!containerRef.current) return;

    // Limpiar cualquier chart anterior que pudiera existir
    if (chartInstanceRef.current) {
      try {
        chartInstanceRef.current.destroy();
      } catch {
        // Ignorar errores de destrucci√≥n
      }
      chartInstanceRef.current = null;
    }

    // Usar valores iniciales de los refs
    const opts = initialOptionsRef.current;
    const ser = initialSeriesRef.current;
    const t = initialTypeRef.current;
    const h = initialHeightRef.current;
    const w = initialWidthRef.current;

    // Crear configuraci√≥n completa del chart
    const chartConfig = {
      ...opts,
      chart: {
        ...opts.chart,
        type: t || opts.chart?.type || "line",
        height: h || opts.chart?.height || "100%",
        width: w || opts.chart?.width || "100%",
      },
      series: ser || [],
    };

    // Crear nueva instancia
    const chart = new ApexCharts(containerRef.current, chartConfig);
    chartInstanceRef.current = chart;

    // Renderizar el chart
    chart.render();

    // Cleanup: destruir chart cuando el componente se desmonte
    return () => {
      if (chartInstanceRef.current) {
        try {
          chartInstanceRef.current.destroy();
        } catch {
          // Ignorar errores durante cleanup
        }
        chartInstanceRef.current = null;
      }
    };
  }, []); // Solo al montar/desmontar - las actualizaciones se hacen en otros effects

  // Efecto para actualizar opciones cuando cambien
  useEffect(() => {
    if (!chartInstanceRef.current) return;

    try {
      chartInstanceRef.current.updateOptions(
        {
          ...options,
          chart: {
            ...options.chart,
            type: type || options.chart?.type || "line",
          },
        },
        false, // No redraw
        true   // Animate
      );
    } catch (e) {
      console.warn("Error actualizando opciones del chart:", e);
    }
  }, [options, type]);

  // Efecto para actualizar series cuando cambien
  useEffect(() => {
    if (!chartInstanceRef.current) return;

    try {
      chartInstanceRef.current.updateSeries(series || [], true);
    } catch (e) {
      console.warn("Error actualizando series del chart:", e);
    }
  }, [series]);

  return (
    <div
      ref={containerRef}
      style={{
        width: width || "100%",
        height: height || "100%",
        minHeight: "200px",
      }}
    />
  );
});

ApexChartWrapper.displayName = "ApexChartWrapper";

export default memo(ApexChartWrapper);

// ===== ./src/componentes/comunes/index.js =====

// componentes/comunes/index.js
// Componentes comunes reutilizables

export { default as ApexChartWrapper } from "./ApexChartWrapper";
export { default as SelectorFecha } from "./SelectorFecha";

// ===== ./src/componentes/comunes/SelectorFecha.jsx =====

/**
 * Componente SelectorFecha - DatePicker modular reutilizable
 * Soporta selecci√≥n de d√≠a √∫nico o rango de fechas
 * Navegaci√≥n drill-down: d√≠as ‚Üí meses ‚Üí a√±os
 *
 * Modo rango:
 * - Primer click: selecciona "desde"
 * - Segundo click: selecciona "hasta" (si es despu√©s del desde) o nuevo "desde" (si es antes)
 * - Los d√≠as entre ambos se marcan con color de fondo
 */

import { useState, useRef, useEffect } from "react";
import "./SelectorFecha.css";

const SelectorFecha = ({
  value,
  onChange,
  minDate,
  maxDate,
  placeholder = "Seleccionar fecha",
  disabled = false,
  className = "",
  // Nuevas props para modo rango
  modoRango = false,
  valueHasta = null,
  onChangeRango = null, // (desde, hasta) => void
}) => {
  const [abierto, setAbierto] = useState(false);
  const [mesActual, setMesActual] = useState(() => {
    const fecha = value ? new Date(value) : new Date();
    return new Date(fecha.getFullYear(), fecha.getMonth(), 1);
  });
  // Vista actual: "dias" | "meses" | "anios"
  const [vistaActual, setVistaActual] = useState("dias");
  // Para modo rango: guardamos temporalmente el "desde" mientras se selecciona el "hasta"
  const [seleccionandoRango, setSeleccionandoRango] = useState(false);
  const contenedorRef = useRef(null);

  // Cerrar al hacer clic fuera
  useEffect(() => {
    const handleClickFuera = (e) => {
      if (contenedorRef.current && !contenedorRef.current.contains(e.target)) {
        setAbierto(false);
        setVistaActual("dias");
        // Si estaba seleccionando rango y cierra, mantener solo el desde
        if (seleccionandoRango && value && !valueHasta) {
          setSeleccionandoRango(false);
        }
      }
    };

    if (abierto) {
      document.addEventListener("mousedown", handleClickFuera);
    }

    return () => {
      document.removeEventListener("mousedown", handleClickFuera);
    };
  }, [abierto, seleccionandoRango, value, valueHasta]);

  // Actualizar mes cuando cambia el valor
  useEffect(() => {
    if (value) {
      const fecha = new Date(value);
      setMesActual(new Date(fecha.getFullYear(), fecha.getMonth(), 1));
    }
  }, [value]);

  // Reset vista cuando se abre
  useEffect(() => {
    if (abierto) {
      setVistaActual("dias");
    }
  }, [abierto]);

  const nombresMeses = [
    "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
    "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
  ];

  const nombresMesesCortos = [
    "Ene", "Feb", "Mar", "Abr", "May", "Jun",
    "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"
  ];

  const nombresDias = ["Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sa"];

  const obtenerDiasMes = (fecha) => {
    const year = fecha.getFullYear();
    const month = fecha.getMonth();
    const primerDia = new Date(year, month, 1);
    const ultimoDia = new Date(year, month + 1, 0);
    const diasEnMes = ultimoDia.getDate();
    const diaSemanaInicio = primerDia.getDay();

    const dias = [];

    // D√≠as del mes anterior
    const mesAnterior = new Date(year, month, 0);
    const diasMesAnterior = mesAnterior.getDate();
    for (let i = diaSemanaInicio - 1; i >= 0; i--) {
      dias.push({
        dia: diasMesAnterior - i,
        mesActual: false,
        fecha: new Date(year, month - 1, diasMesAnterior - i),
      });
    }

    // D√≠as del mes actual
    for (let i = 1; i <= diasEnMes; i++) {
      dias.push({
        dia: i,
        mesActual: true,
        fecha: new Date(year, month, i),
      });
    }

    // D√≠as del mes siguiente para completar la √∫ltima fila (solo si es necesario)
    const diasEnUltimaFila = dias.length % 7;
    if (diasEnUltimaFila > 0) {
      const diasRestantes = 7 - diasEnUltimaFila;
      for (let i = 1; i <= diasRestantes; i++) {
        dias.push({
          dia: i,
          mesActual: false,
          fecha: new Date(year, month + 1, i),
        });
      }
    }

    return dias;
  };

  // Obtener d√©cada actual (ej: 2020-2029)
  const obtenerDecada = (year) => {
    const inicio = Math.floor(year / 10) * 10;
    return { inicio, fin: inicio + 9 };
  };

  const irMesAnterior = () => {
    setMesActual(new Date(mesActual.getFullYear(), mesActual.getMonth() - 1, 1));
  };

  const irMesSiguiente = () => {
    setMesActual(new Date(mesActual.getFullYear(), mesActual.getMonth() + 1, 1));
  };

  const irAnioAnterior = () => {
    setMesActual(new Date(mesActual.getFullYear() - 1, mesActual.getMonth(), 1));
  };

  const irAnioSiguiente = () => {
    setMesActual(new Date(mesActual.getFullYear() + 1, mesActual.getMonth(), 1));
  };

  const irDecadaAnterior = () => {
    setMesActual(new Date(mesActual.getFullYear() - 10, mesActual.getMonth(), 1));
  };

  const irDecadaSiguiente = () => {
    setMesActual(new Date(mesActual.getFullYear() + 10, mesActual.getMonth(), 1));
  };

  const seleccionarMes = (mesIndex) => {
    setMesActual(new Date(mesActual.getFullYear(), mesIndex, 1));
    setVistaActual("dias");
  };

  const seleccionarAnio = (year) => {
    setMesActual(new Date(year, mesActual.getMonth(), 1));
    setVistaActual("meses");
  };

  const normalizarFecha = (fecha) => {
    const d = new Date(fecha);
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  };

  const compararFechas = (fecha1, fecha2) => {
    const d1 = normalizarFecha(fecha1);
    const d2 = normalizarFecha(fecha2);
    return d1.getTime() - d2.getTime();
  };

  const seleccionarDia = (dia) => {
    if (disabled) return;

    const fechaSeleccionada = dia.fecha;

    // Validar min/max
    if (minDate && fechaSeleccionada < new Date(minDate)) return;
    if (maxDate && fechaSeleccionada > new Date(maxDate)) return;

    if (modoRango && onChangeRango) {
      // Modo rango
      if (!value || (value && valueHasta)) {
        // No hay desde, o ya hay rango completo: empezar nuevo rango
        onChangeRango(fechaSeleccionada, null);
        setSeleccionandoRango(true);
      } else if (value && !valueHasta) {
        // Ya hay desde, seleccionar hasta
        const desde = new Date(value);
        if (compararFechas(fechaSeleccionada, desde) < 0) {
          // Click en fecha anterior al desde: usar como nuevo desde
          onChangeRango(fechaSeleccionada, null);
          setSeleccionandoRango(true);
        } else if (compararFechas(fechaSeleccionada, desde) === 0) {
          // Mismo d√≠a: selecci√≥n de d√≠a √∫nico
          onChangeRango(fechaSeleccionada, fechaSeleccionada);
          setSeleccionandoRango(false);
          setAbierto(false);
        } else {
          // Fecha posterior: completar rango
          onChangeRango(desde, fechaSeleccionada);
          setSeleccionandoRango(false);
          setAbierto(false);
        }
      }
    } else {
      // Modo d√≠a √∫nico
      onChange(fechaSeleccionada);
      setAbierto(false);
    }
  };

  const esDiaSeleccionado = (dia) => {
    if (!value) return false;
    return compararFechas(dia.fecha, value) === 0;
  };

  const esDiaHasta = (dia) => {
    if (!valueHasta) return false;
    return compararFechas(dia.fecha, valueHasta) === 0;
  };

  const esDiaEnRango = (dia) => {
    if (!modoRango || !value || !valueHasta) return false;
    const fechaDia = normalizarFecha(dia.fecha);
    const desde = normalizarFecha(value);
    const hasta = normalizarFecha(valueHasta);
    return fechaDia > desde && fechaDia < hasta;
  };

  const esHoy = (dia) => {
    const hoy = new Date();
    return (
      dia.fecha.getDate() === hoy.getDate() &&
      dia.fecha.getMonth() === hoy.getMonth() &&
      dia.fecha.getFullYear() === hoy.getFullYear()
    );
  };

  const esDiaDeshabilitado = (dia) => {
    if (minDate && dia.fecha < new Date(minDate)) return true;
    if (maxDate && dia.fecha > new Date(maxDate)) return true;
    return false;
  };

  const esMesActual = (mesIndex) => {
    const hoy = new Date();
    return mesIndex === hoy.getMonth() && mesActual.getFullYear() === hoy.getFullYear();
  };

  const esAnioActual = (year) => {
    return year === new Date().getFullYear();
  };

  const formatearFechaDisplay = (fecha) => {
    if (!fecha) return "";
    const d = new Date(fecha);
    const dia = d.getDate().toString().padStart(2, "0");
    const mes = (d.getMonth() + 1).toString().padStart(2, "0");
    const anio = d.getFullYear().toString().slice(-2);
    return `${dia}/${mes}/${anio}`;
  };

  const obtenerTextoBoton = () => {
    if (modoRango) {
      if (value && valueHasta) {
        if (compararFechas(value, valueHasta) === 0) {
          return formatearFechaDisplay(value);
        }
        return `${formatearFechaDisplay(value)} - ${formatearFechaDisplay(valueHasta)}`;
      }
      if (value && !valueHasta) {
        return `${formatearFechaDisplay(value)} - ...`;
      }
    } else if (value) {
      return formatearFechaDisplay(value);
    }
    return placeholder;
  };

  const limpiarSeleccion = () => {
    if (modoRango && onChangeRango) {
      onChangeRango(null, null);
    } else {
      onChange(null);
    }
    setSeleccionandoRango(false);
    setAbierto(false);
  };

  const tieneSeleccion = modoRango ? (value || valueHasta) : value;

  const dias = obtenerDiasMes(mesActual);
  const decada = obtenerDecada(mesActual.getFullYear());

  // Renderizar header seg√∫n vista
  const renderHeader = () => {
    if (vistaActual === "dias") {
      return (
        <div className="selector-fecha-header">
          <button type="button" className="selector-fecha-nav" onClick={irMesAnterior}>
            ‚óÄ
          </button>
          <button
            type="button"
            className="selector-fecha-titulo"
            onClick={() => setVistaActual("meses")}
          >
            {nombresMeses[mesActual.getMonth()]} {mesActual.getFullYear()}
          </button>
          <button type="button" className="selector-fecha-nav" onClick={irMesSiguiente}>
            ‚ñ∂
          </button>
        </div>
      );
    }

    if (vistaActual === "meses") {
      return (
        <div className="selector-fecha-header">
          <button type="button" className="selector-fecha-nav" onClick={irAnioAnterior}>
            ‚óÄ
          </button>
          <button
            type="button"
            className="selector-fecha-titulo"
            onClick={() => setVistaActual("anios")}
          >
            {mesActual.getFullYear()}
          </button>
          <button type="button" className="selector-fecha-nav" onClick={irAnioSiguiente}>
            ‚ñ∂
          </button>
        </div>
      );
    }

    // Vista a√±os
    return (
      <div className="selector-fecha-header">
        <button type="button" className="selector-fecha-nav" onClick={irDecadaAnterior}>
          ‚óÄ
        </button>
        <span className="selector-fecha-titulo selector-fecha-titulo--no-click">
          {decada.inicio} - {decada.fin}
        </span>
        <button type="button" className="selector-fecha-nav" onClick={irDecadaSiguiente}>
          ‚ñ∂
        </button>
      </div>
    );
  };

  // Renderizar contenido seg√∫n vista
  const renderContenido = () => {
    if (vistaActual === "dias") {
      return (
        <>
          <div className="selector-fecha-dias-semana">
            {nombresDias.map((nombre) => (
              <span key={nombre} className="selector-fecha-dia-semana">
                {nombre}
              </span>
            ))}
          </div>
          <div className="selector-fecha-grilla">
            {dias.map((dia, index) => (
              <button
                key={index}
                type="button"
                className={`selector-fecha-dia ${
                  !dia.mesActual ? "selector-fecha-dia--otro-mes" : ""
                } ${esDiaSeleccionado(dia) ? "selector-fecha-dia--desde" : ""} ${
                  esDiaHasta(dia) ? "selector-fecha-dia--hasta" : ""
                } ${esDiaEnRango(dia) ? "selector-fecha-dia--en-rango" : ""} ${
                  esHoy(dia) ? "selector-fecha-dia--hoy" : ""
                } ${esDiaDeshabilitado(dia) ? "selector-fecha-dia--deshabilitado" : ""}`}
                onClick={() => seleccionarDia(dia)}
                disabled={esDiaDeshabilitado(dia)}
              >
                {dia.dia}
              </button>
            ))}
          </div>
        </>
      );
    }

    if (vistaActual === "meses") {
      return (
        <div className="selector-fecha-grilla-meses">
          {nombresMesesCortos.map((nombre, index) => (
            <button
              key={index}
              type="button"
              className={`selector-fecha-mes-item ${
                esMesActual(index) ? "selector-fecha-mes-item--actual" : ""
              } ${
                mesActual.getMonth() === index ? "selector-fecha-mes-item--seleccionado" : ""
              }`}
              onClick={() => seleccionarMes(index)}
            >
              {nombre}
            </button>
          ))}
        </div>
      );
    }

    // Vista a√±os
    const anios = [];
    for (let i = decada.inicio; i <= decada.fin; i++) {
      anios.push(i);
    }

    return (
      <div className="selector-fecha-grilla-anios">
        {anios.map((year) => (
          <button
            key={year}
            type="button"
            className={`selector-fecha-anio-item ${
              esAnioActual(year) ? "selector-fecha-anio-item--actual" : ""
            } ${
              mesActual.getFullYear() === year ? "selector-fecha-anio-item--seleccionado" : ""
            }`}
            onClick={() => seleccionarAnio(year)}
          >
            {year}
          </button>
        ))}
      </div>
    );
  };

  return (
    <div className={`selector-fecha ${className}`} ref={contenedorRef}>
      <button
        type="button"
        className={`selector-fecha-btn ${abierto ? "selector-fecha-btn--activo" : ""} ${disabled ? "selector-fecha-btn--disabled" : ""} ${tieneSeleccion ? "selector-fecha-btn--con-valor" : ""}`}
        onClick={() => !disabled && setAbierto(!abierto)}
        disabled={disabled}
        title={obtenerTextoBoton()}
      >
        <span className="selector-fecha-icono">üìÖ</span>
      </button>

      {abierto && (
        <div className="selector-fecha-dropdown">
          {/* Indicador de modo rango */}
          {modoRango && (
            <div className="selector-fecha-modo">
              <div className="selector-fecha-modo-contenido">
                {!value ? (
                  <span className="selector-fecha-instruccion">Selecciona fecha inicial</span>
                ) : !valueHasta ? (
                  <span className="selector-fecha-instruccion selector-fecha-instruccion--activo">
                    <span className="selector-fecha-desde-badge">{formatearFechaDisplay(value)}</span>
                    ‚Üí Selecciona fecha final
                  </span>
                ) : (
                  <span className="selector-fecha-instruccion selector-fecha-instruccion--completo">
                    <span className="selector-fecha-desde-badge">{formatearFechaDisplay(value)}</span>
                    ‚Üí
                    <span className="selector-fecha-hasta-badge">{formatearFechaDisplay(valueHasta)}</span>
                  </span>
                )}
              </div>
              {tieneSeleccion && (
                <button
                  type="button"
                  className="selector-fecha-limpiar-mini"
                  onClick={limpiarSeleccion}
                  title="Limpiar selecci√≥n"
                >
                  Limpiar
                </button>
              )}
            </div>
          )}

          {renderHeader()}
          {renderContenido()}

          {/* Footer solo para modo simple (no rango) */}
          {!modoRango && tieneSeleccion && vistaActual === "dias" && (
            <div className="selector-fecha-footer">
              <button
                type="button"
                className="selector-fecha-limpiar"
                onClick={limpiarSeleccion}
              >
                Limpiar
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default SelectorFecha;

// ===== ./src/contextos/AuthContext.jsx =====

// src/contextos/AuthContext.jsx
// Contexto de autenticaci√≥n para toda la aplicaci√≥n

import React, { createContext, useContext, useState, useEffect } from 'react';
import {
  iniciarSesion,
  cerrarSesion,
  obtenerSesion,
  obtenerUsuarioActual,
  registrarUsuario,
  recuperarContrasena,
  suscribirseACambiosAuth,
} from '../servicios/authService';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [usuario, setUsuario] = useState(null);
  const [cargando, setCargando] = useState(true);
  const [error, setError] = useState(null);

  // Cargar sesi√≥n al iniciar
  useEffect(() => {
    const cargarSesion = async () => {
      try {
        const { session } = await obtenerSesion();
        if (session) {
          const { usuario: datosUsuario } = await obtenerUsuarioActual();
          setUsuario(datosUsuario);
        }
      } catch (err) {
        console.error('Error al cargar sesi√≥n:', err);
      } finally {
        setCargando(false);
      }
    };

    cargarSesion();

    // Suscribirse a cambios de auth
    const desuscribir = suscribirseACambiosAuth(async (event, session) => {
      if (event === 'SIGNED_IN' && session) {
        const { usuario: datosUsuario } = await obtenerUsuarioActual();
        setUsuario(datosUsuario);
      } else if (event === 'SIGNED_OUT') {
        setUsuario(null);
      }
    });

    return () => desuscribir();
  }, []);

  // Funci√≥n de login
  const login = async (email, password) => {
    setError(null);
    const { user, error: loginError } = await iniciarSesion(email, password);

    if (loginError) {
      setError(loginError);
      return { exito: false, error: loginError };
    }

    if (user) {
      const { usuario: datosUsuario } = await obtenerUsuarioActual();
      setUsuario(datosUsuario);
    }

    return { exito: true, error: null };
  };

  // Funci√≥n de registro
  const registro = async (email, password, nombre) => {
    setError(null);
    const { user, error: registroError } = await registrarUsuario(email, password, nombre);

    if (registroError) {
      setError(registroError);
      return { exito: false, error: registroError };
    }

    return { exito: true, error: null, requiereConfirmacion: true };
  };

  // Funci√≥n de logout
  const logout = async () => {
    const { error: logoutError } = await cerrarSesion();
    if (!logoutError) {
      setUsuario(null);
    }
    return { error: logoutError };
  };

  // Funci√≥n para recuperar contrase√±a
  const recuperar = async (email) => {
    setError(null);
    const { error: recuperarError } = await recuperarContrasena(email);

    if (recuperarError) {
      setError(recuperarError);
      return { exito: false, error: recuperarError };
    }

    return { exito: true, error: null };
  };

  const valor = {
    usuario,
    cargando,
    error,
    estaAutenticado: !!usuario,
    login,
    logout,
    registro,
    recuperar,
  };

  return (
    <AuthContext.Provider value={valor}>
      {children}
    </AuthContext.Provider>
  );
}

// Hook personalizado para usar el contexto
export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth debe usarse dentro de un AuthProvider');
  }
  return context;
}

// ===== ./src/hooks/usePushNotifications.js =====

// src/hooks/usePushNotifications.js
// Hook para gestionar push notifications en la app

import { useEffect, useRef, useCallback } from 'react';
import {
  esPlataformaNativa,
  registrarPushNotifications,
  desregistrarPushNotifications,
} from '../servicios/pushNotifications';
import { registrarTokenDispositivo } from '../servicios/apiService';

/**
 * Hook para inicializar y gestionar push notifications.
 * Solo funciona en plataformas nativas (Android/iOS).
 *
 * @param {Object} opciones - Opciones del hook
 * @param {boolean} opciones.habilitado - Si las notificaciones est√°n habilitadas (default: true)
 * @param {Function} opciones.onNotificacion - Callback cuando llega una notificaci√≥n en primer plano
 * @param {Function} opciones.onNotificacionTocada - Callback cuando el usuario toca la notificaci√≥n
 * @returns {Object} { esNativo, tokenRegistrado }
 */
export function usePushNotifications({
  habilitado = true,
  onNotificacion = null,
  onNotificacionTocada = null,
} = {}) {
  const tokenRegistradoRef = useRef(false);
  const esNativo = esPlataformaNativa();

  // Callback para cuando se recibe el token FCM
  const handleTokenRecibido = useCallback(async (token) => {
    if (tokenRegistradoRef.current) {
      console.log('[Push Hook] Token ya registrado, ignorando');
      return;
    }

    try {
      console.log('[Push Hook] Registrando token en backend...');
      await registrarTokenDispositivo(token, 'android');
      tokenRegistradoRef.current = true;
      console.log('[Push Hook] Token registrado exitosamente');
    } catch (error) {
      console.error('[Push Hook] Error registrando token:', error);
    }
  }, []);

  // Callback para notificaciones en primer plano
  const handleNotificacion = useCallback((notificacion) => {
    console.log('[Push Hook] Notificaci√≥n recibida:', notificacion);
    if (onNotificacion) {
      onNotificacion(notificacion);
    }
  }, [onNotificacion]);

  // Callback para cuando el usuario toca la notificaci√≥n
  const handleNotificacionTocada = useCallback((datos) => {
    console.log('[Push Hook] Notificaci√≥n tocada:', datos);
    if (onNotificacionTocada) {
      onNotificacionTocada(datos);
    }
  }, [onNotificacionTocada]);

  useEffect(() => {
    if (!esNativo || !habilitado) {
      console.log('[Push Hook] Saltando inicializaci√≥n (nativo:', esNativo, ', habilitado:', habilitado, ')');
      return;
    }

    console.log('[Push Hook] Inicializando push notifications...');

    // Inicializar push notifications
    registrarPushNotifications(
      handleTokenRecibido,
      handleNotificacion,
      handleNotificacionTocada
    );

    // Cleanup al desmontar
    return () => {
      console.log('[Push Hook] Limpiando listeners...');
      desregistrarPushNotifications();
    };
  }, [esNativo, habilitado, handleTokenRecibido, handleNotificacion, handleNotificacionTocada]);

  return {
    esNativo,
    tokenRegistrado: tokenRegistradoRef.current,
  };
}

export default usePushNotifications;

// ===== ./src/lib/supabase.js =====

// src/lib/supabase.js
// Cliente de Supabase para el frontend

import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Faltan las variables de entorno de Supabase (VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY)');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);

// ===== ./src/main.jsx =====

// src/main.jsx
import React from "react";                         // librer√≠a principal de React para componentes
import ReactDOM from "react-dom/client";           // API moderna de renderizado en el navegador
import { BrowserRouter } from "react-router-dom";  // enrutador basado en historial del navegador
import { AuthProvider } from "./contextos/AuthContext"; // contexto de autenticaci√≥n con Supabase
import App from "./App.jsx";                       // componente ra√≠z de la aplicaci√≥n (define las rutas)
import "./index.css";                              // estilos globales (variables CSS + tema)
import "./fuentes.css";                            // fuentes locales desde public/fonts/
import { Capacitor } from "@capacitor/core";       // para detectar plataforma nativa

// Configurar plataforma nativa (Android/iOS)
if (Capacitor.isNativePlatform()) {
   // Agregar clase a html y body para estilos espec√≠ficos de app nativa
   document.documentElement.classList.add('capacitor-native');
   document.body.classList.add('capacitor-native');
   // Los insets se manejan desde MainActivity.java con ViewCompat.setOnApplyWindowInsetsListener
}

ReactDOM.createRoot(document.getElementById("root")).render(   // crea la ra√≠z de React sobre el div#root
   <React.StrictMode>                   {/* modo estricto: ayuda a detectar problemas en desarrollo */}
      <BrowserRouter>                   {/* provee contexto de rutas a toda la app */}
         <AuthProvider>                 {/* provee contexto de autenticaci√≥n a toda la app */}
            <App />                     {/* componente principal que contiene las p√°ginas/rutas */}
         </AuthProvider>
      </BrowserRouter>
   </React.StrictMode>
);

// ---------------------------------------------------------------------------
// NOTA PERSONAL SOBRE ESTE ARCHIVO (main.jsx)
// - Este es el punto de entrada de la app React que usa Vite.
// - ReactDOM.createRoot() toma el <div id="root"> del index.html y ah√≠ monta todo.
// - StrictMode solo afecta al modo desarrollo: vuelve a montar componentes para
//   avisar de problemas potenciales, pero en producci√≥n no impacta.
// - BrowserRouter envuelve a <App /> para que dentro pueda usar rutas
//   (Link, Route, useNavigate, etc.) basadas en la URL del navegador.
// - En resumen: ac√° se conecta el HTML base con mi √°rbol de componentes y el
//   sistema de rutas de React Router.

// ===== ./src/paginas/PaginaAlimentadores/componentes/historial/BarraControlesHistorial.jsx =====

/**
 * Barra de controles para la ventana de historial
 * Incluye: toggle panel, tabs de zona, selector de rango, tipo de grafico, selector alimentador, cache
 */

import PropTypes from "prop-types";
import { RANGOS_TIEMPO, TIPOS_GRAFICO } from "../../constantes/historialConfig";
import SelectorFecha from "../../../../componentes/comunes/SelectorFecha";

/**
 * @param {Object} props
 * @param {boolean} props.panelDatosAbierto - Si el panel de datos est√° visible
 * @param {Function} props.onTogglePanel - Callback para toggle del panel
 * @param {string} props.zonaSeleccionada - "superior" o "inferior"
 * @param {Function} props.onZonaChange - Callback al cambiar zona
 * @param {Function} props.zonaDisponible - Funci√≥n que verifica si una zona est√° disponible
 * @param {string} props.tituloSuperior - T√≠tulo de la zona superior
 * @param {string} props.tituloInferior - T√≠tulo de la zona inferior
 * @param {string} props.rangoSeleccionado - ID del rango seleccionado
 * @param {Function} props.onRangoChange - Callback al cambiar rango
 * @param {Date|null} props.fechaRangoDesde - Fecha desde (rango personalizado)
 * @param {Date|null} props.fechaRangoHasta - Fecha hasta (rango personalizado)
 * @param {Function} props.onFechaRangoChange - Callback al cambiar fechas
 * @param {string} props.tipoGrafico - Tipo de gr√°fico seleccionado
 * @param {Function} props.onTipoGraficoChange - Callback al cambiar tipo
 * @param {string} props.alimentadorId - ID del alimentador actual
 * @param {Array} props.alimentadores - Lista de alimentadores disponibles
 * @param {Function} props.onAlimentadorChange - Callback al cambiar alimentador
 * @param {number} props.precargaProgreso - Progreso de precarga (0-100)
 * @param {boolean} props.precargaCompleta - Si la precarga termin√≥
 * @param {boolean} props.precargando - Si est√° precargando
 * @param {string|null} props.fuenteDatos - Fuente de datos actual
 * @param {Function} props.onLimpiarCache - Callback para limpiar cache
 */
const BarraControlesHistorial = ({
  panelDatosAbierto,
  onTogglePanel,
  zonaSeleccionada,
  onZonaChange,
  zonaDisponible,
  tituloSuperior,
  tituloInferior,
  rangoSeleccionado,
  onRangoChange,
  fechaRangoDesde,
  fechaRangoHasta,
  onFechaRangoChange,
  tipoGrafico,
  onTipoGraficoChange,
  alimentadorId,
  alimentadores,
  onAlimentadorChange,
  precargaProgreso,
  precargaCompleta,
  precargando,
  fuenteDatos,
  onLimpiarCache,
  graficoVisible,
  onToggleGrafico,
}) => {
  return (
    <div className="ventana-controles">
      {/* Boton toggle para panel de datos */}
      <button
        type="button"
        className={`ventana-toggle-datos ${panelDatosAbierto ? "ventana-toggle-datos--activo" : ""}`}
        onClick={onTogglePanel}
        title={panelDatosAbierto ? "Ocultar datos" : "Ver datos"}
      >
        <span className="ventana-toggle-icono">‚ñ≤</span>
      </button>

      {/* Tabs de zona */}
      <div className="ventana-tabs">
        <button
          type="button"
          className={`ventana-tab ${zonaSeleccionada === "superior" ? "ventana-tab--activo" : ""}`}
          onClick={() => onZonaChange("superior")}
          disabled={!zonaDisponible("superior")}
        >
          {tituloSuperior}
        </button>
        <button
          type="button"
          className={`ventana-tab ${zonaSeleccionada === "inferior" ? "ventana-tab--activo" : ""}`}
          onClick={() => onZonaChange("inferior")}
          disabled={!zonaDisponible("inferior")}
        >
          {tituloInferior}
        </button>
      </div>

      {/* Selector de rango */}
      <div className="ventana-rango">
        {RANGOS_TIEMPO.filter((r) => r.id !== "custom").map((r) => (
          <button
            key={r.id}
            type="button"
            className={`ventana-rango-btn ${rangoSeleccionado === r.id && !fechaRangoDesde ? "ventana-rango-btn--activo" : ""}`}
            onClick={() => onRangoChange(r.id)}
          >
            {r.label}
          </button>
        ))}
      </div>

      {/* Grupo: Selector de fechas + Tipo de gr√°fico */}
      <div className="ventana-grupo-graficos">
        {/* Selector de rango de fechas */}
        <div className="ventana-selector-dia">
          <SelectorFecha
            value={fechaRangoDesde}
            valueHasta={fechaRangoHasta}
            modoRango={true}
            onChangeRango={onFechaRangoChange}
            maxDate={new Date()}
            placeholder="Seleccionar fechas"
          />
          {fechaRangoDesde && fechaRangoHasta && (
            <span className="ventana-dia-seleccionado">
              {new Date(fechaRangoDesde).toLocaleDateString("es-AR", {
                day: "2-digit",
                month: "2-digit",
                year: "2-digit",
              })}
              {fechaRangoDesde.getTime() !== fechaRangoHasta.getTime() && (
                <>
                  {" "}
                  -{" "}
                  {new Date(fechaRangoHasta).toLocaleDateString("es-AR", {
                    day: "2-digit",
                    month: "2-digit",
                    year: "2-digit",
                  })}
                </>
              )}
            </span>
          )}
        </div>

        {/* Selector de tipo de grafico */}
        <div className="ventana-tipo-grafico">
          {TIPOS_GRAFICO.map((tipo) => (
            <button
              key={tipo.id}
              type="button"
              className={`ventana-tipo-btn ${tipoGrafico === tipo.id ? "ventana-tipo-btn--activo" : ""}`}
              onClick={() => onTipoGraficoChange(tipo.id)}
              title={tipo.label}
            >
              {tipo.icon}
            </button>
          ))}
        </div>
      </div>

      {/* Selector de alimentador */}
      {alimentadores && alimentadores.length > 1 && (
        <div className="ventana-selector-alimentador-container">
          <select
            className="ventana-selector-alimentador"
            value={alimentadorId}
            onChange={(e) => onAlimentadorChange(e.target.value)}
            title="Cambiar alimentador"
          >
            {alimentadores.map((alim) => (
              <option key={alim.id} value={alim.id}>
                {alim.nombre}
              </option>
            ))}
          </select>
        </div>
      )}

      {/* Cache + Fuente */}
      <div className="ventana-cache">
        {/* Bot√≥n toggle gr√°fico - solo visible en m√≥vil portrait */}
        <button
          type="button"
          className={`ventana-toggle-grafico ${graficoVisible ? "" : "ventana-toggle-grafico--cerrado"}`}
          onClick={onToggleGrafico}
          title={graficoVisible ? "Ocultar gr√°fico" : "Mostrar gr√°fico"}
        >
          <span className="ventana-toggle-grafico-icono">‚ñº</span>
        </button>
        <div className="ventana-cache-barra">
          <div
            className={`ventana-cache-progreso ${precargaCompleta ? "ventana-cache-progreso--completo" : ""}`}
            style={{ width: `${precargaProgreso}%` }}
          />
        </div>
        <span className="ventana-cache-texto">
          {precargaCompleta ? "‚úì" : `${precargaProgreso}%`}
        </span>
        {fuenteDatos && (
          <span className={`ventana-fuente ventana-fuente--${fuenteDatos}`}>
            {fuenteDatos === "local" ? "Local" : fuenteDatos === "remoto" ? "BD" : "Mixto"}
          </span>
        )}
        <button
          type="button"
          className="ventana-btn-limpiar"
          onClick={onLimpiarCache}
          disabled={precargando}
          title="Limpiar cache"
        >
          üóë
        </button>
      </div>
    </div>
  );
};

BarraControlesHistorial.propTypes = {
  panelDatosAbierto: PropTypes.bool.isRequired,
  onTogglePanel: PropTypes.func.isRequired,
  zonaSeleccionada: PropTypes.oneOf(["superior", "inferior"]).isRequired,
  onZonaChange: PropTypes.func.isRequired,
  zonaDisponible: PropTypes.func.isRequired,
  tituloSuperior: PropTypes.string,
  tituloInferior: PropTypes.string,
  rangoSeleccionado: PropTypes.string.isRequired,
  onRangoChange: PropTypes.func.isRequired,
  fechaRangoDesde: PropTypes.instanceOf(Date),
  fechaRangoHasta: PropTypes.instanceOf(Date),
  onFechaRangoChange: PropTypes.func.isRequired,
  tipoGrafico: PropTypes.oneOf(["line", "area", "bar"]).isRequired,
  onTipoGraficoChange: PropTypes.func.isRequired,
  alimentadorId: PropTypes.string,
  alimentadores: PropTypes.array,
  onAlimentadorChange: PropTypes.func,
  precargaProgreso: PropTypes.number,
  precargaCompleta: PropTypes.bool,
  precargando: PropTypes.bool,
  fuenteDatos: PropTypes.oneOf(["local", "remoto", "mixto", null]),
  onLimpiarCache: PropTypes.func.isRequired,
  graficoVisible: PropTypes.bool,
  onToggleGrafico: PropTypes.func,
};

BarraControlesHistorial.defaultProps = {
  tituloSuperior: "Superior",
  tituloInferior: "Inferior",
  fechaRangoDesde: null,
  fechaRangoHasta: null,
  alimentadorId: "",
  alimentadores: [],
  onAlimentadorChange: () => {},
  precargaProgreso: 0,
  precargaCompleta: false,
  precargando: false,
  fuenteDatos: null,
  graficoVisible: true,
  onToggleGrafico: () => {},
};

export default BarraControlesHistorial;

// ===== ./src/paginas/PaginaAlimentadores/componentes/historial/BarraTituloVentana.jsx =====

/**
 * Barra de titulo arrastrable para ventanas flotantes de historial
 * Incluye titulo, botones de minimizar/maximizar/cerrar
 * En m√≥vil solo muestra el bot√≥n de cerrar
 */

import { forwardRef } from "react";
import PropTypes from "prop-types";

/**
 * @param {Object} props
 * @param {string} props.nombre - Nombre del alimentador
 * @param {boolean} props.maximizada - Si la ventana esta maximizada
 * @param {Function} props.onMinimizar - Callback para minimizar
 * @param {Function} props.onMaximizar - Callback para maximizar/restaurar
 * @param {Function} props.onCerrar - Callback para cerrar
 * @param {Function} props.onMouseDown - Callback para iniciar arrastre
 * @param {React.Ref} ref - Ref para el header
 */
const BarraTituloVentana = forwardRef(({
  nombre,
  maximizada,
  onMinimizar,
  onMaximizar,
  onCerrar,
  onMouseDown,
}, ref) => {
  return (
    <header
      ref={ref}
      className="ventana-historial-header"
      onMouseDown={onMouseDown}
    >
      <div className="ventana-historial-titulo">
        <span className="ventana-historial-icono">üìä</span>
        <span className="ventana-historial-nombre">{nombre}</span>
      </div>
      <div className="ventana-historial-controles">
        {/* Botones minimizar/maximizar ocultos en m√≥vil via CSS */}
        <button
          type="button"
          className="ventana-btn ventana-btn--minimizar ventana-btn--desktop-only"
          onClick={onMinimizar}
          title="Minimizar"
        >
          <span>‚îÄ</span>
        </button>
        <button
          type="button"
          className="ventana-btn ventana-btn--maximizar ventana-btn--desktop-only"
          onClick={onMaximizar}
          title={maximizada ? "Restaurar" : "Maximizar"}
        >
          <span>{maximizada ? "‚ùê" : "‚ñ°"}</span>
        </button>
        <button
          type="button"
          className="ventana-btn ventana-btn--cerrar"
          onClick={onCerrar}
          title="Cerrar"
        >
          <span>√ó</span>
        </button>
      </div>
    </header>
  );
});

BarraTituloVentana.displayName = "BarraTituloVentana";

BarraTituloVentana.propTypes = {
  nombre: PropTypes.string,
  maximizada: PropTypes.bool,
  onMinimizar: PropTypes.func.isRequired,
  onMaximizar: PropTypes.func.isRequired,
  onCerrar: PropTypes.func.isRequired,
  onMouseDown: PropTypes.func.isRequired,
};

BarraTituloVentana.defaultProps = {
  nombre: "Ventana",
  maximizada: false,
};

export default BarraTituloVentana;

// ===== ./src/paginas/PaginaAlimentadores/componentes/historial/ControlEscalaY.jsx =====

// componentes/historial/ControlEscalaY.jsx
// Control slider vertical para ajustar la escala Y del gr√°fico

/**
 * Control de escala Y con slider vertical y edici√≥n manual
 * @param {Object} props
 * @param {boolean} props.visible - Si mostrar el control
 * @param {number|null} props.escalaYMax - Valor actual de escala (null = auto)
 * @param {Function} props.setEscalaYMax - Setter para escala
 * @param {{min: number, max: number}} props.limitesEscalaY - L√≠mites del slider
 * @param {boolean} props.editandoEscalaY - Si est√° en modo edici√≥n manual
 * @param {Function} props.setEditandoEscalaY - Setter para modo edici√≥n
 * @param {Function} props.handleEscalaYManual - Handler para valor manual
 */
const ControlEscalaY = ({
   visible,
   escalaYMax,
   setEscalaYMax,
   limitesEscalaY,
   editandoEscalaY,
   setEditandoEscalaY,
   handleEscalaYManual,
}) => {
   if (!visible) return null;

   const handleSubirEscala = () => {
      const valorActual = escalaYMax ?? limitesEscalaY.min;
      const redondeado = Math.ceil(valorActual / 10) * 10;
      const nuevoValor = redondeado === valorActual ? valorActual + 10 : redondeado;
      setEscalaYMax(Math.min(nuevoValor, limitesEscalaY.max));
   };

   const handleBajarEscala = () => {
      const valorActual = escalaYMax ?? limitesEscalaY.min;
      const redondeado = Math.floor(valorActual / 10) * 10;
      const nuevoValor = redondeado === valorActual ? valorActual - 10 : redondeado;
      setEscalaYMax(Math.max(nuevoValor, limitesEscalaY.min));
   };

   return (
      <div className="ventana-escala-y">
         {/* Bot√≥n subir escala */}
         <button
            type="button"
            className="ventana-escala-y-btn ventana-escala-y-btn--arriba"
            onClick={handleSubirEscala}
            title="Aumentar escala +10"
         >
            ‚ñ≤
         </button>

         {/* Valor editable o label */}
         {editandoEscalaY ? (
            <input
               type="number"
               className="ventana-escala-y-input"
               defaultValue={escalaYMax ?? limitesEscalaY.min}
               autoFocus
               onBlur={(e) => handleEscalaYManual(e.target.value)}
               onKeyDown={(e) => {
                  if (e.key === "Enter") handleEscalaYManual(e.target.value);
                  if (e.key === "Escape") setEditandoEscalaY(false);
               }}
            />
         ) : (
            <span
               className="ventana-escala-y-label ventana-escala-y-label--editable"
               onDoubleClick={() => setEditandoEscalaY(true)}
               title="Doble click para editar"
            >
               {escalaYMax ?? limitesEscalaY.min}
            </span>
         )}

         {/* Slider */}
         <input
            type="range"
            className="ventana-escala-y-slider"
            min={limitesEscalaY.min}
            max={limitesEscalaY.max}
            step={0.5}
            value={escalaYMax ?? limitesEscalaY.min}
            onChange={(e) => setEscalaYMax(Number(e.target.value))}
            title={`Escala Y: 0 - ${escalaYMax ?? limitesEscalaY.min}`}
         />

         <span className="ventana-escala-y-label">0</span>

         {/* Bot√≥n bajar escala */}
         <button
            type="button"
            className="ventana-escala-y-btn ventana-escala-y-btn--abajo"
            onClick={handleBajarEscala}
            title="Disminuir escala -10"
         >
            ‚ñº
         </button>

         {/* Bot√≥n auto */}
         <button
            type="button"
            className="ventana-escala-y-reset"
            onClick={() => setEscalaYMax(null)}
            title="Restaurar escala autom√°tica"
            disabled={!escalaYMax}
         >
            Auto
         </button>
      </div>
   );
};

export default ControlEscalaY;

// ===== ./src/paginas/PaginaAlimentadores/componentes/historial/EstadisticasHistorial.jsx =====

// componentes/historial/EstadisticasHistorial.jsx
// Barra de estad√≠sticas del historial con botones de exportaci√≥n

/**
 * Muestra estad√≠sticas (puntos, min, max, promedio) y botones de exportaci√≥n
 * @param {Object} props
 * @param {Object|null} props.estadisticas - Estad√≠sticas calculadas
 * @param {Function} props.onExportarCSV - Handler para exportar CSV
 * @param {Function} props.onAbrirInforme - Handler para abrir modal de informe
 * @param {boolean} props.datosDisponibles - Si hay datos para exportar
 */
const EstadisticasHistorial = ({
   estadisticas,
   onExportarCSV,
   onAbrirInforme,
   datosDisponibles,
}) => {
   if (!estadisticas) return null;

   return (
      <div className="ventana-stats">
         <span className="ventana-stat">
            <b>Puntos:</b>
            <input
               type="text"
               className="ventana-stat-input"
               value={estadisticas.puntos}
               size={String(estadisticas.puntos).length || 1}
               readOnly
            />
         </span>

         <span className="ventana-stat">
            <b>M√≠n:</b>
            <input
               type="text"
               className="ventana-stat-input"
               value={estadisticas.min}
               size={estadisticas.min.length || 1}
               readOnly
            />
            {estadisticas.minFecha && (
               <span className="ventana-stat-fecha">({estadisticas.minFecha})</span>
            )}
         </span>

         <span className="ventana-stat">
            <b>M√°x:</b>
            <input
               type="text"
               className="ventana-stat-input"
               value={estadisticas.max}
               size={estadisticas.max.length || 1}
               readOnly
            />
            {estadisticas.maxFecha && (
               <span className="ventana-stat-fecha">({estadisticas.maxFecha})</span>
            )}
         </span>

         <span className="ventana-stat">
            <b>Prom:</b>
            <input
               type="text"
               className="ventana-stat-input"
               value={estadisticas.promedio}
               size={estadisticas.promedio.length || 1}
               readOnly
            />
         </span>

         <button
            type="button"
            className="ventana-btn-exportar ventana-btn--desktop-only"
            onClick={onExportarCSV}
            disabled={!datosDisponibles}
         >
            CSV
         </button>

         <button
            type="button"
            className="ventana-btn-exportar ventana-btn-informe ventana-btn--desktop-only"
            onClick={onAbrirInforme}
            disabled={!datosDisponibles}
         >
            Informe
         </button>
      </div>
   );
};

export default EstadisticasHistorial;

// ===== ./src/paginas/PaginaAlimentadores/componentes/historial/EstadoGrafico.jsx =====

// componentes/historial/EstadoGrafico.jsx
// Componente que muestra estados de carga/error/vac√≠o del gr√°fico

/**
 * Renderiza estados de carga, error o sin datos del gr√°fico
 * @param {Object} props
 * @param {boolean} props.cargando - Si est√° cargando
 * @param {string|null} props.error - Mensaje de error
 * @param {boolean} props.precargando - Si est√° precargando datos
 * @param {number} props.datosLength - Cantidad de datos
 * @param {Function} props.onReintentar - Callback para reintentar carga
 * @param {React.ReactNode} props.children - Gr√°fico a renderizar cuando hay datos
 */
const EstadoGrafico = ({
   cargando,
   error,
   precargando,
   datosLength,
   onReintentar,
   children,
}) => {
   if (cargando) {
      return (
         <div className="ventana-estado">
            <div className="ventana-spinner" />
            <span>Cargando...</span>
         </div>
      );
   }

   if (error) {
      return (
         <div className="ventana-estado ventana-estado--error">
            <span>Error: {error}</span>
            <button onClick={onReintentar}>Reintentar</button>
         </div>
      );
   }

   if (precargando && datosLength === 0) {
      return (
         <div className="ventana-estado">
            <div className="ventana-spinner" />
            <span>Descargando datos de la base de datos...</span>
         </div>
      );
   }

   if (datosLength === 0) {
      return (
         <div className="ventana-estado">
            <span>No hay datos en el per√≠odo seleccionado</span>
         </div>
      );
   }

   return children;
};

export default EstadoGrafico;

// ===== ./src/paginas/PaginaAlimentadores/componentes/historial/index.js =====

// componentes/historial/index.js
// Componentes relacionados con la visualizaci√≥n del historial

export { default as PanelDatosHistorial } from "./PanelDatosHistorial";
export { default as BarraTituloVentana } from "./BarraTituloVentana";
export { default as BarraControlesHistorial } from "./BarraControlesHistorial";
export { default as ControlEscalaY } from "./ControlEscalaY";
export { default as EstadoGrafico } from "./EstadoGrafico";
export { default as EstadisticasHistorial } from "./EstadisticasHistorial";

// ===== ./src/paginas/PaginaAlimentadores/componentes/historial/PanelDatosHistorial.jsx =====

/**
 * Panel lateral que muestra la tabla de datos del historial
 * Recibe los datos ya filtrados desde VentanaHistorial
 */

import { useMemo } from "react";
import PropTypes from "prop-types";

/**
 * @param {Object} props
 * @param {boolean} props.abierto - Si el panel est√° visible
 * @param {string} props.tituloPeriodo - T√≠tulo mostrando el per√≠odo de fechas
 * @param {number} props.intervaloFiltro - Intervalo de filtrado actual (0, 15, 30, 60 minutos)
 * @param {Function} props.onIntervaloChange - Callback al cambiar intervalo
 * @param {Array} props.datosFiltrados - Datos ya filtrados [{x, y}]
 * @param {string} props.tipoGrafico - Tipo de gr√°fico actual (line, area, bar)
 */
const PanelDatosHistorial = ({
  abierto,
  tituloPeriodo,
  intervaloFiltro,
  onIntervaloChange,
  datosFiltrados,
  tipoGrafico,
}) => {
  // El gr√°fico de barras no soporta "Todos (1/min)" por rendimiento
  const todosDeshabilitado = tipoGrafico === "bar";

  // Formatear datos para la tabla
  const datosTabla = useMemo(() => {
    return datosFiltrados.map((punto) => {
      const fecha = new Date(punto.x);
      return {
        fecha: fecha.toLocaleDateString("es-AR", { day: "2-digit", month: "2-digit", year: "2-digit" }),
        hora: fecha.toLocaleTimeString("es-AR", { hour: "2-digit", minute: "2-digit", second: "2-digit" }),
        medicion: Math.ceil(punto.y * 100) / 100,
      };
    });
  }, [datosFiltrados]);

  if (!abierto) return null;

  return (
    <div className="ventana-panel-datos">
      <div className="ventana-panel-header">
        <span>{tituloPeriodo}</span>
        <select
          className="ventana-panel-intervalo"
          value={intervaloFiltro}
          onChange={(e) => onIntervaloChange(Number(e.target.value))}
        >
          <option value={0} disabled={todosDeshabilitado}>
            {todosDeshabilitado ? "Todos (no disp.)" : "Todos"}
          </option>
          <option value={15}>cada 15m</option>
          <option value={30}>cada 30m</option>
          <option value={60}>cada 60m</option>
        </select>
      </div>
      <div className="ventana-panel-tabla-container">
        <table className="ventana-panel-tabla">
          <thead>
            <tr>
              <th>Fecha</th>
              <th>Hora</th>
              <th>Medicion</th>
            </tr>
          </thead>
          <tbody>
            {datosTabla.map((fila, idx) => (
              <tr key={idx}>
                <td>{fila.fecha}</td>
                <td>{fila.hora}</td>
                <td>{fila.medicion.toFixed(2)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

PanelDatosHistorial.propTypes = {
  abierto: PropTypes.bool.isRequired,
  tituloPeriodo: PropTypes.string,
  intervaloFiltro: PropTypes.number,
  onIntervaloChange: PropTypes.func.isRequired,
  datosFiltrados: PropTypes.arrayOf(
    PropTypes.shape({
      x: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.number]),
      y: PropTypes.number,
    })
  ),
  tipoGrafico: PropTypes.oneOf(["line", "area", "bar"]),
};

PanelDatosHistorial.defaultProps = {
  tituloPeriodo: "Sin datos",
  intervaloFiltro: 60,
  datosFiltrados: [],
  tipoGrafico: "line",
};

export default PanelDatosHistorial;

// ===== ./src/paginas/PaginaAlimentadores/componentes/layout/EstadoCarga.jsx =====

// componentes/layout/EstadoCarga.jsx
// Estados de carga y error para la vista principal

/**
 * Muestra estado de carga o error
 * @param {Object} props
 * @param {string|null} props.error - Mensaje de error (si hay)
 */
const EstadoCarga = ({ error = null }) => {
   if (error) {
      return (
         <div className="alim-page alim-page--error">
            <div className="alim-error">
               <p>Error: {error}</p>
               <button onClick={() => window.location.reload()}>Reintentar</button>
            </div>
         </div>
      );
   }

   return (
      <div className="alim-page alim-page--cargando">
         <div className="alim-loading">
            <div className="alim-loading__spinner"></div>
            <p>Cargando configuraci√≥n...</p>
         </div>
      </div>
   );
};

export default EstadoCarga;

// ===== ./src/paginas/PaginaAlimentadores/componentes/layout/EstadoVacio.jsx =====

// componentes/layout/EstadoVacio.jsx
// Estados vac√≠os para cuando no hay workspace o puestos

/**
 * Muestra estados vac√≠os seg√∫n el tipo
 * @param {Object} props
 * @param {'sinWorkspace'|'sinPuestos'} props.tipo - Tipo de estado vac√≠o
 * @param {Function} props.onSalir - Handler para bot√≥n de salir
 */
const EstadoVacio = ({ tipo, onSalir }) => {
   if (tipo === "sinWorkspace") {
      return (
         <div className="alim-sin-workspace">
            <h2>Sin acceso a workspaces</h2>
            <p>No tienes ning√∫n workspace asignado.</p>
            <p>Contacta a un administrador para que te asigne acceso a un workspace.</p>
            <button onClick={onSalir}>Volver al inicio</button>
         </div>
      );
   }

   // sinPuestos
   return (
      <div className="alim-empty-state">
         <p>
            No hay puestos creados. Haz clic en el boton "+" para agregar
            uno.
         </p>
      </div>
   );
};

export default EstadoVacio;

// ===== ./src/paginas/PaginaAlimentadores/componentes/layout/ModalesVista.jsx =====

// componentes/layout/ModalesVista.jsx
// Contenedor de todos los modales de la vista de alimentadores

import { ModalNuevoPuesto, ModalEditarPuestos, ModalConfiguracionPuesto } from "../modales/puesto";
import ModalConfiguracionAlimentador from "../modales/ModalConfiguracionAlimentador.jsx";
import ModalConfigurarAgente from "../modales/ModalConfigurarAgente.jsx";
import { ModalGestionarAccesos, ModalPanelPermisos } from "../modales/permisos";

/**
 * Contenedor de todos los modales de la vista
 */
const ModalesVista = ({
   // Modal Nuevo Puesto
   modalNuevoPuestoAbierto,
   onCerrarNuevoPuesto,
   onCrearPuesto,
   coloresSistema,
   // Modal Editar Puestos
   modalEditarPuestosAbierto,
   puestosConPreferencias,
   onCerrarEditarPuestos,
   onGuardarPuestos,
   esCreador,
   rolEnWorkspace,
   esCompacto,
   obtenerEscalaPuesto,
   onEscalaPuestoChange,
   ESCALA_MIN,
   ESCALA_MAX,
   estilosGlobales,
   onGuardarEstilos,
   // Modal Alimentador
   modalAlimentadorAbierto,
   puestoNombre,
   workspaceId,
   modoAlimentador,
   alimentadorEnEdicion,
   onCancelarAlimentador,
   onConfirmarAlimentador,
   onEliminarAlimentador,
   // Modal Config Puesto
   modalConfigPuestoAbierto,
   puesto,
   onCerrarConfigPuesto,
   estaPolling,
   onPlayStopClick,
   buscarRegistrador,
   // Modal Agente
   ventanaConfigAgente,
   onCerrarConfigAgente,
   onMinimizarConfigAgente,
   onMaximizarConfigAgente,
   onEnfocarConfigAgente,
   onMoverConfigAgente,
   // Modal Accesos
   modalAccesosAbierto,
   onCerrarAccesos,
   usuarioActualId,
   // Modal Panel Permisos
   modalPanelPermisosAbierto,
   onCerrarPanelPermisos,
}) => {
   return (
      <>
         <ModalNuevoPuesto
            abierto={modalNuevoPuestoAbierto}
            onCerrar={onCerrarNuevoPuesto}
            onCrear={onCrearPuesto}
            coloresSistema={coloresSistema}
         />

         <ModalEditarPuestos
            abierto={modalEditarPuestosAbierto}
            puestos={puestosConPreferencias}
            onCerrar={onCerrarEditarPuestos}
            onGuardar={onGuardarPuestos}
            esCreador={esCreador}
            rolEnWorkspace={rolEnWorkspace}
            obtenerEscalaPuesto={!esCompacto ? obtenerEscalaPuesto : undefined}
            onEscalaPuestoChange={!esCompacto ? onEscalaPuestoChange : undefined}
            ESCALA_MIN={ESCALA_MIN}
            ESCALA_MAX={ESCALA_MAX}
            estilosGlobales={estilosGlobales}
            onGuardarEstilos={onGuardarEstilos}
         />

         <ModalConfiguracionAlimentador
            abierto={modalAlimentadorAbierto}
            puestoNombre={puestoNombre}
            workspaceId={workspaceId}
            modo={modoAlimentador}
            initialData={alimentadorEnEdicion}
            onCancelar={onCancelarAlimentador}
            onConfirmar={onConfirmarAlimentador}
            onEliminar={onEliminarAlimentador}
            esCreador={esCreador}
            rolEnWorkspace={rolEnWorkspace}
         />

         <ModalConfiguracionPuesto
            abierto={modalConfigPuestoAbierto}
            puesto={puesto}
            onCerrar={onCerrarConfigPuesto}
            estaPolling={estaPolling}
            onPlayStopClick={onPlayStopClick}
            buscarRegistrador={buscarRegistrador}
         />

         <ModalConfigurarAgente
            abierto={ventanaConfigAgente.abierta}
            workspaceId={ventanaConfigAgente.workspaceId}
            onCerrar={onCerrarConfigAgente}
            minimizada={ventanaConfigAgente.minimizada}
            maximizada={ventanaConfigAgente.maximizada}
            posicion={ventanaConfigAgente.posicion}
            zIndex={ventanaConfigAgente.zIndex}
            onMinimizar={onMinimizarConfigAgente}
            onMaximizar={onMaximizarConfigAgente}
            onEnfocar={onEnfocarConfigAgente}
            onMover={onMoverConfigAgente}
         />

         <ModalGestionarAccesos
            abierto={modalAccesosAbierto}
            workspaceId={workspaceId}
            workspaceNombre={puesto?.nombre}
            usuarioActualId={usuarioActualId}
            onCerrar={onCerrarAccesos}
         />

         <ModalPanelPermisos
            abierto={modalPanelPermisosAbierto}
            onCerrar={onCerrarPanelPermisos}
         />
      </>
   );
};

export default ModalesVista;

// ===== ./src/paginas/PaginaAlimentadores/componentes/layout/OverlayConexion.jsx =====

// componentes/layout/OverlayConexion.jsx
// Overlay de problema de conexi√≥n

/**
 * Overlay que se muestra cuando hay problema de conexi√≥n
 * @param {Object} props
 * @param {boolean} props.visible - Si mostrar el overlay
 */
const OverlayConexion = ({ visible }) => {
   if (!visible) return null;

   return (
      <div className="alim-overlay-conexion">
         <div className="alim-overlay-conexion__contenido">
            <span className="alim-overlay-conexion__icono">‚ö†</span>
            <span className="alim-overlay-conexion__titulo">SIN CONEXI√ìN</span>
            <span className="alim-overlay-conexion__texto">
               No se pueden obtener lecturas del servidor
            </span>
         </div>
      </div>
   );
};

export default OverlayConexion;

// ===== ./src/paginas/PaginaAlimentadores/componentes/layout/OverlayGuardando.jsx =====

// componentes/layout/OverlayGuardando.jsx
// Overlay de guardando cambios

import ReactDOM from "react-dom";

/**
 * Overlay que se muestra mientras se guardan cambios
 * @param {Object} props
 * @param {boolean} props.visible - Si mostrar el overlay
 * @param {string} props.texto - Texto a mostrar (default: "Guardando cambios...")
 */
const OverlayGuardando = ({ visible, texto = "Guardando cambios..." }) => {
   if (!visible) return null;

   return ReactDOM.createPortal(
      <div className="guardar-overlay">
         <div className="guardar-overlay__contenido">
            <div className="guardar-overlay__spinner" />
            <span className="guardar-overlay__texto">{texto}</span>
         </div>
      </div>,
      document.body
   );
};

export default OverlayGuardando;

// ===== ./src/paginas/PaginaAlimentadores/componentes/layout/VistaAlimentadores.jsx =====

// src/paginas/PaginaAlimentadores/componentes/layout/VistaAlimentadores.jsx

import React, { useEffect, useCallback } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../../../contextos/AuthContext";
import "./VistaAlimentadores.css";
import "../navegacion/BotonGuardarCambios.css";

import BarraNavegacion from "../navegacion/BarraNavegacion.jsx";
import MenuLateral from "../navegacion/MenuLateral.jsx";
import GrillaTarjetas from "../tarjetas/GrillaTarjetas.jsx";
import SkeletonCard from "../tarjetas/SkeletonCard.jsx";
import { ContenedorVentanasHistorial } from "../modales/historial";

import { COLORES_SISTEMA } from "../../constantes/colores";
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase";
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import { useHistorialLocal } from "../../hooks/historial";
import { usePushNotifications } from "../../../../hooks/usePushNotifications";
import { usePollingLecturas } from "../../hooks/mediciones";

// Hooks UI
import { useVentanasHistorial, useGestorModales, useModoCompacto } from "../../hooks/ui";
import { useVentanaConfigAgente, useRegistradoresWorkspace } from "../../hooks/agentes";
import {
   useArrastrarSoltar,
   usePreferenciasVisualesPuestos,
   useGestionPuestos,
   useGestionAlimentadores,
   useDragDropAlimentadores,
} from "../../hooks/puestos";

// Componentes extra√≠dos
import EstadoCarga from "./EstadoCarga";
import EstadoVacio from "./EstadoVacio";
import OverlayGuardando from "./OverlayGuardando";
import OverlayConexion from "./OverlayConexion";
import ModalesVista from "./ModalesVista";

const VistaAlimentadores = () => {
   const navigate = useNavigate();
   const { logout } = useAuth();
   const {
      configuracionSeleccionada,
      perfil,
      rolGlobal,
      estilosGlobales,
      guardarEstilosGlobales,
   } = usarContextoConfiguracion();

   const {
      puestos,
      puestoSeleccionado,
      agregarPuesto,
      eliminarPuesto,
      seleccionarPuesto,
      actualizarPuestos,
      agregarAlimentador,
      actualizarAlimentador,
      eliminarAlimentador,
      reordenarAlimentadores,
      lecturasTarjetas,
      estaMidiendo,
      obtenerTimestampInicio,
      obtenerContadorLecturas,
      detenerMedicion,
      actualizarRegistros,
      cargando,
      error,
      obtenerGap,
      establecerGap,
      obtenerRowGap,
      establecerRowGap,
      GAP_DEFAULT,
      escalaGlobal,
      obtenerEscalaEfectiva,
      establecerEscalaTarjeta,
      resetearEscalaTarjeta,
      obtenerEscalaPuesto,
      establecerEscalaPuesto,
      ESCALA_MIN,
      ESCALA_MAX,
      limpiarPreferenciasUI,
      sincronizando,
      obtenerBgColorPuesto,
      esCreador,
      preferenciasVisuales,
   } = usarContextoAlimentadores();

   // Hook de arrastre base
   const {
      elementoArrastrandoId,
      alIniciarArrastre,
      alTerminarArrastre,
      alPasarPorEncima,
      reordenarLista,
      moverAlFinal,
   } = useArrastrarSoltar();

   // Gestor de modales
   const { abrirModal, cerrarModal, obtenerEstado } = useGestorModales();
   const { guardarLecturaLocal } = useHistorialLocal();

   // Push notifications
   usePushNotifications({
      habilitado: true,
      onNotificacion: (notif) => {
         console.log('[VistaAlimentadores] Notificaci√≥n en primer plano:', notif);
      },
      onNotificacionTocada: (datos) => {
         console.log('[VistaAlimentadores] Usuario toc√≥ notificaci√≥n:', datos);
      },
   });

   // Sistema de ventanas flotantes de historial
   const {
      listaVentanas,
      ventanasMinimizadas,
      abrirVentana,
      cerrarVentana,
      toggleMinimizar,
      toggleMaximizar,
      enfocarVentana,
      moverVentana,
   } = useVentanasHistorial();

   // Modo compacto (responsive)
   const { esCompacto, obtenerEscalaEfectivaConModoCompacto } = useModoCompacto({
      escalaGlobal,
      obtenerEscalaEfectiva,
   });

   // Estados locales simples
   const [menuAbierto, setMenuAbierto] = React.useState(false);
   const [modalAccesosAbierto, setModalAccesosAbierto] = React.useState(false);
   const [modalPanelPermisosAbierto, setModalPanelPermisosAbierto] = React.useState(false);

   // Ventana de configuraci√≥n de agente
   const {
      ventana: ventanaConfigAgente,
      abrirVentana: abrirVentanaConfigAgente,
      cerrarVentana: cerrarVentanaConfigAgente,
      toggleMinimizar: toggleMinimizarConfigAgente,
      toggleMaximizar: toggleMaximizarConfigAgente,
      enfocarVentana: enfocarVentanaConfigAgente,
      moverVentana: moverVentanaConfigAgente,
   } = useVentanaConfigAgente();

   // Registradores del workspace
   const { buscarRegistrador } = useRegistradoresWorkspace(configuracionSeleccionada?.id);

   // Preferencias visuales aplicadas
   const { puestosConPreferencias, alimentadoresConPreferencias } = usePreferenciasVisualesPuestos({
      esCreador,
      puestos,
      puestoSeleccionado,
      preferenciasVisuales,
   });

   // Estados de modales
   const estadoModalNuevoPuesto = obtenerEstado("nuevoPuesto");
   const estadoModalEditarPuestos = obtenerEstado("editarPuestos");
   const estadoModalAlimentador = obtenerEstado("alimentador");
   const estadoModalConfigPuesto = obtenerEstado("configPuesto");

   const buscarAlimentador = useCallback(
      (alimId) => alimentadoresConPreferencias.find((a) => a.id === alimId) || null,
      [alimentadoresConPreferencias]
   );

   const alimentadorEnEdicion = estadoModalAlimentador.datos?.alimentadorId
      ? buscarAlimentador(estadoModalAlimentador.datos.alimentadorId)
      : null;
   const modoAlimentador = estadoModalAlimentador.datos?.modo || "crear";

   // Hook de polling de lecturas
   const {
      estaPolling,
      obtenerContadorPolling,
      obtenerErrorPolling,
      handlePlayStopClick,
      limpiarTodosIntervalos,
      hayProblemaConexion,
   } = usePollingLecturas({
      actualizarRegistros,
      guardarLecturaLocal,
      buscarAlimentador,
   });

   // Gesti√≥n de puestos
   const {
      guardandoPuestos,
      abrirModalNuevoPuesto,
      abrirModalEditarPuestos,
      abrirModalConfigPuesto,
      handleCrearPuesto,
      handleGuardarPuestos,
      handleEscalaPuestoChange,
   } = useGestionPuestos({
      puestos,
      agregarPuesto,
      eliminarPuesto,
      actualizarPuestos,
      resetearEscalaTarjeta,
      establecerEscalaPuesto,
      abrirModal,
      cerrarModal,
   });

   // Gesti√≥n de alimentadores
   const {
      guardandoAlimentador,
      abrirModalNuevoAlim,
      abrirModalEditarAlim,
      handleGuardarAlimentador,
      handleEliminarAlimentador,
   } = useGestionAlimentadores({
      puestoSeleccionado,
      alimentadorEnEdicion,
      modoAlimentador,
      esCreador,
      preferenciasVisuales,
      agregarAlimentador,
      actualizarAlimentador,
      eliminarAlimentador,
      detenerMedicion,
      obtenerGap,
      establecerGap,
      abrirModal,
      cerrarModal,
   });

   // Drag & drop de alimentadores
   const { handleDragStartAlim, handleDragEndAlim, handleDropAlim, handleDropAlimAlFinal } =
      useDragDropAlimentadores({
         puestoSeleccionado,
         elementoArrastrandoId,
         alIniciarArrastre,
         alTerminarArrastre,
         reordenarLista,
         moverAlFinal,
         reordenarAlimentadores,
         establecerGap,
         GAP_DEFAULT,
      });

   // Navegaci√≥n
   const handleSalir = async () => {
      limpiarPreferenciasUI();
      await logout();
      navigate("/");
   };

   // Handlers de modales especiales
   const abrirModalConfigurarAgente = () => abrirVentanaConfigAgente(configuracionSeleccionada?.id);
   const abrirModalGestionarAccesos = () => setModalAccesosAbierto(true);
   const abrirModalPanelPermisos = () => setModalPanelPermisosAbierto(true);

   // Limpiar intervalos de polling al desmontar
   useEffect(() => {
      return () => limpiarTodosIntervalos();
   }, [limpiarTodosIntervalos]);

   // Estado de carga
   if (cargando && !sincronizando) {
      return <EstadoCarga />;
   }

   // Estado de error
   if (error) {
      return <EstadoCarga error={error} />;
   }

   return (
      <div className="alim-page">
         {/* Overlay de guardando puestos */}
         <OverlayGuardando visible={guardandoPuestos} />

         {/* ===== NAV SUPERIOR ===== */}
         <BarraNavegacion
            esCompacto={esCompacto}
            puestos={puestos}
            puestoSeleccionado={puestoSeleccionado}
            onSeleccionarPuesto={seleccionarPuesto}
            onAbrirModalNuevoPuesto={abrirModalNuevoPuesto}
            onAbrirModalEditarPuestos={abrirModalEditarPuestos}
            onAbrirModalConfigPuesto={abrirModalConfigPuesto}
            onAbrirModalConfigurarAgente={abrirModalConfigurarAgente}
            onAbrirModalGestionarAccesos={abrirModalGestionarAccesos}
            onAbrirModalPanelPermisos={abrirModalPanelPermisos}
            onSalir={handleSalir}
            onAbrirMenu={() => setMenuAbierto(true)}
            coloresSistema={COLORES_SISTEMA}
            estaPolling={estaPolling}
            onPlayStopClick={handlePlayStopClick}
         />

         {/* ===== MENU LATERAL (modo compacto) ===== */}
         {esCompacto && (
            <MenuLateral
               abierto={menuAbierto}
               onCerrar={() => setMenuAbierto(false)}
               puestos={puestos}
               puestoSeleccionado={puestoSeleccionado}
               onSeleccionarPuesto={seleccionarPuesto}
               onAbrirModalNuevoPuesto={abrirModalNuevoPuesto}
               onAbrirModalEditarPuestos={abrirModalEditarPuestos}
               onAbrirModalConfigurarAgente={abrirModalConfigurarAgente}
               onAbrirModalGestionarAccesos={abrirModalGestionarAccesos}
               onAbrirModalPanelPermisos={abrirModalPanelPermisos}
               onSalir={handleSalir}
               coloresSistema={COLORES_SISTEMA}
            />
         )}

         {/* ===== MAIN ===== */}
         <main
            className="alim-main"
            style={{
               backgroundColor: puestoSeleccionado
                  ? obtenerBgColorPuesto(puestoSeleccionado.id) || "#e5e7eb"
                  : "#e5e7eb",
            }}
         >
            {/* Overlay de problema de conexi√≥n */}
            <OverlayConexion visible={hayProblemaConexion} />

            {/* Contenido principal */}
            {!configuracionSeleccionada ? (
               <EstadoVacio tipo="sinWorkspace" onSalir={handleSalir} />
            ) : !puestoSeleccionado ? (
               <EstadoVacio tipo="sinPuestos" />
            ) : (
               <GrillaTarjetas
                  alimentadores={alimentadoresConPreferencias}
                  lecturas={lecturasTarjetas}
                  puestoId={puestoSeleccionado.id}
                  workspaceId={configuracionSeleccionada?.id}
                  elementoArrastrandoId={elementoArrastrandoId}
                  onAbrirConfiguracion={abrirModalEditarAlim}
                  onAbrirHistorial={(puestoId, alim) => abrirVentana(alim, alim.card_design)}
                  onDragStart={handleDragStartAlim}
                  onDragOver={alPasarPorEncima}
                  onDrop={handleDropAlim}
                  onDragEnd={handleDragEndAlim}
                  skeletonCard={guardandoAlimentador ? <SkeletonCard /> : null}
                  onDropAlFinal={handleDropAlimAlFinal}
                  onAgregarNuevo={abrirModalNuevoAlim}
                  puedeAgregarNuevo={
                     configuracionSeleccionada?.esCreador
                        ? rolGlobal === "superadmin" || rolGlobal === "admin"
                        : configuracionSeleccionada?.rol === "admin"
                  }
                  esObservador={rolGlobal === "observador" || configuracionSeleccionada?.rol === "observador"}
                  estaMidiendo={estaMidiendo}
                  obtenerTimestampInicio={obtenerTimestampInicio}
                  obtenerContadorLecturas={obtenerContadorLecturas}
                  obtenerGap={obtenerGap}
                  onGapChange={establecerGap}
                  obtenerRowGap={obtenerRowGap}
                  onRowGapChange={establecerRowGap}
                  estaPolling={estaPolling}
                  onPlayStopClick={handlePlayStopClick}
                  obtenerContadorPolling={obtenerContadorPolling}
                  obtenerErrorPolling={obtenerErrorPolling}
                  obtenerEscalaEfectiva={obtenerEscalaEfectivaConModoCompacto}
                  onEscalaChange={establecerEscalaTarjeta}
                  ESCALA_MIN={ESCALA_MIN}
                  ESCALA_MAX={ESCALA_MAX}
               />
            )}
         </main>

         {/* ===== MODALES ===== */}
         <ModalesVista
            // Modal Nuevo Puesto
            modalNuevoPuestoAbierto={estadoModalNuevoPuesto.abierto}
            onCerrarNuevoPuesto={() => cerrarModal("nuevoPuesto")}
            onCrearPuesto={handleCrearPuesto}
            // Modal Editar Puestos
            modalEditarPuestosAbierto={estadoModalEditarPuestos.abierto}
            puestosConPreferencias={puestosConPreferencias}
            onCerrarEditarPuestos={() => cerrarModal("editarPuestos")}
            onGuardarPuestos={handleGuardarPuestos}
            esCreador={configuracionSeleccionada?.esCreador}
            rolEnWorkspace={configuracionSeleccionada?.rol}
            esCompacto={esCompacto}
            obtenerEscalaPuesto={obtenerEscalaPuesto}
            onEscalaPuestoChange={handleEscalaPuestoChange}
            ESCALA_MIN={ESCALA_MIN}
            ESCALA_MAX={ESCALA_MAX}
            estilosGlobales={estilosGlobales}
            onGuardarEstilos={guardarEstilosGlobales}
            // Modal Alimentador
            modalAlimentadorAbierto={estadoModalAlimentador.abierto}
            puestoNombre={puestoSeleccionado?.nombre || ""}
            workspaceId={configuracionSeleccionada?.id}
            modoAlimentador={modoAlimentador}
            alimentadorEnEdicion={alimentadorEnEdicion}
            onCancelarAlimentador={() => cerrarModal("alimentador")}
            onConfirmarAlimentador={handleGuardarAlimentador}
            onEliminarAlimentador={handleEliminarAlimentador}
            // Modal Config Puesto
            modalConfigPuestoAbierto={estadoModalConfigPuesto.abierto}
            puesto={puestoSeleccionado}
            onCerrarConfigPuesto={() => cerrarModal("configPuesto")}
            estaPolling={estaPolling}
            onPlayStopClick={handlePlayStopClick}
            buscarRegistrador={buscarRegistrador}
            // Modal Agente
            ventanaConfigAgente={ventanaConfigAgente}
            onCerrarConfigAgente={cerrarVentanaConfigAgente}
            onMinimizarConfigAgente={toggleMinimizarConfigAgente}
            onMaximizarConfigAgente={toggleMaximizarConfigAgente}
            onEnfocarConfigAgente={enfocarVentanaConfigAgente}
            onMoverConfigAgente={moverVentanaConfigAgente}
            // Modal Accesos
            modalAccesosAbierto={modalAccesosAbierto}
            onCerrarAccesos={() => setModalAccesosAbierto(false)}
            usuarioActualId={perfil?.id}
            // Modal Panel Permisos
            modalPanelPermisosAbierto={modalPanelPermisosAbierto}
            onCerrarPanelPermisos={() => setModalPanelPermisosAbierto(false)}
            // Colores
            coloresSistema={COLORES_SISTEMA}
         />

         {/* Sistema de ventanas flotantes de historial */}
         <ContenedorVentanasHistorial
            listaVentanas={listaVentanas}
            ventanasMinimizadas={ventanasMinimizadas}
            cerrarVentana={cerrarVentana}
            toggleMinimizar={toggleMinimizar}
            toggleMaximizar={toggleMaximizar}
            enfocarVentana={enfocarVentana}
            moverVentana={moverVentana}
         />
      </div>
   );
};

export default VistaAlimentadores;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/apariencia/ColorPickerBoton.jsx =====

// componentes/modales/apariencia/ColorPickerBoton.jsx
// Bot√≥n de color con popover usando react-colorful

import { useState, useEffect, useRef } from "react";
import { createPortal } from "react-dom";
import { HexColorPicker } from "react-colorful";

/**
 * Bot√≥n de color con popover usando react-colorful
 *
 * @param {Object} props
 * @param {string} props.color - Color actual en formato hex (#RRGGBB)
 * @param {Function} props.onChange - Callback cuando cambia el color
 */
export function ColorPickerBoton({ color, onChange }) {
   const [abierto, setAbierto] = useState(false);
   const [posicion, setPosicion] = useState({ top: 0, left: 0 });
   const [valorHex, setValorHex] = useState(color);
   const pickerRef = useRef(null);
   const buttonRef = useRef(null);

   // Sincronizar valor cuando cambia el color externo
   useEffect(() => {
      setValorHex(color);
   }, [color]);

   // Calcular posici√≥n del picker al abrirlo
   const togglePicker = (e) => {
      e.stopPropagation();
      if (abierto) {
         setAbierto(false);
         return;
      }

      if (buttonRef.current) {
         const rect = buttonRef.current.getBoundingClientRect();
         const alturaPopover = 260;
         const anchoPopover = 240;

         // Calcular posici√≥n vertical (preferir abajo)
         let top = rect.bottom + 8;
         if (top + alturaPopover > window.innerHeight - 10) {
            top = rect.top - alturaPopover - 8;
         }

         // Calcular posici√≥n horizontal centrada
         let left = rect.left + rect.width / 2 - anchoPopover / 2;
         if (left < 10) left = 10;
         if (left + anchoPopover > window.innerWidth - 10) {
            left = window.innerWidth - anchoPopover - 10;
         }

         setPosicion({ top, left });
         setAbierto(true);
      }
   };

   // Cerrar al hacer clic fuera
   useEffect(() => {
      if (!abierto) return;
      const handleClickFuera = (e) => {
         if (
            pickerRef.current &&
            !pickerRef.current.contains(e.target) &&
            buttonRef.current &&
            !buttonRef.current.contains(e.target)
         ) {
            setAbierto(false);
         }
      };
      const timeoutId = setTimeout(() => {
         document.addEventListener("mousedown", handleClickFuera);
      }, 10);
      return () => {
         clearTimeout(timeoutId);
         document.removeEventListener("mousedown", handleClickFuera);
      };
   }, [abierto]);

   const handleColorChange = (nuevoColor) => {
      setValorHex(nuevoColor);
      onChange(nuevoColor);
   };

   const handleInputChange = (e) => {
      const valor = e.target.value;
      setValorHex(valor);
      if (/^#[0-9A-Fa-f]{6}$/.test(valor)) {
         onChange(valor);
      }
   };

   return (
      <div className="apariencia-colorpicker-wrapper">
         <button
            ref={buttonRef}
            type="button"
            className="apariencia-color-picker-btn"
            style={{ backgroundColor: color }}
            onClick={togglePicker}
            title="Color personalizado"
         />
         {abierto &&
            createPortal(
               <div
                  ref={pickerRef}
                  className="apariencia-colorpicker-popover"
                  style={{ top: `${posicion.top}px`, left: `${posicion.left}px` }}
                  onClick={(e) => e.stopPropagation()}
                  onMouseDown={(e) => e.stopPropagation()}
               >
                  <HexColorPicker color={color} onChange={handleColorChange} />
                  <div className="apariencia-colorpicker-input-row">
                     <input
                        type="text"
                        value={valorHex}
                        onChange={handleInputChange}
                        className="apariencia-colorpicker-hex-input"
                        placeholder="#000000"
                        maxLength={7}
                     />
                     <button
                        type="button"
                        className="apariencia-colorpicker-copy-btn"
                        onClick={() => navigator.clipboard.writeText(valorHex)}
                        title="Copiar color"
                     >
                        üìã
                     </button>
                  </div>
               </div>,
               document.body
            )}
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/apariencia/index.js =====

// componentes/modales/apariencia/index.js
// Exportaciones centralizadas de componentes de apariencia

export { SelectorFuente } from "./SelectorFuente";
export { SliderConFlechas } from "./SliderConFlechas";
export { ColorPickerBoton } from "./ColorPickerBoton";
export { PreviewTarjeta } from "./PreviewTarjeta";

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/apariencia/PreviewTarjeta.jsx =====

// componentes/modales/apariencia/PreviewTarjeta.jsx
// Componente de preview que muestra c√≥mo quedan los estilos aplicados

/**
 * Formatea un valor seg√∫n la cantidad de decimales configurada
 * @param {string} valor - Valor original (puede ser "--,--" o n√∫mero con coma)
 * @param {number} decimales - Cantidad de decimales a mostrar
 */
const formatearValorConDecimales = (valor, decimales) => {
   if (valor === "--,--" || valor === "--" || valor === "--,-") {
      if (decimales === 0) return "--";
      if (decimales === 1) return "--,-";
      return "--,--";
   }

   // Convertir coma a punto para parsear
   const numStr = valor.replace(",", ".");
   const num = parseFloat(numStr);
   if (isNaN(num)) return valor;

   return num.toFixed(decimales).replace(".", ",");
};

/**
 * Componente de preview que muestra c√≥mo quedan los estilos aplicados
 *
 * @param {Object} props
 * @param {Object} props.estilos - Estilos de la tarjeta
 * @param {Array<string>} props.valores - Valores a mostrar en el preview
 * @param {Function} props.onRandomizar - Callback para randomizar valores
 * @param {Function} props.onResetearValores - Callback para resetear valores a "--,--"
 */
export function PreviewTarjeta({ estilos, valores, onRandomizar, onResetearValores }) {
   const decimales = estilos.valorBox.decimales ?? 2;

   return (
      <div className="preview-tarjeta">
         <div className="preview-header">
            <div className="preview-header-icons">
               <span className="preview-icon">‚ñ≤</span>
            </div>
            <span
               className="preview-titulo"
               style={{
                  fontFamily: estilos.header.fontFamily,
                  fontSize: estilos.header.fontSize,
                  fontWeight: estilos.header.fontWeight,
               }}
            >
               TRAFO 1
            </span>
         </div>

         <div className="preview-body">
            {/* Secci√≥n superior */}
            <div className="preview-seccion">
               <div
                  className="preview-zona-titulo"
                  style={{
                     fontFamily: estilos.tituloZona.fontFamily,
                     fontSize: estilos.tituloZona.fontSize,
                  }}
               >
                  CORRIENTE DE L√çNEA (A) (EN 33 KV)
               </div>
               <div className="preview-boxes" style={{ gap: estilos.box.gap }}>
                  {["R", "S", "T"].map((fase, idx) => (
                     <div
                        key={fase}
                        className="preview-box"
                        style={{ width: estilos.box.width, flex: `0 0 ${estilos.box.width}` }}
                     >
                        <span
                           className="preview-box-titulo"
                           style={{
                              fontFamily: estilos.tituloBox.fontFamily,
                              fontSize: estilos.tituloBox.fontSize,
                           }}
                        >
                           {fase}
                        </span>
                        <span
                           className="preview-box-valor"
                           style={{
                              fontFamily: estilos.valorBox.fontFamily,
                              fontSize: estilos.valorBox.fontSize,
                              color: estilos.valorBox.color,
                              width: "100%",
                              height:
                                 estilos.box.height !== "auto" ? estilos.box.height : undefined,
                              overflow: "hidden",
                              textOverflow: "ellipsis",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                           }}
                        >
                           {formatearValorConDecimales(valores[idx], decimales)}
                        </span>
                     </div>
                  ))}
               </div>
            </div>

            {/* Secci√≥n inferior */}
            <div className="preview-seccion">
               <div
                  className="preview-zona-titulo"
                  style={{
                     fontFamily: estilos.tituloZona.fontFamily,
                     fontSize: estilos.tituloZona.fontSize,
                  }}
               >
                  CORRIENTE DE L√çNEA (A) (EN 13,2 KV)
               </div>
               <div className="preview-boxes" style={{ gap: estilos.box.gap }}>
                  {["R", "S", "T"].map((fase, idx) => (
                     <div
                        key={`inf-${fase}`}
                        className="preview-box"
                        style={{ width: estilos.box.width, flex: `0 0 ${estilos.box.width}` }}
                     >
                        <span
                           className="preview-box-titulo"
                           style={{
                              fontFamily: estilos.tituloBox.fontFamily,
                              fontSize: estilos.tituloBox.fontSize,
                           }}
                        >
                           {fase}
                        </span>
                        <span
                           className="preview-box-valor"
                           style={{
                              fontFamily: estilos.valorBox.fontFamily,
                              fontSize: estilos.valorBox.fontSize,
                              color: estilos.valorBox.color,
                              width: "100%",
                              height:
                                 estilos.box.height !== "auto" ? estilos.box.height : undefined,
                              overflow: "hidden",
                              textOverflow: "ellipsis",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                           }}
                        >
                           {formatearValorConDecimales(valores[idx], decimales)}
                        </span>
                     </div>
                  ))}
               </div>
            </div>
         </div>

         {/* Botones para controlar los valores del preview */}
         <div className="preview-acciones">
            <button
               type="button"
               className="preview-btn"
               onClick={onRandomizar}
               title="Poner valores aleatorios"
            >
               üé≤
            </button>
            <button
               type="button"
               className="preview-btn"
               onClick={onResetearValores}
               title="Volver a --,--"
            >
               ‚ü≤
            </button>
         </div>
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/apariencia/SelectorFuente.jsx =====

// componentes/modales/apariencia/SelectorFuente.jsx
// Selector de fuentes personalizado con auto-scroll y navegaci√≥n por teclado

import { useState, useEffect, useRef } from "react";

/**
 * Selector de fuentes personalizado que muestra cada opci√≥n con su propia tipograf√≠a
 * - Auto-scroll a la fuente seleccionada al abrir
 * - Navegaci√≥n con flechas arriba/abajo con preview en vivo
 * - Enter para confirmar, Escape para cancelar
 *
 * @param {Object} props
 * @param {string} props.value - ID de la fuente seleccionada
 * @param {Function} props.onChange - Callback cuando cambia la fuente
 * @param {Array<{id: string, label: string}>} props.fuentes - Lista de fuentes disponibles
 */
export function SelectorFuente({ value, onChange, fuentes }) {
   const [abierto, setAbierto] = useState(false);
   const [indiceResaltado, setIndiceResaltado] = useState(-1);
   const [valorOriginal, setValorOriginal] = useState(value);
   const contenedorRef = useRef(null);
   const dropdownRef = useRef(null);
   const opcionesRefs = useRef([]);

   // √çndice de la fuente actualmente seleccionada
   const indiceSeleccionado = fuentes.findIndex((f) => f.id === value);

   // Al abrir el dropdown: guardar valor original, scroll a la opci√≥n seleccionada
   useEffect(() => {
      if (abierto) {
         setValorOriginal(value);
         setIndiceResaltado(indiceSeleccionado);

         // Scroll a la opci√≥n seleccionada despu√©s de que el DOM se actualice
         requestAnimationFrame(() => {
            const opcionActiva = opcionesRefs.current[indiceSeleccionado];
            if (opcionActiva && dropdownRef.current) {
               opcionActiva.scrollIntoView({ block: "center", behavior: "instant" });
            }
         });
      }
   }, [abierto, indiceSeleccionado, value]);

   // Cerrar dropdown al hacer clic fuera
   useEffect(() => {
      const handleClickFuera = (e) => {
         if (contenedorRef.current && !contenedorRef.current.contains(e.target)) {
            // Restaurar valor original si se cierra sin confirmar
            onChange(valorOriginal);
            setAbierto(false);
         }
      };
      if (abierto) {
         document.addEventListener("mousedown", handleClickFuera);
      }
      return () => document.removeEventListener("mousedown", handleClickFuera);
   }, [abierto, valorOriginal, onChange]);

   // Manejo de teclado
   useEffect(() => {
      if (!abierto) return;

      const handleKeyDown = (e) => {
         switch (e.key) {
            case "ArrowDown":
               e.preventDefault();
               setIndiceResaltado((prev) => {
                  const nuevoIndice = prev < fuentes.length - 1 ? prev + 1 : 0;
                  // Aplicar preview de la fuente
                  onChange(fuentes[nuevoIndice].id);
                  // Scroll a la opci√≥n
                  requestAnimationFrame(() => {
                     opcionesRefs.current[nuevoIndice]?.scrollIntoView({
                        block: "nearest",
                        behavior: "smooth",
                     });
                  });
                  return nuevoIndice;
               });
               break;
            case "ArrowUp":
               e.preventDefault();
               setIndiceResaltado((prev) => {
                  const nuevoIndice = prev > 0 ? prev - 1 : fuentes.length - 1;
                  // Aplicar preview de la fuente
                  onChange(fuentes[nuevoIndice].id);
                  // Scroll a la opci√≥n
                  requestAnimationFrame(() => {
                     opcionesRefs.current[nuevoIndice]?.scrollIntoView({
                        block: "nearest",
                        behavior: "smooth",
                     });
                  });
                  return nuevoIndice;
               });
               break;
            case "Enter":
               e.preventDefault();
               // Confirmar selecci√≥n actual
               setAbierto(false);
               break;
            case "Escape":
               e.preventDefault();
               // Restaurar valor original y cerrar
               onChange(valorOriginal);
               setAbierto(false);
               break;
            default:
               break;
         }
      };

      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
   }, [abierto, fuentes, onChange, valorOriginal]);

   // Encontrar la fuente seleccionada para mostrar en el bot√≥n
   const fuenteSeleccionada = fuentes.find((f) => f.id === value) || fuentes[0];

   return (
      <div className="selector-fuente" ref={contenedorRef}>
         <button
            type="button"
            className="selector-fuente-btn"
            onClick={() => setAbierto(!abierto)}
            style={{
               fontFamily: fuenteSeleccionada.id !== "inherit" ? fuenteSeleccionada.id : undefined,
            }}
         >
            <span className="selector-fuente-texto">{fuenteSeleccionada.label}</span>
            <span className="selector-fuente-flecha">{abierto ? "‚ñ≤" : "‚ñº"}</span>
         </button>
         {abierto && (
            <div className="selector-fuente-dropdown" ref={dropdownRef}>
               {fuentes.map((f, idx) => (
                  <div
                     key={f.id}
                     ref={(el) => (opcionesRefs.current[idx] = el)}
                     className={`selector-fuente-opcion ${f.id === value ? "selector-fuente-opcion--activa" : ""} ${idx === indiceResaltado ? "selector-fuente-opcion--resaltada" : ""}`}
                     style={{ fontFamily: f.id !== "inherit" ? f.id : undefined }}
                     onClick={() => {
                        onChange(f.id);
                        setAbierto(false);
                     }}
                     onMouseEnter={() => {
                        // Solo resaltar visualmente, sin aplicar preview ni scroll
                        setIndiceResaltado(idx);
                     }}
                  >
                     {f.label}
                  </div>
               ))}
            </div>
         )}
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/apariencia/SliderConFlechas.jsx =====

// componentes/modales/apariencia/SliderConFlechas.jsx
// Slider con botones de incrementar/decrementar

/**
 * Redondea un n√∫mero para evitar errores de punto flotante
 * @param {number} valor - Valor a redondear
 * @param {number} decimales - Cantidad de decimales
 */
const redondear = (valor, decimales = 2) => {
   const factor = Math.pow(10, decimales);
   return Math.round(valor * factor) / factor;
};

/**
 * Componente Slider con flechitas para incrementar/decrementar
 *
 * @param {Object} props
 * @param {number} props.value - Valor actual
 * @param {Function} props.onChange - Callback cuando cambia el valor
 * @param {number} props.min - Valor m√≠nimo
 * @param {number} props.max - Valor m√°ximo
 * @param {number} props.step - Incremento por paso
 * @param {string} props.valorDisplay - Texto a mostrar como valor
 */
export function SliderConFlechas({ value, onChange, min, max, step, valorDisplay }) {
   // Calcular decimales del step para redondear correctamente
   const decimalesStep = step < 1 ? String(step).split(".")[1]?.length || 0 : 0;

   const incrementar = () => {
      const nuevoValor = redondear(Math.min(max, parseFloat(value) + step), decimalesStep);
      onChange(nuevoValor);
   };

   const decrementar = () => {
      const nuevoValor = redondear(Math.max(min, parseFloat(value) - step), decimalesStep);
      onChange(nuevoValor);
   };

   return (
      <div className="slider-con-flechas">
         <button
            type="button"
            className="slider-flecha slider-flecha--izq"
            onClick={decrementar}
            disabled={parseFloat(value) <= min}
         >
            ‚óÄ
         </button>
         <input
            type="range"
            min={min}
            max={max}
            step={step}
            value={value}
            onChange={(e) => onChange(parseFloat(e.target.value))}
         />
         <button
            type="button"
            className="slider-flecha slider-flecha--der"
            onClick={incrementar}
            disabled={parseFloat(value) >= max}
         >
            ‚ñ∂
         </button>
         <span className="apariencia-valor">{valorDisplay}</span>
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/comunes/ColorPickerSimple.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ColorPickerSimple.jsx
// Componente minimalista de selector de color con picker inline

import React, { useState, useRef, useEffect } from "react";
import { createPortal } from "react-dom";
import { HexColorPicker, HexColorInput } from "react-colorful";
import "./ColorPickerSimple.css";

const ColorPickerSimple = ({ color, onChange, label, posicionArriba = false }) => {
	const [mostrarPicker, setMostrarPicker] = useState(false);
	const [posicion, setPosicion] = useState({ top: 0, left: 0 });
	const [valorHex, setValorHex] = useState(color);
	const pickerRef = useRef(null);
	const buttonRef = useRef(null);

	// Calcular posici√≥n del picker al abrirlo/cerrarlo (toggle)
	const togglePicker = (e) => {
		e.stopPropagation();

		// Si ya est√° abierto, cerrarlo
		if (mostrarPicker) {
			setMostrarPicker(false);
			return;
		}

		if (buttonRef.current) {
			const rect = buttonRef.current.getBoundingClientRect();
			// Altura aproximada del popover (picker + input hex)
			const alturaPopover = 260;
			const anchoPopover = 240;

			// Calcular posici√≥n vertical
			let top;
			if (posicionArriba) {
				top = rect.top - alturaPopover - 8;
				// Si no cabe arriba, mostrar abajo
				if (top < 10) {
					top = rect.bottom + 8;
				}
			} else {
				top = rect.bottom + 8;
				// Si no cabe abajo, mostrar arriba
				if (top + alturaPopover > window.innerHeight - 10) {
					top = rect.top - alturaPopover - 8;
				}
			}

			// Calcular posici√≥n horizontal centrada
			let left = rect.left + rect.width / 2 - anchoPopover / 2;
			// Asegurar que no se salga por la izquierda
			if (left < 10) {
				left = 10;
			}
			// Asegurar que no se salga por la derecha
			if (left + anchoPopover > window.innerWidth - 10) {
				left = window.innerWidth - anchoPopover - 10;
			}

			setPosicion({ top, left });
			setMostrarPicker(true);
		}
	};

	// Actualizar valor hex cuando cambia el color desde el picker
	const handleColorChange = (nuevoColor) => {
		setValorHex(nuevoColor);
		onChange(nuevoColor);
	};

	// Manejar cambio en el input de texto
	const handleInputChange = (e) => {
		const valor = e.target.value;
		setValorHex(valor);

		// Validar que sea un color hex v√°lido antes de notificar al padre
		if (/^#[0-9A-Fa-f]{6}$/.test(valor)) {
			onChange(valor);
		}
	};

	// Copiar al portapapeles
	const copiarColor = () => {
		navigator.clipboard.writeText(valorHex);
	};

	// Cerrar el picker al hacer click fuera
	useEffect(() => {
		if (!mostrarPicker) return;

		const handleClickOutside = (event) => {
			if (
				pickerRef.current &&
				!pickerRef.current.contains(event.target) &&
				buttonRef.current &&
				!buttonRef.current.contains(event.target)
			) {
				setMostrarPicker(false);
			}
		};

		// Agregar listener despu√©s de un peque√±o delay para evitar que el mismo click que abre el picker lo cierre
		const timeoutId = setTimeout(() => {
			document.addEventListener("mousedown", handleClickOutside);
		}, 10);

		return () => {
			clearTimeout(timeoutId);
			document.removeEventListener("mousedown", handleClickOutside);
		};
	}, [mostrarPicker]);

	return (
		<div className="color-picker-simple">
			<span className="color-picker-simple-label">{label}</span>
			<div className="color-picker-simple-wrapper">
				<button
					ref={buttonRef}
					type="button"
					className="color-picker-simple-button"
					style={{ backgroundColor: color }}
					onClick={togglePicker}
				/>
				{mostrarPicker &&
					createPortal(
						<div
							ref={pickerRef}
							className="color-picker-simple-popover"
							style={{ top: `${posicion.top}px`, left: `${posicion.left}px` }}
							onClick={(e) => e.stopPropagation()}
							onMouseDown={(e) => e.stopPropagation()}
						>
							<HexColorPicker color={color} onChange={handleColorChange} />
							<div className="color-picker-hex-input-wrapper">
								<input
									type="text"
									value={valorHex}
									onChange={handleInputChange}
									className="color-picker-hex-input"
									placeholder="#000000"
									maxLength={7}
								/>
								<button
									type="button"
									className="color-picker-copy-btn"
									onClick={copiarColor}
									title="Copiar color"
								>
									üìã
								</button>
							</div>
						</div>,
						document.body
					)}
			</div>
		</div>
	);
};

export default ColorPickerSimple;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/comunes/index.js =====

// modales/comunes/index.js
// Componentes comunes de modales

export { default as ModalConfirmacion } from "./ModalConfirmacion";
export { default as ColorPickerSimple } from "./ColorPickerSimple";
export { default as TabApariencia } from "./TabApariencia";

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/comunes/ModalConfirmacion.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfirmacion.jsx
// Modal de confirmaci√≥n reutilizable con estilo oscuro

import React from "react";
import "./ModalConfirmacion.css";

/**
 * Modal de confirmaci√≥n gen√©rico.
 * Muestra un mensaje y dos botones: Cancelar y Confirmar.
 */
const ModalConfirmacion = ({
  abierto,
  titulo = "Confirmar acci√≥n",
  mensaje,
  textoConfirmar = "Confirmar",
  textoCancelar = "Cancelar",
  onConfirmar,
  onCancelar,
  peligroso = false, // Si es true, el bot√≥n de confirmar ser√° rojo
}) => {
  if (!abierto) return null;

  return (
    <div className="confirmacion-fondo-oscuro">
      <div className="confirmacion-contenedor">
        <h2>{titulo}</h2>
        <p className="confirmacion-mensaje">{mensaje}</p>

        <div className="confirmacion-acciones">
          <button
            type="button"
            className="confirmacion-boton confirmacion-cancelar"
            onClick={onCancelar}
          >
            {textoCancelar}
          </button>
          <button
            type="button"
            className={`confirmacion-boton ${peligroso ? "confirmacion-peligro" : "confirmacion-confirmar"}`}
            onClick={onConfirmar}
          >
            {textoConfirmar}
          </button>
        </div>
      </div>
    </div>
  );
};

export default ModalConfirmacion;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/comunes/TabApariencia.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/TabApariencia.jsx
// Pesta√±a de configuraci√≥n de apariencia global de las tarjetas

import { useState, useCallback, useRef } from "react";
import {
   FUENTES_DISPONIBLES,
   LIMITES_TAMA√ëO,
   COLORES_VALOR_PREDEFINIDOS,
   OPCIONES_DECIMALES,
} from "../../../constantes/estilosGlobalesTarjeta";
import { useEstilosApariencia } from "../../../hooks/preferencias";
import {
   SelectorFuente,
   SliderConFlechas,
   ColorPickerBoton,
   PreviewTarjeta,
} from "../apariencia";
import "./TabApariencia.css";

/**
 * Nombres de los slides del carrusel para m√≥vil
 */
const SLIDES_CARRUSEL = [
   { id: "header", label: "Header" },
   { id: "zona", label: "Zona" },
   { id: "fases", label: "Fases" },
   { id: "valores1", label: "Valores 1/2" },
   { id: "valores2", label: "Valores 2/2" },
   { id: "dimensiones", label: "Dimensiones" },
];

// ============================================================================
// Componentes de secci√≥n para Desktop
// ============================================================================

/**
 * Secci√≥n de configuraci√≥n del header
 */
const SeccionHeader = ({ estilos, actualizarHeader, remANumero }) => (
   <div className="apariencia-grupo">
      <span className="apariencia-grupo-label">Header</span>
      <SelectorFuente
         value={estilos.header.fontFamily}
         onChange={(fontFamily) => actualizarHeader({ fontFamily })}
         fuentes={FUENTES_DISPONIBLES}
      />
      <SliderConFlechas
         value={remANumero(estilos.header.fontSize)}
         onChange={(val) => actualizarHeader({ fontSize: `${val}rem` })}
         min={LIMITES_TAMA√ëO.header.min}
         max={LIMITES_TAMA√ëO.header.max}
         step={LIMITES_TAMA√ëO.header.step}
         valorDisplay={estilos.header.fontSize}
      />
   </div>
);

/**
 * Secci√≥n de configuraci√≥n de t√≠tulo de zona
 */
const SeccionZona = ({ estilos, actualizarTituloZona, remANumero }) => (
   <div className="apariencia-grupo">
      <span className="apariencia-grupo-label">Zona</span>
      <SelectorFuente
         value={estilos.tituloZona.fontFamily}
         onChange={(fontFamily) => actualizarTituloZona({ fontFamily })}
         fuentes={FUENTES_DISPONIBLES}
      />
      <SliderConFlechas
         value={remANumero(estilos.tituloZona.fontSize)}
         onChange={(val) => actualizarTituloZona({ fontSize: `${val}rem` })}
         min={LIMITES_TAMA√ëO.tituloZona.min}
         max={LIMITES_TAMA√ëO.tituloZona.max}
         step={LIMITES_TAMA√ëO.tituloZona.step}
         valorDisplay={estilos.tituloZona.fontSize}
      />
   </div>
);

/**
 * Secci√≥n de configuraci√≥n de fases (t√≠tulos de box)
 */
const SeccionFases = ({ estilos, actualizarTituloBox, remANumero }) => (
   <div className="apariencia-grupo">
      <span className="apariencia-grupo-label">Fases</span>
      <SelectorFuente
         value={estilos.tituloBox.fontFamily}
         onChange={(fontFamily) => actualizarTituloBox({ fontFamily })}
         fuentes={FUENTES_DISPONIBLES}
      />
      <SliderConFlechas
         value={remANumero(estilos.tituloBox.fontSize)}
         onChange={(val) => actualizarTituloBox({ fontSize: `${val}rem` })}
         min={LIMITES_TAMA√ëO.tituloBox.min}
         max={LIMITES_TAMA√ëO.tituloBox.max}
         step={LIMITES_TAMA√ëO.tituloBox.step}
         valorDisplay={estilos.tituloBox.fontSize}
      />
   </div>
);

/**
 * Secci√≥n de configuraci√≥n de valores (fuente, tama√±o, color, decimales)
 */
const SeccionValores = ({ estilos, actualizarValorBox, remANumero }) => (
   <>
      <div className="apariencia-grupo">
         <span className="apariencia-grupo-label">Valores</span>
         <SelectorFuente
            value={estilos.valorBox.fontFamily}
            onChange={(fontFamily) => actualizarValorBox({ fontFamily })}
            fuentes={FUENTES_DISPONIBLES}
         />
         <SliderConFlechas
            value={remANumero(estilos.valorBox.fontSize)}
            onChange={(val) => actualizarValorBox({ fontSize: `${val}rem` })}
            min={LIMITES_TAMA√ëO.valorBox.min}
            max={LIMITES_TAMA√ëO.valorBox.max}
            step={LIMITES_TAMA√ëO.valorBox.step}
            valorDisplay={estilos.valorBox.fontSize}
         />
      </div>

      {/* Colores y Decimales en una fila */}
      <div className="apariencia-colores-decimales">
         {/* Colores a la izquierda */}
         <div className="apariencia-colores-grupo">
            <span className="apariencia-mini-label">Color:</span>
            <div className="apariencia-colores-inline">
               {COLORES_VALOR_PREDEFINIDOS.map((color) => (
                  <button
                     key={color}
                     type="button"
                     className={`apariencia-color-btn ${estilos.valorBox.color === color ? "apariencia-color-btn--activo" : ""}`}
                     style={{ backgroundColor: color }}
                     onClick={() => actualizarValorBox({ color })}
                     title={color}
                  />
               ))}
               <ColorPickerBoton
                  color={estilos.valorBox.color}
                  onChange={(color) => actualizarValorBox({ color })}
               />
            </div>
         </div>

         {/* Decimales a la derecha */}
         <div className="apariencia-decimales-grupo">
            <span className="apariencia-mini-label">Decimales:</span>
            <div className="apariencia-decimales-inline">
               {OPCIONES_DECIMALES.map((opcion) => (
                  <button
                     key={opcion.valor}
                     type="button"
                     className={`apariencia-decimal-btn ${(estilos.valorBox.decimales ?? 2) === opcion.valor ? "apariencia-decimal-btn--activo" : ""}`}
                     onClick={() => actualizarValorBox({ decimales: opcion.valor })}
                  >
                     {opcion.valor}
                  </button>
               ))}
            </div>
         </div>
      </div>
   </>
);

/**
 * Secci√≥n de configuraci√≥n de dimensiones (ancho, alto, espacio)
 */
const SeccionDimensiones = ({ estilos, actualizarBox, pxANumero }) => (
   <div className="apariencia-grupo apariencia-grupo--dimensiones">
      <span className="apariencia-grupo-label">Dimensiones</span>
      <div className="apariencia-dimensiones-fila">
         <div className="apariencia-dimension-item">
            <label>Ancho</label>
            <SliderConFlechas
               value={pxANumero(estilos.box.width)}
               onChange={(val) => actualizarBox({ width: `${val}px` })}
               min={LIMITES_TAMA√ëO.boxWidth.min}
               max={LIMITES_TAMA√ëO.boxWidth.max}
               step={LIMITES_TAMA√ëO.boxWidth.step}
               valorDisplay={estilos.box.width}
            />
         </div>
         <div className="apariencia-dimension-item">
            <label>Espacio</label>
            <SliderConFlechas
               value={pxANumero(estilos.box.gap)}
               onChange={(val) => actualizarBox({ gap: `${val}px` })}
               min={LIMITES_TAMA√ëO.gap.min}
               max={LIMITES_TAMA√ëO.gap.max}
               step={LIMITES_TAMA√ëO.gap.step}
               valorDisplay={estilos.box.gap}
            />
         </div>
         <div className="apariencia-dimension-item">
            <label>Alto</label>
            <SliderConFlechas
               value={
                  estilos.box.height === "auto"
                     ? LIMITES_TAMA√ëO.boxHeight.min
                     : pxANumero(estilos.box.height)
               }
               onChange={(val) => actualizarBox({ height: `${val}px` })}
               min={LIMITES_TAMA√ëO.boxHeight.min}
               max={LIMITES_TAMA√ëO.boxHeight.max}
               step={LIMITES_TAMA√ëO.boxHeight.step}
               valorDisplay={estilos.box.height}
            />
         </div>
      </div>
   </div>
);

// ============================================================================
// Componentes de slide para Carrusel m√≥vil
// ============================================================================

/**
 * Slide gen√©rico para fuente y tama√±o
 */
const SlideFuenteTama√±o = ({
   estilos,
   seccion,
   actualizar,
   remANumero,
   limites,
   slideActual,
   indice,
}) => (
   <div className={`carrusel-slide ${slideActual === indice ? "carrusel-slide--activo" : ""}`}>
      <div className="carrusel-fila">
         <span className="carrusel-label">Fuente:</span>
         <SelectorFuente
            value={estilos[seccion].fontFamily}
            onChange={(fontFamily) => actualizar({ fontFamily })}
            fuentes={FUENTES_DISPONIBLES}
         />
      </div>
      <div className="carrusel-fila">
         <span className="carrusel-label">Tama√±o:</span>
         <SliderConFlechas
            value={remANumero(estilos[seccion].fontSize)}
            onChange={(val) => actualizar({ fontSize: `${val}rem` })}
            min={limites.min}
            max={limites.max}
            step={limites.step}
            valorDisplay={estilos[seccion].fontSize}
         />
      </div>
   </div>
);

/**
 * Slide de colores y decimales
 */
const SlideColoresDecimales = ({ estilos, actualizarValorBox, slideActual }) => (
   <div className={`carrusel-slide ${slideActual === 4 ? "carrusel-slide--activo" : ""}`}>
      <div className="carrusel-fila carrusel-fila--colores">
         <span className="carrusel-label">Color:</span>
         <div className="apariencia-colores-inline">
            {COLORES_VALOR_PREDEFINIDOS.map((color) => (
               <button
                  key={color}
                  type="button"
                  className={`apariencia-color-btn ${estilos.valorBox.color === color ? "apariencia-color-btn--activo" : ""}`}
                  style={{ backgroundColor: color }}
                  onClick={() => actualizarValorBox({ color })}
                  title={color}
               />
            ))}
            <ColorPickerBoton
               color={estilos.valorBox.color}
               onChange={(color) => actualizarValorBox({ color })}
            />
         </div>
      </div>
      <div className="carrusel-fila">
         <span className="carrusel-label">Decimales:</span>
         <div className="apariencia-decimales-inline">
            {OPCIONES_DECIMALES.map((opcion) => (
               <button
                  key={opcion.valor}
                  type="button"
                  className={`apariencia-decimal-btn ${(estilos.valorBox.decimales ?? 2) === opcion.valor ? "apariencia-decimal-btn--activo" : ""}`}
                  onClick={() => actualizarValorBox({ decimales: opcion.valor })}
               >
                  {opcion.valor}
               </button>
            ))}
         </div>
      </div>
   </div>
);

/**
 * Slide de dimensiones
 */
const SlideDimensiones = ({ estilos, actualizarBox, pxANumero, slideActual }) => (
   <div className={`carrusel-slide ${slideActual === 5 ? "carrusel-slide--activo" : ""}`}>
      <div className="carrusel-fila">
         <span className="carrusel-label">Ancho:</span>
         <SliderConFlechas
            value={pxANumero(estilos.box.width)}
            onChange={(val) => actualizarBox({ width: `${val}px` })}
            min={LIMITES_TAMA√ëO.boxWidth.min}
            max={LIMITES_TAMA√ëO.boxWidth.max}
            step={LIMITES_TAMA√ëO.boxWidth.step}
            valorDisplay={estilos.box.width}
         />
      </div>
      <div className="carrusel-fila">
         <span className="carrusel-label">Alto:</span>
         <SliderConFlechas
            value={
               estilos.box.height === "auto"
                  ? LIMITES_TAMA√ëO.boxHeight.min
                  : pxANumero(estilos.box.height)
            }
            onChange={(val) => actualizarBox({ height: `${val}px` })}
            min={LIMITES_TAMA√ëO.boxHeight.min}
            max={LIMITES_TAMA√ëO.boxHeight.max}
            step={LIMITES_TAMA√ëO.boxHeight.step}
            valorDisplay={estilos.box.height}
         />
      </div>
      <div className="carrusel-fila">
         <span className="carrusel-label">Espacio:</span>
         <SliderConFlechas
            value={pxANumero(estilos.box.gap)}
            onChange={(val) => actualizarBox({ gap: `${val}px` })}
            min={LIMITES_TAMA√ëO.gap.min}
            max={LIMITES_TAMA√ëO.gap.max}
            step={LIMITES_TAMA√ëO.gap.step}
            valorDisplay={estilos.box.gap}
         />
      </div>
   </div>
);

// ============================================================================
// Componente principal TabApariencia
// ============================================================================

/**
 * Componente para configurar la apariencia global de las tarjetas
 */
const TabApariencia = ({ estilosIniciales, onGuardar, onCancelar }) => {
   // Estado para el carrusel en m√≥vil
   const [slideActual, setSlideActual] = useState(0);

   // Referencia para el input de archivo oculto
   const inputArchivoRef = useRef(null);

   // Hook de manejo de estilos
   const {
      estilos,
      valoresPreview,
      actualizarHeader,
      actualizarTituloZona,
      actualizarTituloBox,
      actualizarValorBox,
      actualizarBox,
      restaurarDefecto,
      randomizarValores,
      resetearValoresPreview,
      exportarConfiguracion,
      importarConfiguracion,
      remANumero,
      pxANumero,
   } = useEstilosApariencia({ estilosIniciales });

   // Navegaci√≥n del carrusel
   const irAlSlideAnterior = useCallback(() => {
      setSlideActual((prev) => (prev > 0 ? prev - 1 : SLIDES_CARRUSEL.length - 1));
   }, []);

   const irAlSlideSiguiente = useCallback(() => {
      setSlideActual((prev) => (prev < SLIDES_CARRUSEL.length - 1 ? prev + 1 : 0));
   }, []);

   // Guardar cambios
   const handleGuardar = () => {
      onGuardar(estilos);
   };

   return (
      <div className="tab-apariencia">
         <div className="apariencia-layout">
            {/* Columna de controles */}
            <div className="apariencia-controles-columna">
               {/* Versi√≥n Desktop: contenedor con scroll */}
               <div className="apariencia-controles-unificado apariencia-controles-desktop">
                  <SeccionHeader
                     estilos={estilos}
                     actualizarHeader={actualizarHeader}
                     remANumero={remANumero}
                  />
                  <div className="apariencia-separador" />

                  <SeccionZona
                     estilos={estilos}
                     actualizarTituloZona={actualizarTituloZona}
                     remANumero={remANumero}
                  />
                  <div className="apariencia-separador" />

                  <SeccionFases
                     estilos={estilos}
                     actualizarTituloBox={actualizarTituloBox}
                     remANumero={remANumero}
                  />
                  <div className="apariencia-separador" />

                  <SeccionValores
                     estilos={estilos}
                     actualizarValorBox={actualizarValorBox}
                     remANumero={remANumero}
                  />
                  <div className="apariencia-separador" />

                  <SeccionDimensiones
                     estilos={estilos}
                     actualizarBox={actualizarBox}
                     pxANumero={pxANumero}
                  />
               </div>

               {/* Versi√≥n M√≥vil: Carrusel con flechas */}
               <div className="apariencia-carrusel">
                  {/* Navegaci√≥n del carrusel con t√≠tulo en el centro */}
                  <div className="carrusel-navegacion">
                     <button
                        type="button"
                        className="carrusel-flecha carrusel-flecha--izq"
                        onClick={irAlSlideAnterior}
                        aria-label="Slide anterior"
                     >
                        ‚óÄ
                     </button>

                     <span className="carrusel-titulo-central">
                        {SLIDES_CARRUSEL[slideActual].label}
                     </span>

                     <button
                        type="button"
                        className="carrusel-flecha carrusel-flecha--der"
                        onClick={irAlSlideSiguiente}
                        aria-label="Slide siguiente"
                     >
                        ‚ñ∂
                     </button>
                  </div>

                  {/* Contenedor de slides */}
                  <div className="carrusel-contenedor">
                     {/* Slide 0: Header */}
                     <SlideFuenteTama√±o
                        estilos={estilos}
                        seccion="header"
                        actualizar={actualizarHeader}
                        remANumero={remANumero}
                        limites={LIMITES_TAMA√ëO.header}
                        slideActual={slideActual}
                        indice={0}
                     />

                     {/* Slide 1: Zona */}
                     <SlideFuenteTama√±o
                        estilos={estilos}
                        seccion="tituloZona"
                        actualizar={actualizarTituloZona}
                        remANumero={remANumero}
                        limites={LIMITES_TAMA√ëO.tituloZona}
                        slideActual={slideActual}
                        indice={1}
                     />

                     {/* Slide 2: Fases */}
                     <SlideFuenteTama√±o
                        estilos={estilos}
                        seccion="tituloBox"
                        actualizar={actualizarTituloBox}
                        remANumero={remANumero}
                        limites={LIMITES_TAMA√ëO.tituloBox}
                        slideActual={slideActual}
                        indice={2}
                     />

                     {/* Slide 3: Valores 1/2 (Fuente y Tama√±o) */}
                     <SlideFuenteTama√±o
                        estilos={estilos}
                        seccion="valorBox"
                        actualizar={actualizarValorBox}
                        remANumero={remANumero}
                        limites={LIMITES_TAMA√ëO.valorBox}
                        slideActual={slideActual}
                        indice={3}
                     />

                     {/* Slide 4: Valores 2/2 (Color y Decimales) */}
                     <SlideColoresDecimales
                        estilos={estilos}
                        actualizarValorBox={actualizarValorBox}
                        slideActual={slideActual}
                     />

                     {/* Slide 5: Dimensiones */}
                     <SlideDimensiones
                        estilos={estilos}
                        actualizarBox={actualizarBox}
                        pxANumero={pxANumero}
                        slideActual={slideActual}
                     />
                  </div>
               </div>
            </div>

            {/* Columna de preview */}
            <div className="apariencia-preview-columna">
               <div className="apariencia-preview-label">Vista previa</div>
               <PreviewTarjeta
                  estilos={estilos}
                  valores={valoresPreview}
                  onRandomizar={randomizarValores}
                  onResetearValores={resetearValoresPreview}
               />
            </div>
         </div>

         {/* Footer con botones */}
         <div className="apariencia-footer">
            <div className="apariencia-footer-izquierda">
               <button
                  type="button"
                  className="apariencia-btn apariencia-btn--reset"
                  onClick={restaurarDefecto}
               >
                  Restaurar por defecto
               </button>
               <button
                  type="button"
                  className="apariencia-btn apariencia-btn--importar"
                  onClick={() => inputArchivoRef.current?.click()}
                  title="Importar configuraci√≥n desde archivo"
               >
                  Importar
               </button>
               <button
                  type="button"
                  className="apariencia-btn apariencia-btn--exportar"
                  onClick={exportarConfiguracion}
                  title="Exportar configuraci√≥n a archivo"
               >
                  Exportar
               </button>
               {/* Input oculto para importar archivo */}
               <input
                  ref={inputArchivoRef}
                  type="file"
                  accept=".json"
                  onChange={importarConfiguracion}
                  style={{ display: "none" }}
               />
            </div>
            <div className="apariencia-footer-derecha">
               <button
                  type="button"
                  className="apariencia-btn apariencia-btn--cancelar"
                  onClick={onCancelar}
               >
                  Cancelar
               </button>
               <button
                  type="button"
                  className="apariencia-btn apariencia-btn--guardar"
                  onClick={handleGuardar}
               >
                  Guardar
               </button>
            </div>
         </div>
      </div>
   );
};

export default TabApariencia;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/configuracion-alimentador/constantes.js =====

/**
 * Constantes para ModalConfiguracionAlimentador
 */

// Opciones predefinidas para el t√≠tulo del bloque (magnitudes t√≠picas)
export const OPCIONES_TITULO = [
   { id: "tension_linea", label: "Tensi√≥n de l√≠nea (kV)" },
   { id: "tension_entre_lineas", label: "Tensi√≥n entre l√≠neas (kV)" },
   { id: "corriente_132", label: "Corriente de l√≠nea (A) (en 13,2 kV)" },
   { id: "corriente_33", label: "Corriente de l√≠nea (A) (en 33 kV)" },
   { id: "potencia_activa", label: "Potencia activa (kW)" },
   { id: "potencia_reactiva", label: "Potencia reactiva (kVAr)" },
   { id: "potencia_aparente", label: "Potencia aparente (kVA)" },
   { id: "factor_potencia", label: "Factor de Potencia" },
   { id: "frecuencia", label: "Frecuencia (Hz)" },
   { id: "corriente_neutro", label: "Corriente de Neutro (A)" },
   { id: "custom", label: "Otro (personalizado)..." },
];

// Placeholders sugeridos para las etiquetas de cada box
export const PLACEHOLDERS_BOX = ["Ej: R o L1", "Ej: S o L2", "Ej: T o L3", "Ej: Total"];

/**
 * Dise√±o por defecto para un lado de la card
 */
export const crearSideDesignDefault = (tituloId = "corriente_132") => ({
   tituloId,
   tituloCustom: "",
   registrador_id: null,
   cantidad: 3,
   oculto: false,
   boxes: [
      { enabled: false, label: "", indice: null, formula: "" },
      { enabled: false, label: "", indice: null, formula: "" },
      { enabled: false, label: "", indice: null, formula: "" },
      { enabled: false, label: "", indice: null, formula: "" },
   ],
});

/**
 * Dise√±o por defecto para toda la card
 */
export const crearCardDesignDefault = () => ({
   superior: crearSideDesignDefault("corriente_132"),
   inferior: crearSideDesignDefault("tension_linea"),
});

// Intervalo de consulta por defecto en segundos
export const INTERVALO_CONSULTA_DEFAULT = 60;

// Intervalo m√≠nimo permitido en segundos
export const INTERVALO_CONSULTA_MIN = 5;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/configuracion-alimentador/index.js =====

// configuracion-alimentador/index.js
// Exportaciones centralizadas

export * from "./constantes";
export { default as SeccionCardDesign } from "./SeccionCardDesign";
export { default as SelectorColor } from "./SelectorColor";
export { useConfigAlimentador, useDeteccionDuplicados } from "./useConfigAlimentador";

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/configuracion-alimentador/SeccionCardDesign.jsx =====

/**
 * Subcomponente: Secci√≥n de dise√±o de card (superior/inferior)
 */

import { useState } from "react";
import { OPCIONES_TITULO, PLACEHOLDERS_BOX } from "./constantes";

const SeccionCardDesign = ({
   titulo,
   zona,
   design,
   registradores,
   registradorActual,
   indicesDisponibles,
   onChangeRegistrador,
   onChangeTitulo,
   onChangeTituloCustom,
   onChangeCantidad,
   onChangeBox,
   onDragOver,
   onDrop,
   onDragStart,
   estaIndiceDuplicado,
   obtenerMensajeDuplicado,
}) => {
   const [expandido, setExpandido] = useState(false);
   const [tooltipIdx, setTooltipIdx] = useState(null);
   const cant = design.cantidad || 3;
   const estaOculto = design.oculto || false;

   return (
      <div
         className={`alim-modal-card-section ${expandido ? "alim-modal-card-section--expandido" : ""} ${estaOculto ? "alim-modal-card-section--oculto" : ""}`}
      >
         <button
            type="button"
            className="alim-modal-card-section-header"
            onClick={() => setExpandido(!expandido)}
         >
            <span
               className={`alim-modal-card-section-arrow ${expandido ? "alim-modal-card-section-arrow--expandido" : ""}`}
            >
               ‚ñ∂
            </span>
            <span className="alim-modal-card-section-titulo">{titulo}</span>
            {registradorActual && !estaOculto && (
               <span className="alim-modal-card-section-registrador">{registradorActual.nombre}</span>
            )}
            {estaOculto && <span className="alim-modal-card-section-oculto-badge">OCULTO</span>}
         </button>

         {expandido && (
            <div className="alim-modal-card-section-content">
               {/* Selector de registrador para esta zona */}
               <div className="alim-modal-campo">
                  <label>Registrador</label>
                  <select
                     className="alim-modal-select"
                     value={design.registrador_id || ""}
                     onChange={(e) => onChangeRegistrador(e.target.value)}
                  >
                     <option value="">-- Sin registrador --</option>
                     {registradores.map((reg) => (
                        <option key={reg.id} value={reg.id}>
                           {reg.nombre} ({reg.agenteNombre}) - {reg.ip}:{reg.puerto} | Reg:{" "}
                           {reg.indice_inicial}-{reg.indice_inicial + reg.cantidad_registros - 1}
                        </option>
                     ))}
                  </select>
               </div>

               {/* √çndices arrastrables del registrador seleccionado */}
               {registradorActual && indicesDisponibles.length > 0 && (
                  <div className="alim-modal-indices">
                     <span className="alim-modal-indices-label">√çndices arrastrables:</span>
                     <div className="alim-modal-indices-chips">
                        {indicesDisponibles.map((indice) => (
                           <span
                              key={indice}
                              className="alim-modal-indice-chip"
                              draggable
                              onDragStart={(e) => onDragStart(e, indice)}
                           >
                              {indice}
                           </span>
                        ))}
                     </div>
                  </div>
               )}

               <div className="alim-modal-card-header">
                  <div className="alim-modal-campo">
                     <label>T√≠tulo</label>
                     <select
                        className="alim-modal-select"
                        value={design.tituloId || "corriente_132"}
                        onChange={(e) => onChangeTitulo(e.target.value)}
                     >
                        {OPCIONES_TITULO.map((op) => (
                           <option key={op.id} value={op.id}>
                              {op.label}
                           </option>
                        ))}
                     </select>
                  </div>

                  {design.tituloId === "custom" && (
                     <div className="alim-modal-campo">
                        <label>T√≠tulo personalizado</label>
                        <input
                           type="text"
                           className="alim-modal-input"
                           placeholder="Ej: CONSUMO (A)"
                           value={design.tituloCustom || ""}
                           onChange={(e) => onChangeTituloCustom(e.target.value)}
                        />
                     </div>
                  )}

                  <div className="alim-modal-campo alim-modal-campo--small">
                     <label>Cantidad boxes</label>
                     <select
                        className="alim-modal-select"
                        value={cant}
                        onChange={(e) => onChangeCantidad(Number(e.target.value))}
                     >
                        {[1, 2, 3, 4].map((n) => (
                           <option key={n} value={n}>
                              {n}
                           </option>
                        ))}
                     </select>
                  </div>
               </div>

               <div className="alim-modal-boxes">
                  {Array.from({ length: cant }).map((_, idx) => {
                     const box = design.boxes[idx] || {};
                     const duplicado = estaIndiceDuplicado(zona, idx, box.indice);

                     return (
                        <div key={`${zona}-box-${idx}`} className="alim-modal-box">
                           <span className="alim-modal-box-titulo">Box {idx + 1}</span>
                           <div className="alim-modal-box-row">
                              <label className="alim-modal-box-check">
                                 <input
                                    type="checkbox"
                                    checked={!!box.enabled}
                                    onChange={(e) => onChangeBox(idx, "enabled", e.target.checked)}
                                 />
                              </label>

                              <input
                                 type="text"
                                 className="alim-modal-input alim-modal-box-label"
                                 placeholder={PLACEHOLDERS_BOX[idx] || `Ej: R o L1`}
                                 value={box.label || ""}
                                 onChange={(e) => onChangeBox(idx, "label", e.target.value)}
                              />

                              <div className="alim-modal-box-indice-wrapper">
                                 <input
                                    type="number"
                                    className={`alim-modal-input alim-modal-box-indice ${duplicado ? "alim-modal-box-indice--duplicado" : ""}`}
                                    placeholder="√çndice"
                                    value={box.indice ?? ""}
                                    onChange={(e) =>
                                       onChangeBox(idx, "indice", e.target.value ? Number(e.target.value) : null)
                                    }
                                    onDragOver={onDragOver}
                                    onDrop={(e) => onDrop(e, idx)}
                                 />
                                 {duplicado && (
                                    <span
                                       className="alim-modal-box-warning"
                                       onMouseEnter={() => setTooltipIdx(idx)}
                                       onMouseLeave={() => setTooltipIdx(null)}
                                    >
                                       ‚ö†Ô∏è
                                       {tooltipIdx === idx && (
                                          <div className="alim-modal-box-warning-tooltip">
                                             {obtenerMensajeDuplicado(zona, idx, box.indice)}
                                          </div>
                                       )}
                                    </span>
                                 )}
                              </div>

                              <input
                                 type="text"
                                 className="alim-modal-input alim-modal-box-formula"
                                 placeholder="F√≥rmula (ej: x*250/1000)"
                                 value={box.formula || ""}
                                 onChange={(e) => onChangeBox(idx, "formula", e.target.value)}
                              />
                           </div>
                        </div>
                     );
                  })}
               </div>
            </div>
         )}
      </div>
   );
};

export default SeccionCardDesign;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/configuracion-alimentador/SelectorColor.jsx =====

/**
 * Componente selector de color con picker personalizado
 */

import { useState, useRef, useEffect } from "react";
import { HexColorPicker } from "react-colorful";
import { COLORES_SISTEMA } from "../../../constantes/colores";

const SelectorColor = ({ color, onChange }) => {
   const [mostrarPicker, setMostrarPicker] = useState(false);
   const [colorPersonalizado, setColorPersonalizado] = useState("#ff6b6b");
   const [valorHex, setValorHex] = useState("#ff6b6b");
   const pickerRef = useRef(null);
   const pickerBtnRef = useRef(null);

   const esColorPersonalizado = !COLORES_SISTEMA.includes(color);

   // Cerrar picker al hacer click fuera
   useEffect(() => {
      const handleClickOutside = (event) => {
         if (
            pickerRef.current &&
            !pickerRef.current.contains(event.target) &&
            pickerBtnRef.current &&
            !pickerBtnRef.current.contains(event.target)
         ) {
            setMostrarPicker(false);
         }
      };

      if (mostrarPicker) {
         document.addEventListener("mousedown", handleClickOutside);
      }
      return () => document.removeEventListener("mousedown", handleClickOutside);
   }, [mostrarPicker]);

   const handleHexInputChange = (e) => {
      const valor = e.target.value;
      setValorHex(valor);
      if (/^#[0-9A-Fa-f]{6}$/.test(valor)) {
         onChange(valor);
         setColorPersonalizado(valor);
      }
   };

   const copiarColor = () => {
      navigator.clipboard.writeText(color);
   };

   return (
      <>
         <div className="alim-color-grid">
            {COLORES_SISTEMA.map((c) => (
               <button
                  key={c}
                  type="button"
                  className={`alim-color-swatch ${color === c ? "alim-color-swatch-selected" : ""}`}
                  style={{ backgroundColor: c }}
                  onClick={() => {
                     onChange(c);
                     setMostrarPicker(false);
                  }}
                  aria-label={`Elegir color ${c}`}
               />
            ))}
            {/* Bot√≥n color personalizado */}
            <button
               ref={pickerBtnRef}
               type="button"
               className={`alim-color-swatch alim-color-custom ${esColorPersonalizado ? "alim-color-swatch-selected" : ""}`}
               onClick={() => {
                  setMostrarPicker(!mostrarPicker);
                  if (!mostrarPicker) {
                     setValorHex(color);
                  }
               }}
               aria-label="Color personalizado"
            />
            {/* Preview del color seleccionado */}
            <div className="alim-color-preview" style={{ backgroundColor: color }} title={color}>
               <span className="alim-color-preview-text">COLOR</span>
            </div>
         </div>

         {/* Picker flotante */}
         {mostrarPicker && (
            <div ref={pickerRef} className="color-picker-simple-popover alim-color-picker-popover">
               <HexColorPicker
                  color={color}
                  onChange={(nuevoColor) => {
                     onChange(nuevoColor);
                     setColorPersonalizado(nuevoColor);
                     setValorHex(nuevoColor);
                  }}
               />
               <div className="color-picker-hex-input-wrapper">
                  <input
                     type="text"
                     value={valorHex}
                     onChange={handleHexInputChange}
                     className="color-picker-hex-input"
                     placeholder="#000000"
                     maxLength={7}
                  />
                  <button type="button" className="color-picker-copy-btn" onClick={copiarColor} title="Copiar color">
                     üìã
                  </button>
               </div>
            </div>
         )}
      </>
   );
};

export default SelectorColor;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/configuracion-alimentador/useConfigAlimentador.js =====

/**
 * Hook para gestionar la l√≥gica de configuraci√≥n de alimentador
 * Incluye: detecci√≥n de duplicados, carga de registradores, gesti√≥n de card design
 */

import { useState, useEffect, useCallback, useMemo } from "react";
import { listarAgentesWorkspace, listarRegistradoresAgente } from "@/servicios/apiService";
import { crearCardDesignDefault, INTERVALO_CONSULTA_DEFAULT } from "./constantes";
import { COLORES_SISTEMA } from "../../../constantes/colores";

/**
 * Hook para gestionar la configuraci√≥n de alimentador
 * @param {Object} params
 * @param {boolean} params.abierto - Si el modal est√° abierto
 * @param {string} params.workspaceId - ID del workspace
 * @param {Object} params.initialData - Datos iniciales del alimentador
 */
export const useConfigAlimentador = ({ abierto, workspaceId, initialData }) => {
   // Estado b√°sico
   const [nombre, setNombre] = useState("");
   const [color, setColor] = useState(COLORES_SISTEMA[0]);
   const [intervaloConsultaSeg, setIntervaloConsultaSeg] = useState(INTERVALO_CONSULTA_DEFAULT);
   const [cardDesign, setCardDesign] = useState(crearCardDesignDefault());

   // Estado de registradores
   const [agentesVinculados, setAgentesVinculados] = useState([]);
   const [registradoresPorAgente, setRegistradoresPorAgente] = useState({});
   const [cargandoAgentes, setCargandoAgentes] = useState(false);

   // Cargar agentes vinculados
   useEffect(() => {
      if (!abierto || !workspaceId) return;

      const cargarAgentes = async () => {
         setCargandoAgentes(true);
         try {
            const agentes = await listarAgentesWorkspace(workspaceId);
            setAgentesVinculados(agentes || []);

            const registradoresMap = {};
            for (const agente of agentes || []) {
               try {
                  const regs = await listarRegistradoresAgente(agente.id);
                  registradoresMap[agente.id] = regs || [];
               } catch (err) {
                  console.error(`Error cargando registradores del agente ${agente.id}:`, err);
                  registradoresMap[agente.id] = [];
               }
            }
            setRegistradoresPorAgente(registradoresMap);
         } catch (err) {
            console.error("Error cargando agentes:", err);
         } finally {
            setCargandoAgentes(false);
         }
      };

      cargarAgentes();
   }, [abierto, workspaceId]);

   // Cargar datos iniciales
   useEffect(() => {
      if (!abierto) return;

      if (initialData) {
         setNombre(initialData.nombre || "");
         setColor(initialData.color || COLORES_SISTEMA[0]);
         const intervaloMs = initialData.intervalo_consulta_ms || 60000;
         setIntervaloConsultaSeg(Math.max(5, Math.round(intervaloMs / 1000)));

         let design = initialData.card_design || crearCardDesignDefault();

         // Migraci√≥n: formato antiguo con registrador_id en ra√≠z
         if (initialData.registrador_id && !design.superior?.registrador_id && !design.inferior?.registrador_id) {
            design = {
               ...design,
               superior: { ...design.superior, registrador_id: initialData.registrador_id },
               inferior: { ...design.inferior, registrador_id: initialData.registrador_id },
            };
         }

         setCardDesign(design);
      } else {
         setNombre("");
         setColor(COLORES_SISTEMA[0]);
         setIntervaloConsultaSeg(INTERVALO_CONSULTA_DEFAULT);
         setCardDesign(crearCardDesignDefault());
      }
   }, [abierto, initialData]);

   // Agrupar todos los registradores
   const todosRegistradores = useMemo(() => {
      const lista = [];
      for (const agente of agentesVinculados) {
         const regs = registradoresPorAgente[agente.id] || [];
         for (const reg of regs) {
            lista.push({ ...reg, agenteNombre: agente.nombre });
         }
      }
      return lista;
   }, [agentesVinculados, registradoresPorAgente]);

   // Buscar registrador por ID
   const buscarRegistrador = useCallback(
      (regId) => {
         if (!regId) return null;
         return todosRegistradores.find((r) => r.id === regId) || null;
      },
      [todosRegistradores]
   );

   // Obtener √≠ndices disponibles para una zona
   const obtenerIndicesZona = useCallback(
      (zona) => {
         const regId = cardDesign[zona]?.registrador_id;
         const reg = buscarRegistrador(regId);
         if (!reg) return [];
         return Array.from({ length: reg.cantidad_registros }, (_, i) => reg.indice_inicial + i);
      },
      [cardDesign, buscarRegistrador]
   );

   // Actualizar una propiedad de una zona
   const actualizarSide = useCallback((zona, campo, valor) => {
      setCardDesign((prev) => ({
         ...prev,
         [zona]: {
            ...prev[zona],
            [campo]: valor,
         },
      }));
   }, []);

   // Actualizar una propiedad de un box
   const actualizarBox = useCallback((zona, index, campo, valor) => {
      setCardDesign((prev) => {
         const newBoxes = [...prev[zona].boxes];
         newBoxes[index] = { ...newBoxes[index], [campo]: valor };
         return {
            ...prev,
            [zona]: {
               ...prev[zona],
               boxes: newBoxes,
            },
         };
      });
   }, []);

   return {
      // Estado b√°sico
      nombre,
      setNombre,
      color,
      setColor,
      intervaloConsultaSeg,
      setIntervaloConsultaSeg,
      cardDesign,
      setCardDesign,

      // Registradores
      agentesVinculados,
      cargandoAgentes,
      todosRegistradores,
      buscarRegistrador,
      obtenerIndicesZona,

      // Acciones
      actualizarSide,
      actualizarBox,
   };
};

/**
 * Hook para detectar √≠ndices duplicados en el card design
 * @param {Object} cardDesign - Dise√±o de la card
 */
export const useDeteccionDuplicados = (cardDesign) => {
   return useMemo(() => {
      const indicesUsados = [];
      const duplicados = [];

      // Recolectar √≠ndices de ambas zonas
      const procesarZona = (zona, boxes) => {
         boxes.forEach((box, idx) => {
            if (box.indice !== null && box.indice !== undefined && box.indice !== "") {
               const clave = String(box.indice);
               const info = { zona, boxNum: idx + 1, indice: box.indice };

               const existente = indicesUsados.find((r) => r.clave === clave);
               if (existente) {
                  duplicados.push({ ...info, duplicadoCon: existente.info });
               } else {
                  indicesUsados.push({ clave, info });
               }
            }
         });
      };

      procesarZona("superior", cardDesign.superior?.boxes || []);
      procesarZona("inferior", cardDesign.inferior?.boxes || []);

      // Crear set de claves duplicadas
      const clavesDuplicadas = new Set();
      duplicados.forEach((dup) => {
         clavesDuplicadas.add(`${dup.zona}-${dup.boxNum - 1}-${dup.indice}`);
         clavesDuplicadas.add(`${dup.duplicadoCon.zona}-${dup.duplicadoCon.boxNum - 1}-${dup.duplicadoCon.indice}`);
      });

      // Funciones de utilidad
      const estaIndiceDuplicado = (zona, index, indice) => {
         if (indice === null || indice === undefined || indice === "") return false;
         return clavesDuplicadas.has(`${zona}-${index}-${indice}`);
      };

      const obtenerMensajeDuplicado = (zona, index, indice) => {
         if (indice === null || indice === undefined || indice === "") return "";

         const dup = duplicados.find((d) => d.zona === zona && d.boxNum === index + 1 && d.indice === indice);
         if (dup) {
            const zonaLabel = dup.duplicadoCon.zona === "superior" ? "Parte superior" : "Parte inferior";
            return `Este √≠ndice ya est√° usado en ${zonaLabel} Box ${dup.duplicadoCon.boxNum}`;
         }

         const original = duplicados.find(
            (d) => d.duplicadoCon.zona === zona && d.duplicadoCon.boxNum === index + 1 && d.duplicadoCon.indice === indice
         );
         if (original) {
            const zonaLabel = original.zona === "superior" ? "Parte superior" : "Parte inferior";
            return `Este √≠ndice tambi√©n se usa en ${zonaLabel} Box ${original.boxNum}`;
         }

         return "";
      };

      return {
         duplicados,
         estaIndiceDuplicado,
         obtenerMensajeDuplicado,
      };
   }, [cardDesign]);
};

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/configurar-agente/FormularioRegistrador.jsx =====

// componentes/modales/configurar-agente/FormularioRegistrador.jsx
// Formulario para crear/editar registradores (analizador o rel√©)

import { ConfiguracionRele } from "../rele";

/**
 * Formulario de analizador de redes
 */
const FormularioAnalizador = ({
   nuevoRegistrador,
   setNuevoRegistrador,
   guardandoRegistrador,
   testEnCurso,
   onTest,
   onCancelar,
   onSubmit,
   registradorEditando,
}) => (
   <div className="config-agente-analizador">
      {/* Nombre del registrador */}
      <div className="config-agente-analizador-nombre">
         <label>Nombre del Registrador</label>
         <input
            type="text"
            value={nuevoRegistrador.nombre}
            onChange={(e) => setNuevoRegistrador((prev) => ({ ...prev, nombre: e.target.value }))}
            placeholder="Ej: Analizador Trafo 1"
            disabled={guardandoRegistrador}
         />
      </div>

      {/* Secciones en dos columnas */}
      <div className="config-agente-analizador-grid">
         {/* Secci√≥n Conexi√≥n */}
         <div className="config-agente-analizador-seccion">
            <h6>üì° Conexi√≥n Modbus TCP</h6>
            <div className="config-agente-analizador-campos">
               <div className="config-agente-campo-inline">
                  <label>IP</label>
                  <input
                     type="text"
                     value={nuevoRegistrador.ip}
                     onChange={(e) =>
                        setNuevoRegistrador((prev) => ({ ...prev, ip: e.target.value }))
                     }
                     placeholder="192.168.1.100"
                     disabled={guardandoRegistrador}
                  />
               </div>
               <div className="config-agente-campo-inline">
                  <label>Puerto</label>
                  <input
                     type="number"
                     value={nuevoRegistrador.puerto}
                     onChange={(e) =>
                        setNuevoRegistrador((prev) => ({ ...prev, puerto: e.target.value }))
                     }
                     placeholder="502"
                     disabled={guardandoRegistrador}
                  />
               </div>
               <div className="config-agente-campo-inline">
                  <label>Unit ID</label>
                  <input
                     type="number"
                     value={nuevoRegistrador.unitId}
                     onChange={(e) =>
                        setNuevoRegistrador((prev) => ({ ...prev, unitId: e.target.value }))
                     }
                     placeholder="1"
                     disabled={guardandoRegistrador}
                  />
               </div>
            </div>
         </div>

         {/* Secci√≥n Registros */}
         <div className="config-agente-analizador-seccion">
            <h6>üìã Registros Modbus</h6>
            <div className="config-agente-analizador-campos">
               <div className="config-agente-campo-inline">
                  <label>√çndice Inicial</label>
                  <input
                     type="number"
                     value={nuevoRegistrador.indiceInicial}
                     onChange={(e) =>
                        setNuevoRegistrador((prev) => ({ ...prev, indiceInicial: e.target.value }))
                     }
                     placeholder="0"
                     disabled={guardandoRegistrador}
                  />
               </div>
               <div className="config-agente-campo-inline">
                  <label>Cantidad</label>
                  <input
                     type="number"
                     value={nuevoRegistrador.cantidadRegistros}
                     onChange={(e) =>
                        setNuevoRegistrador((prev) => ({
                           ...prev,
                           cantidadRegistros: e.target.value,
                        }))
                     }
                     placeholder="20"
                     disabled={guardandoRegistrador}
                  />
               </div>
               <div className="config-agente-campo-inline">
                  <label>Intervalo</label>
                  <div className="config-agente-input-con-sufijo">
                     <input
                        type="number"
                        value={nuevoRegistrador.intervaloSegundos}
                        onChange={(e) =>
                           setNuevoRegistrador((prev) => ({
                              ...prev,
                              intervaloSegundos: e.target.value,
                           }))
                        }
                        placeholder="60"
                        disabled={guardandoRegistrador}
                     />
                     <span>seg</span>
                  </div>
               </div>
            </div>
         </div>
      </div>

      <div className="config-agente-form-acciones">
         <button
            type="button"
            className="config-agente-btn config-agente-btn--test"
            onClick={onTest}
            disabled={
               guardandoRegistrador ||
               testEnCurso ||
               !nuevoRegistrador.ip.trim() ||
               !nuevoRegistrador.puerto ||
               !nuevoRegistrador.indiceInicial ||
               !nuevoRegistrador.cantidadRegistros
            }
            title="Probar conexi√≥n antes de guardar"
         >
            {testEnCurso ? "Probando..." : "Test"}
         </button>
         <div className="config-agente-form-acciones-derecha">
            <button
               type="button"
               className="config-agente-btn config-agente-btn--secundario"
               onClick={onCancelar}
               disabled={guardandoRegistrador || testEnCurso}
            >
               Cancelar
            </button>
            <button
               type="submit"
               className="config-agente-btn config-agente-btn--primario"
               disabled={
                  guardandoRegistrador ||
                  testEnCurso ||
                  !nuevoRegistrador.nombre.trim() ||
                  !nuevoRegistrador.ip.trim() ||
                  !nuevoRegistrador.puerto ||
                  !nuevoRegistrador.indiceInicial ||
                  !nuevoRegistrador.cantidadRegistros
               }
            >
               {guardandoRegistrador ? "Guardando..." : registradorEditando ? "Guardar" : "Crear"}
            </button>
         </div>
      </div>
   </div>
);

/**
 * Formulario de rel√© de protecci√≥n
 */
const FormularioRele = ({
   nuevoRegistrador,
   setNuevoRegistrador,
   guardandoRegistrador,
   onCancelar,
   registradorEditando,
   agenteId,
}) => (
   <>
      {/* Nombre del registrador */}
      <div className="config-agente-rele-nombre">
         <label>Nombre del Registrador</label>
         <input
            type="text"
            value={nuevoRegistrador.nombre}
            onChange={(e) => setNuevoRegistrador((prev) => ({ ...prev, nombre: e.target.value }))}
            placeholder="Ej: Rel√© REF615 Bah√≠a 1"
            disabled={guardandoRegistrador}
         />
      </div>
      <ConfiguracionRele
         configuracionInicial={nuevoRegistrador.configuracionRele}
         onChange={(config) =>
            setNuevoRegistrador((prev) => ({
               ...prev,
               configuracionRele: config,
            }))
         }
         agenteId={agenteId}
      />
      <div className="config-agente-form-acciones">
         <div className="config-agente-form-acciones-derecha">
            <button
               type="button"
               className="config-agente-btn config-agente-btn--secundario"
               onClick={onCancelar}
               disabled={guardandoRegistrador}
            >
               Cancelar
            </button>
            <button
               type="submit"
               className="config-agente-btn config-agente-btn--primario"
               disabled={
                  guardandoRegistrador ||
                  !nuevoRegistrador.nombre.trim() ||
                  !nuevoRegistrador.configuracionRele
               }
            >
               {guardandoRegistrador ? "Guardando..." : registradorEditando ? "Guardar" : "Crear"}
            </button>
         </div>
      </div>
   </>
);

/**
 * Formulario principal para crear/editar registradores
 *
 * @param {Object} props
 * @param {string} props.agenteId - ID del agente
 * @param {Object} props.nuevoRegistrador - Estado del formulario
 * @param {Function} props.setNuevoRegistrador - Setter del estado
 * @param {Object|null} props.registradorEditando - Registrador en edici√≥n
 * @param {boolean} props.guardandoRegistrador - Si est√° guardando
 * @param {boolean} props.testEnCurso - Si hay test en curso
 * @param {Function} props.onSubmit - Callback al enviar
 * @param {Function} props.onTest - Callback para test
 * @param {Function} props.onCancelar - Callback para cancelar
 */
export function FormularioRegistrador({
   agenteId,
   nuevoRegistrador,
   setNuevoRegistrador,
   registradorEditando,
   guardandoRegistrador,
   testEnCurso,
   onSubmit,
   onTest,
   onCancelar,
}) {
   return (
      <form className="config-agente-reg-form" onSubmit={onSubmit}>
         <h5>{registradorEditando ? "Editar Registrador" : "Nuevo Registrador"}</h5>

         {/* Selector de tipo de dispositivo */}
         <div className="config-agente-tipo-row">
            <label className="config-agente-tipo-label">Tipo de Dispositivo:</label>
            <select
               value={nuevoRegistrador.tipoDispositivo}
               onChange={(e) =>
                  setNuevoRegistrador((prev) => ({
                     ...prev,
                     tipoDispositivo: e.target.value,
                     configuracionRele: e.target.value === "analizador" ? null : prev.configuracionRele,
                  }))
               }
               disabled={guardandoRegistrador}
               className="config-agente-select-tipo"
            >
               <option value="analizador">üìä Analizador de Redes</option>
               <option value="rele">üõ°Ô∏è Rel√© de Protecci√≥n</option>
            </select>
         </div>

         {/* Formulario espec√≠fico seg√∫n tipo */}
         {nuevoRegistrador.tipoDispositivo === "analizador" ? (
            <FormularioAnalizador
               nuevoRegistrador={nuevoRegistrador}
               setNuevoRegistrador={setNuevoRegistrador}
               guardandoRegistrador={guardandoRegistrador}
               testEnCurso={testEnCurso}
               onTest={onTest}
               onCancelar={onCancelar}
               onSubmit={onSubmit}
               registradorEditando={registradorEditando}
            />
         ) : (
            <FormularioRele
               nuevoRegistrador={nuevoRegistrador}
               setNuevoRegistrador={setNuevoRegistrador}
               guardandoRegistrador={guardandoRegistrador}
               onCancelar={onCancelar}
               registradorEditando={registradorEditando}
               agenteId={agenteId}
            />
         )}
      </form>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/configurar-agente/index.js =====

// componentes/modales/configurar-agente/index.js
// Exportaciones centralizadas de componentes de configuraci√≥n de agentes

export { TarjetaAgente, EstadoConexion } from "./TarjetaAgente";
export { ListaRegistradores, ToolbarRegistradores } from "./ListaRegistradores";
export { FormularioRegistrador } from "./FormularioRegistrador";
export { ModalResultadoTest, IndicadorTestProgreso } from "./ModalResultadoTest";

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/configurar-agente/ListaRegistradores.jsx =====

// componentes/modales/configurar-agente/ListaRegistradores.jsx
// Lista de registradores de un agente con acciones opcionales

/**
 * Lista de registradores con acciones opcionales
 *
 * @param {Object} props
 * @param {Array} props.registradores - Lista de registradores
 * @param {boolean} props.conAcciones - Si mostrar acciones (toggle, editar, eliminar)
 * @param {string|null} props.registradorProcesando - ID del registrador proces√°ndose
 * @param {Function} props.onToggle - Callback para toggle activar/desactivar
 * @param {Function} props.onEditar - Callback para editar
 * @param {Function} props.onEliminar - Callback para eliminar
 */
export function ListaRegistradores({
   registradores,
   conAcciones = false,
   registradorProcesando,
   onToggle,
   onEditar,
   onEliminar,
}) {
   if (registradores.length === 0) {
      return <div className="config-agente-regs-vacio">Sin registradores configurados</div>;
   }

   return (
      <div className="config-agente-regs-lista">
         {registradores.map((reg) => {
            const esRele = reg.tipo_dispositivo === "rele";
            const configRele = reg.configuracion_rele;

            return (
               <div
                  key={reg.id}
                  className={`config-agente-reg-item ${conAcciones ? "config-agente-reg-item--admin" : ""} ${esRele ? "config-agente-reg-item--rele" : ""}`}
               >
                  <div className="config-agente-reg-info">
                     <span
                        className={`config-agente-reg-estado ${reg.activo ? "config-agente-reg-estado--activo" : ""}`}
                        title={reg.activo ? "Activo" : "Inactivo"}
                     ></span>
                     <span
                        className="config-agente-reg-tipo"
                        title={esRele ? "Rel√© de Protecci√≥n" : "Analizador de Redes"}
                     >
                        {esRele ? "üõ°Ô∏è" : "üìä"}
                     </span>
                     <span className="config-agente-reg-nombre">{reg.nombre}</span>
                     {esRele && configRele ? (
                        <span className="config-agente-reg-detalle">
                           {reg.ip}:{reg.puerto} | {configRele.modeloId} - {configRele.configuracionId}{" "}
                           | {reg.intervalo_segundos}s
                        </span>
                     ) : (
                        <span className="config-agente-reg-detalle">
                           {reg.ip}:{reg.puerto} | Reg: {reg.indice_inicial}-
                           {reg.indice_inicial + reg.cantidad_registros - 1} | {reg.intervalo_segundos}
                           s
                        </span>
                     )}
                  </div>
                  {conAcciones && (
                     <div className="config-agente-reg-acciones">
                        <button
                           className={`config-agente-btn-icon ${reg.activo ? "config-agente-btn-icon--success" : ""}`}
                           onClick={() => onToggle(reg.id)}
                           title={reg.activo ? "Desactivar" : "Activar"}
                           disabled={registradorProcesando === reg.id}
                        >
                           {registradorProcesando === reg.id ? (
                              <span className="config-agente-spinner-mini"></span>
                           ) : reg.activo ? (
                              "‚è∏"
                           ) : (
                              "‚ñ∂"
                           )}
                        </button>
                        <button
                           className="config-agente-btn-icon"
                           onClick={() => onEditar(reg)}
                           title="Editar"
                           disabled={registradorProcesando === reg.id}
                        >
                           ‚úèÔ∏è
                        </button>
                        <button
                           className="config-agente-btn-icon config-agente-btn-icon--danger"
                           onClick={() => onEliminar(reg.id, reg.nombre)}
                           title="Eliminar"
                           disabled={registradorProcesando === reg.id}
                        >
                           üóë
                        </button>
                     </div>
                  )}
               </div>
            );
         })}
      </div>
   );
}

/**
 * Toolbar de acciones para registradores
 */
export function ToolbarRegistradores({
   registradores,
   registradorProcesando,
   onAgregar,
   onIniciarTodos,
   onPausarTodos,
}) {
   const hayActivos = registradores.some((r) => r.activo);
   const hayInactivos = registradores.some((r) => !r.activo);

   return (
      <div className="config-agente-regs-toolbar">
         <button className="config-agente-btn config-agente-btn--agregar-reg" onClick={onAgregar}>
            + Agregar Registrador
         </button>
         {registradores.length > 0 && (
            <div className="config-agente-regs-toolbar-acciones">
               {hayInactivos && (
                  <button
                     className="config-agente-btn config-agente-btn--iniciar-todos"
                     onClick={onIniciarTodos}
                     disabled={registradorProcesando === "todos"}
                     title="Iniciar todos los registradores pausados"
                  >
                     {registradorProcesando === "todos" ? (
                        <span className="config-agente-spinner-mini"></span>
                     ) : (
                        "‚ñ∂"
                     )}{" "}
                     Iniciar todos
                  </button>
               )}
               {hayActivos && (
                  <button
                     className="config-agente-btn config-agente-btn--parar-todos"
                     onClick={onPausarTodos}
                     disabled={registradorProcesando === "todos"}
                     title="Pausar todos los registradores activos"
                  >
                     {registradorProcesando === "todos" ? (
                        <span className="config-agente-spinner-mini"></span>
                     ) : (
                        "‚è∏"
                     )}{" "}
                     Pausar todos
                  </button>
               )}
            </div>
         )}
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/configurar-agente/ModalResultadoTest.jsx =====

// componentes/modales/configurar-agente/ModalResultadoTest.jsx
// Modal que muestra el resultado de un test de conexi√≥n

/**
 * Modal de resultado del test de conexi√≥n
 *
 * @param {Object} props
 * @param {Object} props.resultadoTest - Resultado del test
 * @param {Function} props.onCerrar - Callback para cerrar
 */
export function ModalResultadoTest({ resultadoTest, onCerrar }) {
   if (!resultadoTest) return null;

   return (
      <div className="config-agente-test-overlay" onClick={onCerrar}>
         <div className="config-agente-test-modal" onClick={(e) => e.stopPropagation()}>
            <div className="config-agente-test-header">
               <h3>Resultado del Test</h3>
               <button className="config-agente-cerrar" onClick={onCerrar}>
                  √ó
               </button>
            </div>
            <div className="config-agente-test-contenido">
               <div className="config-agente-test-info">
                  <strong>{resultadoTest.registrador?.nombre}</strong>
                  <span className="config-agente-test-detalle">
                     {resultadoTest.registrador?.ip}:{resultadoTest.registrador?.puerto}
                  </span>
               </div>

               {resultadoTest.exito ? (
                  <div className="config-agente-test-exito">
                     <div className="config-agente-test-icono">‚úì</div>
                     <h4>Conexi√≥n Exitosa</h4>
                     <p className="config-agente-test-tiempo">
                        Tiempo de respuesta: <strong>{resultadoTest.tiempo_respuesta_ms}ms</strong>
                     </p>
                     {resultadoTest.valores && resultadoTest.valores.length > 0 && (
                        <div className="config-agente-test-valores">
                           <h5>Valores le√≠dos ({resultadoTest.valores.length} registros):</h5>
                           <div className="config-agente-test-valores-grid">
                              {resultadoTest.valores.map((valor, idx) => (
                                 <div key={idx} className="config-agente-test-valor">
                                    <span className="config-agente-test-valor-idx">
                                       [{resultadoTest.registrador?.indice_inicial + idx}]
                                    </span>
                                    <span className="config-agente-test-valor-num">{valor}</span>
                                 </div>
                              ))}
                           </div>
                        </div>
                     )}
                  </div>
               ) : (
                  <div className="config-agente-test-error">
                     <div className="config-agente-test-icono config-agente-test-icono--error">
                        ‚úó
                     </div>
                     <h4>
                        {resultadoTest.estado === "timeout" && "Tiempo Agotado"}
                        {resultadoTest.estado === "cooldown" && "Espera Requerida"}
                        {resultadoTest.estado === "error" && "Error de Conexi√≥n"}
                     </h4>
                     <p className="config-agente-test-mensaje">{resultadoTest.error_mensaje}</p>
                     {resultadoTest.tiempo_respuesta_ms && (
                        <p className="config-agente-test-tiempo">
                           Tiempo transcurrido: {resultadoTest.tiempo_respuesta_ms}ms
                        </p>
                     )}
                  </div>
               )}
            </div>
            <div className="config-agente-test-acciones">
               <button className="config-agente-btn config-agente-btn--primario" onClick={onCerrar}>
                  Cerrar
               </button>
            </div>
         </div>
      </div>
   );
}

/**
 * Indicador de test en progreso
 */
export function IndicadorTestProgreso({ testEnCurso }) {
   if (!testEnCurso) return null;

   return (
      <div className="config-agente-test-progreso">
         <div className="config-agente-test-progreso-contenido">
            <span className="config-agente-spinner"></span>
            <span>Esperando respuesta del agente...</span>
            <div className="config-agente-test-progreso-barra">
               <div
                  className="config-agente-test-progreso-fill"
                  style={{ width: `${testEnCurso.progreso}%` }}
               ></div>
            </div>
         </div>
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/configurar-agente/TarjetaAgente.jsx =====

// componentes/modales/configurar-agente/TarjetaAgente.jsx
// Tarjeta individual de un agente con estado y acciones

/**
 * Indicador de estado de conexi√≥n
 */
export const EstadoConexion = ({ conectado }) => (
   <span
      className={`config-agente-estado ${conectado ? "config-agente-estado--conectado" : "config-agente-estado--desconectado"}`}
   >
      <span className="config-agente-estado-punto"></span>
      {conectado ? "Conectado" : "Desconectado"}
   </span>
);

/**
 * Tarjeta de agente reutilizable
 *
 * @param {Object} props
 * @param {Object} props.agente - Datos del agente
 * @param {boolean} props.expandido - Si los registradores est√°n expandidos
 * @param {Function} props.onToggleExpandir - Callback para expandir/colapsar
 * @param {Function} props.onAccionPrincipal - Callback para acci√≥n principal (vincular/desvincular)
 * @param {string} props.accionPrincipalLabel - Label del bot√≥n de acci√≥n principal
 * @param {string} props.accionPrincipalTipo - Tipo del bot√≥n ('vincular', 'desvincular', etc.)
 * @param {boolean} props.accionPrincipalDisabled - Si la acci√≥n est√° deshabilitada
 * @param {string} props.accionPrincipalTitle - Tooltip del bot√≥n
 * @param {boolean} props.mostrarAccionesAdmin - Si mostrar acciones de admin (rotar clave, eliminar)
 * @param {Function} props.onRotarClave - Callback para rotar clave
 * @param {Function} props.onEliminar - Callback para eliminar
 * @param {React.ReactNode} props.children - Contenido adicional (registradores)
 * @param {string} props.variante - Variante de estilo ('disponible', 'admin')
 */
export function TarjetaAgente({
   agente,
   expandido,
   onToggleExpandir,
   onAccionPrincipal,
   accionPrincipalLabel,
   accionPrincipalTipo,
   accionPrincipalDisabled,
   accionPrincipalTitle,
   mostrarAccionesAdmin,
   onRotarClave,
   onEliminar,
   children,
   variante,
}) {
   const claseVariante = variante ? `config-agente-card--${variante}` : "";

   return (
      <div className={`config-agente-card ${claseVariante}`}>
         <div className="config-agente-card-header">
            <div className="config-agente-card-info">
               <h3>{agente.nombre}</h3>
               <EstadoConexion conectado={agente.conectado} />
               {!agente.activo && (
                  <span className="config-agente-badge config-agente-badge--inactivo">Inactivo</span>
               )}
            </div>
            <div className="config-agente-card-acciones">
               {onToggleExpandir && (
                  <button
                     className="config-agente-btn-icon"
                     onClick={() => onToggleExpandir(agente.id)}
                     title="Ver registradores"
                  >
                     {expandido ? "‚ñ≤" : "‚ñº"}
                  </button>
               )}

               {/* Acci√≥n principal (vincular/desvincular) */}
               {onAccionPrincipal && accionPrincipalTipo === "vincular" && (
                  <button
                     className="config-agente-btn config-agente-btn--vincular"
                     onClick={() => onAccionPrincipal(agente.id)}
                  >
                     {accionPrincipalLabel}
                  </button>
               )}

               {onAccionPrincipal && accionPrincipalTipo === "desvincular" && (
                  <button
                     className={`config-agente-btn-icon config-agente-btn-icon--danger ${accionPrincipalDisabled ? "config-agente-btn-icon--disabled" : ""}`}
                     onClick={() => onAccionPrincipal(agente.id)}
                     title={accionPrincipalTitle || "Desvincular"}
                  >
                     ‚úï
                  </button>
               )}

               {/* Acciones de admin */}
               {mostrarAccionesAdmin && (
                  <>
                     <button
                        className="config-agente-btn-icon"
                        onClick={() => onRotarClave(agente.id)}
                        title="Rotar clave"
                     >
                        üîë
                     </button>
                     <button
                        className="config-agente-btn-icon config-agente-btn-icon--danger"
                        onClick={() => onEliminar(agente.id, agente.nombre)}
                        title="Eliminar"
                     >
                        üóë
                     </button>
                  </>
               )}
            </div>
         </div>

         {agente.descripcion && <p className="config-agente-card-desc">{agente.descripcion}</p>}

         {/* Contenido expandido (registradores) */}
         {expandido && children}
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/historial/ContenedorVentanasHistorial.jsx =====

/**
 * Contenedor para m√∫ltiples ventanas de historial flotantes
 * Incluye barra de tareas para ventanas minimizadas
 */

import VentanaHistorial from "./VentanaHistorial";
import "./VentanaHistorial.css";

const ContenedorVentanasHistorial = ({
  listaVentanas,
  ventanasMinimizadas,
  cerrarVentana,
  toggleMinimizar,
  toggleMaximizar,
  enfocarVentana,
  moverVentana,
}) => {
  return (
    <>
      {/* Renderizar ventanas abiertas (no minimizadas) */}
      {listaVentanas
        .filter((v) => !v.minimizada)
        .map((ventana) => (
          <VentanaHistorial
            key={ventana.id}
            ventana={ventana}
            onCerrar={() => cerrarVentana(ventana.id)}
            onMinimizar={() => toggleMinimizar(ventana.id)}
            onMaximizar={() => toggleMaximizar(ventana.id)}
            onEnfocar={() => enfocarVentana(ventana.id)}
            onMover={(pos) => moverVentana(ventana.id, pos)}
          />
        ))}

      {/* Barra de tareas para ventanas minimizadas */}
      {ventanasMinimizadas.length > 0 && (
        <div className="ventanas-barra-tareas">
          {ventanasMinimizadas.map((ventana) => (
            <div
              key={ventana.id}
              className="ventana-tarea"
              onClick={() => toggleMinimizar(ventana.id)}
            >
              <span className="ventana-tarea-icono">üìä</span>
              <span className="ventana-tarea-nombre">
                {ventana.alimentador?.nombre}
              </span>
              <button
                type="button"
                className="ventana-tarea-cerrar"
                onClick={(e) => {
                  e.stopPropagation();
                  cerrarVentana(ventana.id);
                }}
              >
                √ó
              </button>
            </div>
          ))}
        </div>
      )}
    </>
  );
};

export default ContenedorVentanasHistorial;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/historial/index.js =====

// modales/historial/index.js
// Modales y ventanas de historial

export { default as VentanaHistorial } from "./VentanaHistorial";
export { default as ContenedorVentanasHistorial } from "./ContenedorVentanasHistorial";
export { default as ModalConfigInforme } from "./ModalConfigInforme";

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/historial/ModalConfigInforme.jsx =====

/**
 * Modal de configuraci√≥n para generar informes Excel
 * Permite configurar: solicitante, intervalo de muestreo
 */

import { useState, useMemo, useEffect } from "react";
import PropTypes from "prop-types";
import { INTERVALOS_INFORME } from "../../../constantes/historialConfig";
import { generarImagenGrafico } from "../../../utilidades/generarGraficoInforme";
import "./ModalConfigInforme.css";

/**
 * Determina qu√© intervalos est√°n habilitados seg√∫n la duraci√≥n del per√≠odo
 * @param {number} duracionMs - Duraci√≥n en milisegundos
 * @returns {number[]} - Array de IDs de intervalos habilitados
 */
const obtenerIntervalosHabilitados = (duracionMs) => {
  const duracionHoras = duracionMs / (1000 * 60 * 60);

  if (duracionHoras <= 1) {
    // Hasta 1 hora: solo 15 min
    return [15];
  } else if (duracionHoras <= 2) {
    // M√°s de 1h hasta 2h: 15 min o 30 min
    return [15, 30];
  } else if (duracionHoras <= 6) {
    // M√°s de 2h hasta 6h: 15, 30 min o 1 hora
    return [15, 30, 60];
  } else if (duracionHoras <= 12) {
    // M√°s de 6h hasta 12h: 30 min o 1 hora
    return [30, 60];
  } else if (duracionHoras <= 24) {
    // M√°s de 12h hasta 24h: 30 min, 1 hora o 3 horas
    return [30, 60, 180];
  } else if (duracionHoras <= 48) {
    // M√°s de 24h hasta 48h: 3 horas o 6 horas
    return [180, 360];
  } else {
    // M√°s de 48h (7 d√≠as o m√°s): 3, 6 o 12 horas
    return [180, 360, 720];
  }
};

const ModalConfigInforme = ({
  visible,
  onCerrar,
  onGenerar,
  datos,
  nombreAlimentador,
  tituloMedicion,
  tipoGrafico = "line",
}) => {
  const [solicitadoPor, setSolicitadoPor] = useState("");
  const [intervaloSeleccionado, setIntervaloSeleccionado] = useState(null);
  const [generando, setGenerando] = useState(false);

  // Calcular duraci√≥n del per√≠odo de datos
  const { duracionMs, fechaInicio, fechaFin } = useMemo(() => {
    if (!datos || datos.length === 0) {
      return { duracionMs: 0, fechaInicio: null, fechaFin: null };
    }

    const timestamps = datos.map((d) => new Date(d.x).getTime());
    const min = Math.min(...timestamps);
    const max = Math.max(...timestamps);

    return {
      duracionMs: max - min,
      fechaInicio: new Date(min),
      fechaFin: new Date(max),
    };
  }, [datos]);

  // Intervalos habilitados seg√∫n la duraci√≥n
  const intervalosHabilitados = useMemo(() => {
    return obtenerIntervalosHabilitados(duracionMs);
  }, [duracionMs]);

  // Seleccionar autom√°ticamente el primer intervalo habilitado si no hay selecci√≥n v√°lida
  useEffect(() => {
    if (
      intervalosHabilitados.length > 0 &&
      (!intervaloSeleccionado || !intervalosHabilitados.includes(intervaloSeleccionado))
    ) {
      setIntervaloSeleccionado(intervalosHabilitados[0]);
    }
  }, [intervalosHabilitados, intervaloSeleccionado]);

  // Filtrar datos seg√∫n el intervalo seleccionado
  // Optimizado: usa muestreo por salto de √≠ndice para datasets grandes
  const datosFiltrados = useMemo(() => {
    if (!datos || datos.length === 0 || !intervaloSeleccionado) return [];

    const intervaloMs = intervaloSeleccionado * 60 * 1000;

    // Para datasets peque√±os (< 1000 puntos), usar filtrado tradicional
    if (datos.length < 1000) {
      let ultimoTimestamp = 0;
      return datos.filter((punto) => {
        const timestamp = new Date(punto.x).getTime();
        if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs) {
          ultimoTimestamp = timestamp;
          return true;
        }
        return false;
      });
    }

    // Para datasets grandes, calcular paso estimado y usar muestreo por √≠ndice
    // Esto reduce de O(n) a O(n/paso) iteraciones
    const primerTs = new Date(datos[0].x).getTime();
    const ultimoTs = new Date(datos[datos.length - 1].x).getTime();
    const duracionTotal = ultimoTs - primerTs;

    if (duracionTotal <= 0) return [datos[0]];

    // Estimar el intervalo promedio entre puntos
    const intervaloPromedio = duracionTotal / (datos.length - 1);
    // Calcular paso aproximado de √≠ndices
    const pasoEstimado = Math.max(1, Math.floor(intervaloMs / intervaloPromedio));

    const resultado = [];
    let ultimoTimestamp = 0;

    // Iterar con saltos, pero verificar timestamp real para precisi√≥n
    for (let i = 0; i < datos.length; i += pasoEstimado) {
      const punto = datos[i];
      const timestamp = new Date(punto.x).getTime();

      if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs * 0.9) {
        resultado.push(punto);
        ultimoTimestamp = timestamp;
      }
    }

    return resultado;
  }, [datos, intervaloSeleccionado]);

  const handleGenerar = async () => {
    setGenerando(true);

    try {
      // Generar imagen del gr√°fico con los datos filtrados del modal
      const imagenGrafico = await generarImagenGrafico(datosFiltrados, {
        tipo: tipoGrafico,
        titulo: "", // Sin t√≠tulo en el gr√°fico, ya est√° en el Excel
      });

      onGenerar({
        solicitadoPor: solicitadoPor.trim() || "No especificado",
        intervalo: intervaloSeleccionado,
        datosFiltrados,
        fechaInicio,
        fechaFin,
        imagenGrafico,
      });
      onCerrar();
    } catch (err) {
      console.error("Error generando informe:", err);
    } finally {
      setGenerando(false);
    }
  };

  if (!visible) return null;

  const formatearFecha = (fecha) => {
    if (!fecha) return "--";
    return fecha.toLocaleString("es-AR", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  const duracionTexto = () => {
    const horas = Math.floor(duracionMs / (1000 * 60 * 60));
    const minutos = Math.floor((duracionMs % (1000 * 60 * 60)) / (1000 * 60));

    if (horas >= 24) {
      const dias = Math.floor(horas / 24);
      const horasRestantes = horas % 24;
      return `${dias} d√≠a${dias > 1 ? "s" : ""} ${horasRestantes}h`;
    }
    return `${horas}h ${minutos}min`;
  };

  return (
    <div className="modal-config-informe-overlay" onClick={onCerrar}>
      <div className="modal-config-informe" onClick={(e) => e.stopPropagation()}>
        <header className="modal-config-header">
          <h3>Configurar Informe</h3>
          <button type="button" className="modal-config-cerrar" onClick={onCerrar}>
            √ó
          </button>
        </header>

        <div className="modal-config-contenido">
          {/* Info del informe */}
          <div className="modal-config-info">
            <p>
              <strong>Registros para:</strong> {nombreAlimentador}
            </p>
            <p>
              <strong>Medici√≥n:</strong> {tituloMedicion}
            </p>
            <p>
              <strong>Per√≠odo:</strong> {formatearFecha(fechaInicio)} - {formatearFecha(fechaFin)}
            </p>
            <p>
              <strong>Duraci√≥n:</strong> {duracionTexto()}
            </p>
          </div>

          {/* Solicitado por */}
          <div className="modal-config-campo">
            <label htmlFor="solicitadoPor">Solicitado por:</label>
            <input
              type="text"
              id="solicitadoPor"
              value={solicitadoPor}
              onChange={(e) => setSolicitadoPor(e.target.value)}
              placeholder="Nombre del solicitante"
              autoFocus
            />
          </div>

          {/* Intervalo de muestreo */}
          <div className="modal-config-campo">
            <label>Intervalo de muestreo:</label>
            <div className="modal-config-intervalos">
              {INTERVALOS_INFORME.map((intervalo) => {
                const habilitado = intervalosHabilitados.includes(intervalo.id);
                const seleccionado = intervaloSeleccionado === intervalo.id;

                return (
                  <button
                    key={intervalo.id}
                    type="button"
                    className={`modal-config-intervalo ${seleccionado ? "seleccionado" : ""}`}
                    disabled={!habilitado}
                    onClick={() => setIntervaloSeleccionado(intervalo.id)}
                  >
                    {intervalo.label}
                  </button>
                );
              })}
            </div>
          </div>

          {/* Preview de registros */}
          <div className="modal-config-preview">
            <span>
              Registros en el informe: <strong>{datosFiltrados.length}</strong>
            </span>
          </div>
        </div>

        <footer className="modal-config-footer">
          <button type="button" className="modal-config-btn cancelar" onClick={onCerrar}>
            Cancelar
          </button>
          <button
            type="button"
            className="modal-config-btn generar"
            onClick={handleGenerar}
            disabled={datosFiltrados.length === 0 || generando}
          >
            {generando ? "Generando..." : "Generar Informe"}
          </button>
        </footer>
      </div>
    </div>
  );
};

ModalConfigInforme.propTypes = {
  visible: PropTypes.bool.isRequired,
  onCerrar: PropTypes.func.isRequired,
  onGenerar: PropTypes.func.isRequired,
  datos: PropTypes.arrayOf(
    PropTypes.shape({
      x: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.number]),
      y: PropTypes.number,
    })
  ),
  nombreAlimentador: PropTypes.string,
  tituloMedicion: PropTypes.string,
  tipoGrafico: PropTypes.oneOf(["line", "area", "bar"]),
};

ModalConfigInforme.defaultProps = {
  datos: [],
  nombreAlimentador: "Alimentador",
  tituloMedicion: "Medici√≥n",
  tipoGrafico: "line",
};

export default ModalConfigInforme;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/historial/VentanaHistorial.jsx =====

/**
 * Ventana flotante para visualizar el historial de lecturas con gr√°ficos
 * Soporta: arrastrar, minimizar, maximizar, m√∫ltiples instancias
 */

import { useRef } from "react";
import ApexChartWrapper from "../../../../../componentes/comunes/ApexChartWrapper";
import { usarContextoAlimentadores } from "../../../contexto/ContextoAlimentadoresSupabase";
import { useVentanaHistorialLogica } from "../../../hooks/historial";
import { useArrastrarVentana } from "../../../hooks/ui";
import { exportarCSV } from "../../../utilidades/exportarCSV";
import { generarInformePDF } from "../../../utilidades/exportarInformePDF";
import ModalConfigInforme from "./ModalConfigInforme";
import PanelDatosHistorial from "../../historial/PanelDatosHistorial";
import BarraTituloVentana from "../../historial/BarraTituloVentana";
import BarraControlesHistorial from "../../historial/BarraControlesHistorial";
import ControlEscalaY from "../../historial/ControlEscalaY";
import EstadoGrafico from "../../historial/EstadoGrafico";
import EstadisticasHistorial from "../../historial/EstadisticasHistorial";
import "./VentanaHistorial.css";

const VentanaHistorial = ({
   ventana,
   onCerrar,
   onMinimizar,
   onMaximizar,
   onEnfocar,
   onMover,
}) => {
   const { alimentador: alimentadorInicial, cardDesign: cardDesignInicial, minimizada, maximizada, posicion, zIndex } = ventana;

   // Obtener alimentadores del puesto desde el contexto
   const { puestoSeleccionado } = usarContextoAlimentadores();
   const alimentadoresPuesto = puestoSeleccionado?.alimentadores || [];

   // Refs
   const ventanaRef = useRef(null);
   const headerRef = useRef(null);
   const chartRef = useRef(null);

   // Hook de arrastre
   const { arrastrando, handleMouseDown } = useArrastrarVentana({
      ventanaRef,
      maximizada,
      onEnfocar,
      onMover,
   });

   // Hook de l√≥gica principal
   const {
      alimentador,
      cargando,
      error,
      datosGrafico,
      datosFiltrados,
      precargando,
      precargaProgreso,
      precargaCompleta,
      panelDatosAbierto,
      setPanelDatosAbierto,
      graficoVisible,
      setGraficoVisible,
      modalInformeVisible,
      setModalInformeVisible,
      editandoEscalaY,
      setEditandoEscalaY,
      zonaSeleccionada,
      setZonaSeleccionada,
      zonaDisponible,
      tituloSuperior,
      tituloInferior,
      tituloZonaActual,
      rangoSeleccionado,
      fechaRangoDesde,
      fechaRangoHasta,
      handleRangoChange,
      handleFechaRangoChange,
      tipoGrafico,
      handleTipoGraficoChange,
      opcionesGrafico,
      seriesGrafico,
      escalaYMax,
      setEscalaYMax,
      handleEscalaYManual,
      limitesEscalaY,
      intervaloFiltro,
      setIntervaloFiltro,
      fuenteDatosEfectiva,
      tituloPanelDatos,
      estadisticasGrafico,
      cargarDatos,
      handleLimpiarCache,
      handleAlimentadorChange,
   } = useVentanaHistorialLogica({
      alimentadorInicial,
      cardDesignInicial,
      minimizada,
      alimentadoresPuesto,
   });

   // Handlers de exportaci√≥n
   const handleExportarCSV = () => {
      if (datosGrafico.length === 0) return;
      exportarCSV(datosGrafico, `historial_${alimentador?.nombre}_${zonaSeleccionada}_${Date.now()}`, {
         columnas: ["timestamp", "valor"],
         etiquetas: { timestamp: "Fecha/Hora", valor: `Promedio ${tituloZonaActual}` },
      });
   };

   const handleAbrirModalInforme = () => {
      if (datosGrafico.length === 0) return;
      setModalInformeVisible(true);
   };

   const handleGenerarInforme = async (configInforme) => {
      const { solicitadoPor, datosFiltrados: datosInforme, fechaInicio, fechaFin, intervalo, imagenGrafico } = configInforme;
      await generarInformePDF({
         nombreAlimentador: alimentador?.nombre || "Alimentador",
         tituloMedicion: tituloZonaActual,
         datos: datosInforme,
         fechaInicio,
         fechaFin,
         solicitadoPor,
         imagenGrafico,
         intervalo,
      });
   };

   // No renderizar si est√° minimizada
   if (minimizada) return null;

   const estiloVentana = maximizada
      ? { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, width: "100%", height: "100%", zIndex }
      : { position: "fixed", top: posicion.y, left: posicion.x, zIndex };

   return (
      <div
         ref={ventanaRef}
         className={`ventana-historial ${maximizada ? "ventana-historial--maximizada" : ""} ${arrastrando ? "ventana-historial--arrastrando" : ""}`}
         style={estiloVentana}
         onMouseDown={() => onEnfocar()}
      >
         {/* Header arrastrable */}
         <BarraTituloVentana
            ref={headerRef}
            nombre={alimentador?.nombre}
            maximizada={maximizada}
            onMinimizar={onMinimizar}
            onMaximizar={onMaximizar}
            onCerrar={onCerrar}
            onMouseDown={handleMouseDown}
         />

         {/* Contenido */}
         <div className="ventana-historial-content">
            {/* Barra de controles compacta */}
            <BarraControlesHistorial
               panelDatosAbierto={panelDatosAbierto}
               onTogglePanel={() => setPanelDatosAbierto(!panelDatosAbierto)}
               zonaSeleccionada={zonaSeleccionada}
               onZonaChange={setZonaSeleccionada}
               zonaDisponible={zonaDisponible}
               tituloSuperior={tituloSuperior}
               tituloInferior={tituloInferior}
               rangoSeleccionado={rangoSeleccionado}
               onRangoChange={handleRangoChange}
               fechaRangoDesde={fechaRangoDesde}
               fechaRangoHasta={fechaRangoHasta}
               onFechaRangoChange={handleFechaRangoChange}
               tipoGrafico={tipoGrafico}
               onTipoGraficoChange={handleTipoGraficoChange}
               alimentadorId={alimentador?.id}
               alimentadores={alimentadoresPuesto}
               onAlimentadorChange={handleAlimentadorChange}
               precargaProgreso={precargaProgreso}
               precargaCompleta={precargaCompleta}
               precargando={precargando}
               fuenteDatos={fuenteDatosEfectiva}
               onLimpiarCache={handleLimpiarCache}
               graficoVisible={graficoVisible}
               onToggleGrafico={() => setGraficoVisible(!graficoVisible)}
            />

            {/* Contenedor del gr√°fico y panel de datos */}
            <div className={`ventana-grafico-container ${!graficoVisible ? "ventana-grafico-container--oculto" : ""}`}>
               {/* Panel lateral de datos */}
               <PanelDatosHistorial
                  abierto={panelDatosAbierto}
                  tituloPeriodo={tituloPanelDatos}
                  intervaloFiltro={intervaloFiltro}
                  onIntervaloChange={setIntervaloFiltro}
                  datosFiltrados={datosFiltrados}
                  tipoGrafico={tipoGrafico}
               />

               {/* Control de escala Y */}
               <ControlEscalaY
                  visible={datosGrafico.length > 0 && !cargando && !error}
                  escalaYMax={escalaYMax}
                  setEscalaYMax={setEscalaYMax}
                  limitesEscalaY={limitesEscalaY}
                  editandoEscalaY={editandoEscalaY}
                  setEditandoEscalaY={setEditandoEscalaY}
                  handleEscalaYManual={handleEscalaYManual}
               />

               {/* Gr√°fico */}
               <div className="ventana-grafico">
                  <EstadoGrafico
                     cargando={cargando}
                     error={error}
                     precargando={precargando}
                     datosLength={datosGrafico.length}
                     onReintentar={cargarDatos}
                  >
                     <ApexChartWrapper
                        key={`chart-${tipoGrafico}-${escalaYMax}`}
                        ref={chartRef}
                        options={opcionesGrafico}
                        series={seriesGrafico}
                        type={tipoGrafico}
                        height="100%"
                     />
                  </EstadoGrafico>
               </div>
            </div>

            {/* Estad√≠sticas */}
            <EstadisticasHistorial
               estadisticas={estadisticasGrafico}
               onExportarCSV={handleExportarCSV}
               onAbrirInforme={handleAbrirModalInforme}
               datosDisponibles={datosGrafico.length > 0}
            />
         </div>

         {/* Modal de configuraci√≥n de informe */}
         <ModalConfigInforme
            visible={modalInformeVisible}
            onCerrar={() => setModalInformeVisible(false)}
            onGenerar={handleGenerarInforme}
            datos={datosGrafico}
            nombreAlimentador={alimentador?.nombre || "Alimentador"}
            tituloMedicion={tituloZonaActual}
            tipoGrafico={tipoGrafico}
         />
      </div>
   );
};

export default VentanaHistorial;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionAlimentador.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionAlimentador.jsx
// Modal unificado para configurar alimentador: nombre, color, registrador y dise√±o de card

import "./ModalConfiguracionAlimentador.css";
import "./comunes/ColorPickerSimple.css";
import {
   SeccionCardDesign,
   SelectorColor,
   useConfigAlimentador,
   useDeteccionDuplicados,
   INTERVALO_CONSULTA_MIN,
} from "./configuracion-alimentador";

const ModalConfiguracionAlimentador = ({
   abierto,
   puestoNombre,
   workspaceId,
   modo = "crear",
   initialData,
   onCancelar,
   onConfirmar,
   onEliminar,
   esCreador = false,
   rolEnWorkspace = null,
}) => {
   // Determinar permisos seg√∫n rol
   const esAdmin = esCreador || rolEnWorkspace === "admin";
   const puedeEditarNombre = esAdmin;
   const puedeEditarDiseno = esAdmin;
   const puedeEliminar = esAdmin;
   const puedeEditarIntervalo = esAdmin;
   const puedeOcultarZonas = esAdmin;

   // Hook de configuraci√≥n
   const {
      nombre,
      setNombre,
      color,
      setColor,
      intervaloConsultaSeg,
      setIntervaloConsultaSeg,
      cardDesign,
      agentesVinculados,
      cargandoAgentes,
      todosRegistradores,
      buscarRegistrador,
      obtenerIndicesZona,
      actualizarSide,
      actualizarBox,
   } = useConfigAlimentador({ abierto, workspaceId, initialData });

   // Hook de detecci√≥n de duplicados
   const { estaIndiceDuplicado, obtenerMensajeDuplicado } = useDeteccionDuplicados(cardDesign);

   // Handlers de drag & drop
   const handleDragStart = (e, indice) => {
      e.dataTransfer.setData("text/plain", String(indice));
      e.dataTransfer.effectAllowed = "copy";
   };

   const handleDragOver = (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = "copy";
   };

   const handleDrop = (e, zona, boxIndex) => {
      e.preventDefault();
      const indice = parseInt(e.dataTransfer.getData("text/plain"), 10);
      if (!isNaN(indice)) {
         actualizarBox(zona, boxIndex, "indice", indice);
      }
   };

   // Submit
   const handleSubmit = (e) => {
      e.preventDefault();
      const limpioNombre = nombre.trim();
      if (!limpioNombre) return;

      onConfirmar({
         nombre: limpioNombre,
         color,
         intervalo_consulta_ms: intervaloConsultaSeg * 1000,
         card_design: cardDesign,
      });
   };

   const handleEliminarClick = () => {
      if (!onEliminar) return;
      const seguro = window.confirm("¬øSeguro que quer√©s eliminar este alimentador?");
      if (seguro) {
         onEliminar();
      }
   };

   if (!abierto) return null;

   return (
      <div className="alim-modal-overlay">
         <div className="alim-modal alim-modal--grande">
            <h2>
               {modo === "editar" ? "Editar alimentador" : "Nuevo alimentador"}
               {puestoNombre && `: ${puestoNombre}`}
            </h2>

            <form onSubmit={handleSubmit}>
               <div className="alim-modal-content">
                  {/* === SECCI√ìN: Nombre y Color === */}
                  <div className="alim-modal-seccion">
                     <div className="alim-modal-campo">
                        <label>Nombre del Alimentador</label>
                        <input
                           id="nombre-alimentador"
                           type="text"
                           className="alim-modal-input"
                           value={nombre}
                           onChange={(e) => setNombre(e.target.value)}
                           placeholder="Ej: ALIMENTADOR 1"
                           required
                           autoComplete="off"
                           autoCorrect="off"
                           spellCheck={false}
                           autoFocus={puedeEditarNombre}
                           disabled={!puedeEditarNombre}
                        />
                     </div>

                     <SelectorColor color={color} onChange={setColor} />
                  </div>

                  {/* === SECCI√ìN: Dise√±o de Card === */}
                  {puedeEditarDiseno && (
                     <div className="alim-modal-seccion">
                        <h3 className="alim-modal-seccion-titulo">Dise√±o de la tarjeta</h3>

                        {cargandoAgentes ? (
                           <p className="alim-modal-cargando">Cargando registradores...</p>
                        ) : agentesVinculados.length === 0 ? (
                           <p className="alim-modal-aviso">
                              No hay agentes vinculados a este workspace. Vincul√° un agente desde el panel de
                              configuraci√≥n para poder asignar registradores.
                           </p>
                        ) : (
                           <>
                              <p className="alim-modal-seccion-ayuda">
                                 Seleccion√° un registrador para cada zona y arrastr√° los √≠ndices a los campos.
                              </p>

                              {/* Parte Superior */}
                              <SeccionCardDesign
                                 titulo="Parte superior"
                                 zona="superior"
                                 design={cardDesign.superior}
                                 registradores={todosRegistradores}
                                 registradorActual={buscarRegistrador(cardDesign.superior?.registrador_id)}
                                 indicesDisponibles={obtenerIndicesZona("superior")}
                                 onChangeRegistrador={(regId) => actualizarSide("superior", "registrador_id", regId || null)}
                                 onChangeTitulo={(val) => actualizarSide("superior", "tituloId", val)}
                                 onChangeTituloCustom={(val) => actualizarSide("superior", "tituloCustom", val)}
                                 onChangeCantidad={(val) => actualizarSide("superior", "cantidad", val)}
                                 onChangeBox={(idx, campo, val) => actualizarBox("superior", idx, campo, val)}
                                 onDragOver={handleDragOver}
                                 onDrop={(e, idx) => handleDrop(e, "superior", idx)}
                                 onDragStart={handleDragStart}
                                 estaIndiceDuplicado={estaIndiceDuplicado}
                                 obtenerMensajeDuplicado={obtenerMensajeDuplicado}
                              />

                              {/* Parte Inferior */}
                              <SeccionCardDesign
                                 titulo="Parte inferior"
                                 zona="inferior"
                                 design={cardDesign.inferior}
                                 registradores={todosRegistradores}
                                 registradorActual={buscarRegistrador(cardDesign.inferior?.registrador_id)}
                                 indicesDisponibles={obtenerIndicesZona("inferior")}
                                 onChangeRegistrador={(regId) => actualizarSide("inferior", "registrador_id", regId || null)}
                                 onChangeTitulo={(val) => actualizarSide("inferior", "tituloId", val)}
                                 onChangeTituloCustom={(val) => actualizarSide("inferior", "tituloCustom", val)}
                                 onChangeCantidad={(val) => actualizarSide("inferior", "cantidad", val)}
                                 onChangeBox={(idx, campo, val) => actualizarBox("inferior", idx, campo, val)}
                                 onDragOver={handleDragOver}
                                 onDrop={(e, idx) => handleDrop(e, "inferior", idx)}
                                 onDragStart={handleDragStart}
                                 estaIndiceDuplicado={estaIndiceDuplicado}
                                 obtenerMensajeDuplicado={obtenerMensajeDuplicado}
                              />
                           </>
                        )}
                     </div>
                  )}

                  {/* === SECCI√ìN: Intervalo de consulta + Ocultar zonas === */}
                  {(puedeEditarIntervalo || puedeOcultarZonas) && (
                     <div className="alim-modal-seccion">
                        <h3 className="alim-modal-seccion-titulo">Intervalo de consulta</h3>
                        <div className="alim-modal-intervalo-wrapper">
                           <div className="alim-modal-campo">
                              <label>Segundos entre consultas a la Base de Datos</label>
                              <input
                                 type="number"
                                 className="alim-modal-input-numero"
                                 value={intervaloConsultaSeg}
                                 onChange={(e) => {
                                    const valor = Number(e.target.value);
                                    setIntervaloConsultaSeg(Math.max(INTERVALO_CONSULTA_MIN, valor));
                                 }}
                                 min={INTERVALO_CONSULTA_MIN}
                                 step={1}
                                 disabled={!puedeEditarIntervalo}
                              />
                              <span className="alim-modal-campo-ayuda">
                                 Cada cu√°nto el frontend consulta la √∫ltima lectura (m√≠n. {INTERVALO_CONSULTA_MIN}s)
                              </span>
                           </div>

                           {/* Checkboxes para ocultar zonas */}
                           <div className="alim-modal-ocultar-zonas">
                              <span className="alim-modal-ocultar-zonas-titulo">Ocultar en tarjeta</span>
                              <label
                                 className={`alim-modal-ocultar-zona-item ${!puedeOcultarZonas ? "alim-modal-ocultar-zona-item--disabled" : ""}`}
                              >
                                 <input
                                    type="checkbox"
                                    checked={cardDesign.superior?.oculto || false}
                                    onChange={(e) => actualizarSide("superior", "oculto", e.target.checked)}
                                    disabled={!puedeOcultarZonas}
                                 />
                                 <span>Parte superior</span>
                              </label>
                              <label
                                 className={`alim-modal-ocultar-zona-item ${!puedeOcultarZonas ? "alim-modal-ocultar-zona-item--disabled" : ""}`}
                              >
                                 <input
                                    type="checkbox"
                                    checked={cardDesign.inferior?.oculto || false}
                                    onChange={(e) => actualizarSide("inferior", "oculto", e.target.checked)}
                                    disabled={!puedeOcultarZonas}
                                 />
                                 <span>Parte inferior</span>
                              </label>
                           </div>
                        </div>
                     </div>
                  )}
               </div>

               {/* Botones inferiores */}
               <div className="alim-modal-actions">
                  {modo === "editar" && puedeEliminar && (
                     <button type="button" className="alim-modal-btn-eliminar" onClick={handleEliminarClick}>
                        Eliminar
                     </button>
                  )}

                  <div className="alim-modal-actions-right">
                     <button type="button" className="alim-modal-btn alim-modal-btn-cancelar" onClick={onCancelar}>
                        Cancelar
                     </button>

                     <button type="submit" className="alim-modal-btn alim-modal-btn-guardar">
                        Guardar
                     </button>
                  </div>
               </div>
            </form>
         </div>
      </div>
   );
};

export default ModalConfiguracionAlimentador;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigurarAgente.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfigurarAgente.jsx
// Ventana flotante para configurar agentes con pesta√±as din√°micas seg√∫n rol
// Soporta: arrastrar, minimizar, maximizar, redimensionar, m√∫ltiples instancias

import React, { useState, useEffect, useCallback } from "react";
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import { useVentanaFlotante } from "../../hooks/ui";
import { useAgentesConfig, useRegistradoresConfig } from "../../hooks/agentes";
import {
   TarjetaAgente,
   ListaRegistradores,
   ToolbarRegistradores,
   FormularioRegistrador,
   ModalResultadoTest,
   IndicadorTestProgreso,
} from "./configurar-agente";
import "./ModalConfigurarAgente.css";

// ============================================================================
// Componentes auxiliares inline
// ============================================================================

/** Alerta de clave generada */
const AlertaClave = ({ clave, onCopiar, onCerrar }) => (
   <div className="config-agente-alerta config-agente-alerta--exito">
      <div className="config-agente-alerta-header">
         <strong>Clave del Agente</strong>
         <button onClick={onCerrar}>√ó</button>
      </div>
      <p>Guarda esta clave, no se mostrar√° de nuevo:</p>
      <div className="config-agente-clave-box">
         <code>{clave}</code>
         <button onClick={() => onCopiar(clave)}>Copiar</button>
      </div>
   </div>
);

/** Alerta de error */
const AlertaError = ({ mensaje, onCerrar }) => (
   <div className="config-agente-alerta config-agente-alerta--error">
      {mensaje}
      <button onClick={onCerrar}>√ó</button>
   </div>
);

/** Indicador de carga */
const IndicadorCargando = () => (
   <div className="config-agente-cargando">
      <span className="config-agente-spinner"></span>
      Cargando...
   </div>
);

/** Estado vac√≠o con CTA */
const EstadoVacio = ({ icono, mensaje, children }) => (
   <div className="config-agente-vacio">
      <span className="config-agente-vacio-icono">{icono}</span>
      <p>{mensaje}</p>
      {children}
   </div>
);

// ============================================================================
// Componentes de pesta√±as
// ============================================================================

/** Pesta√±a: Agentes Vinculados */
const PestanaAgentesVinculados = ({
   agentesVinculados,
   agenteExpandido,
   registradoresAgente,
   esAdmin,
   puedeVincularDesvincular,
   puedeVincular,
   onToggleRegistradores,
   onDesvincular,
   onIrAVincular,
}) => {
   if (agentesVinculados.length === 0) {
      return (
         <EstadoVacio icono="üì°" mensaje="No hay agentes vinculados a este workspace">
            {puedeVincular && (
               <button
                  className="config-agente-btn config-agente-btn--primario"
                  onClick={onIrAVincular}
               >
                  Vincular un Agente
               </button>
            )}
            {!puedeVincular && (
               <p className="config-agente-hint">Contacta a un administrador para vincular agentes.</p>
            )}
         </EstadoVacio>
      );
   }

   return (
      <div className="config-agente-lista">
         {agentesVinculados.map((agente) => (
            <TarjetaAgente
               key={agente.id}
               agente={agente}
               expandido={agenteExpandido === agente.id}
               onToggleExpandir={onToggleRegistradores}
               onAccionPrincipal={
                  esAdmin
                     ? (id) => {
                          if (puedeVincularDesvincular) {
                             onDesvincular(id);
                          } else {
                             alert("Solo el administrador que cre√≥ el workspace puede desvincular agentes.");
                          }
                       }
                     : null
               }
               accionPrincipalTipo={esAdmin ? "desvincular" : null}
               accionPrincipalTitle={
                  puedeVincularDesvincular
                     ? "Desvincular"
                     : "Solo el creador del workspace puede desvincular"
               }
               accionPrincipalDisabled={!puedeVincularDesvincular}
            >
               {agenteExpandido === agente.id && (
                  <div className="config-agente-card-regs">
                     <h4>Registradores</h4>
                     <ListaRegistradores
                        registradores={registradoresAgente[agente.id] || []}
                        conAcciones={false}
                     />
                  </div>
               )}
            </TarjetaAgente>
         ))}
      </div>
   );
};

/** Pesta√±a: Vincular Agente */
const PestanaVincularAgente = ({ agentesDisponibles, esSuperadmin, onVincular, onIrAAdmin }) => {
   if (agentesDisponibles.length === 0) {
      return (
         <EstadoVacio icono="üîç" mensaje="No hay agentes disponibles para vincular">
            {esSuperadmin && (
               <button className="config-agente-btn config-agente-btn--primario" onClick={onIrAAdmin}>
                  Crear nuevo Agente
               </button>
            )}
         </EstadoVacio>
      );
   }

   return (
      <>
         <p className="config-agente-instruccion">
            Selecciona un agente disponible para vincularlo a este workspace.
         </p>
         <div className="config-agente-lista">
            {agentesDisponibles.map((agente) => (
               <TarjetaAgente
                  key={agente.id}
                  agente={agente}
                  onAccionPrincipal={onVincular}
                  accionPrincipalLabel="Vincular"
                  accionPrincipalTipo="vincular"
                  variante="disponible"
               />
            ))}
         </div>
      </>
   );
};

/** Formulario para crear nuevo agente */
const FormularioCrearAgente = ({ nuevoAgente, setNuevoAgente, creando, onSubmit, onCancelar }) => (
   <form className="config-agente-form" onSubmit={onSubmit}>
      <h4>Nuevo Agente</h4>
      <div className="config-agente-form-grupo">
         <label>Nombre *</label>
         <input
            type="text"
            value={nuevoAgente.nombre}
            onChange={(e) => setNuevoAgente((prev) => ({ ...prev, nombre: e.target.value }))}
            placeholder="Ej: Agente Subestaci√≥n Norte"
            disabled={creando}
         />
      </div>
      <div className="config-agente-form-grupo">
         <label>Descripci√≥n</label>
         <input
            type="text"
            value={nuevoAgente.descripcion}
            onChange={(e) => setNuevoAgente((prev) => ({ ...prev, descripcion: e.target.value }))}
            placeholder="Descripci√≥n opcional"
            disabled={creando}
         />
      </div>
      <div className="config-agente-form-acciones">
         <button
            type="button"
            className="config-agente-btn config-agente-btn--secundario"
            onClick={onCancelar}
            disabled={creando}
         >
            Cancelar
         </button>
         <button
            type="submit"
            className="config-agente-btn config-agente-btn--primario"
            disabled={creando || !nuevoAgente.nombre.trim()}
         >
            {creando ? "Creando..." : "Crear Agente"}
         </button>
      </div>
   </form>
);

// ============================================================================
// Componente principal
// ============================================================================

/**
 * Modal para configurar agentes con pesta√±as seg√∫n rol del usuario.
 *
 * Pesta√±as:
 * - "Agentes Vinculados": Todos los roles con acceso al workspace
 * - "Vincular Agente": Solo creador del workspace o superadmin
 * - "Panel SuperAdmin": Solo Superadmin (CRUD de agentes y registradores)
 */
const ModalConfigurarAgente = ({
   abierto,
   workspaceId,
   onCerrar,
   minimizada = false,
   maximizada = false,
   posicion = { x: 100, y: 50 },
   zIndex = 1000,
   onMinimizar,
   onMaximizar,
   onEnfocar,
   onMover,
}) => {
   const { rolGlobal, configuracionSeleccionada } = usarContextoConfiguracion();

   // Determinar permisos seg√∫n rol
   const esSuperadmin = rolGlobal === "superadmin";
   const rolEnWorkspace = configuracionSeleccionada?.rol;
   const esAdmin = esSuperadmin || rolEnWorkspace === "admin";
   const esCreadorWorkspace = configuracionSeleccionada?.esCreador === true;
   const puedeVincularDesvincular = esSuperadmin || esCreadorWorkspace;
   const puedeVincular = puedeVincularDesvincular;

   // Pesta√±as disponibles seg√∫n rol
   const pestanasDisponibles = [
      { id: "vinculados", label: "Agentes Vinculados", visible: true },
      { id: "vincular", label: "Vincular Agente", visible: puedeVincular },
      { id: "admin", label: "Panel SuperAdmin", visible: esSuperadmin },
   ].filter((p) => p.visible);

   // Estado local de UI
   const [pestanaActiva, setPestanaActiva] = useState("vinculados");

   // Hook de ventana flotante (drag/resize)
   const {
      ventanaRef,
      headerRef,
      dimensiones,
      arrastrando,
      redimensionando,
      handleMouseDownDrag,
      handleMouseDownResize,
   } = useVentanaFlotante({ maximizada, onMover, onEnfocar });

   // Hook de agentes
   const {
      cargando,
      error,
      agentesVinculados,
      agentesDisponibles,
      todosAgentes,
      mostrarFormCrear,
      nuevoAgente,
      creando,
      claveGenerada,
      agenteExpandido,
      setMostrarFormCrear,
      setNuevoAgente,
      setError,
      cargarDatos,
      vincularAgente,
      desvincularAgente,
      crearNuevoAgente,
      eliminarAgenteById,
      rotarClave,
      toggleExpandirAgente,
      resetearEstado: resetearEstadoAgentes,
      limpiarClaveGenerada,
   } = useAgentesConfig({ workspaceId, puedeVincular, esSuperadmin });

   // Hook de registradores
   const {
      registradoresAgente,
      mostrarFormRegistrador,
      registradorEditando,
      nuevoRegistrador,
      guardandoRegistrador,
      registradorProcesando,
      testEnCurso,
      resultadoTest,
      setMostrarFormRegistrador,
      setNuevoRegistrador,
      resetFormRegistrador,
      cargarRegistradores,
      guardarRegistrador,
      editarRegistrador,
      eliminarRegistrador,
      toggleRegistrador,
      toggleTodosRegistradores,
      testRegistrador,
      limpiarResultadoTest,
      resetearEstado: resetearEstadoRegistradores,
   } = useRegistradoresConfig();

   // Cargar datos al abrir
   useEffect(() => {
      if (abierto && workspaceId) {
         cargarDatos();
      }
   }, [abierto, workspaceId, cargarDatos]);

   // Resetear estado al cerrar
   useEffect(() => {
      if (!abierto) {
         setPestanaActiva("vinculados");
         resetearEstadoAgentes();
         resetearEstadoRegistradores();
      }
   }, [abierto, resetearEstadoAgentes, resetearEstadoRegistradores]);

   // ==========================================================================
   // Handlers de agentes
   // ==========================================================================

   const handleVincular = async (agenteId) => {
      const exito = await vincularAgente(agenteId);
      if (exito) setPestanaActiva("vinculados");
   };

   const handleDesvincular = async (agenteId) => {
      if (!confirm("¬øDesvincular este agente del workspace?")) return;
      await desvincularAgente(agenteId);
   };

   const handleCrearAgente = async (e) => {
      e.preventDefault();
      await crearNuevoAgente(nuevoAgente.nombre, nuevoAgente.descripcion);
   };

   const handleEliminarAgente = async (agenteId, nombre) => {
      if (!confirm(`¬øEliminar el agente "${nombre}"? Esta acci√≥n no se puede deshacer.`)) return;
      await eliminarAgenteById(agenteId);
   };

   const handleRotarClave = async (agenteId) => {
      if (!confirm("¬øRotar la clave del agente? Deber√°s actualizar el agente con la nueva clave."))
         return;
      await rotarClave(agenteId);
   };

   // Toggle registradores de un agente
   const toggleRegistradores = async (agenteId) => {
      if (agenteExpandido === agenteId) {
         toggleExpandirAgente(null);
         setMostrarFormRegistrador(null);
         return;
      }
      if (!registradoresAgente[agenteId]) {
         await cargarRegistradores(agenteId);
      }
      toggleExpandirAgente(agenteId);
   };

   // ==========================================================================
   // Handlers de registradores
   // ==========================================================================

   const handleGuardarRegistrador = async (e, agenteId) => {
      e.preventDefault();
      if (!nuevoRegistrador.nombre.trim()) return;

      const esRele = nuevoRegistrador.tipoDispositivo === "rele";

      if (esRele) {
         const configRele = nuevoRegistrador.configuracionRele;
         if (!configRele || !configRele.plantillaId) {
            setError("Debes seleccionar una plantilla de configuraci√≥n");
            return;
         }
         if (!configRele.conexion?.ip) {
            setError("Debes configurar la IP del rel√©");
            return;
         }
      } else {
         if (
            !nuevoRegistrador.ip.trim() ||
            !nuevoRegistrador.puerto ||
            !nuevoRegistrador.indiceInicial ||
            !nuevoRegistrador.cantidadRegistros
         )
            return;
      }

      try {
         await guardarRegistrador(agenteId, nuevoRegistrador, registradorEditando?.id);
      } catch (err) {
         setError(err.message);
      }
   };

   const handleEliminarRegistrador = async (registradorId, nombre) => {
      if (!confirm(`¬øEliminar el registrador "${nombre}"?`)) return;
      try {
         await eliminarRegistrador(agenteExpandido, registradorId);
      } catch (err) {
         setError(err.message);
      }
   };

   const handleToggleRegistrador = async (registradorId) => {
      try {
         await toggleRegistrador(agenteExpandido, registradorId);
      } catch (err) {
         setError(err.message);
      }
   };

   const handleToggleTodosRegistradores = async (agenteId, iniciar) => {
      try {
         await toggleTodosRegistradores(agenteId, iniciar);
      } catch (err) {
         setError(err.message);
      }
   };

   const handleTestRegistrador = async (agenteId) => {
      if (
         !nuevoRegistrador.ip.trim() ||
         !nuevoRegistrador.puerto ||
         !nuevoRegistrador.indiceInicial ||
         !nuevoRegistrador.cantidadRegistros
      ) {
         setError("Completa IP, Puerto, √çndice Inicial y Cantidad de Registros para hacer el test");
         return;
      }
      try {
         await testRegistrador(agenteId, nuevoRegistrador);
      } catch (err) {
         setError(err.message);
      }
   };

   // Copiar al portapapeles
   const copiarAlPortapapeles = (texto) => {
      navigator.clipboard.writeText(texto);
   };

   // Handlers de ventana
   const handleMinimizar = useCallback(() => {
      if (onMinimizar) onMinimizar();
   }, [onMinimizar]);

   const handleMaximizar = useCallback(() => {
      if (onMaximizar) onMaximizar();
   }, [onMaximizar]);

   const handleEnfocar = useCallback(() => {
      if (onEnfocar) onEnfocar();
   }, [onEnfocar]);

   // ==========================================================================
   // Render
   // ==========================================================================

   if (!abierto || minimizada) return null;

   const estiloVentana = maximizada
      ? { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, width: "100%", height: "100%", zIndex }
      : {
           position: "fixed",
           top: posicion.y,
           left: posicion.x,
           width: dimensiones.width,
           height: dimensiones.height,
           zIndex,
        };

   return (
      <div
         ref={ventanaRef}
         className={`config-agente-ventana ${maximizada ? "config-agente-ventana--maximizada" : ""} ${arrastrando ? "config-agente-ventana--arrastrando" : ""} ${redimensionando ? "config-agente-ventana--redimensionando" : ""}`}
         style={estiloVentana}
         onMouseDown={handleEnfocar}
      >
         {/* Header arrastrable */}
         <header ref={headerRef} className="config-agente-header" onMouseDown={handleMouseDownDrag}>
            <div className="config-agente-titulo">
               <span className="config-agente-icono">‚öôÔ∏è</span>
               <h2>Configuraci√≥n de Agentes</h2>
            </div>
            <div className="config-agente-controles-ventana">
               <button
                  type="button"
                  className="config-agente-btn-ventana config-agente-btn-ventana--minimizar"
                  onClick={handleMinimizar}
                  title="Minimizar"
               >
                  <span>‚îÄ</span>
               </button>
               <button
                  type="button"
                  className="config-agente-btn-ventana config-agente-btn-ventana--maximizar"
                  onClick={handleMaximizar}
                  title={maximizada ? "Restaurar" : "Maximizar"}
               >
                  <span>{maximizada ? "‚ùê" : "‚ñ°"}</span>
               </button>
               <button
                  type="button"
                  className="config-agente-btn-ventana config-agente-btn-ventana--cerrar"
                  onClick={onCerrar}
                  title="Cerrar"
               >
                  <span>√ó</span>
               </button>
            </div>
         </header>

         {/* Pesta√±as */}
         <div className="config-agente-tabs">
            {pestanasDisponibles.map((p) => (
               <button
                  key={p.id}
                  className={`config-agente-tab ${pestanaActiva === p.id ? "config-agente-tab--activa" : ""}`}
                  onClick={() => setPestanaActiva(p.id)}
               >
                  {p.label}
               </button>
            ))}
         </div>

         {/* Contenido */}
         <div className="config-agente-contenido">
            {/* Alertas */}
            {claveGenerada && (
               <AlertaClave
                  clave={claveGenerada}
                  onCopiar={copiarAlPortapapeles}
                  onCerrar={limpiarClaveGenerada}
               />
            )}
            {error && <AlertaError mensaje={error} onCerrar={() => setError(null)} />}
            {cargando && <IndicadorCargando />}

            {/* PESTA√ëA: AGENTES VINCULADOS */}
            {pestanaActiva === "vinculados" && !cargando && (
               <div className="config-agente-seccion">
                  <PestanaAgentesVinculados
                     agentesVinculados={agentesVinculados}
                     agenteExpandido={agenteExpandido}
                     registradoresAgente={registradoresAgente}
                     esAdmin={esAdmin}
                     puedeVincularDesvincular={puedeVincularDesvincular}
                     puedeVincular={puedeVincular}
                     onToggleRegistradores={toggleRegistradores}
                     onDesvincular={handleDesvincular}
                     onIrAVincular={() => setPestanaActiva("vincular")}
                  />
               </div>
            )}

            {/* PESTA√ëA: VINCULAR AGENTE */}
            {pestanaActiva === "vincular" && !cargando && (
               <div className="config-agente-seccion">
                  <PestanaVincularAgente
                     agentesDisponibles={agentesDisponibles}
                     esSuperadmin={esSuperadmin}
                     onVincular={handleVincular}
                     onIrAAdmin={() => setPestanaActiva("admin")}
                  />
               </div>
            )}

            {/* PESTA√ëA: PANEL ADMIN */}
            {pestanaActiva === "admin" && !cargando && (
               <div className="config-agente-seccion">
                  {/* Formulario crear agente */}
                  {!mostrarFormCrear ? (
                     <button
                        className="config-agente-btn config-agente-btn--crear"
                        onClick={() => setMostrarFormCrear(true)}
                     >
                        + Crear Nuevo Agente
                     </button>
                  ) : (
                     <FormularioCrearAgente
                        nuevoAgente={nuevoAgente}
                        setNuevoAgente={setNuevoAgente}
                        creando={creando}
                        onSubmit={handleCrearAgente}
                        onCancelar={() => setMostrarFormCrear(false)}
                     />
                  )}

                  {/* Lista de todos los agentes */}
                  <div className="config-agente-admin-lista">
                     <h4>Todos los Agentes del Sistema</h4>
                     {todosAgentes.length === 0 ? (
                        <EstadoVacio mensaje="No hay agentes en el sistema" />
                     ) : (
                        <div className="config-agente-lista">
                           {todosAgentes.map((agente) => (
                              <TarjetaAgente
                                 key={agente.id}
                                 agente={agente}
                                 expandido={agenteExpandido === agente.id}
                                 onToggleExpandir={toggleRegistradores}
                                 mostrarAccionesAdmin
                                 onRotarClave={handleRotarClave}
                                 onEliminar={handleEliminarAgente}
                                 variante="admin"
                              >
                                 {agenteExpandido === agente.id && (
                                    <div className="config-agente-card-regs">
                                       <h4>Registradores</h4>
                                       <div className="config-agente-regs-contenedor">
                                          <ToolbarRegistradores
                                             registradores={registradoresAgente[agente.id] || []}
                                             registradorProcesando={registradorProcesando}
                                             onAgregar={() => {
                                                resetFormRegistrador();
                                                setMostrarFormRegistrador(agente.id);
                                             }}
                                             onIniciarTodos={() =>
                                                handleToggleTodosRegistradores(agente.id, true)
                                             }
                                             onPausarTodos={() =>
                                                handleToggleTodosRegistradores(agente.id, false)
                                             }
                                          />

                                          {mostrarFormRegistrador === agente.id && (
                                             <FormularioRegistrador
                                                agenteId={agente.id}
                                                nuevoRegistrador={nuevoRegistrador}
                                                setNuevoRegistrador={setNuevoRegistrador}
                                                registradorEditando={registradorEditando}
                                                guardandoRegistrador={guardandoRegistrador}
                                                testEnCurso={testEnCurso}
                                                onSubmit={(e) => handleGuardarRegistrador(e, agente.id)}
                                                onTest={() => handleTestRegistrador(agente.id)}
                                                onCancelar={() => {
                                                   setMostrarFormRegistrador(null);
                                                   resetFormRegistrador();
                                                }}
                                             />
                                          )}

                                          <ListaRegistradores
                                             registradores={registradoresAgente[agente.id] || []}
                                             conAcciones
                                             registradorProcesando={registradorProcesando}
                                             onToggle={handleToggleRegistrador}
                                             onEditar={(reg) =>
                                                editarRegistrador({ ...reg, agente_id: agente.id })
                                             }
                                             onEliminar={handleEliminarRegistrador}
                                          />
                                       </div>
                                    </div>
                                 )}
                              </TarjetaAgente>
                           ))}
                        </div>
                     )}
                  </div>
               </div>
            )}
         </div>

         {/* Modal de resultado del test */}
         <ModalResultadoTest resultadoTest={resultadoTest} onCerrar={limpiarResultadoTest} />

         {/* Indicador de test en progreso */}
         <IndicadorTestProgreso testEnCurso={testEnCurso} />

         {/* Handle de resize */}
         {!maximizada && (
            <div
               className="config-agente-resize-handle"
               onMouseDown={handleMouseDownResize}
               title="Arrastrar para redimensionar"
            />
         )}
      </div>
   );
};

export default ModalConfigurarAgente;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/FormularioEdicion.jsx =====

// componentes/FormularioEdicion.jsx
// Formulario de edici√≥n de permisos de usuario

/**
 * Formulario para editar rol y acceso a agentes de un usuario
 * @param {Object} props
 * @param {Object} props.cambiosPendientes - Estado de cambios actuales
 * @param {Array} props.rolesDisponibles - Roles disponibles para asignar
 * @param {Array} props.agentesDisponibles - Agentes disponibles
 * @param {boolean} props.guardando - Si est√° guardando
 * @param {boolean} props.tieneModificaciones - Si hay cambios pendientes
 * @param {Function} props.onCambioRol - Handler para cambio de rol
 * @param {Function} props.onToggleAccesoTotal - Handler para toggle acceso total
 * @param {Function} props.onToggleAgente - Handler para toggle agente
 * @param {Function} props.onGuardar - Handler para guardar
 * @param {Function} props.onCancelar - Handler para cancelar
 */
const FormularioEdicion = ({
   cambiosPendientes,
   rolesDisponibles,
   agentesDisponibles,
   guardando,
   tieneModificaciones,
   onCambioRol,
   onToggleAccesoTotal,
   onToggleAgente,
   onGuardar,
   onCancelar,
}) => {
   return (
      <div className="permisos-detalle-edicion">
         <h4>Editar Permisos</h4>

         <div className="permisos-campo">
            <label className="permisos-label">Rol Global</label>
            <select
               className="permisos-select"
               value={cambiosPendientes.rolGlobal || ""}
               onChange={(e) => onCambioRol(e.target.value)}
               disabled={guardando}
            >
               {rolesDisponibles.map((rol) => (
                  <option key={rol.codigo} value={rol.codigo}>
                     {rol.nombre}
                  </option>
               ))}
            </select>
         </div>

         <div className="permisos-campo">
            <label className="permisos-label">Acceso a Agentes</label>
            <label className="permisos-checkbox permisos-checkbox--destacado">
               <input
                  type="checkbox"
                  checked={cambiosPendientes.accesoTotal}
                  onChange={onToggleAccesoTotal}
                  disabled={guardando}
               />
               <span>Acceso a todos los agentes</span>
            </label>

            {!cambiosPendientes.accesoTotal && (
               <div className="permisos-agentes-lista">
                  {agentesDisponibles.length === 0 ? (
                     <span className="permisos-agentes-vacio">No hay agentes disponibles</span>
                  ) : (
                     agentesDisponibles.map((agente) => (
                        <label key={agente.id} className="permisos-checkbox">
                           <input
                              type="checkbox"
                              checked={cambiosPendientes.agentesIds.includes(agente.id)}
                              onChange={() => onToggleAgente(agente.id)}
                              disabled={guardando}
                           />
                           <span>{agente.nombre}</span>
                           {!agente.activo && (
                              <span className="permisos-agente-inactivo">(inactivo)</span>
                           )}
                        </label>
                     ))
                  )}
               </div>
            )}
         </div>

         <div className="permisos-edicion-acciones">
            <button
               type="button"
               className="permisos-btn permisos-btn--cancelar"
               onClick={onCancelar}
               disabled={guardando}
            >
               Cancelar
            </button>
            <button
               type="button"
               className="permisos-btn permisos-btn--guardar"
               onClick={onGuardar}
               disabled={guardando || !tieneModificaciones}
            >
               {guardando ? "Guardando..." : "Guardar"}
            </button>
         </div>
      </div>
   );
};

export default FormularioEdicion;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/index.js =====

// componentes/index.js
// Exportaciones de componentes del panel de permisos

export { default as PanelDetallesVacio } from "./PanelDetallesVacio";
export { default as FormularioEdicion } from "./FormularioEdicion";
export { default as WorkspacesGrid } from "./WorkspacesGrid";
export { default as PanelDetalles } from "./PanelDetalles";
export { default as ListaUsuarios } from "./ListaUsuarios";

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/ListaUsuarios.jsx =====

// componentes/ListaUsuarios.jsx
// Lista de usuarios con b√∫squeda y filtrado

/**
 * Lista de usuarios del panel de permisos
 * @param {Object} props
 * @param {Array} props.usuarios - Lista de usuarios
 * @param {Array} props.usuariosFiltrados - Lista filtrada
 * @param {boolean} props.cargando - Si est√° cargando
 * @param {string} props.error - Error si existe
 * @param {string} props.busqueda - T√©rmino de b√∫squeda
 * @param {string} props.filtroRol - Filtro de rol activo
 * @param {Object} props.usuarioSeleccionado - Usuario seleccionado
 * @param {Function} props.onBusquedaChange - Handler para cambio de b√∫squeda
 * @param {Function} props.onFiltroRolChange - Handler para cambio de filtro
 * @param {Function} props.onSeleccionarUsuario - Handler para seleccionar usuario
 * @param {Function} props.onRecargar - Handler para recargar datos
 */
const ListaUsuarios = ({
   usuarios,
   usuariosFiltrados,
   cargando,
   error,
   busqueda,
   filtroRol,
   usuarioSeleccionado,
   onBusquedaChange,
   onFiltroRolChange,
   onSeleccionarUsuario,
   onRecargar,
}) => {
   return (
      <div className="permisos-master">
         {/* B√∫squeda y filtros */}
         <div className="permisos-master-toolbar">
            <input
               type="text"
               placeholder="Buscar usuario..."
               value={busqueda}
               onChange={(e) => onBusquedaChange(e.target.value)}
               className="permisos-input-busqueda"
            />
            <select
               value={filtroRol}
               onChange={(e) => onFiltroRolChange(e.target.value)}
               className="permisos-select-filtro"
            >
               <option value="todos">Todos</option>
               <option value="admin">Admin</option>
               <option value="operador">Operador</option>
               <option value="observador">Observador</option>
            </select>
         </div>

         {/* Lista de usuarios */}
         <div className="permisos-usuarios-lista">
            {cargando ? (
               <div className="permisos-estado">
                  <div className="permisos-spinner"></div>
                  <span>Cargando...</span>
               </div>
            ) : error ? (
               <div className="permisos-estado permisos-estado--error">
                  <span>{error}</span>
                  <button onClick={onRecargar}>Reintentar</button>
               </div>
            ) : usuariosFiltrados.length === 0 ? (
               <div className="permisos-estado">
                  <span>No hay usuarios</span>
               </div>
            ) : (
               usuariosFiltrados.map((usuario) => (
                  <div
                     key={usuario.id}
                     className={`permisos-usuario-item ${
                        usuarioSeleccionado?.id === usuario.id
                           ? "permisos-usuario-item--activo"
                           : ""
                     }`}
                     onClick={() => onSeleccionarUsuario(usuario)}
                  >
                     <div className="permisos-usuario-info">
                        <span className="permisos-usuario-nombre">
                           {usuario.nombre || "Sin nombre"}
                        </span>
                        <span className="permisos-usuario-email">{usuario.email}</span>
                     </div>
                     <span
                        className={`permisos-badge-small permisos-badge-small--${usuario.rolGlobal}`}
                     >
                        {usuario.rolGlobal?.substring(0, 3).toUpperCase()}
                     </span>
                  </div>
               ))
            )}
         </div>

         {/* Contador */}
         <div className="permisos-master-footer">
            {usuariosFiltrados.length} de {usuarios.length} usuarios
         </div>
      </div>
   );
};

export default ListaUsuarios;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/PanelDetalles.jsx =====

// componentes/PanelDetalles.jsx
// Panel de detalles del usuario seleccionado

import PanelDetallesVacio from "./PanelDetallesVacio";
import FormularioEdicion from "./FormularioEdicion";
import WorkspacesGrid from "./WorkspacesGrid";

/**
 * Obtiene el texto descriptivo del acceso a agentes
 */
const getAccesoTexto = (usuario) => {
   if (usuario.permisoAgentes?.accesoTotal) return "Todos";
   const count = usuario.permisoAgentes?.agentes?.length || 0;
   if (count === 0) return "Sin acceso a agentes";
   return `${count} agente${count > 1 ? "s" : ""}`;
};

/**
 * Panel de detalles de usuario
 * @param {Object} props
 * @param {Object} props.usuarioSeleccionado - Usuario seleccionado
 * @param {boolean} props.cargandoDetalles - Si est√° cargando detalles
 * @param {string} props.errorDetalles - Error al cargar detalles
 * @param {Object} props.detallesUsuario - Detalles del usuario
 * @param {boolean} props.modoEdicion - Si est√° en modo edici√≥n
 * @param {Object} props.edicionProps - Props para el formulario de edici√≥n
 */
const PanelDetalles = ({
   usuarioSeleccionado,
   cargandoDetalles,
   errorDetalles,
   detallesUsuario,
   modoEdicion,
   edicionProps,
}) => {
   if (!usuarioSeleccionado) {
      return <PanelDetallesVacio />;
   }

   if (cargandoDetalles) {
      return (
         <div className="permisos-detalle-cargando">
            <div className="permisos-spinner"></div>
            <span>Cargando detalles...</span>
         </div>
      );
   }

   if (errorDetalles) {
      return (
         <div className="permisos-detalle-error">
            <span>Error: {errorDetalles}</span>
         </div>
      );
   }

   const {
      workspacesPropios = [],
      workspacesComoInvitado = [],
      resumen = {},
   } = detallesUsuario || {};

   return (
      <div className="permisos-detalle">
         {/* Header del usuario */}
         <div className="permisos-detalle-header">
            <div className="permisos-detalle-usuario">
               <span className="permisos-detalle-nombre">
                  {usuarioSeleccionado.nombre || "Sin nombre"}
               </span>
               <span className="permisos-detalle-email">{usuarioSeleccionado.email}</span>
            </div>
            <div className="permisos-detalle-badges">
               <span
                  className={`permisos-badge permisos-badge--${usuarioSeleccionado.rolGlobal}`}
               >
                  {usuarioSeleccionado.rolNombre}
               </span>
               <span className="permisos-detalle-acceso">{getAccesoTexto(usuarioSeleccionado)}</span>
            </div>
            {!modoEdicion && (
               <button
                  type="button"
                  className="permisos-btn-editar"
                  onClick={edicionProps.iniciarEdicion}
               >
                  Editar permisos
               </button>
            )}
         </div>

         {/* Modo edici√≥n */}
         {modoEdicion && <FormularioEdicion {...edicionProps} />}

         {/* Resumen y workspaces */}
         {!modoEdicion && detallesUsuario && (
            <>
               <div className="permisos-detalle-stats">
                  <div className="permisos-stat-item">
                     <span className="permisos-stat-numero">
                        {resumen.totalWorkspacesPropios ?? workspacesPropios.length}
                     </span>
                     <span className="permisos-stat-label">Workspaces propios</span>
                  </div>
                  <div className="permisos-stat-item">
                     <span className="permisos-stat-numero">{resumen.totalPuestos ?? 0}</span>
                     <span className="permisos-stat-label">Puestos totales</span>
                  </div>
                  <div className="permisos-stat-item">
                     <span className="permisos-stat-numero">
                        {resumen.totalWorkspacesInvitado ?? workspacesComoInvitado.length}
                     </span>
                     <span className="permisos-stat-label">Como invitado</span>
                  </div>
               </div>

               <WorkspacesGrid
                  workspacesPropios={workspacesPropios}
                  workspacesComoInvitado={workspacesComoInvitado}
               />
            </>
         )}
      </div>
   );
};

export default PanelDetalles;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/PanelDetallesVacio.jsx =====

// componentes/PanelDetallesVacio.jsx
// Estado vac√≠o del panel de detalles

/**
 * Componente mostrado cuando no hay usuario seleccionado
 */
const PanelDetallesVacio = () => (
   <div className="permisos-detalle-vacio">
      <span className="permisos-detalle-vacio-icono">üë§</span>
      <span>Selecciona un usuario para ver sus detalles</span>
   </div>
);

export default PanelDetallesVacio;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/componentes/WorkspacesGrid.jsx =====

// componentes/WorkspacesGrid.jsx
// Grid de workspaces propios y como invitado

/**
 * Agrupa invitados por rol
 */
const agruparInvitadosPorRol = (invitados) => {
   const grupos = {};
   invitados.forEach((inv) => {
      const rol = inv.rol || "observador";
      if (!grupos[rol]) grupos[rol] = [];
      grupos[rol].push(inv);
   });
   return grupos;
};

/**
 * Tarjeta de workspace propio
 */
const WorkspacePropio = ({ workspace }) => {
   const invitadosAgrupados = agruparInvitadosPorRol(workspace.invitados || []);

   return (
      <div className="permisos-workspace-card">
         <div className="permisos-workspace-header">
            <span className="permisos-workspace-nombre">{workspace.nombre}</span>
            <span className="permisos-workspace-puestos">
               {workspace.cantidadPuestos} puesto{workspace.cantidadPuestos !== 1 ? "s" : ""}
            </span>
         </div>

         {/* Agentes */}
         <div className="permisos-workspace-row">
            <span className="permisos-workspace-label">Agentes:</span>
            {workspace.agentes.length === 0 ? (
               <span className="permisos-workspace-vacio">Sin agente</span>
            ) : (
               <div className="permisos-workspace-chips">
                  {workspace.agentes.map((a) => (
                     <span
                        key={a.id}
                        className={`permisos-chip ${!a.activo ? "permisos-chip--inactivo" : ""}`}
                     >
                        {a.nombre}
                     </span>
                  ))}
               </div>
            )}
         </div>

         {/* Invitados agrupados por rol */}
         <div className="permisos-workspace-row">
            <span className="permisos-workspace-label">Invitados:</span>
            {workspace.invitados.length === 0 ? (
               <span className="permisos-workspace-vacio">Sin invitados</span>
            ) : (
               <div className="permisos-invitados-grupos">
                  {Object.entries(invitadosAgrupados).map(([rol, invs]) => (
                     <div key={rol} className="permisos-invitados-grupo">
                        <span className={`permisos-rol-badge permisos-rol-badge--${rol}`}>
                           {rol.toUpperCase()} ({invs.length})
                        </span>
                        <span className="permisos-invitados-nombres">
                           {invs.map((inv) => inv.nombre || inv.email).join(", ")}
                        </span>
                     </div>
                  ))}
               </div>
            )}
         </div>
      </div>
   );
};

/**
 * Tarjeta de workspace como invitado
 */
const WorkspaceInvitado = ({ workspace }) => (
   <div className="permisos-workspace-card permisos-workspace-card--invitado">
      <div className="permisos-workspace-header">
         <span className="permisos-workspace-nombre">{workspace.nombre}</span>
         <span className={`permisos-rol-badge permisos-rol-badge--${workspace.rol}`}>
            {workspace.rol?.toUpperCase()}
         </span>
      </div>
      <div className="permisos-workspace-row">
         <span className="permisos-workspace-label">Propietario:</span>
         <span className="permisos-workspace-propietario">
            {workspace.propietario?.nombre || workspace.propietario?.email || "Desconocido"}
         </span>
      </div>
   </div>
);

/**
 * Grid de workspaces del usuario
 * @param {Object} props
 * @param {Array} props.workspacesPropios - Workspaces propios del usuario
 * @param {Array} props.workspacesComoInvitado - Workspaces donde es invitado
 */
const WorkspacesGrid = ({ workspacesPropios = [], workspacesComoInvitado = [] }) => {
   const sinDatos = workspacesPropios.length === 0 && workspacesComoInvitado.length === 0;

   if (sinDatos) {
      return (
         <div className="permisos-detalle-sin-datos">
            Este usuario no tiene workspaces propios ni acceso como invitado.
         </div>
      );
   }

   return (
      <div className="permisos-detalle-contenido">
         {/* Workspaces propios */}
         {workspacesPropios.length > 0 && (
            <div className="permisos-seccion">
               <h4 className="permisos-seccion-titulo">Workspaces Propios</h4>
               <div className="permisos-workspaces-grid">
                  {workspacesPropios.map((ws) => (
                     <WorkspacePropio key={ws.id} workspace={ws} />
                  ))}
               </div>
            </div>
         )}

         {/* Workspaces como invitado */}
         {workspacesComoInvitado.length > 0 && (
            <div className="permisos-seccion">
               <h4 className="permisos-seccion-titulo">Acceso como Invitado</h4>
               <div className="permisos-workspaces-grid">
                  {workspacesComoInvitado.map((ws) => (
                     <WorkspaceInvitado key={ws.id} workspace={ws} />
                  ))}
               </div>
            </div>
         )}
      </div>
   );
};

export default WorkspacesGrid;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/hooks/index.js =====

// hooks/index.js
// Exportaciones de hooks del panel de permisos

export { useEstadoVentana } from "./useEstadoVentana";
export { useArrastrarModal } from "./useArrastrarModal";
export { useDatosPermisos } from "./useDatosPermisos";
export { useEdicionPermisos } from "./useEdicionPermisos";

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/hooks/useArrastrarModal.js =====

// hooks/useArrastrarModal.js
// Hook para arrastrar un modal por la pantalla

import { useState, useCallback, useEffect, useRef } from "react";

/**
 * Hook para habilitar arrastrar un modal
 * @param {Object} params
 * @param {string} params.estadoVentana - Estado actual de la ventana
 * @param {Object} params.posicion - Posici√≥n {x, y}
 * @param {Function} params.setPosicion - Setter de posici√≥n
 * @param {React.RefObject} params.modalRef - Referencia al elemento modal
 * @returns {Object} Estado y manejadores de arrastre
 */
export const useArrastrarModal = ({ estadoVentana, posicion, setPosicion, modalRef }) => {
   const [arrastrando, setArrastrando] = useState(false);
   const dragOffset = useRef({ x: 0, y: 0 });

   const handleMouseDownDrag = useCallback(
      (e) => {
         if (e.button !== 0 || estadoVentana === "maximizado") return;
         if (e.target.closest(".permisos-controles")) return;

         const modal = modalRef.current;
         if (!modal) return;

         const rect = modal.getBoundingClientRect();
         dragOffset.current = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
         };

         if (posicion.x === null) {
            setPosicion({ x: rect.left, y: rect.top });
         }

         setArrastrando(true);
         e.preventDefault();
      },
      [estadoVentana, posicion.x, setPosicion, modalRef]
   );

   const handleMouseMoveDrag = useCallback(
      (e) => {
         if (!arrastrando) return;

         const newX = e.clientX - dragOffset.current.x;
         const newY = e.clientY - dragOffset.current.y;

         const modal = modalRef.current;
         if (modal) {
            const maxX = window.innerWidth - modal.offsetWidth;
            const maxY = window.innerHeight - modal.offsetHeight;
            setPosicion({
               x: Math.max(0, Math.min(newX, maxX)),
               y: Math.max(0, Math.min(newY, maxY)),
            });
         }
      },
      [arrastrando, setPosicion, modalRef]
   );

   const handleMouseUpDrag = useCallback(() => {
      setArrastrando(false);
   }, []);

   useEffect(() => {
      if (arrastrando) {
         window.addEventListener("mousemove", handleMouseMoveDrag);
         window.addEventListener("mouseup", handleMouseUpDrag);
         return () => {
            window.removeEventListener("mousemove", handleMouseMoveDrag);
            window.removeEventListener("mouseup", handleMouseUpDrag);
         };
      }
   }, [arrastrando, handleMouseMoveDrag, handleMouseUpDrag]);

   return {
      arrastrando,
      handleMouseDownDrag,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/hooks/useDatosPermisos.js =====

// hooks/useDatosPermisos.js
// Hook para cargar y gestionar datos del panel de permisos

import { useState, useCallback, useMemo, useEffect } from "react";
import {
   listarUsuariosAdmin,
   listarAgentesParaPermisos,
   obtenerDetallesUsuarioAdmin,
} from "../../../../../../servicios/apiService";

/**
 * Hook para manejar datos de usuarios y agentes del panel de permisos
 * @param {boolean} abierto - Si el modal est√° abierto
 * @returns {Object} Estado y funciones de datos
 */
export const useDatosPermisos = (abierto) => {
   // Estado principal
   const [usuarios, setUsuarios] = useState([]);
   const [agentesDisponibles, setAgentesDisponibles] = useState([]);
   const [cargando, setCargando] = useState(false);
   const [error, setError] = useState(null);

   // B√∫squeda y filtrado
   const [busqueda, setBusqueda] = useState("");
   const [filtroRol, setFiltroRol] = useState("todos");

   // Usuario seleccionado
   const [usuarioSeleccionado, setUsuarioSeleccionado] = useState(null);
   const [detallesUsuario, setDetallesUsuario] = useState(null);
   const [cargandoDetalles, setCargandoDetalles] = useState(false);
   const [errorDetalles, setErrorDetalles] = useState(null);

   // Usuarios filtrados
   const usuariosFiltrados = useMemo(() => {
      return usuarios.filter((u) => {
         const coincideBusqueda =
            busqueda === "" ||
            u.nombre?.toLowerCase().includes(busqueda.toLowerCase()) ||
            u.email?.toLowerCase().includes(busqueda.toLowerCase());
         const coincideRol = filtroRol === "todos" || u.rolGlobal === filtroRol;
         return coincideBusqueda && coincideRol;
      });
   }, [usuarios, busqueda, filtroRol]);

   // Cargar datos
   const cargarDatos = useCallback(async () => {
      try {
         setCargando(true);
         setError(null);

         const [usuariosData, agentesData] = await Promise.all([
            listarUsuariosAdmin(),
            listarAgentesParaPermisos(),
         ]);

         setUsuarios(usuariosData);
         setAgentesDisponibles(agentesData);
      } catch (err) {
         console.error("Error cargando datos:", err);
         setError(err.message);
      } finally {
         setCargando(false);
      }
   }, []);

   // Seleccionar usuario y cargar detalles
   const seleccionarUsuario = useCallback(
      async (usuario) => {
         if (usuarioSeleccionado?.id === usuario.id) return;

         setUsuarioSeleccionado(usuario);
         setCargandoDetalles(true);
         setErrorDetalles(null);
         setDetallesUsuario(null);

         try {
            const detalles = await obtenerDetallesUsuarioAdmin(usuario.id);
            setDetallesUsuario(detalles);
         } catch (err) {
            console.error("Error cargando detalles:", err);
            setErrorDetalles(err.message || "Error al cargar detalles");
         } finally {
            setCargandoDetalles(false);
         }
      },
      [usuarioSeleccionado?.id]
   );

   // Recargar detalles del usuario actual
   const recargarDetallesUsuario = useCallback(async () => {
      if (!usuarioSeleccionado) return null;

      const detalles = await obtenerDetallesUsuarioAdmin(usuarioSeleccionado.id);
      setDetallesUsuario(detalles);

      const usuarioActualizado = (await listarUsuariosAdmin()).find(
         (u) => u.id === usuarioSeleccionado.id
      );
      if (usuarioActualizado) setUsuarioSeleccionado(usuarioActualizado);

      return usuarioActualizado;
   }, [usuarioSeleccionado]);

   // Limpiar estado
   const limpiarEstado = useCallback(() => {
      setUsuarioSeleccionado(null);
      setDetallesUsuario(null);
      setError(null);
      setBusqueda("");
      setFiltroRol("todos");
      setErrorDetalles(null);
   }, []);

   // Cargar datos al abrir
   useEffect(() => {
      if (abierto) {
         cargarDatos();
      }
   }, [abierto, cargarDatos]);

   return {
      // Estado
      usuarios,
      usuariosFiltrados,
      agentesDisponibles,
      cargando,
      error,
      busqueda,
      filtroRol,
      usuarioSeleccionado,
      detallesUsuario,
      cargandoDetalles,
      errorDetalles,

      // Setters
      setBusqueda,
      setFiltroRol,
      setUsuarioSeleccionado,

      // Acciones
      cargarDatos,
      seleccionarUsuario,
      recargarDetallesUsuario,
      limpiarEstado,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/hooks/useEdicionPermisos.js =====

// hooks/useEdicionPermisos.js
// Hook para manejar la edici√≥n de permisos de usuario

import { useState, useCallback } from "react";
import {
   cambiarRolUsuarioAdmin,
   actualizarAgentesUsuarioAdmin,
} from "../../../../../../servicios/apiService";

/**
 * Hook para manejar la edici√≥n de permisos de un usuario
 * @param {Object} params
 * @param {Object} params.usuarioSeleccionado - Usuario actualmente seleccionado
 * @param {Function} params.cargarDatos - Funci√≥n para recargar datos
 * @param {Function} params.recargarDetallesUsuario - Funci√≥n para recargar detalles
 * @returns {Object} Estado y funciones de edici√≥n
 */
export const useEdicionPermisos = ({
   usuarioSeleccionado,
   cargarDatos,
   recargarDetallesUsuario,
}) => {
   const [modoEdicion, setModoEdicion] = useState(false);
   const [cambiosPendientes, setCambiosPendientes] = useState({});
   const [guardando, setGuardando] = useState(false);
   const [errorGuardado, setErrorGuardado] = useState(null);

   // Roles disponibles para asignar (no incluye superadmin)
   const rolesDisponibles = [
      { codigo: "admin", nombre: "Administrador" },
      { codigo: "operador", nombre: "Operador" },
      { codigo: "observador", nombre: "Observador" },
   ];

   // Iniciar modo edici√≥n
   const iniciarEdicion = useCallback(() => {
      if (!usuarioSeleccionado) return;
      setModoEdicion(true);
      setErrorGuardado(null);
      setCambiosPendientes({
         rolGlobal: usuarioSeleccionado.rolGlobal,
         accesoTotal: usuarioSeleccionado.permisoAgentes?.accesoTotal || false,
         agentesIds: usuarioSeleccionado.permisoAgentes?.agentes?.map((a) => a.id) || [],
      });
   }, [usuarioSeleccionado]);

   // Cambiar rol
   const handleCambioRol = useCallback((nuevoRol) => {
      setCambiosPendientes((prev) => ({ ...prev, rolGlobal: nuevoRol }));
   }, []);

   // Toggle acceso total
   const handleToggleAccesoTotal = useCallback(() => {
      setCambiosPendientes((prev) => ({
         ...prev,
         accesoTotal: !prev.accesoTotal,
         agentesIds: !prev.accesoTotal ? [] : prev.agentesIds,
      }));
   }, []);

   // Toggle agente individual
   const handleToggleAgente = useCallback((agenteId) => {
      setCambiosPendientes((prev) => {
         const yaIncluido = prev.agentesIds.includes(agenteId);
         return {
            ...prev,
            agentesIds: yaIncluido
               ? prev.agentesIds.filter((id) => id !== agenteId)
               : [...prev.agentesIds, agenteId],
         };
      });
   }, []);

   // Verificar si hay modificaciones
   const tieneModificaciones = useCallback(() => {
      if (!usuarioSeleccionado || !cambiosPendientes.rolGlobal) return false;

      const rolCambio = usuarioSeleccionado.rolGlobal !== cambiosPendientes.rolGlobal;
      const accesoTotalCambio =
         (usuarioSeleccionado.permisoAgentes?.accesoTotal || false) !==
         cambiosPendientes.accesoTotal;
      const agentesOriginales =
         usuarioSeleccionado.permisoAgentes?.agentes?.map((a) => a.id).sort() || [];
      const agentesNuevos = [...cambiosPendientes.agentesIds].sort();
      const agentesCambio = JSON.stringify(agentesOriginales) !== JSON.stringify(agentesNuevos);

      return rolCambio || accesoTotalCambio || agentesCambio;
   }, [usuarioSeleccionado, cambiosPendientes]);

   // Guardar cambios
   const handleGuardarUsuario = useCallback(async () => {
      if (!usuarioSeleccionado) return;

      try {
         setGuardando(true);
         setErrorGuardado(null);

         if (usuarioSeleccionado.rolGlobal !== cambiosPendientes.rolGlobal) {
            await cambiarRolUsuarioAdmin(usuarioSeleccionado.id, cambiosPendientes.rolGlobal);
         }

         await actualizarAgentesUsuarioAdmin(
            usuarioSeleccionado.id,
            cambiosPendientes.accesoTotal,
            cambiosPendientes.agentesIds
         );

         await cargarDatos();
         await recargarDetallesUsuario();

         setModoEdicion(false);
         setCambiosPendientes({});
      } catch (err) {
         console.error("Error guardando usuario:", err);
         setErrorGuardado(err.message || err.detalles || "Error al guardar permisos");
      } finally {
         setGuardando(false);
      }
   }, [
      usuarioSeleccionado,
      cambiosPendientes,
      cargarDatos,
      recargarDetallesUsuario,
   ]);

   // Cancelar edici√≥n
   const handleCancelarEdicion = useCallback(() => {
      setModoEdicion(false);
      setCambiosPendientes({});
      setErrorGuardado(null);
   }, []);

   // Resetear estado de edici√≥n (al cambiar usuario)
   const resetearEdicion = useCallback(() => {
      setModoEdicion(false);
      setCambiosPendientes({});
      setErrorGuardado(null);
   }, []);

   return {
      // Estado
      modoEdicion,
      cambiosPendientes,
      guardando,
      errorGuardado,
      rolesDisponibles,

      // Acciones
      iniciarEdicion,
      handleCambioRol,
      handleToggleAccesoTotal,
      handleToggleAgente,
      tieneModificaciones,
      handleGuardarUsuario,
      handleCancelarEdicion,
      resetearEdicion,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/hooks/useEstadoVentana.js =====

// hooks/useEstadoVentana.js
// Hook para manejar el estado de ventana (normal, minimizado, maximizado)

import { useState, useCallback } from "react";

/**
 * Hook para manejar estados de ventana tipo escritorio
 * @returns {Object} Estado y funciones de control de ventana
 */
export const useEstadoVentana = () => {
   const [estadoVentana, setEstadoVentana] = useState("normal");
   const [posicion, setPosicion] = useState({ x: null, y: null });

   const handleMinimizar = useCallback(() => {
      setEstadoVentana((prev) => (prev === "minimizado" ? "normal" : "minimizado"));
   }, []);

   const handleMaximizar = useCallback(() => {
      setEstadoVentana((prev) => {
         if (prev === "maximizado") {
            return "normal";
         }
         setPosicion({ x: null, y: null });
         return "maximizado";
      });
   }, []);

   const resetearEstado = useCallback(() => {
      setEstadoVentana("normal");
      setPosicion({ x: null, y: null });
   }, []);

   const getModalClase = useCallback(
      (claseBase, arrastrando = false) => {
         let clase = claseBase;
         if (estadoVentana === "minimizado") clase += ` ${claseBase}--minimizado`;
         if (estadoVentana === "maximizado") clase += ` ${claseBase}--maximizado`;
         if (arrastrando) clase += ` ${claseBase}--arrastrando`;
         return clase;
      },
      [estadoVentana]
   );

   const getModalEstilo = useCallback(() => {
      if (estadoVentana === "maximizado") {
         return {
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            width: "100%",
            height: "100%",
         };
      }
      if (estadoVentana === "minimizado") {
         return { position: "fixed", bottom: "1rem", left: "1rem" };
      }
      if (posicion.x !== null && posicion.y !== null) {
         return { position: "fixed", top: posicion.y, left: posicion.x };
      }
      return {};
   }, [estadoVentana, posicion]);

   const getOverlayClase = useCallback(
      (claseBase) => {
         let clase = claseBase;
         if (estadoVentana === "minimizado") clase += ` ${claseBase}--minimizado`;
         if (estadoVentana === "maximizado") clase += ` ${claseBase}--maximizado`;
         return clase;
      },
      [estadoVentana]
   );

   return {
      estadoVentana,
      posicion,
      setPosicion,
      handleMinimizar,
      handleMaximizar,
      resetearEstado,
      getModalClase,
      getModalEstilo,
      getOverlayClase,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/index.js =====

// modales/permisos/index.js
// Modales de gesti√≥n de accesos y permisos

export { default as ModalGestionarAccesos } from "./ModalGestionarAccesos";
export { default as ModalPanelPermisos } from "./ModalPanelPermisos";

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/ModalGestionarAccesos.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalGestionarAccesos.jsx
// Modal para gestionar usuarios con acceso a un workspace

import React, { useState, useEffect } from "react";
import "../ModalConfiguracionAlimentador.css"; // estilos base del modal
import "./ModalGestionarAccesos.css";         // estilos espec√≠ficos
import {
  obtenerPermisosWorkspace,
  agregarPermisoWorkspace,
  actualizarPermisoWorkspace,
  eliminarPermisoWorkspace,
} from "../../../../../servicios/apiService";

/**
 * Modal para gestionar los accesos (permisos) de usuarios a un workspace.
 * Permite ver usuarios con acceso, invitar nuevos y cambiar/revocar roles.
 */
const ModalGestionarAccesos = ({
  abierto,
  onCerrar,
  workspaceId,
  workspaceNombre,
  usuarioActualId,
}) => {
  // Estado
  const [permisos, setPermisos] = useState([]);
  const [cargando, setCargando] = useState(false);
  const [error, setError] = useState(null);

  // Form de invitaci√≥n
  const [emailInvitar, setEmailInvitar] = useState("");
  const [rolInvitar, setRolInvitar] = useState("observador");
  const [invitando, setInvitando] = useState(false);
  const [errorInvitar, setErrorInvitar] = useState(null);
  const [exitoInvitar, setExitoInvitar] = useState(null);

  // Roles disponibles para asignar (no incluye superadmin)
  const rolesDisponibles = [
    { codigo: "observador", nombre: "Observador", descripcion: "Solo puede ver datos" },
    { codigo: "operador", nombre: "Operador", descripcion: "Puede operar mediciones" },
    { codigo: "admin", nombre: "Administrador", descripcion: "Puede gestionar el workspace" },
  ];

  // Cargar permisos al abrir
  useEffect(() => {
    if (abierto && workspaceId) {
      cargarPermisos();
    }
  }, [abierto, workspaceId]);

  // Limpiar estado al cerrar
  useEffect(() => {
    if (!abierto) {
      setEmailInvitar("");
      setRolInvitar("observador");
      setErrorInvitar(null);
      setExitoInvitar(null);
    }
  }, [abierto]);

  const cargarPermisos = async () => {
    try {
      setCargando(true);
      setError(null);
      const data = await obtenerPermisosWorkspace(workspaceId);
      setPermisos(data);
    } catch (err) {
      console.error("Error cargando permisos:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  };

  const handleInvitar = async (e) => {
    e.preventDefault();
    const email = emailInvitar.trim().toLowerCase();

    if (!email) {
      setErrorInvitar("Ingresa un email");
      return;
    }

    try {
      setInvitando(true);
      setErrorInvitar(null);
      setExitoInvitar(null);

      const nuevoPermiso = await agregarPermisoWorkspace(workspaceId, email, rolInvitar);

      // Agregar a la lista o actualizar si ya exist√≠a
      setPermisos(prev => {
        const existe = prev.find(p => p.usuario_id === nuevoPermiso.usuario_id);
        if (existe) {
          return prev.map(p => p.usuario_id === nuevoPermiso.usuario_id ? nuevoPermiso : p);
        }
        return [...prev, nuevoPermiso];
      });

      setEmailInvitar("");
      setExitoInvitar(`Usuario ${email} agregado correctamente`);

      // Limpiar mensaje de √©xito despu√©s de 3s
      setTimeout(() => setExitoInvitar(null), 3000);
    } catch (err) {
      console.error("Error invitando usuario:", err);
      setErrorInvitar(err.message);
    } finally {
      setInvitando(false);
    }
  };

  const handleCambiarRol = async (permisoId, nuevoRol) => {
    try {
      const actualizado = await actualizarPermisoWorkspace(permisoId, nuevoRol);
      setPermisos(prev => prev.map(p => p.id === permisoId ? actualizado : p));
    } catch (err) {
      console.error("Error actualizando rol:", err);
      setError(err.message);
    }
  };

  const handleEliminarAcceso = async (permisoId, nombreUsuario) => {
    if (!confirm(`¬øEliminar el acceso de ${nombreUsuario} a este workspace?`)) {
      return;
    }

    try {
      await eliminarPermisoWorkspace(permisoId);
      setPermisos(prev => prev.filter(p => p.id !== permisoId));
    } catch (err) {
      console.error("Error eliminando acceso:", err);
      setError(err.message);
    }
  };

  if (!abierto) return null;

  return (
    <div className="alim-modal-overlay">
      <div className="alim-modal modal-accesos">
        {/* Header */}
        <div className="modal-accesos__header">
          <h2>Permisos para Workspace: {workspaceNombre}</h2>
        </div>

        {/* Contenido */}
        <div className="modal-accesos__contenido">
          {/* Secci√≥n: Invitar usuario */}
          <div className="modal-accesos__seccion">
            <h3>Invitar Usuario</h3>
            <form className="modal-accesos__form-invitar" onSubmit={handleInvitar}>
              <input
                type="email"
                className="alim-modal-input"
                placeholder="Ingrese el email del usuario a invitar"
                value={emailInvitar}
                onChange={(e) => setEmailInvitar(e.target.value)}
                disabled={invitando}
              />
              <select
                className="alim-modal-select"
                value={rolInvitar}
                onChange={(e) => setRolInvitar(e.target.value)}
                disabled={invitando}
              >
                {rolesDisponibles.map(r => (
                  <option key={r.codigo} value={r.codigo}>
                    {r.nombre}
                  </option>
                ))}
              </select>
              <button
                type="submit"
                className="modal-accesos__btn-invitar"
                disabled={invitando || !emailInvitar.trim()}
              >
                {invitando ? "Invitando..." : "Invitar"}
              </button>
            </form>

            {errorInvitar && (
              <div className="modal-accesos__mensaje modal-accesos__mensaje--error">
                {errorInvitar}
              </div>
            )}
            {exitoInvitar && (
              <div className="modal-accesos__mensaje modal-accesos__mensaje--exito">
                {exitoInvitar}
              </div>
            )}
          </div>

          {/* Secci√≥n: Lista de usuarios */}
          <div className="modal-accesos__seccion">
            <h3>Usuarios con acceso</h3>

            {cargando ? (
              <div className="modal-accesos__cargando">Cargando...</div>
            ) : error ? (
              <div className="modal-accesos__error">
                Error: {error}
                <button onClick={cargarPermisos}>Reintentar</button>
              </div>
            ) : permisos.filter(p => p.usuario_id !== usuarioActualId).length === 0 ? (
              <div className="modal-accesos__vacio">
                No hay otros usuarios con acceso a este workspace.
              </div>
            ) : (
              <ul className="modal-accesos__lista">
                {permisos.filter(p => p.usuario_id !== usuarioActualId).map(permiso => (
                  <li key={permiso.id} className="modal-accesos__usuario">
                    <div className="modal-accesos__usuario-info">
                      <span className="modal-accesos__usuario-icono">üë§</span>
                      <div className="modal-accesos__usuario-datos">
                        <span className="modal-accesos__usuario-nombre">
                          {permiso.usuarios?.nombre || "Sin nombre"}
                        </span>
                        <span className="modal-accesos__usuario-email">
                          {permiso.usuarios?.email}
                        </span>
                      </div>
                    </div>

                    <div className="modal-accesos__usuario-acciones">
                      <select
                        className="modal-accesos__select-rol"
                        value={permiso.rol}
                        onChange={(e) => handleCambiarRol(permiso.id, e.target.value)}
                      >
                        {rolesDisponibles.map(r => (
                          <option key={r.codigo} value={r.codigo}>
                            {r.nombre}
                          </option>
                        ))}
                      </select>
                      <button
                        type="button"
                        className="modal-accesos__btn-eliminar"
                        onClick={() => handleEliminarAcceso(
                          permiso.id,
                          permiso.usuarios?.nombre || permiso.usuarios?.email
                        )}
                        title="Eliminar acceso"
                      >
                        ‚úï
                      </button>
                    </div>
                  </li>
                ))}
              </ul>
            )}
          </div>
        </div>

        {/* Footer */}
        <div className="modal-accesos__footer">
          <button
            type="button"
            className="alim-modal-btn alim-modal-btn-secondary"
            onClick={onCerrar}
          >
            Cerrar
          </button>
        </div>
      </div>
    </div>
  );
};

export default ModalGestionarAccesos;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/permisos/ModalPanelPermisos.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/permisos/ModalPanelPermisos.jsx
// Modal para gestionar permisos de usuarios y acceso a agentes (solo superadmin)

import React, { useRef, useEffect } from "react";
import "./ModalPanelPermisos.css";

import { useEstadoVentana, useArrastrarModal, useDatosPermisos, useEdicionPermisos } from "./hooks";
import { ListaUsuarios, PanelDetalles } from "./componentes";

/**
 * Modal para gestionar los permisos de usuarios y su acceso a agentes.
 * Solo visible para superadmins.
 * Dise√±o: Master-detail (lista usuarios izquierda + detalles derecha)
 */
const ModalPanelPermisos = ({ abierto, onCerrar }) => {
   const modalRef = useRef(null);

   // Hook de estado de ventana
   const {
      estadoVentana,
      posicion,
      setPosicion,
      handleMinimizar,
      handleMaximizar,
      resetearEstado,
      getModalClase,
      getModalEstilo,
      getOverlayClase,
   } = useEstadoVentana();

   // Hook de arrastre
   const { arrastrando, handleMouseDownDrag } = useArrastrarModal({
      estadoVentana,
      posicion,
      setPosicion,
      modalRef,
   });

   // Hook de datos
   const {
      usuarios,
      usuariosFiltrados,
      agentesDisponibles,
      cargando,
      error,
      busqueda,
      filtroRol,
      usuarioSeleccionado,
      detallesUsuario,
      cargandoDetalles,
      errorDetalles,
      setBusqueda,
      setFiltroRol,
      cargarDatos,
      seleccionarUsuario,
      recargarDetallesUsuario,
      limpiarEstado,
   } = useDatosPermisos(abierto);

   // Hook de edici√≥n
   const edicionHook = useEdicionPermisos({
      usuarioSeleccionado,
      cargarDatos,
      recargarDetallesUsuario,
   });

   // Limpiar estado al cerrar
   useEffect(() => {
      if (!abierto) {
         limpiarEstado();
         edicionHook.resetearEdicion();
         resetearEstado();
      }
   }, [abierto, limpiarEstado, edicionHook.resetearEdicion, resetearEstado]);

   // Resetear edici√≥n al cambiar de usuario
   const handleSeleccionarUsuario = (usuario) => {
      edicionHook.resetearEdicion();
      seleccionarUsuario(usuario);
   };

   if (!abierto) return null;

   // Props para el formulario de edici√≥n
   const edicionProps = {
      cambiosPendientes: edicionHook.cambiosPendientes,
      rolesDisponibles: edicionHook.rolesDisponibles,
      agentesDisponibles,
      guardando: edicionHook.guardando,
      tieneModificaciones: edicionHook.tieneModificaciones(),
      onCambioRol: edicionHook.handleCambioRol,
      onToggleAccesoTotal: edicionHook.handleToggleAccesoTotal,
      onToggleAgente: edicionHook.handleToggleAgente,
      onGuardar: edicionHook.handleGuardarUsuario,
      onCancelar: edicionHook.handleCancelarEdicion,
      iniciarEdicion: edicionHook.iniciarEdicion,
   };

   return (
      <div className={getOverlayClase("permisos-overlay")}>
         <div
            ref={modalRef}
            className={getModalClase("permisos-modal", arrastrando)}
            style={getModalEstilo()}
            onClick={(e) => e.stopPropagation()}
         >
            {/* Header */}
            <div
               className="permisos-header"
               onMouseDown={handleMouseDownDrag}
               onDoubleClick={handleMaximizar}
               style={{ cursor: estadoVentana === "maximizado" ? "default" : "move" }}
            >
               <div className="permisos-titulo">
                  <span className="permisos-icono">üîê</span>
                  <span className="permisos-nombre">Panel de Permisos</span>
               </div>
               <div className="permisos-controles">
                  <button
                     type="button"
                     className="permisos-btn-control"
                     onClick={handleMinimizar}
                     title={estadoVentana === "minimizado" ? "Restaurar" : "Minimizar"}
                  >
                     {estadoVentana === "minimizado" ? "üóó" : "‚Äî"}
                  </button>
                  <button
                     type="button"
                     className="permisos-btn-control"
                     onClick={handleMaximizar}
                     title={estadoVentana === "maximizado" ? "Restaurar" : "Maximizar"}
                  >
                     {estadoVentana === "maximizado" ? "üóó" : "‚òê"}
                  </button>
                  <button
                     type="button"
                     className="permisos-btn-cerrar"
                     onClick={onCerrar}
                     title="Cerrar"
                  >
                     ‚úï
                  </button>
               </div>
            </div>

            {/* Contenido principal - Master Detail */}
            <div className="permisos-content">
               {/* Panel izquierdo - Lista de usuarios */}
               <ListaUsuarios
                  usuarios={usuarios}
                  usuariosFiltrados={usuariosFiltrados}
                  cargando={cargando}
                  error={error}
                  busqueda={busqueda}
                  filtroRol={filtroRol}
                  usuarioSeleccionado={usuarioSeleccionado}
                  onBusquedaChange={setBusqueda}
                  onFiltroRolChange={setFiltroRol}
                  onSeleccionarUsuario={handleSeleccionarUsuario}
                  onRecargar={cargarDatos}
               />

               {/* Panel derecho - Detalles */}
               <div className="permisos-detail">
                  <PanelDetalles
                     usuarioSeleccionado={usuarioSeleccionado}
                     cargandoDetalles={cargandoDetalles}
                     errorDetalles={errorDetalles}
                     detallesUsuario={detallesUsuario}
                     modoEdicion={edicionHook.modoEdicion}
                     edicionProps={edicionProps}
                  />
               </div>
            </div>
         </div>
      </div>
   );
};

export default ModalPanelPermisos;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/puesto/index.js =====

// modales/puesto/index.js
// Modales relacionados con puestos

export { default as ModalNuevoPuesto } from "./ModalNuevoPuesto";
export { default as ModalEditarPuestos } from "./ModalEditarPuestos";
export { default as ModalConfiguracionPuesto } from "./ModalConfiguracionPuesto";

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/puesto/ModalConfiguracionPuesto.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalConfiguracionPuesto.jsx

import React, { useEffect, useState, useRef } from "react";
import "./ModalConfiguracionPuesto.css";

/**
 * Modal de vista r√°pida del puesto.
 * Muestra el estado de cada alimentador con sus registradores asignados (solo lectura).
 * Permite controlar el polling de cada card y de todo el puesto.
 */
const ModalConfiguracionPuesto = ({
	abierto,
	puesto,
	onCerrar,
	// Polling
	estaPolling,              // (alimId) => boolean
	onPlayStopClick,          // (alimId) => void - alterna polling de un alimentador
	// Para obtener nombres de registradores
	buscarRegistrador,        // (regId) => registrador | null
}) => {
	// Estado para arrastrar el modal
	const [posicion, setPosicion] = useState({ x: 0, y: 0 });
	const [arrastrando, setArrastrando] = useState(false);
	const offsetRef = useRef({ x: 0, y: 0 });
	const modalRef = useRef(null);

	// Resetear posici√≥n al abrir el modal
	useEffect(() => {
		if (abierto) {
			setPosicion({ x: 0, y: 0 });
		}
	}, [abierto]);

	// Manejadores de arrastre
	const handleMouseDown = (e) => {
		if (e.target.closest('.puesto-modal__close') || e.target.closest('input') || e.target.closest('button')) {
			return;
		}
		setArrastrando(true);
		offsetRef.current = {
			x: e.clientX - posicion.x,
			y: e.clientY - posicion.y,
		};
	};

	const handleMouseMove = (e) => {
		if (!arrastrando) return;
		setPosicion({
			x: e.clientX - offsetRef.current.x,
			y: e.clientY - offsetRef.current.y,
		});
	};

	const handleMouseUp = () => {
		setArrastrando(false);
	};

	useEffect(() => {
		if (arrastrando) {
			window.addEventListener('mousemove', handleMouseMove);
			window.addEventListener('mouseup', handleMouseUp);
		}
		return () => {
			window.removeEventListener('mousemove', handleMouseMove);
			window.removeEventListener('mouseup', handleMouseUp);
		};
	}, [arrastrando]);

	// Helper para obtener registrador_id de una zona (con compatibilidad legacy)
	const obtenerRegistradorIdZona = (alim, zona) => {
		// Primero intentar obtener de card_design
		const regIdZona = alim.card_design?.[zona]?.registrador_id;
		if (regIdZona) return regIdZona;

		// Fallback: usar registrador_id de la ra√≠z (formato legacy)
		return alim.registrador_id || null;
	};

	if (!abierto || !puesto) return null;

	const alimentadores = puesto.alimentadores || [];

	// Helper para verificar si un alimentador puede hacer polling
	const puedeHacerPolling = (alim) => {
		if (!alim.intervalo_consulta_ms || alim.intervalo_consulta_ms <= 0) return false;

		const cardDesign = alim.card_design || {};
		const superior = cardDesign.superior || {};
		const inferior = cardDesign.inferior || {};

		const tieneRegistrador = !!superior.registrador_id || !!inferior.registrador_id || !!alim.registrador_id;
		if (!tieneRegistrador) return false;

		// Verificar que al menos un box est√© habilitado con √≠ndice v√°lido
		const boxesSuperior = superior.boxes || [];
		const boxesInferior = inferior.boxes || [];
		const todosLosBoxes = [...boxesSuperior, ...boxesInferior];

		const tieneBoxHabilitado = todosLosBoxes.some(
			(box) => box.enabled && box.indice !== null && box.indice !== undefined && box.indice !== ""
		);

		return tieneBoxHabilitado;
	};

	// Obtener nombre del registrador para mostrar
	const obtenerInfoRegistrador = (alim, zona) => {
		const regId = obtenerRegistradorIdZona(alim, zona);
		if (!regId || !buscarRegistrador) return "Sin asignar";
		const reg = buscarRegistrador(regId);
		if (!reg) return "Sin asignar";

		// Solo mostrar el nombre del registrador
		return reg.nombre;
	};

	// ===== BOT√ìN MAESTRO GLOBAL =====
	const alimentadoresConPolling = alimentadores.filter(puedeHacerPolling);
	const hayAlgunoPolling = alimentadoresConPolling.some((alim) => estaPolling?.(alim.id));
	const hayAlgunaCardDisponible = alimentadoresConPolling.length > 0;

	const handleMaestroGlobal = () => {
		if (!hayAlgunaCardDisponible) return;

		if (hayAlgunoPolling) {
			// Detener todos los que est√°n en polling
			alimentadoresConPolling.forEach((alim) => {
				if (estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		} else {
			// Iniciar todos los disponibles
			alimentadoresConPolling.forEach((alim) => {
				if (!estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		}
	};

	return (
		<div className="puesto-modal-overlay">
			<div
				ref={modalRef}
				className={`puesto-modal ${arrastrando ? 'puesto-modal--arrastrando' : ''}`}
				style={{
					transform: `translate(${posicion.x}px, ${posicion.y}px)`,
				}}
				onClick={(e) => e.stopPropagation()}
			>
				{/* Header */}
				<div
					className="puesto-modal__header"
					onMouseDown={handleMouseDown}
					style={{ cursor: 'move' }}
				>
					<h2 className="puesto-modal__title">
						Configuraci√≥n del Puesto: {puesto?.nombre || ""}
					</h2>
					<div className="puesto-modal__header-actions">
						{/* Bot√≥n maestro global */}
						<button
							type="button"
							className={`puesto-card__master-btn ${hayAlgunoPolling ? "puesto-card__master-btn--stop" : ""} ${!hayAlgunaCardDisponible ? "puesto-card__master-btn--disabled" : ""}`}
							onClick={handleMaestroGlobal}
							disabled={!hayAlgunaCardDisponible}
							title={!hayAlgunaCardDisponible ? "Sin alimentadores con configuraci√≥n v√°lida" : hayAlgunoPolling ? "Detener todas las lecturas" : "Iniciar todas las lecturas"}
						>
							{!hayAlgunaCardDisponible ? "‚äò" : hayAlgunoPolling ? "‚èπ" : "‚ñ∂"}
						</button>
						<button
							type="button"
							className="puesto-modal__close"
							onClick={onCerrar}
							aria-label="Cerrar"
						>
							√ó
						</button>
					</div>
				</div>

				{/* Contenido */}
				<div
					className="puesto-modal__content"
					style={{ backgroundColor: puesto?.bgColor || "#1e293b" }}
				>
					{alimentadores.length === 0 ? (
						<p className="puesto-modal__empty">
							No hay alimentadores en este puesto.
						</p>
					) : (
						<div className="puesto-cards">
							{alimentadores.map((alim) => {
								const periodoSeg = alim.intervalo_consulta_ms
									? Math.round(alim.intervalo_consulta_ms / 1000)
									: null;
								const puedePolling = puedeHacerPolling(alim);
								const polling = estaPolling?.(alim.id);

								return (
									<div
										key={alim.id}
										className="puesto-card"
										style={{
											borderLeftColor: alim.color || "#22c55e",
											borderBottomColor: alim.color || "#22c55e",
										}}
									>
										{/* Header de la card: Nombre + Play + Per√≠odo */}
										<div className="puesto-card__header">
											<span className="puesto-card__nombre">{alim.nombre}</span>
											<div className="puesto-card__header-right">
												<button
													type="button"
													className={`puesto-card__play-btn ${polling ? "puesto-card__play-btn--stop" : ""} ${!puedePolling ? "puesto-card__play-btn--disabled" : ""}`}
													onClick={() => puedePolling && onPlayStopClick?.(alim.id)}
													disabled={!puedePolling}
													title={!puedePolling ? "Configuraci√≥n incompleta" : polling ? "Detener lectura" : "Iniciar lectura"}
												>
													{!puedePolling ? "‚äò" : polling ? "‚èπ" : "‚ñ∂"}
												</button>
												<span className="puesto-card__periodo-badge">
													{periodoSeg ? `${periodoSeg}s` : "-"}
												</span>
											</div>
										</div>

										{/* Contenido: Superior e Inferior lado a lado */}
										<div className="puesto-card__body">
											<div className="puesto-card__zonas">
												{/* Zona Superior */}
												<div className="puesto-card__zona">
													<span className="puesto-card__tipo-badge puesto-card__tipo-badge--superior">
														Superior
													</span>
													<span className="puesto-card__registrador" title={obtenerInfoRegistrador(alim, "superior")}>
														{obtenerInfoRegistrador(alim, "superior")}
													</span>
												</div>

												{/* Zona Inferior */}
												<div className="puesto-card__zona">
													<span className="puesto-card__tipo-badge puesto-card__tipo-badge--inferior">
														Inferior
													</span>
													<span className="puesto-card__registrador" title={obtenerInfoRegistrador(alim, "inferior")}>
														{obtenerInfoRegistrador(alim, "inferior")}
													</span>
												</div>
											</div>
										</div>
									</div>
								);
							})}
						</div>
					)}
				</div>

				{/* Footer */}
				<div className="puesto-modal__footer">
					<button
						type="button"
						className="puesto-modal__btn puesto-modal__btn--cerrar"
						onClick={onCerrar}
					>
						Cerrar
					</button>
				</div>
			</div>
		</div>
	);
};

export default ModalConfiguracionPuesto;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/puesto/ModalEditarPuestos.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalEditarPuestos.jsx

import React, { useState, useEffect } from "react";
import "./ModalEditarPuestos.css";
import { ColorPickerSimple, TabApariencia } from "../comunes";
import { ESCALA_MIN, ESCALA_MAX } from "../../../constantes/escalas";

// Componente interno para el input de escala con estado local
const InputEscala = ({ valor, onChange, min, max }) => {
	const [valorLocal, setValorLocal] = useState(valor?.toString() ?? "1");

	// Sincronizar cuando cambia el valor externo
	useEffect(() => {
		setValorLocal(valor?.toString() ?? "1");
	}, [valor]);

	const aplicarCambio = () => {
		const valorNum = parseFloat(valorLocal);
		if (!isNaN(valorNum)) {
			const valorClamped = Math.max(min, Math.min(max, valorNum));
			onChange(valorClamped);
			setValorLocal(valorClamped.toString());
		} else {
			// Si no es v√°lido, restaurar al valor original
			setValorLocal(valor?.toString() ?? "1");
		}
	};

	const handleKeyDown = (e) => {
		if (e.key === "Enter") {
			aplicarCambio();
			e.target.blur();
		}
	};

	return (
		<input
			type="number"
			step="0.1"
			min={min}
			max={max}
			value={valorLocal}
			onChange={(e) => setValorLocal(e.target.value)}
			onBlur={aplicarCambio}
			onKeyDown={handleKeyDown}
			className="editar-escala-input"
		/>
	);
};

const ModalEditarPuestos = ({
	abierto,                                              // si es false, el modal no se renderiza
	puestos,                                              // lista original de puestos proveniente del contexto
	onCerrar,                                             // callback para cerrar sin guardar
	onGuardar,                                            // callback que recibe los puestos modificados
	esCreador,                                            // si el usuario es creador del workspace
	rolEnWorkspace,                                       // rol del usuario en el workspace (admin, operador, observador)
	// Props de escala por puesto
	obtenerEscalaPuesto,
	onEscalaPuestoChange,
	// Props de estilos globales (para pesta√±a Apariencia)
	estilosGlobales,                                      // objeto con estilos actuales
	onGuardarEstilos,                                     // callback para guardar todos los estilos
}) => {
	const [puestosEditados, setPuestosEditados] = useState([]); // copia editable local
	const [tabActiva, setTabActiva] = useState("puestos");      // "puestos" o "apariencia"

	// Solo el creador o admin en el workspace pueden editar nombres y eliminar puestos
	// Operador y observador solo pueden cambiar colores y escala (son preferencias de usuario)
	const puedeEditarNombre = esCreador || rolEnWorkspace === 'admin';

	useEffect(() => {
		if (abierto) {
			// cuando se abre, clono el array de puestos para no mutar el original
			setPuestosEditados(puestos.map((p) => ({ ...p })));
		}
	}, [abierto, puestos]);

	const handleSubmit = () => {
		onGuardar(puestosEditados);                       // devuelvo al caller la versi√≥n editada
	};

	const cambiarNombre = (id, nombreNuevo) => {
		// recorro el array y s√≥lo modifico el puesto que coincide por id
		setPuestosEditados((prev) =>
			prev.map((p) => (p.id === id ? { ...p, nombre: nombreNuevo } : p))
		);
	};

	const cambiarColorBoton = (id, colorNuevo) => {
		setPuestosEditados((prev) =>
			prev.map((p) => (p.id === id ? { ...p, color: colorNuevo } : p))
		);
	};

	const cambiarColorFondo = (id, colorNuevo) => {
		setPuestosEditados((prev) =>
			prev.map((p) => (p.id === id ? { ...p, bgColor: colorNuevo } : p))
		);
	};

	const eliminar = (id) => {
		// filtro el puesto con ese id para "borrarlo" de la lista local
		setPuestosEditados((prev) => prev.filter((p) => p.id !== id));
	};

	if (!abierto) return null;                            // si no est√° abierto, no dibujo nada

	// Clase condicional para hacer el modal m√°s ancho en la pesta√±a de Apariencia
	const clasesContenedor = `editar-contenedor${tabActiva === "apariencia" ? " editar-contenedor--apariencia" : ""}`;

	return (
		<div className="editar-fondo-oscuro">
			<div className={clasesContenedor}>
				<h2>Configuraci√≥n</h2>

				{/* Sistema de tabs */}
				<div className="editar-tabs">
					<button
						type="button"
						className={`editar-tab ${tabActiva === "puestos" ? "editar-tab--activo" : ""}`}
						onClick={() => setTabActiva("puestos")}
					>
						Puestos
					</button>
					<button
						type="button"
						className={`editar-tab ${tabActiva === "apariencia" ? "editar-tab--activo" : ""}`}
						onClick={() => setTabActiva("apariencia")}
					>
						Apariencia
					</button>
				</div>

				{/* Contenido de la tab activa */}
				{tabActiva === "puestos" ? (
					<div className="editar-lista">
						{puestosEditados.map((p) => (
							<div key={p.id} className="editar-fila">
								<input
									type="text"
									className="editar-nombre"
									value={p.nombre}
									onChange={(e) => cambiarNombre(p.id, e.target.value)} // actualiza nombre en la copia local
									disabled={!puedeEditarNombre}                         // solo admin/superadmin pueden editar nombre
								/>

								<div className="editar-controles">
									<ColorPickerSimple
										color={p.color || "#22c55e"}
										onChange={(newColor) => cambiarColorBoton(p.id, newColor)}
										label="Bot√≥n"
									/>

									<ColorPickerSimple
										color={p.bgColor || "#e5e7eb"}
										onChange={(newColor) => cambiarColorFondo(p.id, newColor)}
										label="Fondo"
									/>

									{/* Control de escala por puesto */}
									{obtenerEscalaPuesto && onEscalaPuestoChange && (
										<div className="editar-escala">
											<label className="editar-escala-label">(0.5 - 2)</label>
											<InputEscala
												valor={obtenerEscalaPuesto(p.id) ?? 1.0}
												onChange={(nuevoValor) => onEscalaPuestoChange(p.id, nuevoValor)}
												min={ESCALA_MIN}
												max={ESCALA_MAX}
											/>
										</div>
									)}

									{/* Solo admin/superadmin pueden eliminar puestos */}
									{puedeEditarNombre && (
										<button
											type="button"
											className="editar-eliminar"
											onClick={() => eliminar(p.id)}             // elimina el puesto de la lista local
										>
											Eliminar
										</button>
									)}
								</div>
							</div>
						))}
					</div>
				) : (
					/* Pesta√±a de Apariencia - tiene su propio footer con botones */
					estilosGlobales && (
						<TabApariencia
							estilosIniciales={estilosGlobales}
							onGuardar={(nuevosEstilos) => {
								onGuardarEstilos(nuevosEstilos);
								onCerrar();
							}}
							onCancelar={onCerrar}
						/>
					)
				)}

				{/* Solo mostrar botones para la pesta√±a de Puestos */}
				{tabActiva === "puestos" && (
					<div className="editar-acciones">
						<button
							type="button"
							className="editar-boton editar-cancelar"
							onClick={onCerrar}
						>
							Cancelar
						</button>
						<button
							type="button"
							className="editar-boton editar-guardar"
							onClick={handleSubmit}
						>
							Guardar
						</button>
					</div>
				)}
			</div>
		</div>
	);
};

export default ModalEditarPuestos;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (ModalEditarPuestos.jsx)

 - Este modal funciona como un "panel de edici√≥n masiva" para todos los puestos:
   permite renombrarlos, cambiar el color del bot√≥n y el color de fondo, o
   directamente eliminarlos.

 - Al abrirse (`abierto === true`), clona el array `puestos` en `puestosEditados`
   para trabajar siempre sobre una copia local y no mutar el estado global
   del contexto hasta que realmente aprieto "Guardar".

 - Cada helper (`cambiarNombre`, `cambiarColorBoton`, `cambiarColorFondo`,
   `eliminar`) modifica s√≥lo el puesto indicado buscando por `id` y usando
   funciones de actualizaci√≥n inmutables (`map` / `filter`).

 - Al confirmar, `handleSubmit` llama a `onGuardar(puestosEditados)` y el
   componente padre decide c√≥mo persistir esos cambios (por ejemplo, usando
   `usarPuestos` y guardando en localStorage).

 - Si alguna vez quiero agregar m√°s propiedades editables (por ejemplo, un
   "orden" o una descripci√≥n), basta con extender el objeto `p` y agregar
   los campos en esta lista, manteniendo el mismo patr√≥n de edici√≥n local.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (ModalEditarPuestos.jsx)

0) Visi√≥n general del componente

   `ModalEditarPuestos` es un panel de edici√≥n masiva de puestos. Permite:

   - Cambiar el nombre de cada puesto.
   - Cambiar el color del bot√≥n del puesto (color principal).
   - Cambiar el color de fondo asociado a ese puesto.
   - Eliminar puestos completos de la lista.

   La gracia es que todo se hace sobre una copia local (`puestosEditados`) y
   reci√©n cuando el usuario pulsa ‚ÄúGuardar‚Äù se env√≠an los cambios al exterior.


1) Props del componente

   const ModalEditarPuestos = ({
     abierto,
     puestos,
     onCerrar,
     onGuardar,
   }) => { ... }

   - `abierto` (boolean):
       ‚Ä¢ Si es false    ‚Üí el modal no se renderiza (devuelve `null`).
       ‚Ä¢ Si es true     ‚Üí se dibuja overlay + contenido del modal.

   - `puestos` (array):
       ‚Ä¢ Lista de puestos que viene del contexto/global.
       ‚Ä¢ Cada elemento suele ser algo como:
         { id, nombre, color, bgColor, ... }.

   - `onCerrar()`:
       ‚Ä¢ Se llama al pulsar ‚ÄúCancelar‚Äù o cuando se quiera cerrar sin guardar.

   - `onGuardar(puestosEditados)`:
       ‚Ä¢ Recibe la versi√≥n editada de la lista de puestos,
       ‚Ä¢ El padre (VistaAlimentadores / usarPuestos) decide c√≥mo persistirla
         (estado global, localStorage, etc.).


2) Estado local y sincronizaci√≥n al abrir

   const [puestosEditados, setPuestosEditados] = useState([]);

   - `puestosEditados` es una copia editable de `puestos`:
       ‚Ä¢ Esto evita modificar directamente el array original del contexto.
       ‚Ä¢ Permite descartar cambios f√°cilmente si el usuario cancela.

   useEffect(() => {
     if (abierto) {
       setPuestosEditados(puestos.map((p) => ({ ...p })));
     }
   }, [abierto, puestos]);

   - Cuando el modal se abre (`abierto` pasa a true):

       1) Se recorre `puestos` y se crea un nuevo array con copias
          superficiales de cada puesto (`{ ...p }`).
       2) Se guarda en `puestosEditados`.

   - De esta forma:
       ‚Ä¢ el usuario siempre edita la versi√≥n m√°s actual de la lista,
       ‚Ä¢ y no hay riesgo de mutar accidentalmente el array original.


3) Handlers de actualizaci√≥n

   3.1) handleSubmit

   const handleSubmit = () => {
     onGuardar(puestosEditados);
   };

   - Se ejecuta al pulsar el bot√≥n ‚ÄúGuardar‚Äù.
   - Entrega la lista `puestosEditados` al exterior.
   - A partir de ah√≠, el componente padre decide:
       ‚Ä¢ actualizar el contexto (`actualizarPuestos`),
       ‚Ä¢ cerrar el modal,
       ‚Ä¢ y persistir si hace falta.

   3.2) cambiarNombre(id, nombreNuevo)

   - Busca el puesto con ese `id` y actualiza solo su `nombre`:

       setPuestosEditados((prev) =>
         prev.map((p) => p.id === id ? { ...p, nombre: nombreNuevo } : p)
       );

   - Se apoya en:
       ‚Ä¢ `map` ‚Üí devuelve un nuevo array,
       ‚Ä¢ spread `{ ...p, nombre: nombreNuevo }` ‚Üí respeta inmutabilidad.

   3.3) cambiarColorBoton(id, colorNuevo)

   - Mismo patr√≥n que `cambiarNombre`, pero actualizando `color`.

   3.4) cambiarColorFondo(id, colorNuevo)

   - Mismo patr√≥n, pero actualizando `bgColor`, que es el color de fondo
     del puesto (usado luego en el `<main>` de VistaAlimentadores).

   3.5) eliminar(id)

   - Elimina el puesto con ese `id` de la copia local:

       setPuestosEditados((prev) => prev.filter((p) => p.id !== id));

   - Solo afecta al listado interno del modal; el estado global no se toca
     hasta que se pulsa ‚ÄúGuardar‚Äù.


4) L√≥gica de renderizado condicional

   if (!abierto) return null;

   - Si el modal no est√° abierto, no se renderiza nada.
   - Esto ahorra trabajo de React y evita que el overlay interfiera con la UI.


5) Estructura JSX del modal

   5.1) Overlay y contenedor

   - `<div className="alim-modal-overlay">`:
       ‚Ä¢ fondo semitransparente que oscurece la pantalla.

   - `<div className="alim-modal">`:
       ‚Ä¢ caja blanca centrada donde vive el contenido del modal.

   5.2) Lista editable de puestos

   {puestosEditados.map((p) => (
     <div key={p.id} className="alim-edit-row">
       <input ... value={p.nombre} onChange={(e) => cambiarNombre(...)} />
       ...
       <input type="color" ... value={p.color} onChange={...} />
       <input type="color" ... value={p.bgColor || "#e5e7eb"} onChange={...} />
       <button onClick={() => eliminar(p.id)}>Eliminar</button>
     </div>
   ))}

   - Por cada puesto se dibuja una fila con:

       ‚Ä¢ Input de texto para el nombre:
           - enlazado a `p.nombre`,
           - cualquier cambio llama a `cambiarNombre`.

       ‚Ä¢ Dos ‚Äúpickers‚Äù de color:
           - uno para el color del bot√≥n (`p.color`),
           - otro para el color de fondo (`p.bgColor` o gris claro por defecto).
           - ambos actualizan la copia local por medio de sus handlers.

       ‚Ä¢ Bot√≥n ‚ÄúEliminar‚Äù:
           - quita el puesto de `puestosEditados`.
           - la eliminaci√≥n real se consolida solo si se pulsa ‚ÄúGuardar‚Äù.

   5.3) Botones de acci√≥n

   - Bot√≥n ‚ÄúCancelar‚Äù:
       ‚Ä¢ type="button",
       ‚Ä¢ llama a `onCerrar`,
       ‚Ä¢ descarta cualquier cambio hecho desde que se abri√≥ el modal.

   - Bot√≥n ‚ÄúGuardar‚Äù:
       ‚Ä¢ type="button",
       ‚Ä¢ llama a `handleSubmit`,
       ‚Ä¢ env√≠a `puestosEditados` al padre para que los persista.

---------------------------------------------------------------------------*/
// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/puesto/ModalNuevoPuesto.jsx =====

// src/paginas/PaginaAlimentadores/componentes/modales/ModalNuevoPuesto.jsx

import React, { useState } from "react";
import "../ModalConfiguracionAlimentador.css"; // estilos base del modal
import "./ModalNuevoPuesto.css";
import { ColorPickerSimple } from "../comunes";

/**
 * Modal para crear un nuevo puesto.
 * Permite ingresar nombre y seleccionar color.
 */
const ModalNuevoPuesto = ({
	abierto,                                   // boolean: controla si el modal se muestra
	onCerrar,                                  // callback para cerrar sin crear
	onCrear,                                   // callback que recibe (nombre, color)
	coloresSistema,                            // array de colores disponibles
}) => {
	const [nombrePuesto, setNombrePuesto] = useState("");
	const [colorPuesto, setColorPuesto] = useState(coloresSistema[0]);

	const handleSubmit = (e) => {
		e.preventDefault();
		const nombre = nombrePuesto.trim();
		if (!nombre) return;

		onCrear(nombre, colorPuesto);

		// Limpiar (el cierre lo maneja el padre)
		setNombrePuesto("");
		setColorPuesto(coloresSistema[0]);
	};

	const handleCerrar = () => {
		setNombrePuesto("");
		setColorPuesto(coloresSistema[0]);
		onCerrar();
	};

	if (!abierto) return null;

	return (
		<div className="alim-modal-overlay">
			<div className="alim-modal alim-modal-sm">
				<h2>Nuevo Puesto</h2>
				<form onSubmit={handleSubmit}>
					<div className="nuevo-puesto-contenedor">
						<label className="alim-modal-label">
							Nombre del Puesto
							<input
								type="text"
								className="alim-modal-input"
								value={nombrePuesto}
								onChange={(e) => setNombrePuesto(e.target.value)}
								placeholder="Ej: PUESTO 1"
								autoFocus
							/>
						</label>

						<div className="nuevo-puesto-color-section">
							{/* Grid de colores predefinidos */}
							<div className="nuevo-puesto-color-grid">
								{coloresSistema.slice(0, 8).map((c) => (
									<button
										key={c}
										type="button"
										className={`nuevo-puesto-color-swatch ${
											colorPuesto === c ? "nuevo-puesto-color-swatch--selected" : ""
										}`}
										style={{ backgroundColor: c }}
										onClick={() => setColorPuesto(c)}
										aria-label={`Elegir color ${c}`}
									/>
								))}
								{/* Picker personalizado (c√≠rculo multicolor) */}
								<ColorPickerSimple
									color={colorPuesto}
									onChange={setColorPuesto}
									label=""
								/>
							</div>

							{/* Preview del color seleccionado */}
							<div
								className="nuevo-puesto-color-preview"
								style={{ backgroundColor: colorPuesto }}
								title={colorPuesto}
							>
								<span className="nuevo-puesto-color-preview-text">COLOR</span>
							</div>
						</div>
					</div>

					<div className="alim-modal-actions">
						<button
							type="button"
							className="alim-modal-btn alim-modal-btn-cancelar"
							onClick={handleCerrar}
						>
							Cancelar
						</button>
						<button
							type="submit"
							className="alim-modal-btn alim-modal-btn-guardar"
						>
							Crear
						</button>
					</div>
				</form>
			</div>
		</div>
	);
};

export default ModalNuevoPuesto;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/rele/ConfiguracionRele.jsx =====

import React, { useState, useEffect, useRef } from "react";
import { usePlantillasRele, useConfigRele } from "../../../hooks/rele";
import { useTransformadores } from "../../../hooks/mediciones";
import { useConsolaTest } from "../../../hooks/agentes";
import {
   interpretarRegistro,
   categoriaRequiereInterpretacion,
   obtenerClaseTipo
} from "../../../utilidades/interpreteRegistrosREF615";
import ModalPlantillasRele from "./ModalPlantillasRele";
import ModalTransformadores from "./ModalTransformadores";
import "./ConfiguracionRele.css";

// Categor√≠as disponibles para las funcionalidades
const CATEGORIAS = {
   mediciones: { id: "mediciones", nombre: "Mediciones", icono: "üìä" },
   estados: { id: "estados", nombre: "Estados y Alarmas", icono: "üö¶" },
   sistema: { id: "sistema", nombre: "Sistema", icono: "‚öôÔ∏è" },
};

/**
 * Componente para configurar un registrador de tipo Rel√© de Protecci√≥n.
 */
const ConfiguracionRele = ({ configuracionInicial, onChange, agenteId }) => {
   // Hooks de datos
   const {
      plantillas,
      cargando: cargandoPlantillas,
      crearPlantilla,
      actualizarPlantilla,
      eliminarPlantilla,
      obtenerPlantilla,
   } = usePlantillasRele();

   const {
      transformadores,
      obtenerTIs,
      obtenerTVs,
      obtenerRelaciones,
      obtenerPorId: obtenerTransformadorPorId,
      crearTransformador,
      actualizarTransformador,
      eliminarTransformador,
   } = useTransformadores();

   // Hook de configuraci√≥n
   const configHook = useConfigRele({
      configuracionInicial,
      onChange,
      obtenerPlantilla,
   });

   // Hook de consola
   const consolaHook = useConsolaTest({
      config: configHook.config,
      agenteId,
   });

   // Estado de modales
   const [modalPlantillasAbierto, setModalPlantillasAbierto] = useState(false);
   const [plantillaParaEditar, setPlantillaParaEditar] = useState(null);
   const [modalTransformadoresAbierto, setModalTransformadoresAbierto] = useState(false);
   const [tipoTransformadorModal, setTipoTransformadorModal] = useState("TI");

   // Estado del dropdown de transformadores
   const [dropdownTransformadoresAbierto, setDropdownTransformadoresAbierto] = useState(false);
   const dropdownTransformadoresRef = useRef(null);

   // Cerrar dropdown al hacer click fuera
   useEffect(() => {
      const handleClickOutside = (event) => {
         if (dropdownTransformadoresRef.current && !dropdownTransformadoresRef.current.contains(event.target)) {
            setDropdownTransformadoresAbierto(false);
         }
      };

      if (dropdownTransformadoresAbierto) {
         document.addEventListener("mousedown", handleClickOutside);
      }

      return () => document.removeEventListener("mousedown", handleClickOutside);
   }, [dropdownTransformadoresAbierto]);

   // Handlers de plantillas
   const handleCrearPlantilla = (datos) => {
      const nueva = crearPlantilla(datos);
      if (nueva) {
         configHook.aplicarPlantillaCreada(nueva);
      }
      return nueva;
   };

   const handleActualizarPlantilla = (id, datos) => {
      const exito = actualizarPlantilla(id, datos);
      if (exito && configHook.config.plantillaId === id) {
         const plantillaActualizada = { id, ...datos, funcionalidades: datos.funcionalidades || {} };
         configHook.actualizarFuncionalidades(plantillaActualizada);
      }
      return exito;
   };

   // Aplicar f√≥rmula de transformador
   const aplicarFormulaTransformador = (valor, transformadorId) => {
      if (valor === null || valor === undefined || !transformadorId) return null;

      const transformador = obtenerTransformadorPorId(transformadorId);
      if (!transformador || !transformador.formula) return null;

      try {
         const x = valor;
         // eslint-disable-next-line no-new-func
         const resultado = new Function("x", `return ${transformador.formula}`)(x);
         return typeof resultado === "number" && !isNaN(resultado) ? resultado : null;
      } catch (error) {
         console.error("Error al aplicar f√≥rmula del transformador:", error);
         return null;
      }
   };

   return (
      <div className="config-rele">
         {/* Fila superior: Conexi√≥n/Transformadores y Plantilla */}
         <div className="config-rele-row-superior">
            {/* Columna izquierda */}
            <div className="config-rele-col-izquierda">
               <SeccionConexion
                  config={configHook.config}
                  onConexionChange={configHook.handleConexionChange}
                  onRegistroInicialChange={configHook.handleRegistroInicialChange}
                  onCantidadRegistrosChange={configHook.handleCantidadRegistrosChange}
                  onIntervaloChange={configHook.handleIntervaloChange}
               />

               <SeccionTransformadores
                  dropdownAbierto={dropdownTransformadoresAbierto}
                  setDropdownAbierto={setDropdownTransformadoresAbierto}
                  dropdownRef={dropdownTransformadoresRef}
                  obtenerTIs={obtenerTIs}
                  obtenerTVs={obtenerTVs}
                  obtenerRelaciones={obtenerRelaciones}
                  onAbrirModal={() => {
                     setTipoTransformadorModal("TI");
                     setModalTransformadoresAbierto(true);
                     setDropdownTransformadoresAbierto(false);
                  }}
               />
            </div>

            {/* Secci√≥n Plantilla */}
            <SeccionPlantilla
               plantillas={plantillas}
               config={configHook.config}
               cargandoPlantillas={cargandoPlantillas}
               plantillaSeleccionada={configHook.plantillaSeleccionada}
               plantillaNoEncontrada={configHook.plantillaNoEncontrada}
               onPlantillaChange={(e) => configHook.handlePlantillaChange(e.target.value)}
               onAbrirModalCrear={() => {
                  setPlantillaParaEditar(null);
                  setModalPlantillasAbierto(true);
               }}
               onAbrirModalGestionar={() => {
                  setPlantillaParaEditar(null);
                  setModalPlantillasAbierto(true);
               }}
            />
         </div>

         {/* Fila inferior: Consola + Funcionalidades */}
         <div className="config-rele-row-inferior">
            <SeccionConsola
               consolaHook={consolaHook}
               registrosCrudos={consolaHook.registrosCrudos}
               plantillaSeleccionada={configHook.plantillaSeleccionada}
               funcionalidadesPlantilla={configHook.funcionalidadesPlantilla}
               funcionalidadesActivas={configHook.config.funcionalidadesActivas}
               obtenerTransformadorPorId={obtenerTransformadorPorId}
               aplicarFormulaTransformador={aplicarFormulaTransformador}
            />

            {configHook.plantillaSeleccionada && configHook.funcionalidadesPlantilla.length > 0 && (
               <SeccionFuncionalidades
                  cantidadActivas={configHook.cantidadActivas}
                  tabActivo={configHook.tabFuncionalidadesActivo}
                  setTabActivo={configHook.setTabFuncionalidadesActivo}
                  funcionalidadesPlantilla={configHook.funcionalidadesPlantilla}
                  funcionalidadesActivas={configHook.config.funcionalidadesActivas}
                  filasExpandidas={configHook.filasExpandidas}
                  onToggleFuncionalidad={configHook.handleToggleFuncionalidad}
                  onToggleFilaExpandida={configHook.toggleFilaExpandida}
                  obtenerTransformadorPorId={obtenerTransformadorPorId}
               />
            )}
         </div>

         {/* Modales */}
         <ModalPlantillasRele
            abierto={modalPlantillasAbierto}
            onCerrar={() => {
               setModalPlantillasAbierto(false);
               setPlantillaParaEditar(null);
            }}
            plantillas={plantillas}
            onCrear={handleCrearPlantilla}
            onActualizar={handleActualizarPlantilla}
            onEliminar={eliminarPlantilla}
            plantillaEditando={plantillaParaEditar}
         />

         <ModalTransformadores
            abierto={modalTransformadoresAbierto}
            onCerrar={() => setModalTransformadoresAbierto(false)}
            transformadores={transformadores}
            onCrear={crearTransformador}
            onActualizar={actualizarTransformador}
            onEliminar={eliminarTransformador}
            tipoInicial={tipoTransformadorModal}
         />
      </div>
   );
};

// ============================================
// COMPONENTES AUXILIARES
// ============================================

const SeccionConexion = ({
   config,
   onConexionChange,
   onRegistroInicialChange,
   onCantidadRegistrosChange,
   onIntervaloChange,
}) => (
   <div className="config-rele-seccion config-rele-seccion--conexion">
      <h6>üì° Conexi√≥n Modbus TCP</h6>
      <div className="config-rele-conexion-fila">
         <div className="config-rele-conexion-grupo">
            <div className="config-rele-campo-inline">
               <label>IP</label>
               <input
                  type="text"
                  value={config.conexion.ip}
                  onChange={(e) => onConexionChange("ip", e.target.value)}
                  placeholder="172.16.0.1"
               />
            </div>
            <div className="config-rele-campo-inline">
               <label>Puerto</label>
               <input
                  type="number"
                  value={config.conexion.puerto}
                  onChange={(e) => onConexionChange("puerto", e.target.value === "" ? "" : parseInt(e.target.value))}
                  placeholder="502"
               />
            </div>
            <div className="config-rele-campo-inline">
               <label>Unit ID</label>
               <input
                  type="number"
                  value={config.conexion.unitId}
                  onChange={(e) => onConexionChange("unitId", e.target.value === "" ? "" : parseInt(e.target.value))}
                  placeholder="1"
               />
            </div>
         </div>
         <div className="config-rele-conexion-grupo">
            <div className="config-rele-campo-inline">
               <label>Inicio</label>
               <input
                  type="number"
                  value={config.registroInicial}
                  onChange={(e) => onRegistroInicialChange(e.target.value)}
                  placeholder="120"
                  min={0}
               />
            </div>
            <div className="config-rele-campo-inline">
               <label>Cant.</label>
               <input
                  type="number"
                  value={config.cantidadRegistros}
                  onChange={(e) => onCantidadRegistrosChange(e.target.value)}
                  placeholder="80"
                  min={1}
               />
            </div>
         </div>
         <div className="config-rele-conexion-grupo">
            <div className="config-rele-campo-inline">
               <label>Intervalo</label>
               <input
                  type="number"
                  value={config.intervalo}
                  onChange={(e) => onIntervaloChange(e.target.value)}
                  placeholder="60"
                  min={1}
               />
            </div>
         </div>
      </div>
   </div>
);

const SeccionTransformadores = ({
   dropdownAbierto,
   setDropdownAbierto,
   dropdownRef,
   obtenerTIs,
   obtenerTVs,
   obtenerRelaciones,
   onAbrirModal,
}) => (
   <div className="config-rele-seccion config-rele-seccion--transformadores">
      <h6>‚ö° Relaciones de transformaci√≥n</h6>
      <div className="config-rele-transformadores-compacto" ref={dropdownRef}>
         <div className="config-rele-campo-inline">
            <label>TI / TV / Relaci√≥n [ x : y ]</label>
            <button
               type="button"
               className="config-rele-btn-ver-transformadores"
               onClick={() => setDropdownAbierto(!dropdownAbierto)}
            >
               <span>Ver disponibles ({obtenerTIs().length + obtenerTVs().length + obtenerRelaciones().length})</span>
               <span className={`config-rele-dropdown-arrow ${dropdownAbierto ? "abierto" : ""}`}>‚ñº</span>
            </button>
         </div>
         <button type="button" className="config-rele-btn-editar-transformador" onClick={onAbrirModal} title="Gestionar transformadores">
            ‚öôÔ∏è
         </button>

         {dropdownAbierto && (
            <div className="config-rele-transformadores-dropdown">
               {obtenerTIs().length > 0 && (
                  <div className="config-rele-dropdown-grupo">
                     <div className="config-rele-dropdown-titulo">T.I. (Intensidad)</div>
                     {obtenerTIs().map((t) => (
                        <div key={t.id} className="config-rele-dropdown-item">
                           <span className="config-rele-dropdown-nombre">{t.nombre}</span>
                           <span className="config-rele-dropdown-formula">{t.formula}</span>
                        </div>
                     ))}
                  </div>
               )}
               {obtenerTVs().length > 0 && (
                  <div className="config-rele-dropdown-grupo">
                     <div className="config-rele-dropdown-titulo">T.V. (Voltaje)</div>
                     {obtenerTVs().map((t) => (
                        <div key={t.id} className="config-rele-dropdown-item">
                           <span className="config-rele-dropdown-nombre">{t.nombre}</span>
                           <span className="config-rele-dropdown-formula">{t.formula}</span>
                        </div>
                     ))}
                  </div>
               )}
               {obtenerRelaciones().length > 0 && (
                  <div className="config-rele-dropdown-grupo">
                     <div className="config-rele-dropdown-titulo">Relaci√≥n [ x : y ]</div>
                     {obtenerRelaciones().map((t) => (
                        <div key={t.id} className="config-rele-dropdown-item">
                           <span className="config-rele-dropdown-nombre">{t.nombre}</span>
                           <span className="config-rele-dropdown-formula">{t.formula}</span>
                        </div>
                     ))}
                  </div>
               )}
               {obtenerTIs().length === 0 && obtenerTVs().length === 0 && obtenerRelaciones().length === 0 && (
                  <div className="config-rele-dropdown-vacio">No hay transformadores configurados</div>
               )}
            </div>
         )}
      </div>
   </div>
);

const SeccionPlantilla = ({
   plantillas,
   config,
   cargandoPlantillas,
   plantillaSeleccionada,
   plantillaNoEncontrada,
   onPlantillaChange,
   onAbrirModalCrear,
   onAbrirModalGestionar,
}) => (
   <div className="config-rele-seccion config-rele-seccion--plantilla">
      <h6>üìã Plantilla de Configuraci√≥n</h6>

      <div className="config-rele-plantilla-row">
         <select
            value={config.plantillaId}
            onChange={onPlantillaChange}
            className={`config-rele-select ${plantillaNoEncontrada ? "config-rele-select--error" : ""}`}
         >
            <option value="">Seleccionar plantilla...</option>
            {plantillas.map((p) => (
               <option key={p.id} value={p.id}>{p.nombre}</option>
            ))}
         </select>

         <button type="button" className="config-rele-btn-plantilla" onClick={onAbrirModalCrear} title="Nueva plantilla">
            + Nueva
         </button>

         <button type="button" className="config-rele-btn-plantilla config-rele-btn-plantilla--secundario" onClick={onAbrirModalGestionar} title="Gestionar plantillas">
            Gestionar
         </button>
      </div>

      {plantillaNoEncontrada && (
         <div className="config-rele-alerta">La plantilla seleccionada ya no existe. Selecciona otra.</div>
      )}

      {plantillas.length === 0 && !cargandoPlantillas && (
         <div className="config-rele-mensaje">No hay plantillas. Crea una para continuar.</div>
      )}

      {plantillaSeleccionada?.descripcion && (
         <div className="config-rele-plantilla-desc">{plantillaSeleccionada.descripcion}</div>
      )}
   </div>
);

const SeccionConsola = ({
   consolaHook,
   registrosCrudos,
   plantillaSeleccionada,
   funcionalidadesPlantilla,
   funcionalidadesActivas,
   obtenerTransformadorPorId,
   aplicarFormulaTransformador,
}) => (
   <div className="config-rele-seccion config-rele-seccion--consola">
      <h6>üñ•Ô∏è Consola de Test</h6>

      <div className="config-rele-consola-container" ref={consolaHook.containerRef}>
         <div ref={consolaHook.consolaRef} className="config-rele-consola" style={{ width: `${consolaHook.consolaWidth}%` }}>
            {consolaHook.consolaLogs.length === 0 ? (
               <div className="config-rele-consola-vacio">Presiona "Ejecutar Test" para probar la conexi√≥n Modbus</div>
            ) : (
               consolaHook.consolaLogs.map((log, index) => (
                  <div key={index} className={`config-rele-consola-linea config-rele-consola-linea--${log.tipo}`}>
                     <span className="config-rele-consola-timestamp">[{log.timestamp}]</span>
                     <span className="config-rele-consola-mensaje">{log.mensaje}</span>
                  </div>
               ))
            )}
         </div>

         <div ref={consolaHook.resizerRef} className="config-rele-resizer" onMouseDown={consolaHook.handleMouseDown} />

         <div className="config-rele-registros-panel" style={{ width: `${100 - consolaHook.consolaWidth}%` }}>
            {!registrosCrudos ? (
               <div className="config-rele-registros-vacio">Los valores aparecer√°n aqu√≠ despu√©s del test</div>
            ) : !plantillaSeleccionada ? (
               <div className="config-rele-registros-vacio">Selecciona una plantilla para ver las funcionalidades</div>
            ) : (
               <PanelValoresFuncionalidades
                  registrosCrudos={registrosCrudos}
                  plantillaSeleccionada={plantillaSeleccionada}
                  funcionalidadesPlantilla={funcionalidadesPlantilla}
                  funcionalidadesActivas={funcionalidadesActivas}
                  obtenerTransformadorPorId={obtenerTransformadorPorId}
                  aplicarFormulaTransformador={aplicarFormulaTransformador}
               />
            )}
         </div>
      </div>

      <div className="config-rele-consola-acciones">
         <button type="button" className="config-rele-btn-test" onClick={consolaHook.ejecutarTest} disabled={consolaHook.ejecutandoTest}>
            {consolaHook.ejecutandoTest ? "Ejecutando..." : "Ejecutar Test"}
         </button>
         <button type="button" className="config-rele-btn-csv" onClick={consolaHook.exportarCSV} disabled={!registrosCrudos} title={registrosCrudos ? `Exportar ${registrosCrudos.valores?.length || 0} registros` : "Ejecuta un test primero"}>
            Exportar CSV
         </button>
         <button type="button" className="config-rele-btn-limpiar" onClick={consolaHook.limpiarConsola} disabled={consolaHook.consolaLogs.length === 0 && !registrosCrudos}>
            Limpiar
         </button>
      </div>
   </div>
);

const PanelValoresFuncionalidades = ({
   registrosCrudos,
   plantillaSeleccionada,
   funcionalidadesPlantilla,
   funcionalidadesActivas,
   obtenerTransformadorPorId,
   aplicarFormulaTransformador,
}) => (
   <div className="config-rele-funcionalidades-valores">
      {Object.values(CATEGORIAS).map((categoria) => {
         const funcsActivas = funcionalidadesPlantilla.filter(([funcId, func]) => {
            const estadoActivo = funcionalidadesActivas[funcId];
            return estadoActivo?.habilitado && (func.categoria || "mediciones") === categoria.id;
         });

         if (funcsActivas.length === 0) return null;

         const requiereInterpretacion = categoriaRequiereInterpretacion(categoria.id);

         return (
            <div key={categoria.id} className="config-rele-valores-categoria">
               <div className="config-rele-valores-categoria-titulo">{categoria.nombre}</div>
               {funcsActivas.map(([funcId, plantillaFunc]) => {
                  const estadoActivo = funcionalidadesActivas[funcId];
                  const registrosPlantilla = plantillaFunc.registros || [];
                  const registrosEstado = estadoActivo?.registros || [];
                  const registros = registrosPlantilla.map((regPlantilla, idx) => ({
                     ...regPlantilla,
                     valor: registrosEstado[idx]?.valor ?? regPlantilla.valor,
                     etiqueta: registrosEstado[idx]?.etiqueta ?? regPlantilla.etiqueta,
                     transformadorId: regPlantilla.transformadorId,
                  }));

                  return (
                     <div key={funcId} className="config-rele-valores-func">
                        <div className="config-rele-valores-func-nombre">* {plantillaFunc.nombre}</div>
                        <div className="config-rele-valores-registros">
                           {registros.map((reg, index) => {
                              const regNum = reg.valor;
                              const indiceEnArray = regNum - registrosCrudos.indiceInicial;
                              const valorLeido = indiceEnArray >= 0 && indiceEnArray < registrosCrudos.valores.length
                                 ? registrosCrudos.valores[indiceEnArray]
                                 : null;

                              const transformadorId = reg.transformadorId || null;
                              const valorTransformado = transformadorId && valorLeido !== null
                                 ? aplicarFormulaTransformador(valorLeido, transformadorId)
                                 : null;
                              const transformador = transformadorId ? obtenerTransformadorPorId(transformadorId) : null;

                              const etiquetasPersonalizadas = regNum === 172 && plantillaSeleccionada?.etiquetasBits
                                 ? plantillaSeleccionada.etiquetasBits
                                 : null;

                              const interpretacion = requiereInterpretacion && valorLeido !== null
                                 ? interpretarRegistro(regNum, valorLeido, etiquetasPersonalizadas)
                                 : null;

                              return (
                                 <FilaRegistroValor
                                    key={index}
                                    reg={reg}
                                    index={index}
                                    regNum={regNum}
                                    valorLeido={valorLeido}
                                    valorTransformado={valorTransformado}
                                    transformador={transformador}
                                    interpretacion={interpretacion}
                                 />
                              );
                           })}
                        </div>
                     </div>
                  );
               })}
            </div>
         );
      })}
   </div>
);

const FilaRegistroValor = ({ reg, index, regNum, valorLeido, valorTransformado, transformador, interpretacion }) => (
   <div className="config-rele-valores-registro-container">
      <div className="config-rele-valores-registro">
         {reg.etiqueta || `Reg ${index + 1}`} [{regNum}] = {valorLeido !== null ? valorLeido : "‚Äî"}
         {valorTransformado !== null && (
            <span className="config-rele-valor-transformado" title={`Transformado con ${transformador?.nombre}: ${transformador?.formula}`}>
               {" ‚Üí "}{valorTransformado.toFixed(2)}
            </span>
         )}
      </div>
      {interpretacion && interpretacion.tieneInterpretacion && (
         <div className="config-rele-interpretacion">
            {interpretacion.interpretacionEspecial && (
               <div className={`config-rele-interpretacion-especial ${obtenerClaseTipo(interpretacion.interpretacionEspecial.clase)}`}>
                  {interpretacion.interpretacionEspecial.icono && <span className="interpretacion-icono">{interpretacion.interpretacionEspecial.icono}</span>}
                  <span className="interpretacion-estado">{interpretacion.interpretacionEspecial.estado}</span>
               </div>
            )}
            {interpretacion.bitsActivos.length > 0 && !interpretacion.interpretacionEspecial?.icono && (
               <div className="config-rele-interpretacion-bits">
                  {interpretacion.bitsActivos.map((bit, bitIdx) => (
                     <span key={bitIdx} className={`config-rele-bit ${obtenerClaseTipo(bit.tipo)}`} title={bit.descripcion}>
                        {bit.nombre}
                     </span>
                  ))}
               </div>
            )}
            {interpretacion.bitsActivos.length === 0 && !interpretacion.interpretacionEspecial && (
               <div className="config-rele-interpretacion-vacio">Sin se√±ales activas</div>
            )}
         </div>
      )}
   </div>
);

const SeccionFuncionalidades = ({
   cantidadActivas,
   tabActivo,
   setTabActivo,
   funcionalidadesPlantilla,
   funcionalidadesActivas,
   filasExpandidas,
   onToggleFuncionalidad,
   onToggleFilaExpandida,
   obtenerTransformadorPorId,
}) => (
   <div className="config-rele-seccion config-rele-seccion--funcionalidades">
      <h6>
         üîß Funcionalidades a Monitorear
         <span className="config-rele-contador">{cantidadActivas} activas</span>
      </h6>

      <div className="config-rele-tabs">
         {Object.values(CATEGORIAS).map((categoria) => {
            const funcsDeCategoria = funcionalidadesPlantilla.filter(([, func]) => (func.categoria || "mediciones") === categoria.id);
            if (funcsDeCategoria.length === 0) return null;

            return (
               <button
                  key={categoria.id}
                  type="button"
                  className={`config-rele-tab ${tabActivo === categoria.id ? "activo" : ""}`}
                  onClick={() => setTabActivo(categoria.id)}
               >
                  <span className="config-rele-tab-icono">{categoria.icono}</span>
                  <span className="config-rele-tab-nombre">{categoria.nombre}</span>
                  <span className="config-rele-tab-contador">{funcsDeCategoria.length}</span>
               </button>
            );
         })}
      </div>

      <div className="config-rele-tab-contenido">
         <TablaFuncionalidades
            tabActivo={tabActivo}
            funcionalidadesPlantilla={funcionalidadesPlantilla}
            funcionalidadesActivas={funcionalidadesActivas}
            filasExpandidas={filasExpandidas}
            onToggleFuncionalidad={onToggleFuncionalidad}
            onToggleFilaExpandida={onToggleFilaExpandida}
            obtenerTransformadorPorId={obtenerTransformadorPorId}
         />
      </div>
   </div>
);

const TablaFuncionalidades = ({
   tabActivo,
   funcionalidadesPlantilla,
   funcionalidadesActivas,
   filasExpandidas,
   onToggleFuncionalidad,
   onToggleFilaExpandida,
   obtenerTransformadorPorId,
}) => {
   const funcsDeCategoria = funcionalidadesPlantilla.filter(([, func]) => (func.categoria || "mediciones") === tabActivo);

   if (funcsDeCategoria.length === 0) {
      return <div className="config-rele-tab-vacio">No hay funcionalidades en esta categor√≠a</div>;
   }

   return (
      <table className="config-rele-tabla">
         <thead>
            <tr>
               <th className="config-rele-tabla-th-check"></th>
               <th className="config-rele-tabla-th-nombre">Funcionalidad</th>
               <th className="config-rele-tabla-th-registros">Registros</th>
               <th className="config-rele-tabla-th-ti-tv">TI / TV</th>
            </tr>
         </thead>
         <tbody>
            {funcsDeCategoria.map(([funcId, plantillaFunc]) => (
               <FilaFuncionalidad
                  key={funcId}
                  funcId={funcId}
                  plantillaFunc={plantillaFunc}
                  estadoActivo={funcionalidadesActivas[funcId]}
                  estaExpandida={filasExpandidas.has(funcId)}
                  onToggle={onToggleFuncionalidad}
                  onToggleExpandir={onToggleFilaExpandida}
                  obtenerTransformadorPorId={obtenerTransformadorPorId}
               />
            ))}
         </tbody>
      </table>
   );
};

const FilaFuncionalidad = ({
   funcId,
   plantillaFunc,
   estadoActivo,
   estaExpandida,
   onToggle,
   onToggleExpandir,
   obtenerTransformadorPorId,
}) => {
   const estaHabilitado = estadoActivo?.habilitado || false;
   const registrosPlantilla = plantillaFunc.registros || [];
   const registrosEstado = estadoActivo?.registros || [];
   const registros = registrosPlantilla.map((regPlantilla, idx) => ({
      ...regPlantilla,
      valor: registrosEstado[idx]?.valor ?? regPlantilla.valor,
      etiqueta: registrosEstado[idx]?.etiqueta ?? regPlantilla.etiqueta,
      transformadorId: regPlantilla.transformadorId,
   }));

   const transformadoresUnicos = new Map();
   registros.forEach((reg) => {
      if (reg.transformadorId) {
         const t = obtenerTransformadorPorId(reg.transformadorId);
         if (t) transformadoresUnicos.set(reg.transformadorId, t);
      }
   });
   const cantTransformadores = transformadoresUnicos.size;
   const primerTransformador = cantTransformadores > 0 ? Array.from(transformadoresUnicos.values())[0] : null;

   const resumenRegistros = registros.map((r) => `${r.etiqueta || "Reg"}: ${r.valor}`).join(" | ");

   return (
      <React.Fragment>
         <tr className={`config-rele-tabla-fila ${estaHabilitado ? "activo" : "inactivo"} ${estaExpandida ? "expandida" : ""}`}>
            <td className="config-rele-tabla-td-check">
               <input type="checkbox" checked={estaHabilitado} onChange={() => onToggle(funcId)} />
            </td>
            <td className="config-rele-tabla-td-nombre">
               <button type="button" className="config-rele-tabla-btn-expandir" onClick={() => onToggleExpandir(funcId)}>
                  <span className={`config-rele-tabla-chevron ${estaExpandida ? "expandido" : ""}`}>‚ñ∂</span>
                  <span className="config-rele-tabla-nombre-texto">{plantillaFunc.nombre}</span>
               </button>
            </td>
            <td className="config-rele-tabla-td-registros">
               {!estaExpandida && <span className="config-rele-tabla-resumen">{resumenRegistros}</span>}
            </td>
            <td className="config-rele-tabla-td-ti-tv">
               {cantTransformadores > 1 ? (
                  <div className="config-rele-tabla-transformador">
                     <span className="config-rele-tabla-ti-tv-nombre">{cantTransformadores} diferentes</span>
                     <span className="config-rele-tabla-ti-tv-formula">(ver detalle)</span>
                  </div>
               ) : primerTransformador ? (
                  <div className="config-rele-tabla-transformador">
                     <span className="config-rele-tabla-ti-tv-nombre">{primerTransformador.nombre}</span>
                     <span className="config-rele-tabla-ti-tv-formula">{primerTransformador.formula}</span>
                  </div>
               ) : (
                  <span className="config-rele-tabla-sin-ti-tv">‚Äî</span>
               )}
            </td>
         </tr>
         {estaExpandida && (
            <tr className="config-rele-tabla-fila-expandida">
               <td colSpan={4}>
                  <div className="config-rele-tabla-expandido">
                     <table className="config-rele-subtabla">
                        <thead>
                           <tr>
                              <th>Etiqueta</th>
                              <th>Registro</th>
                              <th>TI / TV / Relaci√≥n</th>
                           </tr>
                        </thead>
                        <tbody>
                           {registros.map((reg, index) => {
                              const transformadorReg = reg.transformadorId ? obtenerTransformadorPorId(reg.transformadorId) : null;
                              return (
                                 <tr key={index}>
                                    <td>{reg.etiqueta || `Reg ${index + 1}`}</td>
                                    <td>{reg.valor}</td>
                                    <td>
                                       {transformadorReg ? (
                                          <span className="config-rele-subtabla-transformador">
                                             {transformadorReg.nombre}
                                             <span className="config-rele-subtabla-formula">{transformadorReg.formula}</span>
                                          </span>
                                       ) : (
                                          <span className="config-rele-subtabla-sin-ti">‚Äî</span>
                                       )}
                                    </td>
                                 </tr>
                              );
                           })}
                        </tbody>
                     </table>
                  </div>
               </td>
            </tr>
         )}
      </React.Fragment>
   );
};

export default ConfiguracionRele;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/rele/DropdownTransformador.jsx =====

import { useState, useEffect, useRef } from "react";

/**
 * Dropdown personalizado para seleccionar TI/TV/Relaci√≥n
 * Con l√≠neas divisorias degradadas y f√≥rmula en input readonly
 * Usa posici√≥n fixed para evitar ser cortado por el modal
 */
const DropdownTransformador = ({
  value,
  onChange,
  disabled,
  tis,
  tvs,
  relaciones = []
}) => {
  const [abierto, setAbierto] = useState(false);
  const [menuPos, setMenuPos] = useState({ top: 0, left: 0 });
  const dropdownRef = useRef(null);
  const triggerRef = useRef(null);
  const menuRef = useRef(null);

  // Calcular posici√≥n del men√∫ cuando se abre
  useEffect(() => {
    if (abierto && triggerRef.current) {
      const rect = triggerRef.current.getBoundingClientRect();
      const menuHeight = 500; // altura m√°xima aproximada
      const viewportHeight = window.innerHeight;

      // Posici√≥n a la derecha del trigger
      let left = rect.right + 8;

      // Centrar verticalmente respecto al trigger
      let top = rect.top + (rect.height / 2) - (menuHeight / 2);

      // Ajustar si se sale por arriba
      if (top < 10) top = 10;

      // Ajustar si se sale por abajo
      if (top + menuHeight > viewportHeight - 10) {
        top = viewportHeight - menuHeight - 10;
      }

      // Si no cabe a la derecha, ponerlo a la izquierda
      if (left + 300 > window.innerWidth) {
        left = rect.left - 308;
      }

      setMenuPos({ top, left });
    }
  }, [abierto]);

  // Cerrar al hacer click fuera
  useEffect(() => {
    const handleClickFuera = (e) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(e.target) &&
        menuRef.current &&
        !menuRef.current.contains(e.target)
      ) {
        setAbierto(false);
      }
    };
    if (abierto) {
      document.addEventListener("mousedown", handleClickFuera);
    }
    return () => document.removeEventListener("mousedown", handleClickFuera);
  }, [abierto]);

  // Encontrar el transformador seleccionado
  const transformadorSeleccionado = value
    ? [...tis, ...tvs, ...relaciones].find(t => t.id === value)
    : null;

  const handleSeleccionar = (id) => {
    onChange(id);
    setAbierto(false);
  };

  return (
    <div
      className={`dropdown-transformador ${disabled ? "disabled" : ""}`}
      ref={dropdownRef}
    >
      <button
        type="button"
        className="dropdown-transformador-trigger"
        onClick={() => !disabled && setAbierto(!abierto)}
        disabled={disabled}
        ref={triggerRef}
      >
        {transformadorSeleccionado ? (
          <>
            <span className="dropdown-transformador-nombre">{transformadorSeleccionado.nombre}</span>
            <input
              type="text"
              className="dropdown-transformador-formula"
              value={transformadorSeleccionado.formula}
              readOnly
              tabIndex={-1}
            />
          </>
        ) : (
          <span className="dropdown-transformador-texto">Sin TI / TV</span>
        )}
        <span className="dropdown-transformador-chevron">{abierto ? "‚ñ≤" : "‚ñº"}</span>
      </button>

      {abierto && (
        <div
          className="dropdown-transformador-menu dropdown-transformador-menu--fixed"
          style={{ top: menuPos.top, left: menuPos.left }}
          ref={menuRef}
        >
          {/* Opci√≥n: Sin TI/TV */}
          <div
            className={`dropdown-transformador-opcion ${!value ? "seleccionado" : ""}`}
            onClick={() => handleSeleccionar("")}
          >
            <span className="dropdown-transformador-nombre">Sin TI / TV</span>
          </div>

          {/* L√≠nea divisoria despu√©s de Sin TI/TV si hay TIs */}
          {tis.length > 0 && <div className="dropdown-transformador-divider" />}

          {/* TIs */}
          {tis.map((t) => (
            <div
              key={t.id}
              className={`dropdown-transformador-opcion ${value === t.id ? "seleccionado" : ""}`}
              onClick={() => handleSeleccionar(t.id)}
            >
              <span className="dropdown-transformador-nombre">{t.nombre}</span>
              <input
                type="text"
                className="dropdown-transformador-formula"
                value={t.formula}
                readOnly
                tabIndex={-1}
              />
            </div>
          ))}

          {/* L√≠nea divisoria entre TIs y TVs */}
          {tis.length > 0 && tvs.length > 0 && <div className="dropdown-transformador-divider" />}

          {/* TVs */}
          {tvs.map((t) => (
            <div
              key={t.id}
              className={`dropdown-transformador-opcion ${value === t.id ? "seleccionado" : ""}`}
              onClick={() => handleSeleccionar(t.id)}
            >
              <span className="dropdown-transformador-nombre">{t.nombre}</span>
              <input
                type="text"
                className="dropdown-transformador-formula"
                value={t.formula}
                readOnly
                tabIndex={-1}
              />
            </div>
          ))}

          {/* L√≠nea divisoria entre TVs y Relaciones */}
          {(tis.length > 0 || tvs.length > 0) && relaciones.length > 0 && <div className="dropdown-transformador-divider" />}

          {/* Relaciones */}
          {relaciones.map((t) => (
            <div
              key={t.id}
              className={`dropdown-transformador-opcion ${value === t.id ? "seleccionado" : ""}`}
              onClick={() => handleSeleccionar(t.id)}
            >
              <span className="dropdown-transformador-nombre">{t.nombre}</span>
              <input
                type="text"
                className="dropdown-transformador-formula"
                value={t.formula}
                readOnly
                tabIndex={-1}
              />
            </div>
          ))}

          {/* Mensaje si no hay transformadores */}
          {tis.length === 0 && tvs.length === 0 && relaciones.length === 0 && (
            <div className="dropdown-transformador-vacio">
              No hay TI/TV/Relaciones configurados
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default DropdownTransformador;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/rele/index.js =====

// modales/rele/index.js
// Modales relacionados con configuraci√≥n de rel√©s

export { default as ConfiguracionRele } from "./ConfiguracionRele";
export { default as ModalPlantillasRele } from "./ModalPlantillasRele";
export { default as ModalTransformadores } from "./ModalTransformadores";
export { default as DropdownTransformador } from "./DropdownTransformador";

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/rele/ModalPlantillasRele.jsx =====

import { useState, useEffect } from "react";
import { SEVERIDADES_DISPONIBLES, PLANTILLAS_ETIQUETAS_LEDS } from "../../../utilidades/interpreteRegistrosREF615";
import { useTransformadores } from "../../../hooks/mediciones";
import { useEtiquetasBits, useFuncionalidadesPlantilla, CATEGORIAS_FUNCIONALIDADES } from "../../../hooks/rele";
import DropdownTransformador from "./DropdownTransformador";
import "./ModalPlantillasRele.css";

/**
 * Modal para gestionar plantillas de rel√©s de protecci√≥n.
 * Permite crear funcionalidades personalizadas con registros individuales.
 */
const ModalPlantillasRele = ({
   abierto,
   onCerrar,
   plantillas,
   onCrear,
   onActualizar,
   onEliminar,
   plantillaEditando = null,
}) => {
   // Hook de transformadores
   const { obtenerTIs, obtenerTVs, obtenerRelaciones, recargar: recargarTransformadores } = useTransformadores();

   // Hook de etiquetas de bits
   const etiquetasHook = useEtiquetasBits();

   // Hook de funcionalidades
   const funcionalidadesHook = useFuncionalidadesPlantilla();

   // Estado del formulario
   const [modo, setModo] = useState("lista");
   const [nombre, setNombre] = useState("");
   const [descripcion, setDescripcion] = useState("");
   const [plantillaSeleccionada, setPlantillaSeleccionada] = useState(null);
   const [error, setError] = useState("");

   // Recargar transformadores cuando el modal se abre
   useEffect(() => {
      if (abierto) {
         recargarTransformadores();
      }
   }, [abierto, recargarTransformadores]);

   // Si se pasa una plantilla para editar, entrar en modo edici√≥n
   useEffect(() => {
      if (plantillaEditando && abierto) {
         setModo("editar");
         setPlantillaSeleccionada(plantillaEditando);
         setNombre(plantillaEditando.nombre);
         setDescripcion(plantillaEditando.descripcion || "");
         funcionalidadesHook.cargarDesdeObjeto(plantillaEditando.funcionalidades);
         etiquetasHook.cargarDesdeObjeto(
            plantillaEditando.etiquetasBits,
            plantillaEditando.plantillaEtiquetasId
         );
      }
   }, [plantillaEditando, abierto]);

   // Reset al cerrar
   useEffect(() => {
      if (!abierto) {
         resetFormulario();
      }
   }, [abierto]);

   const resetFormulario = () => {
      setModo("lista");
      setNombre("");
      setDescripcion("");
      setPlantillaSeleccionada(null);
      setError("");
      funcionalidadesHook.resetear();
      etiquetasHook.resetear();
   };

   const iniciarCreacion = () => {
      resetFormulario();
      setModo("crear");
   };

   const iniciarEdicion = (plantilla) => {
      setPlantillaSeleccionada(plantilla);
      setNombre(plantilla.nombre);
      setDescripcion(plantilla.descripcion || "");
      funcionalidadesHook.cargarDesdeObjeto(plantilla.funcionalidades);
      etiquetasHook.cargarDesdeObjeto(
         plantilla.etiquetasBits,
         plantilla.plantillaEtiquetasId
      );
      setModo("editar");
   };

   const handleAgregarFuncionalidad = () => {
      const resultado = funcionalidadesHook.agregarFuncionalidad();
      if (!resultado.exito) {
         setError(resultado.error);
      } else {
         setError("");
      }
   };

   const handleGuardarPlantillaEtiquetas = () => {
      const resultado = etiquetasHook.guardarPlantillaPersonalizada();
      if (!resultado.exito) {
         setError(resultado.error);
      } else {
         setError("");
      }
   };

   const validarFormulario = () => {
      if (!nombre.trim()) {
         setError("El nombre de la plantilla es requerido");
         return false;
      }

      if (funcionalidadesHook.funcionalidades.length === 0) {
         setError("Debes agregar al menos una funcionalidad");
         return false;
      }

      const hayFuncionalidadActiva = funcionalidadesHook.funcionalidades.some((f) => f.habilitado);
      if (!hayFuncionalidadActiva) {
         setError("Debe habilitar al menos una funcionalidad");
         return false;
      }

      setError("");
      return true;
   };

   const handleGuardar = () => {
      if (!validarFormulario()) return;

      const datos = {
         nombre: nombre.trim(),
         descripcion: descripcion.trim(),
         funcionalidades: funcionalidadesHook.obtenerParaGuardar(),
         etiquetasBits: etiquetasHook.obtenerEtiquetasLimpias(),
         plantillaEtiquetasId: etiquetasHook.plantillaSeleccionada || null,
      };

      if (modo === "crear") {
         const nueva = onCrear(datos);
         if (nueva) resetFormulario();
      } else if (modo === "editar" && plantillaSeleccionada) {
         const exito = onActualizar(plantillaSeleccionada.id, datos);
         if (exito) resetFormulario();
      }
   };

   const handleEliminar = (plantilla) => {
      if (window.confirm(`¬øEliminar la plantilla "${plantilla.nombre}"? Esta acci√≥n no se puede deshacer.`)) {
         onEliminar(plantilla.id);
      }
   };

   if (!abierto) return null;

   return (
      <div className="modal-plantillas-overlay">
         <div className="modal-plantillas-contenido">
            {/* Header */}
            <div className="modal-plantillas-header">
               <h3>
                  {modo === "lista" && "Gestionar Plantillas"}
                  {modo === "crear" && "Nueva Plantilla"}
                  {modo === "editar" && "Editar Plantilla"}
               </h3>
               <button className="modal-plantillas-cerrar" onClick={onCerrar}>√ó</button>
            </div>

            {/* Contenido */}
            <div className="modal-plantillas-body">
               {/* MODO LISTA */}
               {modo === "lista" && (
                  <ListaPlantillas
                     plantillas={plantillas}
                     onCrear={iniciarCreacion}
                     onEditar={iniciarEdicion}
                     onEliminar={handleEliminar}
                     contarFuncionalidades={funcionalidadesHook.contarFuncionalidades}
                     obtenerNombrePlantillaEtiquetas={etiquetasHook.obtenerNombrePlantilla}
                  />
               )}

               {/* MODO CREAR/EDITAR */}
               {(modo === "crear" || modo === "editar") && (
                  <FormularioPlantilla
                     error={error}
                     nombre={nombre}
                     setNombre={setNombre}
                     descripcion={descripcion}
                     setDescripcion={setDescripcion}
                     nuevaFunc={funcionalidadesHook.nuevaFunc}
                     setNuevaFunc={funcionalidadesHook.setNuevaFunc}
                     onAgregarFuncionalidad={handleAgregarFuncionalidad}
                     funcionalidades={funcionalidadesHook.funcionalidades}
                     onToggleFuncionalidad={funcionalidadesHook.toggleFuncionalidad}
                     onMoverArriba={funcionalidadesHook.moverFuncionalidadArriba}
                     onMoverAbajo={funcionalidadesHook.moverFuncionalidadAbajo}
                     onEliminarFuncionalidad={funcionalidadesHook.eliminarFuncionalidad}
                     onCambiarEtiqueta={funcionalidadesHook.cambiarEtiquetaRegistro}
                     onCambiarValorRegistro={funcionalidadesHook.cambiarValorRegistro}
                     onCambiarTransformadorRegistro={funcionalidadesHook.cambiarTransformadorRegistro}
                     obtenerTIs={obtenerTIs}
                     obtenerTVs={obtenerTVs}
                     obtenerRelaciones={obtenerRelaciones}
                     etiquetasHook={etiquetasHook}
                     onGuardarPlantillaEtiquetas={handleGuardarPlantillaEtiquetas}
                  />
               )}
            </div>

            {/* Footer */}
            <div className="modal-plantillas-footer">
               {modo === "lista" ? (
                  <button className="modal-plantillas-btn-cerrar" onClick={onCerrar}>Cerrar</button>
               ) : (
                  <>
                     <button className="modal-plantillas-btn-cancelar" onClick={resetFormulario}>Cancelar</button>
                     <button className="modal-plantillas-btn-guardar" onClick={handleGuardar}>
                        {modo === "crear" ? "Crear Plantilla" : "Guardar Cambios"}
                     </button>
                  </>
               )}
            </div>
         </div>
      </div>
   );
};

// ============================================
// COMPONENTES AUXILIARES
// ============================================

/**
 * Lista de plantillas existentes
 */
const ListaPlantillas = ({
   plantillas,
   onCrear,
   onEditar,
   onEliminar,
   contarFuncionalidades,
   obtenerNombrePlantillaEtiquetas
}) => (
   <>
      <button className="modal-plantillas-btn-crear" onClick={onCrear}>
         + Nueva Plantilla
      </button>

      {plantillas.length === 0 ? (
         <div className="modal-plantillas-vacio">
            <span className="modal-plantillas-vacio-icono">üìã</span>
            <p>No hay plantillas creadas</p>
            <p className="modal-plantillas-hint">Crea una plantilla para empezar a configurar rel√©s</p>
         </div>
      ) : (
         <div className="modal-plantillas-lista">
            {plantillas.map((plantilla) => (
               <div key={plantilla.id} className="modal-plantillas-item">
                  <div className="modal-plantillas-item-info">
                     <span className="modal-plantillas-item-nombre">üìã {plantilla.nombre}</span>
                     {plantilla.descripcion && (
                        <span className="modal-plantillas-item-desc">{plantilla.descripcion}</span>
                     )}
                     <span className="modal-plantillas-item-func">
                        {contarFuncionalidades(plantilla)} funcionalidades
                        {obtenerNombrePlantillaEtiquetas(plantilla.plantillaEtiquetasId) && (
                           <> ¬∑ Panel: {obtenerNombrePlantillaEtiquetas(plantilla.plantillaEtiquetasId)}</>
                        )}
                     </span>
                  </div>
                  <div className="modal-plantillas-item-acciones">
                     <button className="modal-plantillas-btn-editar" onClick={() => onEditar(plantilla)} title="Editar">
                        Editar
                     </button>
                     <button className="modal-plantillas-btn-eliminar" onClick={() => onEliminar(plantilla)} title="Eliminar">
                        Eliminar
                     </button>
                  </div>
               </div>
            ))}
         </div>
      )}
   </>
);

/**
 * Formulario de creaci√≥n/edici√≥n de plantilla
 */
const FormularioPlantilla = ({
   error,
   nombre,
   setNombre,
   descripcion,
   setDescripcion,
   nuevaFunc,
   setNuevaFunc,
   onAgregarFuncionalidad,
   funcionalidades,
   onToggleFuncionalidad,
   onMoverArriba,
   onMoverAbajo,
   onEliminarFuncionalidad,
   onCambiarEtiqueta,
   onCambiarValorRegistro,
   onCambiarTransformadorRegistro,
   obtenerTIs,
   obtenerTVs,
   obtenerRelaciones,
   etiquetasHook,
   onGuardarPlantillaEtiquetas,
}) => (
   <div className="modal-plantillas-formulario">
      {error && <div className="modal-plantillas-error">{error}</div>}

      <div className="modal-plantillas-campo">
         <label>Nombre de la plantilla *</label>
         <input
            type="text"
            value={nombre}
            onChange={(e) => setNombre(e.target.value)}
            placeholder="Ej: FE03 - Feeder con Autorecierre"
         />
      </div>

      <div className="modal-plantillas-campo">
         <label>Descripci√≥n (opcional)</label>
         <input
            type="text"
            value={descripcion}
            onChange={(e) => setDescripcion(e.target.value)}
            placeholder="Ej: Alimentadores sin medici√≥n de tensi√≥n"
         />
      </div>

      {/* Secci√≥n para agregar funcionalidad */}
      <SeccionAgregarFuncionalidad
         nuevaFunc={nuevaFunc}
         setNuevaFunc={setNuevaFunc}
         onAgregar={onAgregarFuncionalidad}
      />

      {/* Lista de funcionalidades */}
      {funcionalidades.length > 0 ? (
         <SeccionFuncionalidades
            funcionalidades={funcionalidades}
            onToggle={onToggleFuncionalidad}
            onMoverArriba={onMoverArriba}
            onMoverAbajo={onMoverAbajo}
            onEliminar={onEliminarFuncionalidad}
            onCambiarEtiqueta={onCambiarEtiqueta}
            onCambiarValorRegistro={onCambiarValorRegistro}
            onCambiarTransformadorRegistro={onCambiarTransformadorRegistro}
            obtenerTIs={obtenerTIs}
            obtenerTVs={obtenerTVs}
            obtenerRelaciones={obtenerRelaciones}
         />
      ) : (
         <div className="modal-plantillas-vacio-func">
            <p>No hay funcionalidades agregadas</p>
            <p className="modal-plantillas-hint">Usa el formulario de arriba para agregar funcionalidades</p>
         </div>
      )}

      {/* Secci√≥n de Etiquetas de Bits (LEDs) */}
      <SeccionEtiquetasBits
         etiquetasHook={etiquetasHook}
         onGuardarPlantilla={onGuardarPlantillaEtiquetas}
      />
   </div>
);

/**
 * Secci√≥n para agregar nueva funcionalidad
 */
const SeccionAgregarFuncionalidad = ({ nuevaFunc, setNuevaFunc, onAgregar }) => (
   <div className="modal-plantillas-seccion">
      <h4>Agregar Funcionalidad</h4>
      <div className="modal-plantillas-agregar-func">
         <div className="modal-plantillas-agregar-row">
            <div className="modal-plantillas-agregar-campo">
               <label>Nombre</label>
               <input
                  type="text"
                  value={nuevaFunc.nombre}
                  onChange={(e) => setNuevaFunc((prev) => ({ ...prev, nombre: e.target.value }))}
                  placeholder="Ej: Corrientes de Fase"
               />
            </div>
            <div className="modal-plantillas-agregar-campo modal-plantillas-agregar-campo--peque√±o">
               <label>Cant. Reg.</label>
               <input
                  type="number"
                  value={nuevaFunc.cantidad}
                  onChange={(e) => setNuevaFunc((prev) => ({ ...prev, cantidad: e.target.value }))}
                  min={1}
                  max={20}
               />
            </div>
            <div className="modal-plantillas-agregar-campo modal-plantillas-agregar-campo--categoria">
               <label>Categor√≠a</label>
               <select
                  value={nuevaFunc.categoria}
                  onChange={(e) => setNuevaFunc((prev) => ({ ...prev, categoria: e.target.value }))}
               >
                  {Object.values(CATEGORIAS_FUNCIONALIDADES).map((cat) => (
                     <option key={cat.id} value={cat.id}>{cat.icono} {cat.nombre}</option>
                  ))}
               </select>
            </div>
            <button type="button" className="modal-plantillas-btn-agregar" onClick={onAgregar}>
               + Agregar
            </button>
         </div>
      </div>
   </div>
);

/**
 * Lista de funcionalidades agrupadas por categor√≠a
 */
const SeccionFuncionalidades = ({
   funcionalidades,
   onToggle,
   onMoverArriba,
   onMoverAbajo,
   onEliminar,
   onCambiarEtiqueta,
   onCambiarValorRegistro,
   onCambiarTransformadorRegistro,
   obtenerTIs,
   obtenerTVs,
   obtenerRelaciones,
}) => (
   <div className="modal-plantillas-seccion">
      <h4>Funcionalidades ({funcionalidades.length})</h4>

      {Object.values(CATEGORIAS_FUNCIONALIDADES).map((categoria) => {
         const funcsDeCategoria = funcionalidades.filter(
            (f) => (f.categoria || "mediciones") === categoria.id
         );

         if (funcsDeCategoria.length === 0) return null;

         return (
            <div key={categoria.id} className="modal-plantillas-categoria">
               <h5>{categoria.icono} {categoria.nombre}</h5>
               <div className="modal-plantillas-func-lista">
                  {funcsDeCategoria.map((func) => (
                     <TarjetaFuncionalidad
                        key={func.id}
                        func={func}
                        categoria={categoria}
                        onToggle={onToggle}
                        onMoverArriba={onMoverArriba}
                        onMoverAbajo={onMoverAbajo}
                        onEliminar={onEliminar}
                        onCambiarEtiqueta={onCambiarEtiqueta}
                        onCambiarValorRegistro={onCambiarValorRegistro}
                        onCambiarTransformadorRegistro={onCambiarTransformadorRegistro}
                        obtenerTIs={obtenerTIs}
                        obtenerTVs={obtenerTVs}
                        obtenerRelaciones={obtenerRelaciones}
                     />
                  ))}
               </div>
            </div>
         );
      })}
   </div>
);

/**
 * Tarjeta de una funcionalidad individual
 */
const TarjetaFuncionalidad = ({
   func,
   categoria,
   onToggle,
   onMoverArriba,
   onMoverAbajo,
   onEliminar,
   onCambiarEtiqueta,
   onCambiarValorRegistro,
   onCambiarTransformadorRegistro,
   obtenerTIs,
   obtenerTVs,
   obtenerRelaciones,
}) => (
   <div className={`modal-plantillas-func-card ${func.habilitado ? "activo" : "inactivo"}`}>
      <div className="modal-plantillas-func-header">
         <label className="modal-plantillas-func-check">
            <input
               type="checkbox"
               checked={func.habilitado}
               onChange={() => onToggle(func.id)}
            />
            <span className="modal-plantillas-func-nombre">{func.nombre}</span>
         </label>
         <div className="modal-plantillas-func-acciones">
            <button type="button" className="modal-plantillas-func-mover" onClick={() => onMoverArriba(func.id)} title="Mover arriba">‚ñ≤</button>
            <button type="button" className="modal-plantillas-func-mover" onClick={() => onMoverAbajo(func.id)} title="Mover abajo">‚ñº</button>
            <button type="button" className="modal-plantillas-func-eliminar" onClick={() => onEliminar(func.id)} title="Eliminar funcionalidad">√ó</button>
         </div>
      </div>

      <div className="modal-plantillas-registros">
         {func.registros.map((reg, index) => (
            <div key={index} className="modal-plantillas-registro-item">
               <input
                  type="text"
                  className="modal-plantillas-registro-etiqueta"
                  value={reg.etiqueta}
                  onChange={(e) => onCambiarEtiqueta(func.id, index, e.target.value)}
                  placeholder={`Etiqueta ${index + 1}`}
                  disabled={!func.habilitado}
               />
               <span className="modal-plantillas-registro-separador">‚Üí</span>
               <input
                  type="number"
                  className="modal-plantillas-registro-valor"
                  value={reg.valor}
                  onChange={(e) => onCambiarValorRegistro(func.id, index, e.target.value)}
                  placeholder={`${137 + index}`}
                  disabled={!func.habilitado}
                  min={0}
               />
               {categoria.id === "mediciones" && (
                  <DropdownTransformador
                     value={reg.transformadorId || ""}
                     onChange={(id) => onCambiarTransformadorRegistro(func.id, index, id)}
                     disabled={!func.habilitado}
                     tis={obtenerTIs()}
                     tvs={obtenerTVs()}
                     relaciones={obtenerRelaciones()}
                  />
               )}
            </div>
         ))}
      </div>
   </div>
);

/**
 * Secci√≥n de etiquetas de bits (LEDs)
 */
const SeccionEtiquetasBits = ({ etiquetasHook, onGuardarPlantilla }) => (
   <div className="modal-plantillas-seccion modal-plantillas-seccion-etiquetas">
      <div
         className="modal-plantillas-seccion-header-colapsable"
         onClick={() => etiquetasHook.setSeccionAbierta(!etiquetasHook.seccionAbierta)}
      >
         <h4>
            <span className={`modal-plantillas-chevron ${etiquetasHook.seccionAbierta ? "abierto" : ""}`}>‚ñ∂</span>
            Etiquetas de LEDs (Registro 172)
            {etiquetasHook.contarEtiquetasConfiguradas() > 0 && (
               <span className="modal-plantillas-badge">{etiquetasHook.contarEtiquetasConfiguradas()}</span>
            )}
         </h4>
         <span className="modal-plantillas-hint-inline">Define qu√© significa cada LED del panel frontal</span>
      </div>

      {etiquetasHook.seccionAbierta && (
         <div className="modal-plantillas-etiquetas-contenido">
            {/* Selector de plantilla */}
            <div className="modal-plantillas-etiquetas-acciones">
               <label>Plantilla:</label>
               <select
                  onChange={(e) => {
                     if (e.target.value === "__nueva__") {
                        etiquetasHook.iniciarNuevaPlantilla();
                     } else if (e.target.value) {
                        etiquetasHook.aplicarPlantilla(e.target.value);
                     } else {
                        etiquetasHook.limpiarEtiquetas();
                     }
                  }}
                  value={etiquetasHook.modoNuevaPlantilla ? "__nueva__" : etiquetasHook.plantillaSeleccionada}
               >
                  <option value="">Seleccionar...</option>
                  <option value="__nueva__">+ Nueva plantilla...</option>
                  <optgroup label="Predefinidas">
                     {Object.entries(PLANTILLAS_ETIQUETAS_LEDS).map(([key, plantilla]) => (
                        <option key={key} value={key}>{plantilla.nombre}</option>
                     ))}
                  </optgroup>
                  {Object.keys(etiquetasHook.plantillasPersonalizadas).length > 0 && (
                     <optgroup label="Mis plantillas">
                        {Object.entries(etiquetasHook.plantillasPersonalizadas).map(([key, plantilla]) => (
                           <option key={key} value={key}>{plantilla.nombre}</option>
                        ))}
                     </optgroup>
                  )}
               </select>
               {etiquetasHook.contarEtiquetasConfiguradas() > 0 && !etiquetasHook.modoNuevaPlantilla && (
                  <button type="button" className="modal-plantillas-btn-limpiar" onClick={etiquetasHook.limpiarEtiquetas}>
                     Limpiar
                  </button>
               )}
            </div>

            {/* Formulario para nueva plantilla */}
            {etiquetasHook.modoNuevaPlantilla && (
               <div className="modal-plantillas-nueva-plantilla-etiquetas">
                  <div className="modal-plantillas-nueva-plantilla-header">
                     <input
                        type="text"
                        className="modal-plantillas-nueva-plantilla-nombre"
                        value={etiquetasHook.nombreNuevaPlantilla}
                        onChange={(e) => etiquetasHook.setNombreNuevaPlantilla(e.target.value)}
                        placeholder="Nombre de la plantilla..."
                     />
                     <div className="modal-plantillas-nueva-plantilla-botones">
                        <button type="button" className="modal-plantillas-btn-guardar-etiquetas" onClick={onGuardarPlantilla} title="Guardar plantilla">
                           Guardar
                        </button>
                        <button type="button" className="modal-plantillas-btn-cancelar-etiquetas" onClick={etiquetasHook.cancelarNuevaPlantilla} title="Cancelar">
                           Cancelar
                        </button>
                     </div>
                  </div>
               </div>
            )}

            {/* Lista de bits */}
            <div className="modal-plantillas-bits-lista">
               {Array.from({ length: etiquetasHook.cantidadBits }, (_, bit) => (
                  <div key={bit} className="modal-plantillas-bit-item">
                     <span className="modal-plantillas-bit-numero">Bit {bit}:</span>
                     <input
                        type="text"
                        className="modal-plantillas-bit-etiqueta"
                        value={etiquetasHook.etiquetasBits[bit]?.texto || ""}
                        onChange={(e) => etiquetasHook.cambiarEtiquetaBit(bit, e.target.value)}
                        placeholder={`LED ${bit + 1} (sin etiqueta)`}
                     />
                     <select
                        className={`modal-plantillas-bit-severidad severidad-${etiquetasHook.etiquetasBits[bit]?.severidad || "info"}`}
                        value={etiquetasHook.etiquetasBits[bit]?.severidad || "info"}
                        onChange={(e) => etiquetasHook.cambiarSeveridadBit(bit, e.target.value)}
                     >
                        {SEVERIDADES_DISPONIBLES.map((sev) => (
                           <option key={sev.id} value={sev.id}>{sev.nombre}</option>
                        ))}
                     </select>
                  </div>
               ))}
            </div>

            {/* Botones agregar/quitar bits */}
            {(etiquetasHook.modoNuevaPlantilla || etiquetasHook.contarEtiquetasConfiguradas() > 0) && (
               <div className="modal-plantillas-bits-acciones">
                  <button type="button" className="modal-plantillas-btn-agregar-bit" onClick={etiquetasHook.agregarFilaBit} title="Agregar fila">
                     + Agregar bit
                  </button>
                  {etiquetasHook.cantidadBits > 1 && (
                     <button type="button" className="modal-plantillas-btn-quitar-bit" onClick={etiquetasHook.quitarFilaBit} title="Quitar √∫ltima fila">
                        ‚àí Quitar bit
                     </button>
                  )}
               </div>
            )}

            {/* Plantillas personalizadas guardadas */}
            {Object.keys(etiquetasHook.plantillasPersonalizadas).length > 0 && !etiquetasHook.modoNuevaPlantilla && (
               <div className="modal-plantillas-etiquetas-guardadas">
                  <span className="modal-plantillas-etiquetas-guardadas-label">Mis plantillas guardadas:</span>
                  <div className="modal-plantillas-etiquetas-guardadas-lista">
                     {Object.entries(etiquetasHook.plantillasPersonalizadas).map(([key, plantilla]) => (
                        <div key={key} className="modal-plantillas-etiqueta-guardada">
                           <span>{plantilla.nombre}</span>
                           <button
                              type="button"
                              className="modal-plantillas-btn-eliminar-etiqueta"
                              onClick={() => etiquetasHook.eliminarPlantillaPersonalizada(key)}
                              title="Eliminar plantilla"
                           >
                              √ó
                           </button>
                        </div>
                     ))}
                  </div>
               </div>
            )}
         </div>
      )}
   </div>
);

export default ModalPlantillasRele;

// ===== ./src/paginas/PaginaAlimentadores/componentes/modales/rele/ModalTransformadores.jsx =====

import { useState, useEffect } from "react";
import "./ModalTransformadores.css";

/**
 * Modal para gestionar transformadores de intensidad (TI) y voltaje (TV)
 */
// Configuraci√≥n de los tipos de transformadores
const TIPOS_CONFIG = {
  TI: {
    nombre: "T.I. (Intensidad)",
    nombreCorto: "T.I.",
    placeholder: "TI 200/1",
    ayudaFormula: "x * 200 / 1000",
    descripcionVacio: "intensidad",
  },
  TV: {
    nombre: "T.V. (Voltaje)",
    nombreCorto: "T.V.",
    placeholder: "TV 33kV",
    ayudaFormula: "x * 33000 / 10000",
    descripcionVacio: "voltaje",
  },
  REL: {
    nombre: "Relaci√≥n [ x : y ]",
    nombreCorto: "Relaci√≥n",
    placeholder: "Rel 1:100",
    ayudaFormula: "x * 100",
    descripcionVacio: "relaci√≥n",
  },
};

const ModalTransformadores = ({
  abierto,
  onCerrar,
  transformadores,
  onCrear,
  onActualizar,
  onEliminar,
  tipoInicial = "TI", // "TI", "TV" o "REL"
}) => {
  const [tipoActivo, setTipoActivo] = useState(tipoInicial);
  const [modoEdicion, setModoEdicion] = useState(null); // null | "crear" | id del transformador
  const [formData, setFormData] = useState({ nombre: "", formula: "" });
  const [confirmandoEliminar, setConfirmandoEliminar] = useState(null);

  // Actualizar tipo activo cuando cambia tipoInicial
  useEffect(() => {
    if (abierto) {
      setTipoActivo(tipoInicial);
    }
  }, [abierto, tipoInicial]);

  // Resetear estado al cerrar
  useEffect(() => {
    if (!abierto) {
      setModoEdicion(null);
      setFormData({ nombre: "", formula: "" });
      setConfirmandoEliminar(null);
    }
  }, [abierto]);

  if (!abierto) return null;

  const transformadoresFiltrados = transformadores.filter(
    (t) => t.tipo === tipoActivo
  );

  const handleNuevo = () => {
    setModoEdicion("crear");
    setFormData({ nombre: "", formula: "" });
  };

  const handleEditar = (transformador) => {
    setModoEdicion(transformador.id);
    setFormData({
      nombre: transformador.nombre,
      formula: transformador.formula,
    });
  };

  const handleCancelar = () => {
    setModoEdicion(null);
    setFormData({ nombre: "", formula: "" });
  };

  const handleGuardar = () => {
    if (!formData.nombre.trim() || !formData.formula.trim()) return;

    if (modoEdicion === "crear") {
      onCrear({
        tipo: tipoActivo,
        nombre: formData.nombre,
        formula: formData.formula,
      });
    } else {
      onActualizar(modoEdicion, {
        nombre: formData.nombre,
        formula: formData.formula,
      });
    }

    setModoEdicion(null);
    setFormData({ nombre: "", formula: "" });
  };

  const handleEliminar = (id) => {
    if (confirmandoEliminar === id) {
      onEliminar(id);
      setConfirmandoEliminar(null);
    } else {
      setConfirmandoEliminar(id);
    }
  };

  return (
    <div className="modal-transformadores-overlay">
      <div
        className="modal-transformadores"
      >
        <div className="modal-transformadores-header">
          <h3>Transformadores de Medida</h3>
          <button className="modal-transformadores-cerrar" onClick={onCerrar}>
            √ó
          </button>
        </div>

        {/* Tabs TI / TV / REL */}
        <div className="modal-transformadores-tabs">
          {Object.entries(TIPOS_CONFIG).map(([tipo, config]) => (
            <button
              key={tipo}
              className={`modal-transformadores-tab ${tipoActivo === tipo ? "activo" : ""}`}
              onClick={() => setTipoActivo(tipo)}
            >
              {config.nombre}
            </button>
          ))}
        </div>

        <div className="modal-transformadores-contenido">
          {/* Lista de transformadores */}
          <div className="modal-transformadores-lista">
            {transformadoresFiltrados.length === 0 ? (
              <div className="modal-transformadores-vacio">
                No hay transformadores de {TIPOS_CONFIG[tipoActivo].descripcionVacio} configurados
              </div>
            ) : (
              transformadoresFiltrados.map((t) => (
                <div
                  key={t.id}
                  className={`modal-transformadores-item ${modoEdicion === t.id ? "editando" : ""}`}
                >
                  {modoEdicion === t.id ? (
                    // Modo edici√≥n inline
                    <div className="modal-transformadores-form-vertical">
                      <input
                        type="text"
                        value={formData.nombre}
                        onChange={(e) =>
                          setFormData({ ...formData, nombre: e.target.value })
                        }
                        placeholder="Nombre"
                        className="modal-transformadores-input modal-transformadores-input-nombre"
                        autoFocus
                      />
                      <div className="modal-transformadores-form-fila">
                        <input
                          type="text"
                          value={formData.formula}
                          onChange={(e) =>
                            setFormData({ ...formData, formula: e.target.value })
                          }
                          placeholder="F√≥rmula (ej: x * 200 / 1000)"
                          className="modal-transformadores-input modal-transformadores-input-formula"
                        />
                        <button
                          className="modal-transformadores-btn-guardar"
                          onClick={handleGuardar}
                          disabled={!formData.nombre.trim() || !formData.formula.trim()}
                        >
                          Guardar
                        </button>
                        <button
                          className="modal-transformadores-btn-cancelar"
                          onClick={handleCancelar}
                        >
                          Cancelar
                        </button>
                      </div>
                    </div>
                  ) : (
                    // Modo visualizaci√≥n
                    <>
                      <div className="modal-transformadores-item-info">
                        <span className="modal-transformadores-item-nombre">
                          {t.nombre}
                        </span>
                        <span className="modal-transformadores-item-formula">
                          {t.formula}
                        </span>
                      </div>
                      <div className="modal-transformadores-item-acciones">
                        <button
                          className="modal-transformadores-btn-editar"
                          onClick={() => handleEditar(t)}
                          title="Editar"
                        >
                          ‚úèÔ∏è
                        </button>
                        <button
                          className={`modal-transformadores-btn-eliminar ${confirmandoEliminar === t.id ? "confirmar" : ""}`}
                          onClick={() => handleEliminar(t.id)}
                          title={confirmandoEliminar === t.id ? "Confirmar eliminaci√≥n" : "Eliminar"}
                        >
                          {confirmandoEliminar === t.id ? "¬øSeguro?" : "üóëÔ∏è"}
                        </button>
                      </div>
                    </>
                  )}
                </div>
              ))
            )}

            {/* Formulario para nuevo transformador */}
            {modoEdicion === "crear" && (
              <div className="modal-transformadores-item editando">
                <div className="modal-transformadores-form-vertical">
                  <input
                    type="text"
                    value={formData.nombre}
                    onChange={(e) =>
                      setFormData({ ...formData, nombre: e.target.value })
                    }
                    placeholder={`Nombre (ej: ${TIPOS_CONFIG[tipoActivo].placeholder})`}
                    className="modal-transformadores-input modal-transformadores-input-nombre"
                    autoFocus
                  />
                  <div className="modal-transformadores-form-fila">
                    <input
                      type="text"
                      value={formData.formula}
                      onChange={(e) =>
                        setFormData({ ...formData, formula: e.target.value })
                      }
                      placeholder="F√≥rmula (ej: x * 200 / 1000)"
                      className="modal-transformadores-input modal-transformadores-input-formula"
                    />
                    <button
                      className="modal-transformadores-btn-guardar"
                      onClick={handleGuardar}
                      disabled={!formData.nombre.trim() || !formData.formula.trim()}
                    >
                      Crear
                    </button>
                    <button
                      className="modal-transformadores-btn-cancelar"
                      onClick={handleCancelar}
                    >
                      Cancelar
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Bot√≥n agregar */}
          {modoEdicion === null && (
            <button
              className="modal-transformadores-btn-nuevo"
              onClick={handleNuevo}
            >
              + Nuevo {TIPOS_CONFIG[tipoActivo].nombreCorto}
            </button>
          )}

          {/* Ayuda */}
          <div className="modal-transformadores-ayuda">
            <strong>F√≥rmula:</strong> Use <code>x</code> para representar el valor le√≠do del registro.
            <br />
            Ejemplo: <code>{TIPOS_CONFIG[tipoActivo].ayudaFormula}</code> multiplica el valor por {tipoActivo === "REL" ? "100" : "200"} {tipoActivo !== "REL" && "y divide entre 1000"}.
          </div>
        </div>
      </div>
    </div>
  );
};

export default ModalTransformadores;

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/BarraNavegacion.jsx =====

// src/paginas/PaginaAlimentadores/componentes/navegacion/BarraNavegacion.jsx

import React, { useState } from "react";
import "./BarraNavegacion.css";            // estilos espec√≠ficos de la barra superior
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase";
import SelectorConfiguracion from "./SelectorConfiguracion.jsx";
import BotonGuardarCambios from "./BotonGuardarCambios.jsx";

/**
 * Barra de navegaci√≥n superior.
 * Muestra t√≠tulo, botones de selecci√≥n de puesto y controles globales.
 */
const BarraNavegacion = ({
	esCompacto,                             // true en pantallas angostas (modo compacto)
	puestos,                                // lista de puestos disponibles
	puestoSeleccionado,                     // puesto actualmente activo
	onSeleccionarPuesto,                    // callback al hacer clic en un bot√≥n de puesto
	onAbrirModalNuevoPuesto,                // callback para abrir modal "Nuevo puesto"
	onAbrirModalEditarPuestos,              // callback para abrir modal "Editar puestos"
	onAbrirModalConfigPuesto,               // callback para abrir modal de configuraci√≥n del puesto
	onAbrirModalConfigurarAgente,           // callback para abrir modal de configuraci√≥n del agente
	onAbrirModalGestionarAccesos,           // callback para abrir modal de gesti√≥n de accesos
	onAbrirModalPanelPermisos,              // callback para abrir modal de panel de permisos (solo superadmin)
	onSalir,                                // callback para cerrar sesi√≥n / volver al inicio
	onAbrirMenu,                            // callback para abrir el men√∫ lateral en modo compacto
	coloresSistema,                         // paleta de colores para botones de puesto
	estaPolling,                            // (alimId) => boolean - verifica si un alimentador est√° en polling
	onPlayStopClick,                        // (alimId) => void - alterna polling de un alimentador
}) => {
	const {
		hayCambiosPendientes,
		sincronizando,
		sincronizarCambios,
		descartarCambios,
		obtenerColorPuesto,
	} = usarContextoAlimentadores();

	// Estado para el di√°logo de confirmaci√≥n
	const [mostrarConfirmacion, setMostrarConfirmacion] = useState(false);

	// ===== L√ìGICA DEL BOT√ìN MAESTRO GLOBAL =====
	// Helper para verificar si un alimentador puede hacer polling (misma l√≥gica que ModalConfiguracionPuesto)
	const puedeHacerPolling = (alim) => {
		if (!alim.intervalo_consulta_ms || alim.intervalo_consulta_ms <= 0) return false;

		const cardDesign = alim.card_design || {};
		const superior = cardDesign.superior || {};
		const inferior = cardDesign.inferior || {};

		const tieneRegistrador = !!superior.registrador_id || !!inferior.registrador_id || !!alim.registrador_id;
		if (!tieneRegistrador) return false;

		// Verificar que al menos un box est√© habilitado con √≠ndice v√°lido
		const boxesSuperior = superior.boxes || [];
		const boxesInferior = inferior.boxes || [];
		const todosLosBoxes = [...boxesSuperior, ...boxesInferior];

		const tieneBoxHabilitado = todosLosBoxes.some(
			(box) => box.enabled && box.indice !== null && box.indice !== undefined && box.indice !== ""
		);

		return tieneBoxHabilitado;
	};

	const calcularEstadoGlobal = () => {
		if (!puestoSeleccionado) {
			return { alimentadoresConPolling: [], hayAlgunaCardDisponible: false, algunaCardMidiendo: false };
		}

		const alimentadores = puestoSeleccionado.alimentadores || [];

		// Filtrar solo los alimentadores que pueden hacer polling
		const alimentadoresConPolling = alimentadores.filter(puedeHacerPolling);

		const hayAlgunaCardDisponible = alimentadoresConPolling.length > 0;
		// Verificar si alg√∫n alimentador est√° actualmente en polling
		const algunaCardMidiendo = alimentadoresConPolling.some((alim) => estaPolling?.(alim.id));

		return { alimentadoresConPolling, hayAlgunaCardDisponible, algunaCardMidiendo };
	};

	const { alimentadoresConPolling, hayAlgunaCardDisponible, algunaCardMidiendo } = calcularEstadoGlobal();

	// Abre el di√°logo de confirmaci√≥n
	const handleClickMaestro = () => {
		if (!hayAlgunaCardDisponible) return;
		setMostrarConfirmacion(true);
	};

	// Ejecuta la acci√≥n despu√©s de confirmar - inicia o detiene el polling de todos los alimentadores
	const ejecutarMaestroGlobal = () => {
		setMostrarConfirmacion(false);

		if (algunaCardMidiendo) {
			// Detener todos los que est√°n en polling
			alimentadoresConPolling.forEach((alim) => {
				if (estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		} else {
			// Iniciar todos los disponibles
			alimentadoresConPolling.forEach((alim) => {
				if (!estaPolling?.(alim.id)) {
					onPlayStopClick?.(alim.id);
				}
			});
		}
	};

	return (
		<>
		<nav
			className={
				"alim-navbar" + (esCompacto ? " alim-navbar-compact" : "")
			}                                  // aplica clase extra cuando est√° en modo compacto
		>
			{esCompacto ? (
				<>
					{/* Bot√≥n men√∫ (solo en modo compacto / mobile) */}
					<button
						type="button"
						className="alim-navbar-menu-btn"
						onClick={onAbrirMenu}
						aria-label="Abrir men√∫"
					>
						‚ò∞
					</button>

					{/* Centro: nombre del puesto o texto gen√©rico */}
					{puestoSeleccionado ? (
						<button
							type="button"
							className="alim-current-puesto-btn"
							onClick={onAbrirModalConfigPuesto}
							title="Configurar puesto"
						>
							{puestoSeleccionado.nombre}
						</button>
					) : (
						<div className="alim-navbar-compact-title">
							Panel de Alimentadores
						</div>
					)}

					{/* Bot√≥n maestro a la derecha (solo si hay puesto seleccionado) */}
					{puestoSeleccionado && (
						<button
							type="button"
							className={`alim-maestro-btn ${algunaCardMidiendo ? "alim-maestro-btn--stop" : ""} ${!hayAlgunaCardDisponible ? "alim-maestro-btn--disabled" : ""}`}
							onClick={handleClickMaestro}
							disabled={!hayAlgunaCardDisponible}
							title={!hayAlgunaCardDisponible ? "Sin registradores con configuraci√≥n v√°lida" : algunaCardMidiendo ? "Detener todas las mediciones" : "Iniciar todas las mediciones"}
						>
							{!hayAlgunaCardDisponible ? "‚äò" : algunaCardMidiendo ? "‚èπ" : "‚ñ∂"}
						</button>
					)}
				</>
			) : (
				<>
					{/* Lado izquierdo: t√≠tulo grande y nombre del puesto actual */}
					<div className="alim-navbar-left">
						<h1 className="alim-title">Panel de Alimentadores</h1>

						{puestoSeleccionado && (
							<div className="alim-puesto-row">
								<button
									type="button"
									className="alim-puesto-nombre-btn"
									onClick={onAbrirModalConfigPuesto}
									title="Configurar puesto"
								>
									{puestoSeleccionado.nombre}
								</button>
								<button
									type="button"
									className={`alim-maestro-btn-texto ${algunaCardMidiendo ? "alim-maestro-btn-texto--stop" : ""} ${!hayAlgunaCardDisponible ? "alim-maestro-btn-texto--disabled" : ""}`}
									onClick={handleClickMaestro}
									disabled={!hayAlgunaCardDisponible}
									title={!hayAlgunaCardDisponible ? "Sin registradores con configuraci√≥n v√°lida" : algunaCardMidiendo ? "Detener todas las mediciones" : "Iniciar todas las mediciones"}
								>
									{!hayAlgunaCardDisponible ? "‚äò" : algunaCardMidiendo ? "PARAR MEDICIONES" : "INICIAR MEDICIONES"}
								</button>
							</div>
						)}
					</div>

					{/* Lado derecho: botones de puestos + controles */}
					<div className="alim-nav-buttons">
						{/* Bloque 2: botones de puestos (uno por cada puesto creado) */}
						<div className="alim-nav-bloque-puestos">
							{puestos.map((p) => (
								<button
									key={p.id}
									className={
										"alim-btn" +
										(puestoSeleccionado &&
										puestoSeleccionado.id === p.id
											? " alim-btn-active"
											: "")
									}
									onClick={() => onSeleccionarPuesto(p.id)}
									style={{
										backgroundColor:
											obtenerColorPuesto(p.id) || coloresSistema[0],
									}}                           // usa el color configurado (con soporte para preferencias de invitado)
								>
									{p.nombre}
								</button>
							))}
						</div>

						{/* Bloque 1: botones de control fijo (nuevo, editar, config, salir) */}
						<div className="alim-nav-bloque-controles">
							<BotonGuardarCambios
								hayCambios={hayCambiosPendientes}
								sincronizando={sincronizando}
								onGuardar={sincronizarCambios}
								onDescartar={descartarCambios}
							/>

							<SelectorConfiguracion
								onAbrirModalNuevoPuesto={onAbrirModalNuevoPuesto}
								onAbrirModalEditarPuestos={onAbrirModalEditarPuestos}
								onAbrirModalConfigurarAgente={onAbrirModalConfigurarAgente}
								onAbrirModalGestionarAccesos={onAbrirModalGestionarAccesos}
								onAbrirModalPanelPermisos={onAbrirModalPanelPermisos}
								puestosLength={puestos.length}
							/>

							<button
								type="button"
								className="alim-btn-exit"
								onClick={onSalir}
							>
								Salir
							</button>
						</div>
					</div>
				</>
			)}
		</nav>

		{/* Di√°logo de confirmaci√≥n para el bot√≥n maestro */}
		{mostrarConfirmacion && (
			<div className="alim-confirmacion-overlay">
				<div className="alim-confirmacion">
					<div className="alim-confirmacion__icono">
						{algunaCardMidiendo ? "‚èπÔ∏è" : "‚ñ∂Ô∏è"}
					</div>
					<h3 className="alim-confirmacion__titulo">
						{algunaCardMidiendo ? "¬øDetener todas las mediciones?" : "¬øIniciar todas las mediciones?"}
					</h3>
					<p className="alim-confirmacion__mensaje">
						{algunaCardMidiendo
							? "Se detendr√°n las mediciones de todos los registradores activos en este puesto."
							: "Se iniciar√°n las mediciones de todos los registradores con configuraci√≥n v√°lida en este puesto."}
					</p>
					<div className="alim-confirmacion__botones">
						<button
							type="button"
							className="alim-confirmacion__btn alim-confirmacion__btn--cancelar"
							onClick={() => setMostrarConfirmacion(false)}
						>
							Cancelar
						</button>
						<button
							type="button"
							className={`alim-confirmacion__btn ${algunaCardMidiendo ? "alim-confirmacion__btn--detener" : "alim-confirmacion__btn--iniciar"}`}
							onClick={ejecutarMaestroGlobal}
						>
							{algunaCardMidiendo ? "Detener" : "Iniciar"}
						</button>
					</div>
				</div>
			</div>
		)}
		</>
	);
};

export default BarraNavegacion;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (BarraNavegacion.jsx)

 - Este componente es la barra superior fija del panel de alimentadores.
   En modo escritorio muestra el t√≠tulo, el puesto actual y todos los botones
   de puestos; en modo compacto solo muestra el bot√≥n de men√∫ y el t√≠tulo.

 - La prop `esCompacto` viene de `VistaAlimentadores` y decide si se muestra la
   versi√≥n completa (desktop) o la versi√≥n reducida (mobile).

 - El array `puestos` se recorre para dibujar un bot√≥n por puesto; el que est√°
   seleccionado recibe la clase `alim-btn-active` y el color que tenga
   configurado (`p.color`).

 - Los callbacks `onSeleccionarPuesto`, `onAbrirModalNuevoPuesto`,
   `onAbrirModalEditarPuestos` y `onSalir` se conectan directamente con la
   l√≥gica del contexto y la navegaci√≥n, pero este componente se limita a
   dispararlos cuando corresponde (no sabe la l√≥gica interna).
---------------------------------------------------------------------------*/}

{/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (BarraNavegacion.jsx)

0) Visi√≥n general del componente

   `BarraNavegacion` es la barra superior fija del panel de alimentadores.

   - En modo escritorio:
       ‚Ä¢ muestra el t√≠tulo grande ‚ÄúPanel de Alimentadores‚Äù,
       ‚Ä¢ debajo, el nombre del puesto actualmente seleccionado,
       ‚Ä¢ a la derecha, todos los botones de puestos,
       ‚Ä¢ y los controles globales: nuevo puesto, editar puestos, salir.

   - En modo compacto (pantallas angostas):
       ‚Ä¢ muestra solo:
           - un bot√≥n de men√∫ (‚ò∞) para abrir el panel lateral,
           - un t√≠tulo centrado (nombre del puesto actual o texto gen√©rico).


1) Props del componente

   const BarraNavegacion = ({
     esCompacto,
     puestos,
     puestoSeleccionado,
     onSeleccionarPuesto,
     onAbrirModalNuevoPuesto,
     onAbrirModalEditarPuestos,
     onSalir,
     onAbrirMenu,
     coloresSistema,
   }) => { ... }

   - `esCompacto` (boolean):
       ‚Ä¢ true  ‚Üí se usa el layout reducido (mobile),
       ‚Ä¢ false ‚Üí se usa el layout completo (desktop).

   - `puestos` (array):
       ‚Ä¢ lista de todos los puestos creados,
       ‚Ä¢ cada puesto suele tener `{ id, nombre, color, ... }`.

   - `puestoSeleccionado` (objeto o null):
       ‚Ä¢ el puesto actualmente activo,
       ‚Ä¢ si existe, se muestra su nombre y se marca su bot√≥n.

   - `onSeleccionarPuesto(idPuesto)`:
       ‚Ä¢ callback que se llama al hacer clic en el bot√≥n de un puesto.

   - `onAbrirModalNuevoPuesto()`:
       ‚Ä¢ se ejecuta al hacer clic en el bot√≥n "+".

   - `onAbrirModalEditarPuestos()`:
       ‚Ä¢ se ejecuta al hacer clic en el bot√≥n de edici√≥n (‚úé).

   - `onSalir()`:
       ‚Ä¢ se ejecuta al hacer clic en el bot√≥n ‚ÄúSalir‚Äù (volver al login).

   - `onAbrirMenu()`:
       ‚Ä¢ se usa solo en modo compacto para abrir el men√∫ lateral.

   - `coloresSistema` (array de colores):
       ‚Ä¢ paleta de fallback para botones de puestos,
       ‚Ä¢ si un puesto no tiene `color`, se usa `coloresSistema[0]`.


2) Contenedor principal <nav>

   return (
     <nav
       className={
         "alim-navbar" + (esCompacto ? " alim-navbar-compact" : "")
       }
     >
       {esCompacto ? ( ... ) : ( ... )}
     </nav>
   );

   - El `<nav>` usa siempre la clase base `"alim-navbar"`.

   - Si `esCompacto` es true, agrega tambi√©n `"alim-navbar-compact"`,
     que aplica estilos espec√≠ficos para el modo reducido (CSS).

   - Dentro del nav se hace un condicional:
       ‚Ä¢ si `esCompacto` es true ‚Üí renderiza la versi√≥n compacta,
       ‚Ä¢ si es false ‚Üí renderiza la versi√≥n completa.


3) Modo compacto (mobile)

   {esCompacto ? (
     <>
       <button ... onClick={onAbrirMenu}>‚ò∞</button>
       <div className="alim-navbar-compact-title">
         {puestoSeleccionado ? puestoSeleccionado.nombre : "Panel de Alimentadores"}
       </div>
     </>
   ) : ( ... )}

   - Bot√≥n de men√∫:
       ‚Ä¢ solo aparece en modo compacto,
       ‚Ä¢ tiene texto ‚Äú‚ò∞‚Äù (√≠cono tipo hamburguesa),
       ‚Ä¢ `onClick={onAbrirMenu}`: dispara la apertura del men√∫ lateral,
       ‚Ä¢ `aria-label="Abrir men√∫"`: mejora la accesibilidad.

   - T√≠tulo centrado:
       ‚Ä¢ si hay `puestoSeleccionado`, muestra su nombre,
       ‚Ä¢ si no, muestra el texto gen√©rico `"Panel de Alimentadores"`.

   - En este modo NO se muestran los botones de puestos ni los controles
     de nuevo/editar/salir; esas funciones se acceden desde el men√∫ lateral.


4) Modo escritorio (layout completo)

   : (
     <>
       // Lado izquierdo: t√≠tulo y puesto actual 
       <div className="alim-navbar-left">
         <h1 className="alim-title">Panel de Alimentadores</h1>

         {puestoSeleccionado && (
           <div className="alim-current-puesto">
             {puestoSeleccionado.nombre}
           </div>
         )}
       </div>

       // Lado derecho: botones de puestos + controles 
       <div className="alim-nav-buttons">
         // Bloque de puestos 
         <div className="alim-nav-bloque-puestos">
           {puestos.map((p) => (
             <button
               key={p.id}
               className={
                 "alim-btn" +
                 (puestoSeleccionado && puestoSeleccionado.id === p.id
                   ? " alim-btn-active"
                   : "")
               }
               onClick={() => onSeleccionarPuesto(p.id)}
               style={{
                 backgroundColor: p.color || coloresSistema[0],
               }}
             >
               {p.nombre}
             </button>
           ))}
         </div>

         // Bloque de controles
         <div className="alim-nav-bloque-controles">
           <button ... onClick={onAbrirModalNuevoPuesto}>+</button>
           <button ... onClick={onAbrirModalEditarPuestos} disabled={puestos.length === 0}>‚úé</button>
           <button ... onClick={onSalir}>Salir</button>
         </div>
       </div>
     </>
   )

   4.1) Lado izquierdo

   - `<h1 className="alim-title">Panel de Alimentadores</h1>`:
       ‚Ä¢ t√≠tulo fijo de la pantalla.

   - `puestoSeleccionado && <div className="alim-current-puesto">...`:
       ‚Ä¢ si hay puesto seleccionado, se muestra su nombre debajo del t√≠tulo,
       ‚Ä¢ si no hay, directamente no se renderiza ese div.


   4.2) Botones de puestos (lado derecho, bloque de puestos)

   {puestos.map((p) => (
     <button
       key={p.id}
       className={
         "alim-btn" +
         (puestoSeleccionado && puestoSeleccionado.id === p.id
           ? " alim-btn-active"
           : "")
       }
       onClick={() => onSeleccionarPuesto(p.id)}
       style={{ backgroundColor: p.color || coloresSistema[0] }}
     >
       {p.nombre}
     </button>
   ))}

   - Se recorre el array `puestos` y se dibuja un bot√≥n por cada puesto.

   - `key={p.id}`:
       ‚Ä¢ clave √∫nica para que React identifique cada bot√≥n.

   - `className`:
       ‚Ä¢ siempre tiene la clase base `"alim-btn"`,
       ‚Ä¢ si este puesto es el seleccionado (`puestoSeleccionado.id === p.id`),
         se agrega `"alim-btn-active"`, lo que aplica estilos de ‚Äúbot√≥n activo‚Äù.

   - `onClick={() => onSeleccionarPuesto(p.id)}`:
       ‚Ä¢ al hacer clic, se llama al callback con el id del puesto,
       ‚Ä¢ la l√≥gica de cambio de puesto vive afuera, en la vista/contexto.

   - `style={{ backgroundColor: p.color || coloresSistema[0] }}`:
       ‚Ä¢ usa el color configurado en el puesto (`p.color`),
       ‚Ä¢ si el puesto no tiene color, cae al primer color del sistema.


   4.3) Botones de control (lado derecho, bloque de controles)

   <div className="alim-nav-bloque-controles">
     <button
       type="button"
       className="alim-btn alim-btn-add"
       onClick={onAbrirModalNuevoPuesto}
     >
       <span className="alim-btn-add-icon">+</span>
     </button>

     <button
       type="button"
       className="alim-btn alim-btn-edit"
       onClick={onAbrirModalEditarPuestos}
       disabled={puestos.length === 0}
     >
       ‚úé
     </button>

     <button
       type="button"
       className="alim-btn-exit"
       onClick={onSalir}
     >
       Salir
     </button>
   </div>

   - Bot√≥n de ‚Äúnuevo puesto‚Äù:
       ‚Ä¢ muestra un ‚Äú+‚Äù,
       ‚Ä¢ dispara `onAbrirModalNuevoPuesto` ‚Üí abre modal de alta de puesto.

   - Bot√≥n de ‚Äúeditar puestos‚Äù:
       ‚Ä¢ muestra un √≠cono ‚úé,
       ‚Ä¢ dispara `onAbrirModalEditarPuestos`,
       ‚Ä¢ est√° `disabled` mientras `puestos.length === 0` (no hay nada que editar).

   - Bot√≥n ‚ÄúSalir‚Äù:
       ‚Ä¢ dispara `onSalir`,
       ‚Ä¢ normalmente vuelve al login o pantalla inicial.


5) Export

   export default BarraNavegacion;

   - Exporta el componente para ser usado en `VistaAlimentadores`.
	
   - Esa vista le pasa:
       ‚Ä¢ los datos (puestos, puesto actual, colores),
       ‚Ä¢ y los callbacks (seleccionar, nuevo, editar, salir, abrir men√∫).

---------------------------------------------------------------------------*/}



// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/BotonGuardarCambios.jsx =====

// src/paginas/PaginaAlimentadores/componentes/navegacion/BotonGuardarCambios.jsx

import React from "react";
import ReactDOM from "react-dom";
import "./BotonGuardarCambios.css";

/**
 * Overlay de guardado que se muestra sobre toda la pantalla
 */
const OverlayGuardando = () => {
  return ReactDOM.createPortal(
    <div className="guardar-overlay">
      <div className="guardar-overlay__contenido">
        <div className="guardar-overlay__spinner" />
        <span className="guardar-overlay__texto">Guardando cambios...</span>
      </div>
    </div>,
    document.body
  );
};

/**
 * Bot√≥n para guardar cambios pendientes en la base de datos.
 * Se activa solo cuando hay diferencias entre el estado local y la BD.
 *
 * @param {boolean} hayCambios - Si hay cambios pendientes por sincronizar
 * @param {boolean} sincronizando - Si est√° en proceso de sincronizaci√≥n
 * @param {Function} onGuardar - Callback para iniciar la sincronizaci√≥n
 * @param {Function} onDescartar - Callback para descartar cambios (opcional)
 */
const BotonGuardarCambios = ({
  hayCambios,
  sincronizando,
  onGuardar,
  onDescartar,
}) => {
  return (
    <>
      {/* Overlay de guardado */}
      {sincronizando && <OverlayGuardando />}

      <div className="guardar-cambios-container">
        <button
          type="button"
          className={`guardar-cambios-btn ${hayCambios ? "guardar-cambios-btn--activo" : ""} ${sincronizando ? "guardar-cambios-btn--sincronizando" : ""}`}
          onClick={onGuardar}
          disabled={!hayCambios || sincronizando}
          title={
            sincronizando
              ? "Guardando..."
              : hayCambios
                ? "Guardar cambios en la base de datos"
                : "No hay cambios pendientes"
          }
        >
          {sincronizando ? (
            <>
              <span className="guardar-cambios-spinner" />
              <span>Guardando...</span>
            </>
          ) : (
            <>
              <span className="guardar-cambios-icono">üíæ</span>
              <span>Guardar</span>
            </>
          )}
        </button>

        {hayCambios && onDescartar && !sincronizando && (
          <button
            type="button"
            className="guardar-cambios-btn-descartar"
            onClick={onDescartar}
            title="Descartar cambios y recargar desde la base de datos"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
              <path d="M3 3v5h5" />
            </svg>
          </button>
        )}
      </div>
    </>
  );
};

export default BotonGuardarCambios;

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/componentes/index.js =====

// componentes/index.js
// Exportaciones de componentes del men√∫ lateral

export { default as SeccionWorkspace } from "./SeccionWorkspace";
export { default as SeccionPuestos } from "./SeccionPuestos";
export { default as SeccionEscala } from "./SeccionEscala";
export { default as SeccionAcciones } from "./SeccionAcciones";

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/componentes/SeccionAcciones.jsx =====

// componentes/SeccionAcciones.jsx
// Secci√≥n de acciones del men√∫ lateral

/**
 * Secci√≥n de acciones en el men√∫ lateral
 * @param {Object} props
 * @param {Object} props.configuracionSeleccionada - Configuraci√≥n actual
 * @param {string} props.rolGlobal - Rol global del usuario
 * @param {number} props.puestosLength - Cantidad de puestos
 * @param {Function} props.onAccion - Handler gen√©rico para acciones
 * @param {Function} props.onAbrirGestionarAccesos - Handler para gestionar accesos
 * @param {Function} props.onAbrirNuevoPuesto - Handler para nuevo puesto
 * @param {Function} props.onAbrirEditarPuestos - Handler para editar puestos
 * @param {Function} props.onAbrirConfigurarAgente - Handler para configurar agente
 * @param {Function} props.onAbrirPanelPermisos - Handler para panel de permisos
 * @param {Function} props.onSalir - Handler para salir
 */
const SeccionAcciones = ({
   configuracionSeleccionada,
   rolGlobal,
   puestosLength,
   onAccion,
   onAbrirGestionarAccesos,
   onAbrirNuevoPuesto,
   onAbrirEditarPuestos,
   onAbrirConfigurarAgente,
   onAbrirPanelPermisos,
   onSalir,
}) => {
   const esCreador = configuracionSeleccionada?.esCreador;
   const esAdmin = configuracionSeleccionada?.rol === "admin";
   const puedeEditar = esCreador || esAdmin;
   const esSuperadmin = rolGlobal === "superadmin";

   return (
      <section className="alim-drawer-section">
         <h3 className="alim-drawer-section-title">Acciones</h3>
         <div className="alim-drawer-actions">
            {/* Gestionar Accesos (SOLO el creador del workspace) */}
            {esCreador && (
               <button
                  type="button"
                  className="alim-drawer-btn-action alim-drawer-btn-accesos"
                  onClick={() => onAccion(onAbrirGestionarAccesos)}
               >
                  <svg
                     className="alim-drawer-btn-icon-svg"
                     viewBox="0 0 24 24"
                     fill="currentColor"
                     width="18"
                     height="18"
                  >
                     <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z" />
                  </svg>
                  Gestionar Accesos
               </button>
            )}

            {/* Nuevo puesto (creador o admin) */}
            {puedeEditar && (
               <button
                  type="button"
                  className="alim-drawer-btn-action alim-drawer-btn-add"
                  onClick={() => onAccion(onAbrirNuevoPuesto)}
               >
                  <span className="alim-drawer-btn-icon">+</span>
                  <span>Nuevo puesto</span>
               </button>
            )}

            <button
               type="button"
               className="alim-drawer-btn-action alim-drawer-btn-edit"
               onClick={() => onAccion(onAbrirEditarPuestos)}
               disabled={puestosLength === 0}
            >
               <span className="alim-drawer-btn-icon">‚úé</span>
               <span>Editar puestos</span>
            </button>

            {/* Configurar Agente (creador o admin) */}
            {puedeEditar && (
               <button
                  type="button"
                  className="alim-drawer-btn-action alim-drawer-btn-config"
                  onClick={() => onAccion(onAbrirConfigurarAgente)}
               >
                  <span className="alim-drawer-btn-icon">‚öô</span>
                  Configurar Agente
               </button>
            )}

            {/* Panel de Permisos (solo superadmin) */}
            {esSuperadmin && (
               <button
                  type="button"
                  className="alim-drawer-btn-action alim-drawer-btn-permisos"
                  onClick={() => onAccion(onAbrirPanelPermisos)}
               >
                  <span className="alim-drawer-btn-icon">üîê</span>
                  Panel de Permisos
               </button>
            )}

            <button
               type="button"
               className="alim-drawer-btn-action alim-drawer-btn-salir"
               onClick={() => onAccion(onSalir)}
            >
               <span className="alim-drawer-btn-icon">‚Ü©</span>
               <span>Salir</span>
            </button>
         </div>
      </section>
   );
};

export default SeccionAcciones;

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/componentes/SeccionEscala.jsx =====

// componentes/SeccionEscala.jsx
// Secci√≥n de control de escala global del men√∫ lateral

/**
 * Secci√≥n de escala global
 * @param {Object} props
 * @param {number} props.escalaGlobal - Valor actual de escala
 * @param {Function} props.onEscalaChange - Handler para cambio de escala
 * @param {number} props.ESCALA_MIN - Valor m√≠nimo
 * @param {number} props.ESCALA_MAX - Valor m√°ximo
 */
const SeccionEscala = ({ escalaGlobal, onEscalaChange, ESCALA_MIN, ESCALA_MAX }) => {
   if (!onEscalaChange) return null;

   const handleInputChange = (e) => {
      const valor = parseFloat(e.target.value);
      if (!isNaN(valor) && valor >= ESCALA_MIN && valor <= ESCALA_MAX) {
         onEscalaChange(valor);
      }
   };

   return (
      <section className="alim-drawer-section">
         <h3 className="alim-drawer-section-title">Escala Global</h3>
         <div className="alim-drawer-escala">
            <input
               type="range"
               min={ESCALA_MIN}
               max={ESCALA_MAX}
               step="0.1"
               value={escalaGlobal ?? 1.0}
               onChange={(e) => onEscalaChange(parseFloat(e.target.value))}
               className="alim-drawer-escala-slider"
            />
            <div className="alim-drawer-escala-valor">
               <input
                  type="number"
                  step="0.1"
                  min={ESCALA_MIN}
                  max={ESCALA_MAX}
                  value={escalaGlobal ?? 1.0}
                  onChange={handleInputChange}
                  className="alim-drawer-escala-input"
               />
               <span className="alim-drawer-escala-x">x</span>
            </div>
            <button
               type="button"
               className="alim-drawer-escala-reset"
               onClick={() => onEscalaChange(1.0)}
               disabled={escalaGlobal === 1.0}
            >
               Reset
            </button>
         </div>
      </section>
   );
};

export default SeccionEscala;

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/componentes/SeccionPuestos.jsx =====

// componentes/SeccionPuestos.jsx
// Secci√≥n de puestos del men√∫ lateral

/**
 * Secci√≥n de puestos en el men√∫ lateral
 * @param {Object} props
 * @param {Array} props.puestos - Lista de puestos
 * @param {Object} props.puestoSeleccionado - Puesto actualmente seleccionado
 * @param {Function} props.onSeleccionarPuesto - Handler para seleccionar puesto
 * @param {Function} props.obtenerColorPuesto - Funci√≥n para obtener color del puesto
 * @param {Array} props.coloresSistema - Colores de fallback
 */
const SeccionPuestos = ({
   puestos,
   puestoSeleccionado,
   onSeleccionarPuesto,
   obtenerColorPuesto,
   coloresSistema,
}) => {
   return (
      <section className="alim-drawer-section">
         <h3 className="alim-drawer-section-title">Puestos</h3>
         <div className="alim-drawer-puestos">
            {puestos.map((p) => (
               <button
                  key={p.id}
                  className={
                     "alim-btn alim-drawer-btn-puesto" +
                     (puestoSeleccionado && puestoSeleccionado.id === p.id
                        ? " alim-btn-active"
                        : "")
                  }
                  style={{
                     backgroundColor: obtenerColorPuesto(p.id) || coloresSistema[0],
                  }}
                  onClick={() => onSeleccionarPuesto(p.id)}
               >
                  {p.nombre}
               </button>
            ))}
         </div>
      </section>
   );
};

export default SeccionPuestos;

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/componentes/SeccionWorkspace.jsx =====

// componentes/SeccionWorkspace.jsx
// Secci√≥n de workspaces del men√∫ lateral

import React, { useState } from "react";

/**
 * Secci√≥n de selecci√≥n de workspace
 * @param {Object} props
 * @param {Array} props.configuraciones - Lista de workspaces disponibles
 * @param {Object} props.configuracionSeleccionada - Workspace actualmente seleccionado
 * @param {Function} props.onSeleccionarWorkspace - Handler para seleccionar workspace
 * @param {boolean} props.puedeCrearWorkspaces - Si puede crear workspaces
 * @param {Function} props.onCrearWorkspace - Handler para crear workspace
 * @param {string} props.workspaceDefaultId - ID del workspace por defecto
 * @param {Function} props.onToggleDefault - Handler para toggle default
 */
const SeccionWorkspace = ({
   configuraciones,
   configuracionSeleccionada,
   onSeleccionarWorkspace,
   puedeCrearWorkspaces,
   onCrearWorkspace,
   workspaceDefaultId,
   onToggleDefault,
}) => {
   const [submenuAbierto, setSubmenuAbierto] = useState(false);
   const [mostrarFormNuevo, setMostrarFormNuevo] = useState(false);
   const [nombreNuevo, setNombreNuevo] = useState("");
   const [creando, setCreando] = useState(false);

   const handleSeleccionar = (id) => {
      onSeleccionarWorkspace(id);
      setSubmenuAbierto(false);
   };

   const handleCrear = async (e) => {
      e.preventDefault();
      if (!nombreNuevo.trim()) return;

      try {
         setCreando(true);
         await onCrearWorkspace(nombreNuevo.trim());
         setNombreNuevo("");
         setMostrarFormNuevo(false);
      } catch (err) {
         console.error("Error creando workspace:", err);
      } finally {
         setCreando(false);
      }
   };

   const handleToggle = async (e, id) => {
      e.stopPropagation();
      try {
         await onToggleDefault(id);
      } catch (err) {
         console.error("Error cambiando workspace default:", err);
      }
   };

   return (
      <section className="alim-drawer-section">
         <h3 className="alim-drawer-section-title">Workspace</h3>

         {/* Bot√≥n trigger */}
         <button
            type="button"
            className="alim-drawer-workspace-trigger"
            onClick={() => setSubmenuAbierto(!submenuAbierto)}
         >
            <span
               className={`alim-drawer-workspace-flecha ${
                  submenuAbierto ? "alim-drawer-workspace-flecha--abierto" : ""
               }`}
            >
               ‚ñ∂
            </span>
            <span>{configuracionSeleccionada?.nombre || "Sin workspace"}</span>
         </button>

         {/* Lista de workspaces */}
         {submenuAbierto && (
            <div className="alim-drawer-workspace-lista">
               {configuraciones.map((config) => (
                  <div key={config.id} className="alim-drawer-workspace-row">
                     <button
                        type="button"
                        className="alim-drawer-workspace-default-btn"
                        onClick={(e) => handleToggle(e, config.id)}
                        title={
                           config.id === workspaceDefaultId
                              ? "Quitar como default"
                              : "Establecer como default"
                        }
                     >
                        {config.id === workspaceDefaultId ? "‚òÖ" : "‚òÜ"}
                     </button>
                     <button
                        type="button"
                        className={`alim-drawer-workspace-item ${
                           config.id === configuracionSeleccionada?.id
                              ? "alim-drawer-workspace-item--activo"
                              : ""
                        }`}
                        onClick={() => handleSeleccionar(config.id)}
                     >
                        {config.nombre}
                        {!config.esCreador && (
                           <em className="alim-drawer-workspace-invitado">(invitado)</em>
                        )}
                     </button>
                  </div>
               ))}
            </div>
         )}

         {/* Formulario nuevo workspace (en Acciones) */}
         {puedeCrearWorkspaces && (
            <div className="alim-drawer-nuevo-workspace">
               {mostrarFormNuevo ? (
                  <form className="alim-drawer-form-workspace" onSubmit={handleCrear}>
                     <input
                        type="text"
                        className="alim-drawer-input"
                        placeholder="Nombre del workspace"
                        value={nombreNuevo}
                        onChange={(e) => setNombreNuevo(e.target.value)}
                        autoFocus
                        disabled={creando}
                     />
                     <div className="alim-drawer-form-btns">
                        <button
                           type="button"
                           className="alim-drawer-btn-cancelar"
                           onClick={() => {
                              setMostrarFormNuevo(false);
                              setNombreNuevo("");
                           }}
                           disabled={creando}
                        >
                           Cancelar
                        </button>
                        <button
                           type="submit"
                           className="alim-drawer-btn-crear"
                           disabled={!nombreNuevo.trim() || creando}
                        >
                           {creando ? "..." : "Crear"}
                        </button>
                     </div>
                  </form>
               ) : (
                  <button
                     type="button"
                     className="alim-drawer-btn-action alim-drawer-btn-nuevo-workspace"
                     onClick={() => setMostrarFormNuevo(true)}
                  >
                     <span className="alim-drawer-btn-icon">+</span>
                     Nuevo workspace
                  </button>
               )}
            </div>
         )}
      </section>
   );
};

export default SeccionWorkspace;

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/MenuLateral.jsx =====

// src/paginas/PaginaAlimentadores/componentes/navegacion/MenuLateral.jsx
// Men√∫ lateral (drawer) para modo compacto

import React from "react";
import "./MenuLateral.css";
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import { usarContextoAlimentadores } from "../../contexto/ContextoAlimentadoresSupabase";
import { ESCALA_MIN, ESCALA_MAX } from "../../constantes/escalas";

import {
   SeccionWorkspace,
   SeccionPuestos,
   SeccionEscala,
   SeccionAcciones,
} from "./componentes";

/**
 * Men√∫ lateral (drawer) para modo compacto.
 * Muestra puestos, workspaces y acciones en un panel deslizante.
 */
const MenuLateral = ({
   abierto,
   onCerrar,
   puestos,
   puestoSeleccionado,
   onSeleccionarPuesto,
   onAbrirModalNuevoPuesto,
   onAbrirModalEditarPuestos,
   onAbrirModalConfigurarAgente,
   onAbrirModalGestionarAccesos,
   onAbrirModalPanelPermisos,
   onSalir,
   coloresSistema,
   escalaGlobal,
   onEscalaGlobalChange,
}) => {
   const {
      configuraciones,
      configuracionSeleccionada,
      seleccionarConfiguracion,
      agregarConfiguracion,
      puedeCrearWorkspaces,
      rolGlobal,
      perfil,
      workspaceDefaultId,
      toggleWorkspaceDefault,
   } = usarContextoConfiguracion();

   const { obtenerColorPuesto } = usarContextoAlimentadores();

   // Handler para seleccionar puesto y cerrar men√∫
   const handleSeleccionarPuesto = (id) => {
      onSeleccionarPuesto(id);
      onCerrar();
   };

   // Handler gen√©rico para acciones (cierra men√∫ y ejecuta)
   const handleAccion = (accion) => {
      if (!accion) return;
      onCerrar();
      accion();
   };

   return (
      <div
         className={"alim-drawer-overlay" + (abierto ? " alim-drawer-open" : "")}
         onClick={onCerrar}
      >
         <aside className="alim-drawer" onClick={(e) => e.stopPropagation()}>
            {/* Header */}
            <header className="alim-drawer-header">
               <h2 className="alim-drawer-title">Panel de Alimentadores</h2>
               {puestoSeleccionado && (
                  <p className="alim-drawer-subtitle">
                     Puesto actual: <strong>{puestoSeleccionado.nombre}</strong>
                  </p>
               )}
            </header>

            {/* Info del usuario */}
            {perfil && (
               <div className="alim-drawer-usuario">
                  <span className="alim-drawer-usuario-nombre">
                     {perfil.nombre || perfil.email}
                  </span>
                  <span className="alim-drawer-usuario-rol">
                     {perfil.roles?.nombre || rolGlobal}
                  </span>
               </div>
            )}

            {/* Secci√≥n Workspace */}
            <SeccionWorkspace
               configuraciones={configuraciones}
               configuracionSeleccionada={configuracionSeleccionada}
               onSeleccionarWorkspace={seleccionarConfiguracion}
               puedeCrearWorkspaces={puedeCrearWorkspaces}
               onCrearWorkspace={agregarConfiguracion}
               workspaceDefaultId={workspaceDefaultId}
               onToggleDefault={toggleWorkspaceDefault}
            />

            {/* Secci√≥n Puestos */}
            <SeccionPuestos
               puestos={puestos}
               puestoSeleccionado={puestoSeleccionado}
               onSeleccionarPuesto={handleSeleccionarPuesto}
               obtenerColorPuesto={obtenerColorPuesto}
               coloresSistema={coloresSistema}
            />

            {/* Secci√≥n Escala Global */}
            <SeccionEscala
               escalaGlobal={escalaGlobal}
               onEscalaChange={onEscalaGlobalChange}
               ESCALA_MIN={ESCALA_MIN}
               ESCALA_MAX={ESCALA_MAX}
            />

            {/* Secci√≥n Acciones */}
            <SeccionAcciones
               configuracionSeleccionada={configuracionSeleccionada}
               rolGlobal={rolGlobal}
               puestosLength={puestos.length}
               onAccion={handleAccion}
               onAbrirGestionarAccesos={onAbrirModalGestionarAccesos}
               onAbrirNuevoPuesto={onAbrirModalNuevoPuesto}
               onAbrirEditarPuestos={onAbrirModalEditarPuestos}
               onAbrirConfigurarAgente={onAbrirModalConfigurarAgente}
               onAbrirPanelPermisos={onAbrirModalPanelPermisos}
               onSalir={onSalir}
            />
         </aside>
      </div>
   );
};

export default MenuLateral;

// ===== ./src/paginas/PaginaAlimentadores/componentes/navegacion/SelectorConfiguracion.jsx =====

// src/paginas/PaginaAlimentadores/componentes/navegacion/SelectorConfiguracion.jsx
// Componente para seleccionar y gestionar workspaces

import React, { useState, useRef, useEffect } from "react";
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import { ModalConfirmacion } from "../modales/comunes";
import "./SelectorConfiguracion.css";

/**
 * Selector dropdown de workspaces.
 * Permite cambiar entre workspaces y crear nuevos.
 */
const SelectorConfiguracion = ({ onAbrirModalEditarPuestos, onAbrirModalNuevoPuesto, onAbrirModalConfigurarAgente, onAbrirModalGestionarAccesos, onAbrirModalPanelPermisos, puestosLength = 0 }) => {
  const {
    configuraciones,
    configuracionSeleccionada,
    cargando,
    error,
    seleccionarConfiguracion,
    agregarConfiguracion,
    eliminarConfiguracion,
    puedeCrearWorkspaces,
    rolGlobal,
    perfil,
    workspaceDefaultId,
    toggleWorkspaceDefault,
  } = usarContextoConfiguracion();

  const [menuAbierto, setMenuAbierto] = useState(false);
  const [mostrarFormNueva, setMostrarFormNueva] = useState(false);
  const [nombreNueva, setNombreNueva] = useState("");
  const [creando, setCreando] = useState(false);
  const [submenuAbierto, setSubmenuAbierto] = useState(false);
  const [modalEliminarAbierto, setModalEliminarAbierto] = useState(false);

  const hoverTimeoutRef = useRef(null);
  const submenuRef = useRef(null);

  // Limpiar timeout al desmontar
  useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);

  // Cerrar submen√∫ cuando se cierra el men√∫ principal
  useEffect(() => {
    if (!menuAbierto) {
      setSubmenuAbierto(false);
    }
  }, [menuAbierto]);

  const handleSubmenuMouseEnter = () => {
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }
    hoverTimeoutRef.current = setTimeout(() => {
      setSubmenuAbierto(true);
    }, 300); // 300ms de delay para abrir
  };

  const handleSubmenuMouseLeave = () => {
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }
    hoverTimeoutRef.current = setTimeout(() => {
      setSubmenuAbierto(false);
    }, 200); // 200ms de delay para cerrar
  };

  const handleSubmenuClick = () => {
    setSubmenuAbierto(!submenuAbierto);
  };

  const handleSeleccionar = (id) => {
    seleccionarConfiguracion(id);
    setSubmenuAbierto(false);
    setMenuAbierto(false);
  };

  const handleToggleDefault = async (e, id) => {
    e.stopPropagation(); // Evitar que se seleccione el workspace
    try {
      await toggleWorkspaceDefault(id);
    } catch (err) {
      console.error("Error cambiando workspace default:", err);
    }
  };

  const handleCrearNueva = async (e) => {
    e.preventDefault();
    if (!nombreNueva.trim()) return;

    try {
      setCreando(true);
      await agregarConfiguracion(nombreNueva.trim());
      setNombreNueva("");
      setMostrarFormNueva(false);
      setMenuAbierto(false);
    } catch (err) {
      console.error("Error creando workspace:", err);
    } finally {
      setCreando(false);
    }
  };

  const handleEliminarActivo = () => {
    if (!configuracionSeleccionada) return;
    if (configuraciones.length <= 1) {
      alert("No se puede eliminar el √∫nico workspace existente.");
      return;
    }
    // Abrir modal de confirmaci√≥n
    setModalEliminarAbierto(true);
  };

  const confirmarEliminarWorkspace = async () => {
    try {
      // Encontrar el √≠ndice del workspace activo
      const indiceActual = configuraciones.findIndex(c => c.id === configuracionSeleccionada.id);

      // Determinar a qu√© workspace cambiar: anterior si existe, sino siguiente
      let nuevoWorkspace;
      if (indiceActual > 0) {
        nuevoWorkspace = configuraciones[indiceActual - 1];
      } else {
        nuevoWorkspace = configuraciones[indiceActual + 1];
      }

      // Cambiar al nuevo workspace antes de eliminar
      seleccionarConfiguracion(nuevoWorkspace.id);

      // Eliminar el workspace
      await eliminarConfiguracion(configuracionSeleccionada.id);

      setModalEliminarAbierto(false);
      setMenuAbierto(false);
    } catch (err) {
      console.error("Error eliminando workspace:", err);
    }
  };

  if (cargando) {
    return (
      <div className="selector-config selector-config--cargando">
        <span className="selector-config__spinner"></span>
        Cargando...
      </div>
    );
  }

  if (error) {
    return (
      <div className="selector-config selector-config--error">
        Error: {error}
      </div>
    );
  }

  // Si no hay workspaces, mostrar estado seg√∫n permisos del rol
  if (configuraciones.length === 0) {
    // Usuarios sin permiso para crear (operador, observador)
    if (!puedeCrearWorkspaces) {
      return (
        <div className="selector-config">
          <button
            type="button"
            className="selector-config__trigger selector-config__trigger--deshabilitado"
            onClick={() => setMenuAbierto(!menuAbierto)}
            aria-expanded={menuAbierto}
          >
            <span className="selector-config__nombre">Sin workspace</span>
            <span className="selector-config__flecha">{menuAbierto ? "‚ñ≤" : "‚ñº"}</span>
          </button>

          {menuAbierto && (
            <>
              <div
                className="selector-config__overlay"
                onClick={() => setMenuAbierto(false)}
              />
              <div className="selector-config__menu">
                {/* Header con usuario y rol */}
                {perfil && (
                  <div className="selector-config__usuario-header">
                    <span className="selector-config__usuario-nombre">{perfil.nombre || perfil.email}</span>
                    <span className="selector-config__usuario-rol">{perfil.roles?.nombre || rolGlobal}</span>
                  </div>
                )}
                <div className="selector-config__vacio-mensaje selector-config__vacio-mensaje--info">
                  No tienes workspaces asignados.
                  <br />
                  <small>Contacta a un administrador para ser invitado a un workspace.</small>
                </div>
              </div>
            </>
          )}
        </div>
      );
    }

    // Usuarios con permiso para crear (superadmin, admin)
    return (
      <div className="selector-config">
        <button
          type="button"
          className="selector-config__trigger selector-config__trigger--crear"
          onClick={() => setMenuAbierto(!menuAbierto)}
          aria-expanded={menuAbierto}
        >
          <span className="selector-config__nombre">+ Crear Workspace</span>
        </button>

        {menuAbierto && (
          <>
            <div
              className="selector-config__overlay"
              onClick={() => {
                setMenuAbierto(false);
                setMostrarFormNueva(false);
              }}
            />
            <div className="selector-config__menu">
              {/* Header con usuario y rol */}
              {perfil && (
                <div className="selector-config__usuario-header">
                  <span className="selector-config__usuario-nombre">{perfil.nombre || perfil.email}</span>
                  <span className="selector-config__usuario-rol">{perfil.roles?.nombre || rolGlobal}</span>
                </div>
              )}
              <div className="selector-config__vacio-mensaje">
                No tienes workspaces asignados.
                <br />
                Crea uno para empezar.
              </div>
              {mostrarFormNueva ? (
                <form className="selector-config__form" onSubmit={handleCrearNueva}>
                  <input
                    type="text"
                    className="selector-config__input"
                    placeholder="Nombre del workspace"
                    value={nombreNueva}
                    onChange={(e) => setNombreNueva(e.target.value)}
                    autoFocus
                    disabled={creando}
                  />
                  <div className="selector-config__form-btns">
                    <button
                      type="button"
                      className="selector-config__btn-cancelar"
                      onClick={() => {
                        setMostrarFormNueva(false);
                        setNombreNueva("");
                      }}
                      disabled={creando}
                    >
                      Cancelar
                    </button>
                    <button
                      type="submit"
                      className="selector-config__btn-crear"
                      disabled={!nombreNueva.trim() || creando}
                    >
                      {creando ? "Creando..." : "Crear"}
                    </button>
                  </div>
                </form>
              ) : (
                <button
                  type="button"
                  className="selector-config__nueva selector-config__nueva--destacado"
                  onClick={() => setMostrarFormNueva(true)}
                >
                  + Crear mi primer workspace
                </button>
              )}
            </div>
          </>
        )}
      </div>
    );
  }

  return (
    <div className="selector-config">
      <button
        type="button"
        className="selector-config__trigger"
        onClick={() => setMenuAbierto(!menuAbierto)}
        aria-expanded={menuAbierto}
        aria-haspopup="listbox"
      >
        <span className="selector-config__nombre">
          {configuracionSeleccionada?.nombre || "Sin workspace"}
        </span>
        <span className="selector-config__flecha">{menuAbierto ? "‚ñ≤" : "‚ñº"}</span>
      </button>

      {menuAbierto && (
        <>
          {/* Overlay para cerrar al hacer clic fuera */}
          <div
            className="selector-config__overlay"
            onClick={() => {
              setMenuAbierto(false);
              setMostrarFormNueva(false);
            }}
          />

          <div className="selector-config__menu" role="listbox">
            {/* Header con usuario y roles (global + workspace) */}
            {perfil && (
              <div className="selector-config__usuario-header">
                {/* Nombre + Rol global en la misma l√≠nea */}
                <div className="selector-config__usuario-linea">
                  <span className="selector-config__usuario-nombre">{perfil.nombre || perfil.email}</span>
                  <span className="selector-config__rol-global">
                    [ <svg className="selector-config__rol-icono" viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                    </svg>
                    {(() => {
                      const nombresRol = {
                        'superadmin': 'SuperAdmin',
                        'admin': 'Admin',
                        'operador': 'Operador',
                        'observador': 'Observador',
                      };
                      return nombresRol[rolGlobal] || 'Observador';
                    })()} ]
                  </span>
                </div>
                {/* Rol en workspace (solo si es invitado) */}
                {(() => {
                  const rolEnWs = configuracionSeleccionada?.rol;
                  const esCreador = configuracionSeleccionada?.esCreador;

                  if (esCreador === false && rolEnWs) {
                    const nombresRol = {
                      'admin': 'Admin',
                      'operador': 'Operador',
                      'observador': 'Observador',
                    };
                    return (
                      <span className="selector-config__rol-workspace">
                        Rol en Workspace: {nombresRol[rolEnWs] || 'Observador'}
                      </span>
                    );
                  }
                  return null;
                })()}
              </div>
            )}

            {/* Opci√≥n Workspaces con submen√∫ */}
            <div
              className="selector-config__submenu-container"
              ref={submenuRef}
              onMouseEnter={handleSubmenuMouseEnter}
              onMouseLeave={handleSubmenuMouseLeave}
            >
              <button
                type="button"
                className={`selector-config__submenu-trigger ${submenuAbierto ? 'selector-config__submenu-trigger--activo' : ''}`}
                onClick={handleSubmenuClick}
              >
                <span className={`selector-config__submenu-flecha ${submenuAbierto ? 'selector-config__submenu-flecha--abierto' : ''}`}>‚ñº</span>
                <span>Workspace</span>
              </button>

              {/* Submen√∫ de workspaces */}
              {submenuAbierto && (
                <div
                  className="selector-config__submenu"
                  onMouseEnter={handleSubmenuMouseEnter}
                  onMouseLeave={handleSubmenuMouseLeave}
                >
                  {configuraciones.length > 0 ? (
                    <ul className="selector-config__lista">
                      {configuraciones.map((config) => (
                        <li
                          key={config.id}
                          className={`selector-config__item ${
                            config.id === configuracionSeleccionada?.id
                              ? "selector-config__item--activo"
                              : ""
                          }`}
                        >
                          <button
                            type="button"
                            className="selector-config__default-btn"
                            onClick={(e) => handleToggleDefault(e, config.id)}
                            title={config.id === workspaceDefaultId ? "Quitar como default" : "Establecer como default"}
                          >
                            {config.id === workspaceDefaultId ? "‚òÖ" : "‚òÜ"}
                          </button>
                          <button
                            type="button"
                            className="selector-config__item-btn"
                            onClick={() => handleSeleccionar(config.id)}
                            role="option"
                            aria-selected={config.id === configuracionSeleccionada?.id}
                          >
                            <span className="selector-config__item-nombre">
                              {config.nombre}
                              {!config.esCreador && <em className="selector-config__item-invitado">(invitado)</em>}
                            </span>
                            {!config.esCreador && (
                              <span className="selector-config__item-rol">
                                <em>rol: {config.rol || 'observador'}</em>
                              </span>
                            )}
                          </button>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <div className="selector-config__vacio">
                      No hay workspaces
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Separador */}
            <div className="selector-config__separador" />

            {/* Bot√≥n/Form para crear nuevo */}
            {mostrarFormNueva ? (
              <form className="selector-config__form" onSubmit={handleCrearNueva}>
                <input
                  type="text"
                  className="selector-config__input"
                  placeholder="Nombre del workspace"
                  value={nombreNueva}
                  onChange={(e) => setNombreNueva(e.target.value)}
                  autoFocus
                  disabled={creando}
                />
                <div className="selector-config__form-btns">
                  <button
                    type="button"
                    className="selector-config__btn-cancelar"
                    onClick={() => {
                      setMostrarFormNueva(false);
                      setNombreNueva("");
                    }}
                    disabled={creando}
                  >
                    Cancelar
                  </button>
                  <button
                    type="submit"
                    className="selector-config__btn-crear"
                    disabled={!nombreNueva.trim() || creando}
                  >
                    {creando ? "Creando..." : "Crear"}
                  </button>
                </div>
              </form>
            ) : (
              <>
                {/*
                  Permisos en el men√∫:
                  - rolGlobal: rol global del usuario en el sistema (superadmin, admin, operador, observador)
                  - configuracionSeleccionada?.rol: rol del usuario EN ESTE WORKSPACE espec√≠fico
                  - configuracionSeleccionada?.esCreador: true si el usuario es el creador del workspace
                  - Gestionar Accesos: SOLO el creador del workspace
                  - Nuevo puesto / Configurar Agente: creador O invitado con rol admin en el workspace
                  - Editar puestos: creador, admin o operador en el workspace
                  - Panel de Permisos: SOLO superadmin global
                */}
                {(() => {
                  const rolEnWorkspace = configuracionSeleccionada?.rol;
                  const esCreador = configuracionSeleccionada?.esCreador;
                  // Para Nuevo puesto: creador O invitado con rol admin en el workspace (NO incluye superadmin global)
                  const puedeCrearPuesto = esCreador || rolEnWorkspace === 'admin';
                  // Para Editar puestos: creador, admin en workspace, o operador en workspace
                  const esOperadorEnWorkspace = puedeCrearPuesto || rolEnWorkspace === 'operador';

                  return (
                    <>
                      {/* Opci√≥n gestionar accesos (SOLO el creador del workspace) */}
                      {esCreador && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalGestionarAccesos?.();
                          }}
                        >
                          <svg className="selector-config__opcion-icono-svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                            <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                          </svg>
                          Gestionar Accesos
                        </button>
                      )}

                      {/* Opci√≥n nuevo puesto (creador O invitado con rol admin en el workspace) */}
                      {puedeCrearPuesto && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalNuevoPuesto?.();
                          }}
                        >
                          <span className="selector-config__opcion-icono">+</span>
                          Nuevo puesto
                        </button>
                      )}

                      {/* Opci√≥n editar puestos (admin u operador en workspace) */}
                      {esOperadorEnWorkspace && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalEditarPuestos?.();
                          }}
                          disabled={puestosLength === 0}
                        >
                          <span className="selector-config__opcion-icono">‚úé</span>
                          Editar puestos
                        </button>
                      )}

                      {/* Opci√≥n configurar agente (creador O invitado con rol admin en el workspace) */}
                      {puedeCrearPuesto && (
                        <button
                          type="button"
                          className="selector-config__opcion-secundaria"
                          onClick={() => {
                            setMenuAbierto(false);
                            onAbrirModalConfigurarAgente?.();
                          }}
                        >
                          <span className="selector-config__opcion-icono">‚öô</span>
                          Configurar Agente
                        </button>
                      )}
                    </>
                  );
                })()}

                {/* Opci√≥n panel de permisos (solo superadmin GLOBAL) */}
                {rolGlobal === 'superadmin' && (
                  <button
                    type="button"
                    className="selector-config__opcion-secundaria"
                    onClick={() => {
                      setMenuAbierto(false);
                      onAbrirModalPanelPermisos?.();
                    }}
                  >
                    <span className="selector-config__opcion-icono">üîê</span>
                    Panel de Permisos
                  </button>
                )}

                {/* Opci√≥n eliminar workspace activo (solo si hay m√°s de uno y es creador/admin) */}
                {configuraciones.length > 1 && configuracionSeleccionada?.esCreador && (
                  <button
                    type="button"
                    className="selector-config__eliminar-activo"
                    onClick={handleEliminarActivo}
                  >
                    <span className="selector-config__eliminar-icono">üóë</span>
                    Eliminar workspace
                  </button>
                )}

                {/* Solo mostrar bot√≥n de crear si tiene permisos */}
                {puedeCrearWorkspaces && (
                  <button
                    type="button"
                    className="selector-config__nueva"
                    onClick={() => setMostrarFormNueva(true)}
                  >
                    + Nuevo workspace
                  </button>
                )}
              </>
            )}
          </div>
        </>
      )}

      {/* Modal de confirmaci√≥n para eliminar workspace */}
      <ModalConfirmacion
        abierto={modalEliminarAbierto}
        titulo="Eliminar workspace"
        mensaje={`¬øEst√°s seguro de que deseas eliminar el workspace "${configuracionSeleccionada?.nombre}"? Esta acci√≥n no se puede deshacer.`}
        textoConfirmar="Eliminar"
        textoCancelar="Cancelar"
        peligroso={true}
        onConfirmar={confirmarEliminarWorkspace}
        onCancelar={() => setModalEliminarAbierto(false)}
      />
    </div>
  );
};

export default SelectorConfiguracion;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/CajaMedicion.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/CajaMedicion.jsx

import React from "react";

/**
 * Formatea un valor seg√∫n la cantidad de decimales configurada.
 * Solo afecta a valores num√©ricos, no modifica el valor interno.
 * @param {string} valor - Valor original (puede ser "--,--" o n√∫mero con coma)
 * @param {number} decimales - Cantidad de decimales a mostrar (0, 1 o 2)
 */
const formatearValorConDecimales = (valor, decimales) => {
	// Si no se especifica decimales, usar 2 por defecto
	if (decimales === undefined || decimales === null) return valor;

	// Si es placeholder, ajustar seg√∫n decimales
	if (valor === "--,--" || valor === "--" || valor === "--,-") {
		if (decimales === 0) return "--";
		if (decimales === 1) return "--,-";
		return "--,--";
	}

	// Convertir coma a punto para parsear
	const numStr = String(valor).replace(",", ".");
	const num = parseFloat(numStr);
	if (isNaN(num)) return valor;

	return num.toFixed(decimales).replace(".", ",");
};

/**
 * Caja individual de medici√≥n con su animaci√≥n de borde y valor.
 */
const CajaMedicion = ({
	box,                              // { etiqueta, valor, enabled, origen }
	indice,                           // posici√≥n dentro del grupo (0..3)
	zona,                             // "sup" o "inf" para identificar el lado
	mideRele,                         // indica si la medici√≥n de rel√© est√° activa
	mideAnalizador,                   // indica si la medici√≥n de analizador est√° activa
	mostrarProgresoRele,              // activa animaci√≥n de borde para rel√©
	mostrarProgresoAnalizador,        // activa animaci√≥n de borde para analizador
	periodoRele,                      // periodo configurado (segundos) para rel√©
	periodoAnalizador,                // periodo configurado (segundos) para analizador
	contadorRele,                     // cu√°ntas lecturas se hicieron para rel√©
	contadorAnalizador,               // cu√°ntas lecturas se hicieron para analizador
	// Polling de lecturas desde BD
	estaPolling = false,              // indica si hay polling activo
	mostrarProgresoPolling = false,   // activa animaci√≥n de borde para polling
	periodoPolling = 60,              // periodo de polling en segundos
	contadorPolling = 0,              // cu√°ntas lecturas se hicieron durante polling
	// Error de polling
	tieneError = false,               // indica si hay error de lectura
	// Estilos globales del box
	estilosBox = null,                // { tituloBox, valorBox, box }
}) => {
	const esDelRele = box.origen === "rele" || !box.origen;       // si no se especifica origen, asumimos rel√©
	const esDelAnalizador = box.origen === "analizador";

	// ===== MODO POLLING (tiene prioridad cuando est√° activo) =====
	// En modo polling, todas las cajas habilitadas muestran animaci√≥n
	const pollingActivo = estaPolling && box.enabled;
	const progresoPollingHabilitado = pollingActivo && mostrarProgresoPolling;

	// ===== MODO MEDICI√ìN TRADICIONAL (rele/analizador) =====
	const medicionActiva =
		!estaPolling &&                                            // solo si NO hay polling activo
		box.enabled &&                                             // la caja debe estar habilitada
		((esDelRele && mideRele) || (esDelAnalizador && mideAnalizador)); // y el equipo correspondiente debe estar midiendo

	const progresoTradicionalHabilitado =
		(esDelRele && mostrarProgresoRele) ||
		(esDelAnalizador && mostrarProgresoAnalizador);            // control global de cu√°ndo mostrar borde animado

	// ===== DECIDIR QU√â ANIMACI√ìN USAR =====
	// Prioridad: polling > medici√≥n tradicional
	let duracionAnimacion;
	let contadorLecturas;
	let propiedadDuracion;
	let usarAnimacion = false;

	if (pollingActivo && progresoPollingHabilitado) {
		// Usar animaci√≥n de polling (reutiliza el CSS de rel√©)
		duracionAnimacion = periodoPolling;
		contadorLecturas = contadorPolling;
		propiedadDuracion = "--rw-progress-duration-rele";          // reutiliza la animaci√≥n del rel√©
		usarAnimacion = true;
	} else if (medicionActiva && progresoTradicionalHabilitado) {
		// Usar animaci√≥n tradicional
		duracionAnimacion = esDelAnalizador ? periodoAnalizador : periodoRele;
		contadorLecturas = esDelAnalizador ? contadorAnalizador : contadorRele;
		propiedadDuracion = esDelRele
			? "--rw-progress-duration-rele"
			: "--rw-progress-duration-analizador";
		usarAnimacion = true;
	} else {
		// Sin animaci√≥n
		duracionAnimacion = 60;
		contadorLecturas = 0;
		propiedadDuracion = "--rw-progress-duration-rele";
	}

	const equipo = pollingActivo ? "polling" : (esDelAnalizador ? "analizador" : "rele");

	let clasesValor = "alim-card-meter-value";                    // clase base del valor

	// TEMPORALMENTE DESACTIVADO: animaci√≥n de borde en el box
	// Se usa la barra de progreso horizontal en su lugar
	// if (usarAnimacion && !tieneError) {
	// 	if (pollingActivo || esDelRele) {
	// 		clasesValor += " alim-meter-progress-rele";
	// 	} else if (esDelAnalizador) {
	// 		clasesValor += " alim-meter-progress-analizador";
	// 	}
	// }

	// si hay error, agregar clase de error
	if (tieneError && box.enabled) {
		clasesValor += " alim-card-meter-value--error";
	}

	// Key que incluye el contador de lecturas para reiniciar animaci√≥n
	const claveValor = `${zona}-${indice}-${equipo}-c${contadorLecturas}`;

	// Determinar qu√© valor mostrar (aplicando formato de decimales)
	const decimalesConfig = estilosBox?.valorBox?.decimales;
	let valorMostrar = box.valor ?? "--,--";
	if (tieneError && box.enabled) {
		valorMostrar = "ERROR";
	} else {
		valorMostrar = formatearValorConDecimales(valorMostrar, decimalesConfig);
	}

	// Construir estilos del t√≠tulo del box (etiqueta como R, S, T)
	const estiloTituloBox = estilosBox?.tituloBox ? {
		fontFamily: estilosBox.tituloBox.fontFamily,
		fontSize: estilosBox.tituloBox.fontSize,
	} : {};

	// Construir estilos del valor del box (n√∫mero) - ahora con tama√±o fijo y overflow
	const boxHeight = estilosBox?.box?.height;
	const estiloValorBase = {
		...(estilosBox?.valorBox ? {
			fontFamily: estilosBox.valorBox.fontFamily,
			fontSize: estilosBox.valorBox.fontSize,
			color: estilosBox.valorBox.color,
		} : {}),
		// El box ahora tiene tama√±o fijo, el texto se recorta si no cabe
		width: "100%",
		...(boxHeight && boxHeight !== "auto" ? { height: boxHeight } : {}),
		overflow: "hidden",
		textOverflow: "ellipsis",
		display: "flex",
		alignItems: "center",
		justifyContent: "center",
	};

	// Combinar con estilos de animaci√≥n si corresponde
	const estiloValor = usarAnimacion && !tieneError
		? {
			...estiloValorBase,
			[propiedadDuracion]: `${duracionAnimacion}s`,
		}
		: estiloValorBase;

	// Estilos del contenedor del box (ancho fijo)
	const estiloMeter = estilosBox?.box?.width ? {
		width: estilosBox.box.width,
		flex: `0 0 ${estilosBox.box.width}`,
	} : {};

	return (
		<div
			key={`${zona}-${indice}`}
			className="alim-card-meter"
			style={Object.keys(estiloMeter).length > 0 ? estiloMeter : undefined}
		>
			<span
				className="alim-card-meter-phase"
				style={estiloTituloBox}
			>
				{box.etiqueta}
			</span>
			<span
				key={claveValor}
				className={clasesValor}
				style={Object.keys(estiloValor).length > 0 ? estiloValor : undefined}
			>
				{valorMostrar}
			</span>
		</div>
	);
};

export default CajaMedicion;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (CajaMedicion.jsx)

 - Representa un √∫nico ‚Äúdisplay‚Äù de la tarjeta (por ejemplo, fase R de corriente),
   encargado de mostrar etiqueta, valor y, opcionalmente, el borde de progreso.

 - `box.origen` decide si la caja pertenece al rel√© o al analizador; si no se
   indica, se asume rel√© por defecto.

 - El par `medicionActiva` + `progresoHabilitado` controla cu√°ndo se aplica la
   clase de borde animado: solo si la caja est√° habilitada y el equipo est√°
   midiendo (y la vista decidi√≥ mostrar progreso).

 - La key `claveValor` incluye el contador de lecturas para que React vuelva a
   montar el span del valor cuando llegue una nueva lectura, reiniciando as√≠ la
   animaci√≥n de borde.

 - `propiedadDuracion` permite ajustar la duraci√≥n de la animaci√≥n v√≠a variable
   CSS diferente para rel√© y analizador.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (CajaMedicion.jsx)

0) Visi√≥n general del componente

   `CajaMedicion` es el ‚Äúdisplay‚Äù individual dentro de la tarjeta:

   - Muestra:
       ‚Ä¢ una etiqueta (ej: "R", "S", "T" o un nombre personalizado),
       ‚Ä¢ un valor num√©rico o placeholder (`"--,--"`).

   - Opcionalmente dibuja una animaci√≥n de borde alrededor del valor para indicar
     el progreso del per√≠odo de medici√≥n (tipo ‚Äúbarra de progreso circular‚Äù):

       ‚Ä¢ puede representar el per√≠odo del rel√©,
       ‚Ä¢ o el del analizador, seg√∫n el origen definido en la caja.


1) Props y rol de cada una

   const CajaMedicion = ({
     box,
     indice,
     zona,
     mideRele,
     mideAnalizador,
     mostrarProgresoRele,
     mostrarProgresoAnalizador,
     periodoRele,
     periodoAnalizador,
     contadorRele,
     contadorAnalizador,
   }) => { ... }

   - `box`:
       ‚Ä¢ objeto con la configuraci√≥n de esta caja:
           - `box.etiqueta`  ‚Üí texto a mostrar encima del valor,
           - `box.valor`     ‚Üí lectura procesada (como string),
           - `box.enabled`   ‚Üí si la caja est√° habilitada para mostrar medici√≥n,
           - `box.origen`    ‚Üí `"rele"`, `"analizador"` o `undefined`:
               ¬∑ si es `"rele"`, la caja depende del rel√©,
               ¬∑ si es `"analizador"`, depende del analizador,
               ¬∑ si no se indica, se asume rel√© por defecto.

   - `indice`:
       ‚Ä¢ posici√≥n dentro del grupo de cajas (0, 1, 2 o 3),
       ‚Ä¢ se usa para construir keys √∫nicas.

   - `zona`:
       ‚Ä¢ indica si esta caja est√° en la parte:
           - `"sup"` ‚Üí bloque superior de la tarjeta,
           - `"inf"` ‚Üí bloque inferior.
       ‚Ä¢ tambi√©n participa en la generaci√≥n de keys.

   - `mideRele` / `mideAnalizador`:
       ‚Ä¢ booleans que indican si hay mediciones activas para cada equipo.
       ‚Ä¢ vienen del contexto y reflejan el estado real de los timers.

   - `mostrarProgresoRele` / `mostrarProgresoAnalizador`:
       ‚Ä¢ booleans que controlan si se debe animar el borde para cada equipo.
       ‚Ä¢ los gestiona `TarjetaAlimentador` seg√∫n si ya hubo lecturas, etc.

   - `periodoRele` / `periodoAnalizador`:
       ‚Ä¢ duraci√≥n del ciclo de actualizaci√≥n en segundos,
       ‚Ä¢ se usan para ajustar la velocidad de la animaci√≥n del borde.

   - `contadorRele` / `contadorAnalizador`:
       ‚Ä¢ se incrementan en cada lectura,
       ‚Ä¢ sirven para forzar el reinicio de la animaci√≥n cuando llega un nuevo set
         de datos (usando la key).


2) Banderas de origen: esDelRele / esDelAnalizador

   const esDelRele = box.origen === "rele" || !box.origen;
   const esDelAnalizador = box.origen === "analizador";

   - `esDelRele`:
       ‚Ä¢ es true si `box.origen` es `"rele"`,
       ‚Ä¢ o si `box.origen` no est√° definido (`!box.origen`),
       ‚Ä¢ en otras palabras: si no se aclara, asumimos rel√© como origen por defecto.

   - `esDelAnalizador`:
       ‚Ä¢ true solo si `box.origen === "analizador"`.

   - Esto permite que la misma caja se integre a la l√≥gica de:
       ‚Ä¢ mediciones y animaciones del rel√©,
       ‚Ä¢ o del analizador,
       ‚Ä¢ sin mezclar ambas cosas a la vez.


3) Determinar si la medici√≥n est√° activa en esta caja

   const medicionActiva =
     box.enabled &&
     ((esDelRele && mideRele) || (esDelAnalizador && mideAnalizador));

   - La caja solo debe considerarse ‚Äúactiva‚Äù si se cumplen dos condiciones:

       1) `box.enabled` es true:
           ‚Ä¢ el mapeo habilit√≥ esta caja (se decidi√≥ usarla).

       2) El equipo correspondiente est√° midiendo:
           ‚Ä¢ si la caja es del rel√© ‚Üí se requiere `mideRele === true`,
           ‚Ä¢ si es del analizador ‚Üí se requiere `mideAnalizador === true`.

   - Si cualquiera de estas condiciones falla:
       ‚Ä¢ `medicionActiva` ser√° false,
       ‚Ä¢ no se mostrar√° animaci√≥n de progreso.


4) Control de progreso: progresoHabilitado

   const progresoHabilitado =
     (esDelRele && mostrarProgresoRele) ||
     (esDelAnalizador && mostrarProgresoAnalizador);

   - Esta bandera no mira solo el estado de medici√≥n, sino la decisi√≥n de la vista
     sobre si debe mostrarse la animaci√≥n en este momento.

   - Resumen:

       ‚Ä¢ Para cajas de rel√©:
             `esDelRele && mostrarProgresoRele`

       ‚Ä¢ Para cajas de analizador:
             `esDelAnalizador && mostrarProgresoAnalizador`

   - `mostrarProgresoRele` / `mostrarProgresoAnalizador` los maneja
     `TarjetaAlimentador` usando contadores de lecturas:
       ‚Ä¢ se activan cuando llega al menos una lectura,
       ‚Ä¢ se apagan si se detiene la medici√≥n o se cambia de puesto.


5) Equipo, duraci√≥n y contador de lecturas

   const equipo = esDelAnalizador ? "analizador" : "rele";

   - Texto de conveniencia para identificar a cu√°l equipo est√° asociada la caja.

   const duracionAnimacion = esDelAnalizador
     ? periodoAnalizador
     : periodoRele;

   - ‚ÄúCu√°nto dura‚Äù el ciclo de animaci√≥n del borde:
       ‚Ä¢ si la caja es del analizador ‚Üí usa `periodoAnalizador`,
       ‚Ä¢ si no ‚Üí usa `periodoRele`.

   const contadorLecturas = esDelAnalizador
     ? contadorAnalizador
     : contadorRele;

   - Se elige el contador que corresponde al equipo de esta caja:

       ‚Ä¢ analizador ‚Üí `contadorAnalizador`,
       ‚Ä¢ rel√©       ‚Üí `contadorRele`.

   - Este valor se usar√° despu√©s para generar una key √∫nica y provocar que
     React remonte el elemento cuando cambie (reiniciando la animaci√≥n).


6) Construcci√≥n de clases CSS para el valor

   let clasesValor = "alim-card-meter-value";

   if (medicionActiva && progresoHabilitado) {
     if (esDelRele) {
       clasesValor += " alim-meter-progress-rele";
     } else if (esDelAnalizador) {
       clasesValor += " alim-meter-progress-analizador";
     }
   }

   - Siempre partimos de la clase base `"alim-card-meter-value"`.

   - Si la medici√≥n est√° activa y el progreso est√° habilitado:

       ‚Ä¢ para cajas del rel√©:
           - se agrega `"alim-meter-progress-rele"`.

       ‚Ä¢ para cajas del analizador:
           - se agrega `"alim-meter-progress-analizador"`.

   - Estas clases extra son las que el CSS usa para dibujar el borde animado,
     usando las variables `--rw-progress-duration-rele` o
     `--rw-progress-duration-analizador`.


7) Key para reiniciar animaci√≥n y variable CSS de duraci√≥n

   const claveValor = `${zona}-${indice}-${equipo}-c${contadorLecturas}`;

   - Esta key se aplica al `<span>` que muestra el valor:

       ‚Ä¢ incluye:
           - `zona` (sup/inf),
           - `indice` dentro del grupo,
           - `equipo` ("rele"/"analizador"),
           - `contadorLecturas`.

   - Cuando `contadorLecturas` cambia (ej: llega una nueva lectura):

       ‚Ä¢ la key cambia,
       ‚Ä¢ React desmonta y vuelve a montar el `<span>`,
       ‚Ä¢ y la animaci√≥n CSS se reinicia desde cero.

   const propiedadDuracion = esDelRele
     ? "--rw-progress-duration-rele"
     : "--rw-progress-duration-analizador";

   - Esta string representa el nombre de la variable CSS que controla 
     la duraci√≥n de la animaci√≥n:

       ‚Ä¢ para cajas del rel√© ‚Üí `"--rw-progress-duration-rele"`,
       ‚Ä¢ para cajas del analizador ‚Üí `"--rw-progress-duration-analizador"`.


8) JSX final

   return (
     <div key={`${zona}-${indice}`} className="alim-card-meter">
       <span className="alim-card-meter-phase">{box.etiqueta}</span>
       <span
         key={claveValor}
         className={clasesValor}
         style={
           medicionActiva && progresoHabilitado
             ? { [propiedadDuracion]: `${duracionAnimacion}s` }
             : undefined
         }
       >
         {box.valor ?? "--,--"}
       </span>
     </div>
   );

   - Contenedor de la caja:
       ‚Ä¢ `<div className="alim-card-meter">` agrupa etiqueta y valor.
       ‚Ä¢ usa `key={`${zona}-${indice`}` para identificar la caja dentro del
         grupo de `GrupoMedidores`.

   - Etiqueta:
       ‚Ä¢ `<span className="alim-card-meter-phase">{box.etiqueta}</span>`
       ‚Ä¢ muestra el texto configurado (ej: R, S, T, ‚ÄúPromedio‚Äù, etc.).

   - Valor:
       ‚Ä¢ `<span key={claveValor} className={clasesValor} ...>`
       ‚Ä¢ `key={claveValor}`:
           - se apoya en el contador de lecturas para reiniciar animaci√≥n.
       ‚Ä¢ `className={clasesValor}`:
           - incluye o no las clases de animaci√≥n seg√∫n corresponda.
       ‚Ä¢ `style={ ... }`:
           - si la medici√≥n est√° activa y el progreso habilitado, se pasa
             un objeto con la variable CSS `[propiedadDuracion]` ajustada
             a `${duracionAnimacion}s`.
           - si no, `style` queda `undefined` y no se aplica ning√∫n override.

       ‚Ä¢ `{box.valor ?? "--,--"}`:
           - muestra `box.valor` si est√° definido,
           - si viene `null` o `undefined`, muestra `"--,--"` como placeholder.


9) Export

   export default CajaMedicion;

   - Permite usar esta caja desde `TarjetaAlimentador`, que es la que decide
     cu√°ntas cajas hay, c√≥mo se agrupan y con qu√© par√°metros se renderiza cada una.

---------------------------------------------------------------------------*/
// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/componentes/BotonesUnifilar.jsx =====

// componentes/BotonesUnifilar.jsx
// Botones flotantes para controlar la grilla unifiliar

/**
 * Bot√≥n flotante para activar modo edici√≥n de diagrama
 * @param {Object} props
 * @param {Function} props.onActivar - Handler para activar edici√≥n
 */
export const BotonEditarDiagrama = ({ onActivar }) => (
   <button
      type="button"
      className="grilla-btn-editar-diagrama"
      onClick={onActivar}
      title="Editar diagrama unifiliar"
   >
      <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
         <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.996.996 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" />
      </svg>
   </button>
);

/**
 * Botones para guardar/cargar diagrama desde archivo
 * @param {Object} props
 * @param {Function} props.onExportar - Handler para exportar
 * @param {Function} props.onImportar - Handler para importar (recibe archivo)
 */
export const BotonesArchivo = ({ onExportar, onImportar }) => (
   <div className="grilla-btns-archivo">
      {/* Bot√≥n guardar */}
      <button
         type="button"
         className="grilla-btn-archivo grilla-btn-archivo--guardar"
         onClick={onExportar}
         title="Guardar diagrama a archivo"
      >
         <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
            <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z" />
         </svg>
      </button>
      {/* Bot√≥n abrir */}
      <label className="grilla-btn-archivo grilla-btn-archivo--abrir" title="Cargar diagrama desde archivo">
         <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
            <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z" />
         </svg>
         <input
            type="file"
            accept=".json"
            style={{ display: "none" }}
            onChange={async (e) => {
               const archivo = e.target.files?.[0];
               if (archivo) {
                  const exito = await onImportar(archivo);
                  if (!exito) {
                     alert("Error al cargar el archivo. Verifica que sea un archivo JSON v√°lido.");
                  }
               }
               e.target.value = "";
            }}
         />
      </label>
   </div>
);

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/componentes/index.js =====

// componentes/tarjetas/componentes/index.js
// Exportaciones centralizadas de componentes auxiliares de tarjetas

export { PopoverEscala } from "./PopoverEscala";
export { MenuFlotante } from "./MenuFlotante";
export { BotonEditarDiagrama, BotonesArchivo } from "./BotonesUnifilar";

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/componentes/MenuFlotante.jsx =====

// componentes/tarjetas/componentes/MenuFlotante.jsx
// Men√∫ flotante desplegable para acciones de tarjeta

import { createPortal } from "react-dom";
import configIcon from "../../../../../assets/imagenes/Config_Icon.png";

/**
 * Men√∫ flotante desplegable con acciones de la tarjeta
 *
 * @param {Object} props
 * @param {React.Ref} props.menuRef - Ref del men√∫
 * @param {Object} props.posicion - Posici√≥n { top, left, width } del men√∫
 * @param {Function} props.onConfigClick - Callback para configuraci√≥n
 * @param {Function} props.onHistorialClick - Callback para historial
 * @param {boolean} props.esObservador - Si el usuario es observador (oculta historial)
 * @param {Function} props.onCerrar - Callback para cerrar el men√∫
 */
export function MenuFlotante({
   menuRef,
   posicion,
   onConfigClick,
   onHistorialClick,
   esObservador,
   onCerrar,
}) {
   return createPortal(
      <div
         ref={menuRef}
         className="alim-card-menu-flotante"
         style={{
            top: `${posicion.top}px`,
            left: `${posicion.left}px`,
            width: `${posicion.width}px`,
         }}
         onClick={(e) => e.stopPropagation()}
         onMouseDown={(e) => e.stopPropagation()}
      >
         <div className="alim-card-menu-flotante-content">
            {/* Bot√≥n de configuraci√≥n */}
            <button
               type="button"
               className="alim-card-menu-flotante-btn"
               onClick={(e) => {
                  e.stopPropagation();
                  onCerrar();
                  onConfigClick?.();
               }}
               title="Configurar registrador"
            >
               <img
                  src={configIcon}
                  alt="Configurar"
                  className="alim-card-menu-flotante-icon"
               />
            </button>

            {/* Bot√≥n de historial/estad√≠sticas (oculto para observadores) */}
            {onHistorialClick && !esObservador && (
               <button
                  type="button"
                  className="alim-card-menu-flotante-btn"
                  onClick={(e) => {
                     e.stopPropagation();
                     onCerrar();
                     onHistorialClick();
                  }}
                  title="Ver historial de lecturas"
               >
                  <span className="alim-card-menu-flotante-emoji">üìà</span>
               </button>
            )}
         </div>
      </div>,
      document.body
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/componentes/PopoverEscala.jsx =====

// componentes/tarjetas/componentes/PopoverEscala.jsx
// Popover para controlar la escala de una tarjeta

import { createPortal } from "react-dom";

/**
 * Popover para controlar la escala de una tarjeta
 *
 * @param {Object} props
 * @param {React.Ref} props.popoverRef - Ref del popover
 * @param {Object} props.posicion - Posici√≥n { top, left } del popover
 * @param {string} props.valorInput - Valor actual del input
 * @param {number} props.escalaMin - Escala m√≠nima
 * @param {number} props.escalaMax - Escala m√°xima
 * @param {Function} props.onInputChange - Handler para cambio de input
 * @param {Function} props.onKeyDown - Handler para teclas
 * @param {Function} props.onIncrementar - Handler para incrementar
 * @param {Function} props.onDecrementar - Handler para decrementar
 * @param {Function} props.onResetear - Handler para resetear
 */
export function PopoverEscala({
   popoverRef,
   posicion,
   valorInput,
   escalaMin,
   escalaMax,
   onInputChange,
   onKeyDown,
   onIncrementar,
   onDecrementar,
   onResetear,
}) {
   return createPortal(
      <div
         ref={popoverRef}
         className="alim-card-scale-popover"
         style={{ top: `${posicion.top}px`, left: `${posicion.left}px` }}
         onClick={(e) => e.stopPropagation()}
         onMouseDown={(e) => e.stopPropagation()}
      >
         <label className="alim-card-scale-label">
            Escala ({escalaMin} - {escalaMax})
         </label>
         <div className="alim-card-scale-controls">
            <button
               type="button"
               className="alim-card-scale-pm-btn"
               onClick={onDecrementar}
               disabled={parseFloat(valorInput) <= escalaMin}
               title="Reducir escala"
            >
               -
            </button>
            <input
               type="number"
               step="0.01"
               min={escalaMin}
               max={escalaMax}
               value={valorInput}
               onChange={onInputChange}
               onKeyDown={onKeyDown}
               className="alim-card-scale-input"
               autoFocus
            />
            <button
               type="button"
               className="alim-card-scale-pm-btn"
               onClick={onIncrementar}
               disabled={parseFloat(valorInput) >= escalaMax}
               title="Aumentar escala"
            >
               +
            </button>
         </div>
         <div className="alim-card-scale-actions">
            <button type="button" className="alim-card-scale-reset" onClick={onResetear}>
               Reset (1.0)
            </button>
         </div>
      </div>,
      document.body
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GapResizer.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/GapResizer.jsx

import React, { useState, useRef, useEffect, useCallback } from "react";
import "./GapResizer.css";

/**
 * Componente que permite ajustar el gap entre tarjetas.
 * Aparece como una l√≠nea con un c√≠rculo al hacer hover entre tarjetas.
 *
 * Comportamiento:
 * - Al hacer hover sobre el handle: aparece la barra de gap con el valor actual
 * - Al arrastrar con click izquierdo: ajusta el gap visualmente
 * - Al hacer doble click: se habilita la edici√≥n manual del input
 * - Enter o click fuera del input: confirma el valor y oculta la barra
 * - Escape: cancela y oculta la barra
 *
 * @param {number} gap - Gap actual en p√≠xeles
 * @param {function} onGapChange - Callback (nuevoGap)
 */
const GapResizer = ({ gap, onGapChange, minGap = 0, maxGap = 500 }) => {
	const [isHovered, setIsHovered] = useState(false);
	const [isDragging, setIsDragging] = useState(false);
	const [isEditing, setIsEditing] = useState(false); // true = input editable
	const [inputValue, setInputValue] = useState(gap);
	const inputRef = useRef(null);
	const containerRef = useRef(null);
	const hitboxRef = useRef(null);
	const startXRef = useRef(0);
	const startGapRef = useRef(gap);

	// Actualizar inputValue cuando cambia el gap desde afuera (pero no durante edici√≥n)
	useEffect(() => {
		if (!isEditing) {
			setInputValue(gap);
		}
	}, [gap, isEditing]);

	// Detectar clicks fuera del componente para cerrar
	// NOTA: No cerrar si est√° en modo edici√≥n (solo Enter/Escape cierran)
	useEffect(() => {
		const handleClickOutside = (e) => {
			if (containerRef.current && !containerRef.current.contains(e.target)) {
				// Solo ocultar si NO est√° editando
				if (!isEditing) {
					setIsHovered(false);
				}
			}
		};

		// Solo escuchar si est√° activo y no editando
		if (isHovered && !isEditing) {
			document.addEventListener('mousedown', handleClickOutside);
		}

		return () => {
			document.removeEventListener('mousedown', handleClickOutside);
		};
	}, [isHovered, isEditing]);

	// ===== DRAG HANDLERS =====
	const handleMouseDown = useCallback((e) => {
		// Solo drag con click izquierdo (button 0)
		if (e.button !== 0) return;
		e.preventDefault();
		e.stopPropagation();
		setIsDragging(true);
		startXRef.current = e.clientX;
		startGapRef.current = gap;
	}, [gap]);

	const handleMouseMove = useCallback((e) => {
		if (!isDragging) return;

		const deltaX = e.clientX - startXRef.current;
		// Cada 2px de movimiento = 1px de gap
		const newGap = Math.round(startGapRef.current + deltaX / 2);
		const clampedGap = Math.max(minGap, Math.min(maxGap, newGap));

		onGapChange(clampedGap);
		setInputValue(clampedGap);
	}, [isDragging, minGap, maxGap, onGapChange]);

	const handleMouseUp = useCallback((e) => {
		setIsDragging(false);

		// Verificar si el mouse est√° fuera del hitbox al soltar
		// Si est√° fuera, ocultar la barra
		if (hitboxRef.current) {
			const rect = hitboxRef.current.getBoundingClientRect();
			const mouseX = e.clientX;
			const mouseY = e.clientY;
			const isOutside =
				mouseX < rect.left ||
				mouseX > rect.right ||
				mouseY < rect.top ||
				mouseY > rect.bottom;

			if (isOutside && !isEditing) {
				setIsHovered(false);
			}
		}
	}, [isEditing]);

	// Doble click para activar modo edici√≥n
	const handleDoubleClick = useCallback((e) => {
		e.preventDefault();
		e.stopPropagation();
		setIsEditing(true);
		setInputValue(gap);
	}, [gap]);

	// Agregar/remover listeners globales para el drag
	useEffect(() => {
		if (isDragging) {
			window.addEventListener("mousemove", handleMouseMove);
			window.addEventListener("mouseup", handleMouseUp);
		}
		return () => {
			window.removeEventListener("mousemove", handleMouseMove);
			window.removeEventListener("mouseup", handleMouseUp);
		};
	}, [isDragging, handleMouseMove, handleMouseUp]);

	// ===== INPUT HANDLERS =====
	// Click en el valor para habilitar edici√≥n
	const handleValueClick = (e) => {
		e.stopPropagation();
		if (!isDragging) {
			setIsEditing(true);
			setInputValue(gap);
		}
	};

	// Enfocar el input cuando se activa la edici√≥n
	useEffect(() => {
		if (isEditing && inputRef.current) {
			inputRef.current.focus();
			inputRef.current.select();
		}
	}, [isEditing]);

	const handleInputChange = (e) => {
		setInputValue(e.target.value);
	};

	const confirmarValor = () => {
		const numValue = parseInt(inputValue, 10);
		if (!isNaN(numValue)) {
			const clampedGap = Math.max(minGap, Math.min(maxGap, numValue));
			onGapChange(clampedGap);
			setInputValue(clampedGap);
		} else {
			setInputValue(gap);
		}
		setIsEditing(false);
	};

	const handleInputBlur = () => {
		// Al perder foco (click fuera), confirmar valor y cerrar igual que Enter
		confirmarValor();
		setIsHovered(false);
	};

	const handleInputKeyDown = (e) => {
		if (e.key === "Enter") {
			e.preventDefault();
			confirmarValor();
			// Tambi√©n ocultar la barra de gap completamente
			setIsHovered(false);
		} else if (e.key === "Escape") {
			setInputValue(gap);
			setIsEditing(false);
			// Tambi√©n ocultar la barra de gap completamente
			setIsHovered(false);
		}
	};

	const isActive = isHovered || isDragging || isEditing;

	return (
		<div
			ref={containerRef}
			className={`gap-resizer ${isActive ? "gap-resizer--active" : ""}`}
			style={{ width: `${gap}px` }}
		>
			{/* Hitbox centrado directamente en el gap-resizer */}
			<div
				ref={hitboxRef}
				className="gap-resizer__hitbox"
				style={{ width: `${Math.min(30, gap)}px` }}
				onMouseEnter={() => setIsHovered(true)}
				onMouseLeave={() => !isDragging && !isEditing && setIsHovered(false)}
				onMouseDown={handleMouseDown}
				onDoubleClick={handleDoubleClick}
			/>

			{/* Handle visual (solo decorativo, los eventos van al hitbox) */}
			<div
				className={`gap-resizer__handle ${isDragging ? "gap-resizer__handle--dragging" : ""}`}
				title="Arrastra para ajustar el espaciado"
			>
				<div className="gap-resizer__line" />
				<div className="gap-resizer__circle" />
				<div className="gap-resizer__line" />
			</div>

			{isActive && (
				<div className="gap-resizer__input-container">
					{isEditing ? (
						<input
							ref={inputRef}
							type="number"
							className="gap-resizer__input"
							value={inputValue}
							onChange={handleInputChange}
							onBlur={handleInputBlur}
							onKeyDown={handleInputKeyDown}
							min={minGap}
							max={maxGap}
						/>
					) : (
						<span
							className="gap-resizer__value"
							onClick={handleValueClick}
							title="Click para editar"
						>
							{gap}px
						</span>
					)}
				</div>
			)}
		</div>
	);
};

export default GapResizer;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/BarraHerramientas.jsx =====

// componentes/BarraHerramientas.jsx
// Barra de herramientas de la grilla

import React from "react";
import { ColorPickerSimple } from "../../../modales/comunes";
import { PanelConfigChispas } from "./PanelConfigChispas";

// Iconos SVG
const IconoPincel = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34a.996.996 0 00-1.41 0L9 12.25 11.75 15l8.96-8.96a.996.996 0 000-1.41z"/>
   </svg>
);

const IconoBorrador = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M15.14 3c-.51 0-1.02.2-1.41.59L2.59 14.73c-.78.78-.78 2.05 0 2.83l3.85 3.85c.39.39.9.59 1.41.59h8.48c.53 0 1.04-.21 1.41-.59l3.67-3.67c.78-.78.78-2.05 0-2.83L12.56 3.59C12.17 3.2 11.66 3 11.14 3h4zm-9.71 18H8.3l8.57-8.57-2.83-2.83L5.43 18.17l-.01 2.83z"/>
   </svg>
);

const IconoBalde = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M19 11.5s-2 2.17-2 3.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-3.5-2-3.5zM5.21 10L10 5.21 14.79 10H5.21zM16.56 8.94L10 2.38 3.44 8.94c-.59.59-.59 1.54 0 2.12l6.56 6.56c.59.59 1.54.59 2.12 0l6.44-6.44c.59-.59.59-1.54 0-2.12l-.12-.12z"/>
   </svg>
);

const IconoTexto = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M5 4v3h5.5v12h3V7H19V4H5z"/>
   </svg>
);

const IconoMover = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"/>
   </svg>
);

const IconoEliminar = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
   </svg>
);

const IconoGotero = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M20.71 5.63l-2.34-2.34a1 1 0 00-1.41 0l-3.12 3.12-1.41-1.41-1.42 1.42 1.41 1.41-7.83 7.83a2 2 0 00-.59 1.42V19h2.83c.53 0 1.04-.21 1.42-.59l7.83-7.83 1.41 1.41 1.42-1.42-1.41-1.41 3.12-3.12a1 1 0 00.09-1.41zM6.41 18H5v-1.41l7.83-7.83 1.41 1.41L6.41 18z"/>
   </svg>
);

const IconoRayo = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M11 21h-1l1-7H7.5c-.58 0-.57-.32-.38-.66l.07-.12C8.48 10.94 10.42 7.54 13 3h1l-1 7h3.5c.49 0 .56.33.47.51l-.07.15C12.96 17.55 11 21 11 21z"/>
   </svg>
);

const IconoDiana = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" strokeWidth="2"/>
      <circle cx="12" cy="12" r="6" fill="none" stroke="currentColor" strokeWidth="2"/>
      <circle cx="12" cy="12" r="2"/>
   </svg>
);

const IconoPlay = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M8 5v14l11-7z"/>
   </svg>
);

const IconoPause = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <rect x="6" y="4" width="4" height="16"/>
      <rect x="14" y="4" width="4" height="16"/>
   </svg>
);

const IconoConfig = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
   </svg>
);

const IconoCheck = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
      <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
   </svg>
);

const IconoX = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
      <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
   </svg>
);

/**
 * Componente de barra de herramientas
 */
export function BarraHerramientas({
   // Colores
   coloresDisponibles,
   colorSeleccionado,
   onCambiarColor,
   // Grosor
   grosoresDisponibles,
   grosorLinea,
   onCambiarGrosor,
   // Gotero
   modoGotero,
   onToggleGotero,
   // Herramientas
   herramienta,
   onSeleccionarPincel,
   onSeleccionarBorrador,
   onSeleccionarBalde,
   onSeleccionarTexto,
   onSeleccionarMover,
   onSeleccionarBorne,
   onLimpiarTodo,
   // Bornes y chispas
   tipoBorneActivo,
   onCambiarTipoBorne,
   bornes,
   animandoChispas,
   onToggleAnimacionChispas,
   panelChispasVisible,
   onTogglePanelChispas,
   chispasConfig,
   onActualizarChispasConfig,
   // Texto
   textoSeleccionadoId,
   textos,
   fuentesDisponibles,
   tamanosDisponibles,
   configTexto,
   onConfigTextoChange,
   onActualizarTexto,
   onEliminarTexto,
   inputTextoVisible,
   // Shift
   shiftPresionado,
   // Cerrar
   onCerrarEdicion
}) {
   const emisores = bornes.filter(b => b.tipo === "EMISOR").length;
   const receptores = bornes.filter(b => b.tipo === "RECEPTOR").length;
   const puedeAnimarChispas = emisores > 0 && receptores > 0;

   return (
      <div className="grilla-unifilar__toolbar">
         {/* Selector de colores */}
         <div className="grilla-unifilar__colores">
            {coloresDisponibles.map((c) => (
               <button
                  key={c.id}
                  type="button"
                  className={`grilla-unifilar__color ${colorSeleccionado === c.color ? "grilla-unifilar__color--activo" : ""} ${c.id === "negro" ? "grilla-unifilar__color--negro" : ""}`}
                  style={{ backgroundColor: c.color }}
                  onClick={() => {
                     onCambiarColor(c.color);
                     if (herramienta !== "texto") {
                        onSeleccionarPincel();
                     }
                  }}
                  title={c.nombre}
               />
            ))}
            <div className="grilla-unifilar__separador" />
            <ColorPickerSimple
               color={colorSeleccionado}
               onChange={(color) => {
                  onCambiarColor(color);
                  if (herramienta !== "texto") {
                     onSeleccionarPincel();
                  }
               }}
               label=""
               posicionArriba={true}
            />
         </div>

         {/* Secci√≥n de grosor y gotero */}
         <div className="grilla-unifilar__seccion-grosor">
            <select
               className="grilla-unifilar__select grilla-unifilar__select--grosor"
               value={grosorLinea}
               onChange={(e) => onCambiarGrosor?.(Number(e.target.value))}
               title="Grosor de l√≠nea"
            >
               {grosoresDisponibles.map((g) => (
                  <option key={g.id} value={g.valor}>
                     {g.nombre}
                  </option>
               ))}
            </select>
            <button
               type="button"
               className={`grilla-unifilar__btn ${modoGotero ? "grilla-unifilar__btn--activo" : ""}`}
               onClick={onToggleGotero}
               title="Gotero - clic en el canvas para copiar color"
            >
               <IconoGotero />
            </button>
         </div>

         {/* Herramientas */}
         <div className="grilla-unifilar__herramientas">
            <button
               type="button"
               className={`grilla-unifilar__btn ${herramienta === "pincel" ? "grilla-unifilar__btn--activo" : ""}`}
               onClick={onSeleccionarPincel}
               title="Pincel (mantener Shift para l√≠nea recta)"
            >
               <IconoPincel />
            </button>
            <button
               type="button"
               className={`grilla-unifilar__btn ${herramienta === "borrador" ? "grilla-unifilar__btn--activo" : ""}`}
               onClick={onSeleccionarBorrador}
               title="Borrador"
            >
               <IconoBorrador />
            </button>
            <button
               type="button"
               className={`grilla-unifilar__btn ${herramienta === "balde" ? "grilla-unifilar__btn--activo" : ""}`}
               onClick={onSeleccionarBalde}
               title="Balde de pintura (cambiar color de l√≠neas conectadas)"
            >
               <IconoBalde />
            </button>
            <button
               type="button"
               className={`grilla-unifilar__btn ${herramienta === "texto" ? "grilla-unifilar__btn--activo" : ""}`}
               onClick={onSeleccionarTexto}
               title="Texto (doble clic para editar, arrastrar para mover)"
            >
               <IconoTexto />
            </button>
            <button
               type="button"
               className={`grilla-unifilar__btn ${herramienta === "mover" ? "grilla-unifilar__btn--activo" : ""}`}
               onClick={onSeleccionarMover}
               title="Mover l√≠neas (arrastra l√≠neas conectadas)"
            >
               <IconoMover />
            </button>
            <button
               type="button"
               className="grilla-unifilar__btn grilla-unifilar__btn--peligro"
               onClick={onLimpiarTodo}
               title="Limpiar todo"
            >
               <IconoEliminar />
            </button>

            <div className="grilla-unifilar__separador" />

            {/* Herramientas de bornes y chispas */}
            <button
               type="button"
               className={`grilla-unifilar__btn grilla-unifilar__btn--emisor ${herramienta === "borne" && tipoBorneActivo === "EMISOR" ? "grilla-unifilar__btn--activo" : ""}`}
               onClick={() => {
                  onCambiarTipoBorne("EMISOR");
                  onSeleccionarBorne?.();
               }}
               title="Colocar borne emisor (origen de chispas)"
            >
               <IconoRayo />
            </button>
            <button
               type="button"
               className={`grilla-unifilar__btn grilla-unifilar__btn--receptor ${herramienta === "borne" && tipoBorneActivo === "RECEPTOR" ? "grilla-unifilar__btn--activo" : ""}`}
               onClick={() => {
                  onCambiarTipoBorne("RECEPTOR");
                  onSeleccionarBorne?.();
               }}
               title="Colocar borne receptor (destino de chispas)"
            >
               <IconoDiana />
            </button>
            <button
               type="button"
               className={`grilla-unifilar__btn ${animandoChispas ? "grilla-unifilar__btn--activo grilla-unifilar__btn--animando" : ""}`}
               onClick={onToggleAnimacionChispas}
               title={animandoChispas ? "Detener animaci√≥n de chispas" : "Iniciar animaci√≥n de chispas"}
               disabled={!puedeAnimarChispas}
            >
               {animandoChispas ? <IconoPause /> : <IconoPlay />}
            </button>
            <button
               type="button"
               className={`grilla-unifilar__btn ${panelChispasVisible ? "grilla-unifilar__btn--activo" : ""}`}
               onClick={onTogglePanelChispas}
               title="Configuraci√≥n de chispas"
            >
               <IconoConfig />
            </button>
         </div>

         {/* Opciones de texto */}
         {herramienta === "texto" && (
            <div className="grilla-unifilar__texto-opciones">
               <select
                  className="grilla-unifilar__select"
                  value={configTexto.fuente}
                  onChange={(e) => {
                     const nuevaFuente = e.target.value;
                     onConfigTextoChange?.({ ...configTexto, fuente: nuevaFuente });
                     if (!inputTextoVisible && textoSeleccionadoId) {
                        onActualizarTexto?.(textoSeleccionadoId, { fuente: nuevaFuente });
                     }
                  }}
                  title="Fuente"
               >
                  {fuentesDisponibles.map((f) => (
                     <option key={f.id} value={f.familia}>
                        {f.nombre}
                     </option>
                  ))}
               </select>

               <select
                  className="grilla-unifilar__select grilla-unifilar__select--tamano"
                  value={configTexto.tamano}
                  onChange={(e) => {
                     const nuevoTamano = Number(e.target.value);
                     onConfigTextoChange?.({ ...configTexto, tamano: nuevoTamano });
                     if (!inputTextoVisible && textoSeleccionadoId) {
                        onActualizarTexto?.(textoSeleccionadoId, { tamano: nuevoTamano });
                     }
                  }}
                  title="Tama√±o"
               >
                  {tamanosDisponibles.map((t) => (
                     <option key={t} value={t}>
                        {t}px
                     </option>
                  ))}
               </select>

               <button
                  type="button"
                  className={`grilla-unifilar__btn grilla-unifilar__btn--formato ${configTexto.negrita ? "grilla-unifilar__btn--activo" : ""}`}
                  onClick={() => {
                     if (inputTextoVisible) {
                        onConfigTextoChange?.({ ...configTexto, negrita: !configTexto.negrita });
                     } else if (textoSeleccionadoId) {
                        const textoActual = textos.find(t => t.id === textoSeleccionadoId);
                        if (textoActual) {
                           onActualizarTexto?.(textoSeleccionadoId, { negrita: !textoActual.negrita });
                        }
                     } else {
                        onConfigTextoChange?.({ ...configTexto, negrita: !configTexto.negrita });
                     }
                  }}
                  title="Negrita"
               >
                  <strong>B</strong>
               </button>

               <button
                  type="button"
                  className={`grilla-unifilar__btn grilla-unifilar__btn--formato ${configTexto.cursiva ? "grilla-unifilar__btn--activo" : ""}`}
                  onClick={() => {
                     if (inputTextoVisible) {
                        onConfigTextoChange?.({ ...configTexto, cursiva: !configTexto.cursiva });
                     } else if (textoSeleccionadoId) {
                        const textoActual = textos.find(t => t.id === textoSeleccionadoId);
                        if (textoActual) {
                           onActualizarTexto?.(textoSeleccionadoId, { cursiva: !textoActual.cursiva });
                        }
                     } else {
                        onConfigTextoChange?.({ ...configTexto, cursiva: !configTexto.cursiva });
                     }
                  }}
                  title="Cursiva"
               >
                  <em>I</em>
               </button>

               {textoSeleccionadoId && (
                  <button
                     type="button"
                     className="grilla-unifilar__btn grilla-unifilar__btn--peligro"
                     onClick={() => onEliminarTexto?.(textoSeleccionadoId)}
                     title="Eliminar texto (Delete)"
                  >
                     <IconoX />
                  </button>
               )}
            </div>
         )}

         {/* Panel de configuraci√≥n de chispas */}
         <PanelConfigChispas
            visible={panelChispasVisible}
            bornes={bornes}
            chispasConfig={chispasConfig}
            onActualizarChispasConfig={onActualizarChispasConfig}
         />

         {/* Indicador de Shift */}
         {herramienta === "pincel" && shiftPresionado && (
            <div className="grilla-unifilar__shift-indicator">
               L√≠nea recta
            </div>
         )}

         {/* Bot√≥n cerrar */}
         <button
            type="button"
            className="grilla-unifilar__btn grilla-unifilar__btn--cerrar"
            onClick={onCerrarEdicion}
            title="Finalizar edici√≥n"
         >
            <IconoCheck />
            <span>Listo</span>
         </button>
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/CanvasChispas.jsx =====

// componentes/CanvasChispas.jsx
// Canvas separado para renderizar chispas con animaci√≥n independiente

import React, { useRef, useEffect } from "react";
import { hexToRgb, calcularAngulo, dibujarForma, dibujarGlow } from "../utilidades";

/**
 * Canvas de chispas - usa requestAnimationFrame independiente
 * @param {Object} props - Propiedades del componente
 */
export function CanvasChispas({
   ancho,
   alto,
   animandoChispas,
   chispasConfig,
   chispasRef,
   onObtenerPosicionPixelChispa,
   onObtenerEstelaPixeles
}) {
   const canvasRef = useRef(null);
   const animationRef = useRef(null);
   const propsRef = useRef({ onObtenerPosicionPixelChispa, onObtenerEstelaPixeles });

   // Mantener ref actualizado
   useEffect(() => {
      propsRef.current = { onObtenerPosicionPixelChispa, onObtenerEstelaPixeles };
   }, [onObtenerPosicionPixelChispa, onObtenerEstelaPixeles]);

   // Loop de animaci√≥n de chispas
   useEffect(() => {
      const canvas = canvasRef.current;
      if (!canvas || ancho === 0) return;

      canvas.width = ancho;
      canvas.height = alto;

      const ctx = canvas.getContext("2d");

      const colorChispa = chispasConfig.color || "#fef08a";
      const tamanoChispa = chispasConfig.tamano || 4;
      const mostrarEstela = chispasConfig.estela !== false;
      const formaChispa = chispasConfig.forma || "circulo";
      const rgb = hexToRgb(colorChispa);

      const dibujarChispas = () => {
         ctx.clearRect(0, 0, ancho, alto);

         const chispasActuales = chispasRef?.current || [];
         const { onObtenerPosicionPixelChispa: getPosicion, onObtenerEstelaPixeles: getEstela } = propsRef.current;

         if (chispasActuales.length > 0 && getPosicion) {
            for (let i = 0; i < chispasActuales.length; i++) {
               const chispa = chispasActuales[i];
               const angulo = calcularAngulo(chispa);

               // Dibujar estela
               if (mostrarEstela && getEstela) {
                  const estelaPixeles = getEstela(chispa);
                  for (let j = 0; j < estelaPixeles.length; j++) {
                     const punto = estelaPixeles[j];
                     dibujarForma(
                        ctx,
                        punto.x,
                        punto.y,
                        tamanoChispa * 0.6,
                        `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${punto.opacidad * 0.6})`,
                        formaChispa,
                        angulo,
                        punto.opacidad * 0.6
                     );
                  }
               }

               // Dibujar chispa principal
               const pos = getPosicion(chispa);

               // Efecto de brillo
               if (["circulo", "estrella", "anillo"].includes(formaChispa)) {
                  dibujarGlow(ctx, pos.x, pos.y, tamanoChispa, colorChispa);
               }

               dibujarForma(ctx, pos.x, pos.y, tamanoChispa, colorChispa, formaChispa, angulo);
            }
         }

         if (animandoChispas) {
            animationRef.current = requestAnimationFrame(dibujarChispas);
         }
      };

      if (animandoChispas) {
         animationRef.current = requestAnimationFrame(dibujarChispas);
      } else {
         ctx.clearRect(0, 0, ancho, alto);
      }

      return () => {
         if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
         }
      };
   }, [ancho, alto, animandoChispas, chispasConfig, chispasRef]);

   return (
      <canvas
         ref={canvasRef}
         className="grilla-unifilar__canvas-chispas"
         style={{ pointerEvents: "none" }}
      />
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/EditorTexto.jsx =====

// componentes/EditorTexto.jsx
// Editor de texto flotante con redimensionamiento

import React from "react";

/**
 * Icono de check
 */
const IconoCheck = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
      <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
   </svg>
);

/**
 * Icono de undo
 */
const IconoUndo = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
      <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
   </svg>
);

/**
 * Icono de cerrar
 */
const IconoCerrar = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
      <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
   </svg>
);

/**
 * Componente de editor de texto
 * @param {Object} props - Propiedades del componente
 */
export function EditorTexto({
   visible,
   x,
   y,
   valor,
   ancho,
   alto,
   editandoId,
   configTexto,
   colorSeleccionado,
   textareaRef,
   onCambiarValor,
   onKeyDown,
   onConfirmar,
   onCancelar,
   onIniciarRedimension
}) {
   if (!visible) return null;

   return (
      <div
         className="grilla-unifilar__input-texto"
         style={{ left: x, top: y }}
      >
         <div className="grilla-unifilar__input-wrapper">
            <div
               className="grilla-unifilar__textarea-container"
               style={{ width: ancho, height: alto }}
            >
               <textarea
                  ref={textareaRef}
                  autoFocus
                  value={valor}
                  onChange={(e) => onCambiarValor(e.target.value)}
                  onKeyDown={onKeyDown}
                  placeholder="Escribir texto... (Alt+Enter para nueva l√≠nea)"
                  style={{
                     fontFamily: configTexto.fuente,
                     fontSize: `${configTexto.tamano}px`,
                     fontWeight: configTexto.negrita ? "bold" : "normal",
                     fontStyle: configTexto.cursiva ? "italic" : "normal",
                     color: colorSeleccionado,
                  }}
               />

               {/* Handles de redimensionamiento - Esquinas */}
               <div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--nw" onMouseDown={(e) => onIniciarRedimension(e, "nw")} />
               <div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--ne" onMouseDown={(e) => onIniciarRedimension(e, "ne")} />
               <div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--sw" onMouseDown={(e) => onIniciarRedimension(e, "sw")} />
               <div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--se" onMouseDown={(e) => onIniciarRedimension(e, "se")} />

               {/* Handles de redimensionamiento - Lados */}
               <div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--n" onMouseDown={(e) => onIniciarRedimension(e, "n")} />
               <div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--s" onMouseDown={(e) => onIniciarRedimension(e, "s")} />
               <div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--e" onMouseDown={(e) => onIniciarRedimension(e, "e")} />
               <div className="grilla-unifilar__resize-handle grilla-unifilar__resize-handle--w" onMouseDown={(e) => onIniciarRedimension(e, "w")} />
            </div>

            {/* Botones de acci√≥n */}
            <div className="grilla-unifilar__input-acciones">
               <button
                  type="button"
                  className="grilla-unifilar__input-btn grilla-unifilar__input-btn--aceptar"
                  onClick={onConfirmar}
                  title="Aceptar (Enter)"
               >
                  <IconoCheck />
               </button>

               <button
                  type="button"
                  className={`grilla-unifilar__input-btn ${editandoId ? "grilla-unifilar__input-btn--volver" : "grilla-unifilar__input-btn--cerrar"}`}
                  onClick={onCancelar}
                  title={editandoId ? "Volver (Esc)" : "Cerrar (Esc)"}
               >
                  {editandoId ? <IconoUndo /> : <IconoCerrar />}
               </button>
            </div>
         </div>
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/index.js =====

// componentes/index.js
export { MenuContextual } from "./MenuContextual.jsx";
export { EditorTexto } from "./EditorTexto.jsx";
export { PanelConfigChispas } from "./PanelConfigChispas.jsx";
export { BarraHerramientas } from "./BarraHerramientas.jsx";
export { CanvasChispas } from "./CanvasChispas.jsx";

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/MenuContextual.jsx =====

// componentes/MenuContextual.jsx
// Men√∫ contextual para copiar/pegar/eliminar texto

import React from "react";

/**
 * Icono de copiar
 */
const IconoCopiar = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
      <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
   </svg>
);

/**
 * Icono de pegar
 */
const IconoPegar = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
      <path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"/>
   </svg>
);

/**
 * Icono de eliminar
 */
const IconoEliminar = () => (
   <svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
      <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
   </svg>
);

/**
 * Componente de men√∫ contextual
 * @param {Object} props - Propiedades del componente
 */
export function MenuContextual({
   visible,
   x,
   y,
   hayTextoEnPosicion,
   textoCopiado,
   onCopiar,
   onPegar,
   onEliminar
}) {
   if (!visible) return null;

   return (
      <div
         className="grilla-unifilar__menu-contextual"
         style={{ left: x, top: y }}
         onClick={(e) => e.stopPropagation()}
         onContextMenu={(e) => e.preventDefault()}
      >
         <button
            type="button"
            className={`grilla-unifilar__menu-item ${!hayTextoEnPosicion ? "grilla-unifilar__menu-item--disabled" : ""}`}
            onClick={onCopiar}
            disabled={!hayTextoEnPosicion}
         >
            <IconoCopiar />
            <span>Copiar</span>
            <span className="grilla-unifilar__menu-shortcut">Ctrl+C</span>
         </button>

         <button
            type="button"
            className={`grilla-unifilar__menu-item ${!textoCopiado ? "grilla-unifilar__menu-item--disabled" : ""}`}
            onClick={onPegar}
            disabled={!textoCopiado}
         >
            <IconoPegar />
            <span>Pegar</span>
            <span className="grilla-unifilar__menu-shortcut">Ctrl+V</span>
         </button>

         {hayTextoEnPosicion && (
            <div className="grilla-unifilar__menu-separator" />
         )}

         <button
            type="button"
            className={`grilla-unifilar__menu-item grilla-unifilar__menu-item--eliminar ${!hayTextoEnPosicion ? "grilla-unifilar__menu-item--disabled" : ""}`}
            onClick={onEliminar}
            disabled={!hayTextoEnPosicion}
         >
            <IconoEliminar />
            <span>Eliminar</span>
            <span className="grilla-unifilar__menu-shortcut">Delete</span>
         </button>
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/componentes/PanelConfigChispas.jsx =====

// componentes/PanelConfigChispas.jsx
// Panel de configuraci√≥n de chispas

import React from "react";

/**
 * Componente de panel de configuraci√≥n de chispas
 * @param {Object} props - Propiedades del componente
 */
export function PanelConfigChispas({
   visible,
   bornes,
   chispasConfig,
   onActualizarChispasConfig
}) {
   if (!visible) return null;

   const emisores = bornes.filter(b => b.tipo === "EMISOR").length;
   const receptores = bornes.filter(b => b.tipo === "RECEPTOR").length;

   return (
      <div className="grilla-unifilar__panel-chispas">
         <div className="grilla-unifilar__panel-header">
            <div className="grilla-unifilar__panel-titulo">Configuraci√≥n de Chispas</div>
            <div className="grilla-unifilar__panel-info-inline">
               Emisores: {emisores} | Receptores: {receptores}
            </div>
         </div>

         <div className="grilla-unifilar__panel-columnas">
            {/* COLUMNA IZQUIERDA */}
            <div className="grilla-unifilar__panel-columna">
               {/* Forma y Color en fila */}
               <div className="grilla-unifilar__panel-fila">
                  <div className="grilla-unifilar__panel-campo grilla-unifilar__panel-campo--flex">
                     <label>Forma:</label>
                     <select
                        className="grilla-unifilar__panel-select"
                        value={chispasConfig.forma || "circulo"}
                        onChange={(e) => onActualizarChispasConfig?.({ forma: e.target.value })}
                     >
                        <option value="circulo">C√≠rculo</option>
                        <option value="cuadrado">Cuadrado</option>
                        <option value="estrella">Estrella</option>
                        <option value="rayo">Rayo</option>
                        <option value="flecha">Flecha</option>
                        <option value="gota">Gota</option>
                        <option value="anillo">Anillo</option>
                        <option value="barra">Barra |</option>
                     </select>
                  </div>
                  <div className="grilla-unifilar__panel-campo grilla-unifilar__panel-campo--color">
                     <label>Color:</label>
                     <input
                        type="color"
                        value={chispasConfig.color || "#fef08a"}
                        onChange={(e) => onActualizarChispasConfig?.({ color: e.target.value })}
                     />
                  </div>
               </div>

               {/* Tama√±o */}
               <div className="grilla-unifilar__panel-campo">
                  <label>Tama√±o:</label>
                  <div className="grilla-unifilar__panel-slider-input">
                     <input
                        type="range"
                        min="2"
                        max="10"
                        value={chispasConfig.tamano || 4}
                        onChange={(e) => onActualizarChispasConfig?.({ tamano: Number(e.target.value) })}
                     />
                     <input
                        type="number"
                        className="grilla-unifilar__panel-number"
                        min="2"
                        max="10"
                        value={chispasConfig.tamano || 4}
                        onChange={(e) => {
                           const val = Math.min(10, Math.max(2, Number(e.target.value) || 2));
                           onActualizarChispasConfig?.({ tamano: val });
                        }}
                        onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
                     />
                     <span className="grilla-unifilar__panel-unidad">px</span>
                  </div>
               </div>

               {/* Velocidad */}
               <div className="grilla-unifilar__panel-campo">
                  <label>Velocidad:</label>
                  <div className="grilla-unifilar__panel-slider-input">
                     <input
                        type="range"
                        min="1"
                        max="20"
                        value={chispasConfig.velocidad || 8}
                        onChange={(e) => onActualizarChispasConfig?.({ velocidad: Number(e.target.value) })}
                     />
                     <input
                        type="number"
                        className="grilla-unifilar__panel-number"
                        min="1"
                        max="20"
                        value={chispasConfig.velocidad || 8}
                        onChange={(e) => {
                           const val = Math.min(20, Math.max(1, Number(e.target.value) || 1));
                           onActualizarChispasConfig?.({ velocidad: val });
                        }}
                        onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
                     />
                     <span className="grilla-unifilar__panel-unidad">cel/s</span>
                  </div>
               </div>
            </div>

            {/* COLUMNA DERECHA */}
            <div className="grilla-unifilar__panel-columna">
               {/* Intervalo entre emisiones */}
               <div className="grilla-unifilar__panel-campo">
                  <label>Intervalo:</label>
                  <div className="grilla-unifilar__panel-slider-input">
                     <input
                        type="range"
                        min="0.3"
                        max="5"
                        step="0.1"
                        value={(chispasConfig.frecuenciaEmision || 2000) / 1000}
                        onChange={(e) => onActualizarChispasConfig?.({ frecuenciaEmision: Math.round(Number(e.target.value) * 1000) })}
                     />
                     <input
                        type="number"
                        className="grilla-unifilar__panel-number"
                        min="0.3"
                        max="5"
                        step="0.1"
                        value={((chispasConfig.frecuenciaEmision || 2000) / 1000).toFixed(1)}
                        onChange={(e) => {
                           const val = Math.min(5, Math.max(0.3, Number(e.target.value) || 0.3));
                           onActualizarChispasConfig?.({ frecuenciaEmision: Math.round(val * 1000) });
                        }}
                        onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
                     />
                     <span className="grilla-unifilar__panel-unidad">seg</span>
                  </div>
               </div>

               {/* Estela checkbox */}
               <div className="grilla-unifilar__panel-campo grilla-unifilar__panel-campo--checkbox">
                  <label>
                     <input
                        type="checkbox"
                        checked={chispasConfig.estela !== false}
                        onChange={(e) => onActualizarChispasConfig?.({ estela: e.target.checked })}
                     />
                     Mostrar estela
                  </label>
               </div>

               {/* Longitud estela */}
               {chispasConfig.estela !== false && (
                  <div className="grilla-unifilar__panel-campo">
                     <label>Longitud:</label>
                     <div className="grilla-unifilar__panel-slider-input">
                        <input
                           type="range"
                           min="1"
                           max="10"
                           value={chispasConfig.longitudEstela || 5}
                           onChange={(e) => onActualizarChispasConfig?.({ longitudEstela: Number(e.target.value) })}
                        />
                        <input
                           type="number"
                           className="grilla-unifilar__panel-number"
                           min="1"
                           max="10"
                           value={chispasConfig.longitudEstela || 5}
                           onChange={(e) => {
                              const val = Math.min(10, Math.max(1, Number(e.target.value) || 1));
                              onActualizarChispasConfig?.({ longitudEstela: val });
                           }}
                           onKeyDown={(e) => e.key === "Enter" && e.target.blur()}
                        />
                        <span className="grilla-unifilar__panel-unidad">celdas</span>
                     </div>
                  </div>
               )}
            </div>
         </div>
      </div>
   );
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/GrillaUnifilar.jsx =====

// grilla-unifilar/GrillaUnifilar.jsx
// Componente refactorizado de grilla unifiliar

import React, { useRef, useEffect, useCallback, useState } from "react";
import { obtenerCoordenadasCelda, obtenerCoordenadasPixel, hayCeldaEn } from "./utilidades";
import { useTextEditor, useDragLines, useAreaBorrador, useKeyboardShortcuts } from "./hooks";
import { MenuContextual, EditorTexto, BarraHerramientas, CanvasChispas } from "./componentes";
import "../GrillaUnifilar.css";

/**
 * Componente de grilla unifiliar para dibujar diagramas
 * Funciona en dos modos:
 * - Modo edici√≥n: grilla visible al frente, permite dibujar
 * - Modo normal: solo muestra el dibujo como fondo transparente
 */
const GrillaUnifilar = ({
   celdas,
   textos = [],
   modoEdicion,
   colorSeleccionado,
   herramienta,
   estaPintando,
   coloresDisponibles,
   fuentesDisponibles = [],
   tamanosDisponibles = [],
   grosoresDisponibles = [],
   grosorLinea = 12,
   onCambiarGrosor,
   configTexto = {},
   onConfigTextoChange,
   textoSeleccionadoId,
   onTextoSeleccionadoChange,
   onPintarCelda,
   onIniciarPintado,
   onDetenerPintado,
   onCambiarColor,
   onSeleccionarPincel,
   onSeleccionarBorrador,
   onSeleccionarTexto,
   onSeleccionarBalde,
   onSeleccionarMover,
   onSeleccionarBorne,
   onRellenarConectadas,
   onBorrarArea,
   onObtenerCeldasConectadas,
   onMoverCeldasConectadas,
   onAgregarTexto,
   onActualizarTexto,
   onEliminarTexto,
   onLimpiarTodo,
   onCerrarEdicion,
   bornes = [],
   chispasConfig = {},
   tiposBorne = {},
   onAgregarBorne,
   onEliminarBorneEnPosicion,
   onActualizarChispasConfig,
   animandoChispas = false,
   onToggleAnimacionChispas,
   chispasRef: chispasRefProp,
   onObtenerPosicionPixelChispa,
   onObtenerEstelaPixeles,
}) => {
   const canvasRef = useRef(null);
   const contenedorRef = useRef(null);
   const posicionMouseRef = useRef({ x: 0, y: 0 });
   const [dimensiones, setDimensiones] = useState({ ancho: 0, alto: 0 });
   const [modoGotero, setModoGotero] = useState(false);
   const [tipoBorneActivo, setTipoBorneActivo] = useState("EMISOR");
   const [panelChispasVisible, setPanelChispasVisible] = useState(false);
   const [sobreTexto, setSobreTexto] = useState(false);
   const [sobreLinea, setSobreLinea] = useState(false);
   const [menuContextual, setMenuContextual] = useState({
      visible: false,
      x: 0,
      y: 0,
      pixelX: 0,
      pixelY: 0,
      hayTextoEnPosicion: false,
   });

   // Hooks personalizados
   const textEditor = useTextEditor({
      textos,
      colorSeleccionado,
      configTexto,
      onAgregarTexto,
      onActualizarTexto,
      onEliminarTexto,
      onTextoSeleccionadoChange,
      onCambiarColor,
      onConfigTextoChange
   });

   const dragLines = useDragLines({
      onActualizarTexto,
      onMoverCeldasConectadas,
      onObtenerCeldasConectadas,
      celdas
   });

   const areaBorrador = useAreaBorrador({ onBorrarArea });

   const { shiftPresionado } = useKeyboardShortcuts({
      textoSeleccionadoId,
      herramienta,
      inputTextoVisible: textEditor.inputTexto.visible,
      modoEdicion,
      textos,
      onEliminarTexto,
      onCopiarTexto: textEditor.copiarTexto,
      onPegarTexto: textEditor.pegarTexto,
      posicionMouseRef
   });

   // Calcular dimensiones
   useEffect(() => {
      let resizeObserver = null;
      let mutationObserver = null;
      const timers = [];

      const actualizarDimensiones = () => {
         if (!contenedorRef.current) return;
         const padre = contenedorRef.current.parentElement;
         if (!padre) return;

         const rect = padre.getBoundingClientRect();
         if (rect.width > 0 && rect.height > 0) {
            setDimensiones((prev) => {
               // Solo actualizar si realmente cambi√≥ para evitar re-renders innecesarios
               if (prev.ancho !== rect.width || prev.alto !== rect.height) {
                  return { ancho: rect.width, alto: rect.height };
               }
               return prev;
            });
         }
      };

      // M√∫ltiples intentos de actualizaci√≥n para capturar el layout estable
      requestAnimationFrame(actualizarDimensiones);
      timers.push(setTimeout(actualizarDimensiones, 50));
      timers.push(setTimeout(actualizarDimensiones, 150));
      timers.push(setTimeout(actualizarDimensiones, 300));
      timers.push(setTimeout(actualizarDimensiones, 500));

      resizeObserver = new ResizeObserver(actualizarDimensiones);
      if (contenedorRef.current?.parentElement) {
         resizeObserver.observe(contenedorRef.current.parentElement);
      }

      // Observar cambios en el body para detectar modales que se abren/cierran
      mutationObserver = new MutationObserver(() => {
         // Cuando se agregan/quitan elementos (modales), recalcular despu√©s de un peque√±o delay
         requestAnimationFrame(actualizarDimensiones);
         setTimeout(actualizarDimensiones, 100);
      });
      mutationObserver.observe(document.body, { childList: true, subtree: false });

      // Tambi√©n observar el documento para detectar cambios de visibilidad
      const handleVisibilityChange = () => {
         if (document.visibilityState === 'visible') {
            requestAnimationFrame(actualizarDimensiones);
         }
      };

      window.addEventListener("resize", actualizarDimensiones);
      document.addEventListener("visibilitychange", handleVisibilityChange);

      return () => {
         timers.forEach(clearTimeout);
         if (resizeObserver) resizeObserver.disconnect();
         if (mutationObserver) mutationObserver.disconnect();
         window.removeEventListener("resize", actualizarDimensiones);
         document.removeEventListener("visibilitychange", handleVisibilityChange);
      };
   }, [modoEdicion]);

   // Dibujar canvas principal
   useEffect(() => {
      const canvas = canvasRef.current;
      if (!canvas || dimensiones.ancho === 0) return;

      const ctx = canvas.getContext("2d");
      const { ancho, alto } = dimensiones;

      canvas.width = ancho;
      canvas.height = alto;
      ctx.clearRect(0, 0, ancho, alto);

      // Dibujar grilla en modo edici√≥n
      if (modoEdicion) {
         ctx.strokeStyle = "rgba(148, 163, 184, 0.5)";
         ctx.lineWidth = 1;

         for (let x = 0; x <= ancho; x += grosorLinea) {
            ctx.beginPath();
            ctx.moveTo(x + 0.5, 0);
            ctx.lineTo(x + 0.5, alto);
            ctx.stroke();
         }

         for (let y = 0; y <= alto; y += grosorLinea) {
            ctx.beginPath();
            ctx.moveTo(0, y + 0.5);
            ctx.lineTo(ancho, y + 0.5);
            ctx.stroke();
         }
      }

      // Dibujar celdas pintadas
      Object.entries(celdas).forEach(([clave, color]) => {
         const [x, y] = clave.split(",").map(Number);
         ctx.fillStyle = color;
         ctx.fillRect(x * grosorLinea, y * grosorLinea, grosorLinea, grosorLinea);
      });

      // Dibujar textos
      textos.forEach((t) => {
         const fontStyle = `${t.cursiva ? "italic " : ""}${t.negrita ? "bold " : ""}${t.tamano}px ${t.fuente}`;
         ctx.font = fontStyle;
         ctx.fillStyle = t.color;
         ctx.textBaseline = "top";

         const lineas = t.texto.split("\n");
         const alturaLinea = t.tamano * 1.2;
         let anchoMaximo = 0;

         lineas.forEach((linea, index) => {
            ctx.fillText(linea, t.x, t.y + index * alturaLinea);
            const anchoLinea = ctx.measureText(linea).width;
            if (anchoLinea > anchoMaximo) anchoMaximo = anchoLinea;
         });

         if (modoEdicion && textoSeleccionadoId === t.id) {
            const alturaTotal = lineas.length * alturaLinea;
            ctx.strokeStyle = "#22d3ee";
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 2]);
            ctx.strokeRect(t.x - 2, t.y - 2, anchoMaximo + 4, alturaTotal + 4);
            ctx.setLineDash([]);
         }
      });

      // Dibujar bornes
      bornes.forEach((borne) => {
         const centroX = borne.x * grosorLinea + grosorLinea / 2;
         const centroY = borne.y * grosorLinea + grosorLinea / 2;
         const radio = grosorLinea * 0.8;

         ctx.beginPath();
         ctx.arc(centroX, centroY, radio, 0, Math.PI * 2);
         ctx.fillStyle = borne.color;
         ctx.fill();
         ctx.strokeStyle = borne.tipo === "EMISOR" ? "#0ea5e9" : "#ea580c";
         ctx.lineWidth = 2;
         ctx.stroke();

         ctx.font = `bold ${grosorLinea * 0.7}px sans-serif`;
         ctx.fillStyle = "#ffffff";
         ctx.textAlign = "center";
         ctx.textBaseline = "middle";
         ctx.fillText(borne.tipo === "EMISOR" ? "E" : "R", centroX, centroY);
      });

      // Dibujar √°rea de selecci√≥n del borrador
      if (areaBorrador.areaBorrador.activo) {
         const { inicioX, inicioY, actualX, actualY } = areaBorrador.areaBorrador;
         const minX = Math.min(inicioX, actualX);
         const maxX = Math.max(inicioX, actualX);
         const minY = Math.min(inicioY, actualY);
         const maxY = Math.max(inicioY, actualY);

         const rectX = minX * grosorLinea;
         const rectY = minY * grosorLinea;
         const rectW = (maxX - minX + 1) * grosorLinea;
         const rectH = (maxY - minY + 1) * grosorLinea;

         ctx.fillStyle = "rgba(239, 68, 68, 0.25)";
         ctx.fillRect(rectX, rectY, rectW, rectH);

         ctx.strokeStyle = "#ef4444";
         ctx.lineWidth = 2;
         ctx.setLineDash([6, 3]);
         ctx.strokeRect(rectX, rectY, rectW, rectH);
         ctx.setLineDash([]);
      }
   }, [celdas, textos, modoEdicion, dimensiones, textoSeleccionadoId, grosorLinea, areaBorrador.areaBorrador, bornes]);

   // Capturar color con gotero
   const capturarColorGotero = useCallback((e) => {
      const canvas = canvasRef.current;
      if (!canvas) return;

      const ctx = canvas.getContext("2d");
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const pixel = ctx.getImageData(x, y, 1, 1).data;
      const r = pixel[0].toString(16).padStart(2, "0");
      const g = pixel[1].toString(16).padStart(2, "0");
      const b = pixel[2].toString(16).padStart(2, "0");

      onCambiarColor(`#${r}${g}${b}`);
      setModoGotero(false);
   }, [onCambiarColor]);

   // Mouse down
   const handleMouseDown = useCallback((e) => {
      if (!modoEdicion) return;
      if (e.button !== 0) return;
      e.preventDefault();

      if (menuContextual.visible) {
         setMenuContextual(prev => ({ ...prev, visible: false }));
         return;
      }

      if (modoGotero) {
         capturarColorGotero(e);
         return;
      }

      const coordsCelda = obtenerCoordenadasCelda(e, canvasRef.current, grosorLinea);
      const coordsPixel = obtenerCoordenadasPixel(e, canvasRef.current);

      if (herramienta === "texto") {
         if (!coordsPixel) return;
         const textoEncontrado = textEditor.textoEnPunto(coordsPixel.x, coordsPixel.y, canvasRef.current);

         if (textoEncontrado) {
            onTextoSeleccionadoChange?.(textoEncontrado.id);
            dragLines.iniciarArrastreTexto(textoEncontrado.id, coordsPixel.x, coordsPixel.y, textoEncontrado.x, textoEncontrado.y);
         } else {
            if (textoSeleccionadoId) {
               onTextoSeleccionadoChange?.(null);
               return;
            }
            textEditor.abrirEditorNuevo(coordsPixel.x, coordsPixel.y);
         }
      } else if (herramienta === "borne") {
         if (coordsCelda) {
            const borneExistente = bornes.find(b => b.x === coordsCelda.x && b.y === coordsCelda.y);
            if (borneExistente) {
               onEliminarBorneEnPosicion?.(coordsCelda.x, coordsCelda.y);
            } else {
               onAgregarBorne?.(coordsCelda.x, coordsCelda.y, tipoBorneActivo);
            }
         }
      } else if (herramienta === "balde") {
         if (coordsCelda) {
            onRellenarConectadas?.(coordsCelda.x, coordsCelda.y);
         }
      } else if (herramienta === "mover") {
         if (coordsCelda && hayCeldaEn(coordsCelda.x, coordsCelda.y, celdas)) {
            dragLines.iniciarArrastreLineas(coordsCelda.x, coordsCelda.y);
         }
      } else if (herramienta === "borrador") {
         if (coordsCelda) {
            areaBorrador.iniciarSeleccion(coordsCelda.x, coordsCelda.y);
         }
      } else {
         if (coordsCelda) {
            onIniciarPintado(coordsCelda.x, coordsCelda.y);
            onPintarCelda(coordsCelda.x, coordsCelda.y, shiftPresionado);
         }
      }
   }, [
      modoEdicion, modoGotero, capturarColorGotero, herramienta, grosorLinea,
      textEditor, dragLines, areaBorrador, onIniciarPintado, onPintarCelda,
      onRellenarConectadas, onTextoSeleccionadoChange, shiftPresionado,
      menuContextual.visible, textoSeleccionadoId, tipoBorneActivo,
      bornes, onAgregarBorne, onEliminarBorneEnPosicion, celdas
   ]);

   // Doble click para editar texto
   const handleDoubleClick = useCallback((e) => {
      if (!modoEdicion || herramienta !== "texto") return;
      e.preventDefault();

      const coordsPixel = obtenerCoordenadasPixel(e, canvasRef.current);
      if (!coordsPixel) return;

      const textoEncontrado = textEditor.textoEnPunto(coordsPixel.x, coordsPixel.y, canvasRef.current);
      if (textoEncontrado) {
         textEditor.abrirEditorExistente(textoEncontrado, canvasRef.current);
      }
   }, [modoEdicion, herramienta, textEditor]);

   // Mouse move
   const handleMouseMove = useCallback((e) => {
      if (!modoEdicion) return;

      const coordsPixel = obtenerCoordenadasPixel(e, canvasRef.current);
      if (coordsPixel) {
         posicionMouseRef.current = { x: coordsPixel.x, y: coordsPixel.y };
      }

      if (dragLines.arrastrando.activo) {
         if (coordsPixel) {
            dragLines.moverTextoArrastrando(coordsPixel.x, coordsPixel.y);
         }
         return;
      }

      if (dragLines.arrastrandoLineas.activo) {
         const coordsCelda = obtenerCoordenadasCelda(e, canvasRef.current, grosorLinea);
         if (coordsCelda) {
            dragLines.moverLineasArrastrando(coordsCelda.x, coordsCelda.y);
         }
         return;
      }

      if (areaBorrador.areaBorrador.activo) {
         const coordsCelda = obtenerCoordenadasCelda(e, canvasRef.current, grosorLinea);
         if (coordsCelda) {
            areaBorrador.actualizarSeleccion(coordsCelda.x, coordsCelda.y);
         }
         return;
      }

      if (herramienta === "texto" && coordsPixel) {
         const textoEncontrado = textEditor.textoEnPunto(coordsPixel.x, coordsPixel.y, canvasRef.current);
         setSobreTexto(!!textoEncontrado);
      }

      if (herramienta === "mover") {
         const coordsCelda = obtenerCoordenadasCelda(e, canvasRef.current, grosorLinea);
         if (coordsCelda) {
            setSobreLinea(hayCeldaEn(coordsCelda.x, coordsCelda.y, celdas));
         }
      }

      if (!estaPintando || herramienta === "texto" || herramienta === "mover" || herramienta === "borrador") return;

      const coordsCelda = obtenerCoordenadasCelda(e, canvasRef.current, grosorLinea);
      if (coordsCelda) {
         onPintarCelda(coordsCelda.x, coordsCelda.y, shiftPresionado);
      }
   }, [modoEdicion, dragLines, areaBorrador, herramienta, estaPintando, grosorLinea, textEditor, onPintarCelda, shiftPresionado, celdas]);

   // Mouse up
   const handleMouseUp = useCallback(() => {
      if (!modoEdicion) return;

      if (areaBorrador.areaBorrador.activo) {
         areaBorrador.confirmarBorrado();
      }

      onDetenerPintado();
      dragLines.detenerArrastre();
   }, [modoEdicion, onDetenerPintado, areaBorrador, dragLines]);

   // Mouse leave
   const handleMouseLeave = useCallback(() => {
      if (estaPintando) onDetenerPintado();
      dragLines.detenerArrastre();
      areaBorrador.cancelarSeleccion();
      setSobreTexto(false);
      setSobreLinea(false);
   }, [estaPintando, onDetenerPintado, dragLines, areaBorrador]);

   // Context menu
   const handleContextMenu = useCallback((e) => {
      if (!modoEdicion) return;
      if (herramienta !== "texto") {
         e.preventDefault();
         return;
      }

      e.preventDefault();
      e.stopPropagation();

      if (menuContextual.visible) {
         setMenuContextual(prev => ({ ...prev, visible: false }));
         return;
      }

      const coordsPixel = obtenerCoordenadasPixel(e, canvasRef.current);
      if (!coordsPixel) return;

      const textoEncontrado = textEditor.textoEnPunto(coordsPixel.x, coordsPixel.y, canvasRef.current);
      if (textoEncontrado) {
         onTextoSeleccionadoChange?.(textoEncontrado.id);
      } else {
         if (textoSeleccionadoId) {
            onTextoSeleccionadoChange?.(null);
            return;
         }
      }

      const rect = canvasRef.current.getBoundingClientRect();
      setMenuContextual({
         visible: true,
         x: e.clientX - rect.left,
         y: e.clientY - rect.top,
         pixelX: coordsPixel.x,
         pixelY: coordsPixel.y,
         hayTextoEnPosicion: !!textoEncontrado,
      });
   }, [modoEdicion, herramienta, textEditor, onTextoSeleccionadoChange, textoSeleccionadoId, menuContextual.visible]);

   // Cerrar men√∫ contextual
   useEffect(() => {
      const handleClick = () => {
         if (menuContextual.visible) {
            setMenuContextual(prev => ({ ...prev, visible: false }));
         }
      };

      if (menuContextual.visible) {
         setTimeout(() => window.addEventListener("click", handleClick), 0);
      }

      return () => window.removeEventListener("click", handleClick);
   }, [menuContextual.visible]);

   // Touch events
   const handleTouchStart = useCallback((e) => {
      if (!modoEdicion || herramienta === "texto") return;
      e.preventDefault();
      const touch = e.touches[0];
      const coordsCelda = obtenerCoordenadasCelda({ clientX: touch.clientX, clientY: touch.clientY }, canvasRef.current, grosorLinea);
      if (coordsCelda) {
         onIniciarPintado(coordsCelda.x, coordsCelda.y);
         onPintarCelda(coordsCelda.x, coordsCelda.y, false);
      }
   }, [modoEdicion, herramienta, grosorLinea, onIniciarPintado, onPintarCelda]);

   const handleTouchMove = useCallback((e) => {
      if (!modoEdicion || !estaPintando || herramienta === "texto") return;
      e.preventDefault();
      const touch = e.touches[0];
      const coordsCelda = obtenerCoordenadasCelda({ clientX: touch.clientX, clientY: touch.clientY }, canvasRef.current, grosorLinea);
      if (coordsCelda) {
         onPintarCelda(coordsCelda.x, coordsCelda.y, false);
      }
   }, [modoEdicion, estaPintando, herramienta, grosorLinea, onPintarCelda]);

   const handleTouchEnd = useCallback(() => {
      if (!modoEdicion) return;
      onDetenerPintado();
   }, [modoEdicion, onDetenerPintado]);

   // Redimensionamiento del textarea
   useEffect(() => {
      if (!textEditor.redimensionando.activo) return;

      const handleMouseMove = (e) => {
         const deltaX = e.clientX - textEditor.redimensionando.inicioX;
         const deltaY = e.clientY - textEditor.redimensionando.inicioY;
         const handle = textEditor.redimensionando.handle;

         let nuevoAncho = textEditor.redimensionando.anchoInicial;
         let nuevoAlto = textEditor.redimensionando.altoInicial;

         if (handle.includes("e")) nuevoAncho = Math.max(100, textEditor.redimensionando.anchoInicial + deltaX);
         if (handle.includes("w")) nuevoAncho = Math.max(100, textEditor.redimensionando.anchoInicial - deltaX);
         if (handle.includes("s")) nuevoAlto = Math.max(30, textEditor.redimensionando.altoInicial + deltaY);
         if (handle.includes("n")) nuevoAlto = Math.max(30, textEditor.redimensionando.altoInicial - deltaY);

         textEditor.setInputTexto(prev => ({ ...prev, ancho: nuevoAncho, alto: nuevoAlto }));
      };

      const handleMouseUp = () => {
         textEditor.setRedimensionando({ activo: false, handle: null, inicioX: 0, inicioY: 0, anchoInicial: 0, altoInicial: 0 });
      };

      window.addEventListener("mousemove", handleMouseMove);
      window.addEventListener("mouseup", handleMouseUp);

      return () => {
         window.removeEventListener("mousemove", handleMouseMove);
         window.removeEventListener("mouseup", handleMouseUp);
      };
   }, [textEditor.redimensionando, textEditor]);

   // No renderizar si no hay contenido y no est√° en modo edici√≥n
   if (!modoEdicion && Object.keys(celdas).length === 0 && textos.length === 0) {
      return null;
   }

   // Determinar cursor
   const getCursor = () => {
      if (!modoEdicion) return "default";
      if (modoGotero) return "crosshair";
      if (dragLines.arrastrando.activo) return "grabbing";
      if (dragLines.arrastrandoLineas.activo) return "grabbing";
      if (herramienta === "borrador") return "crosshair";
      if (herramienta === "balde") return "crosshair";
      if (herramienta === "borne") return "crosshair";
      if (herramienta === "mover") return sobreLinea ? "grab" : "move";
      if (herramienta === "texto") return sobreTexto ? "grab" : "text";
      return "crosshair";
   };

   return (
      <div
         ref={contenedorRef}
         className={`grilla-unifilar ${modoEdicion ? "grilla-unifilar--editando" : "grilla-unifilar--fondo"}`}
         onContextMenu={handleContextMenu}
      >
         <canvas
            ref={canvasRef}
            className="grilla-unifilar__canvas"
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseLeave}
            onDoubleClick={handleDoubleClick}
            onContextMenu={handleContextMenu}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
            style={{ cursor: getCursor() }}
         />

         <CanvasChispas
            ancho={dimensiones.ancho}
            alto={dimensiones.alto}
            animandoChispas={animandoChispas}
            chispasConfig={chispasConfig}
            chispasRef={chispasRefProp}
            onObtenerPosicionPixelChispa={onObtenerPosicionPixelChispa}
            onObtenerEstelaPixeles={onObtenerEstelaPixeles}
         />

         <MenuContextual
            visible={menuContextual.visible}
            x={menuContextual.x}
            y={menuContextual.y}
            hayTextoEnPosicion={menuContextual.hayTextoEnPosicion}
            textoCopiado={textEditor.textoCopiado}
            onCopiar={() => {
               if (textoSeleccionadoId) {
                  textEditor.copiarTexto(textoSeleccionadoId);
                  onTextoSeleccionadoChange?.(null);
               }
               setMenuContextual(prev => ({ ...prev, visible: false }));
            }}
            onPegar={() => {
               textEditor.pegarTexto(menuContextual.pixelX, menuContextual.pixelY);
               setMenuContextual(prev => ({ ...prev, visible: false }));
            }}
            onEliminar={() => {
               if (textoSeleccionadoId) {
                  onEliminarTexto?.(textoSeleccionadoId);
               }
               setMenuContextual(prev => ({ ...prev, visible: false }));
            }}
         />

         <EditorTexto
            visible={textEditor.inputTexto.visible}
            x={textEditor.inputTexto.x}
            y={textEditor.inputTexto.y}
            valor={textEditor.inputTexto.valor}
            ancho={textEditor.inputTexto.ancho}
            alto={textEditor.inputTexto.alto}
            editandoId={textEditor.inputTexto.editandoId}
            configTexto={configTexto}
            colorSeleccionado={colorSeleccionado}
            textareaRef={textEditor.textareaRef}
            onCambiarValor={(valor) => textEditor.setInputTexto(prev => ({ ...prev, valor }))}
            onKeyDown={textEditor.handleInputKeyDown}
            onConfirmar={textEditor.confirmarTexto}
            onCancelar={textEditor.cancelarTexto}
            onIniciarRedimension={textEditor.iniciarRedimension}
         />

         {modoEdicion && (
            <BarraHerramientas
               coloresDisponibles={coloresDisponibles}
               colorSeleccionado={colorSeleccionado}
               onCambiarColor={onCambiarColor}
               grosoresDisponibles={grosoresDisponibles}
               grosorLinea={grosorLinea}
               onCambiarGrosor={onCambiarGrosor}
               modoGotero={modoGotero}
               onToggleGotero={() => setModoGotero(!modoGotero)}
               herramienta={herramienta}
               onSeleccionarPincel={onSeleccionarPincel}
               onSeleccionarBorrador={onSeleccionarBorrador}
               onSeleccionarBalde={onSeleccionarBalde}
               onSeleccionarTexto={onSeleccionarTexto}
               onSeleccionarMover={onSeleccionarMover}
               onSeleccionarBorne={onSeleccionarBorne}
               onLimpiarTodo={onLimpiarTodo}
               tipoBorneActivo={tipoBorneActivo}
               onCambiarTipoBorne={setTipoBorneActivo}
               bornes={bornes}
               animandoChispas={animandoChispas}
               onToggleAnimacionChispas={onToggleAnimacionChispas}
               panelChispasVisible={panelChispasVisible}
               onTogglePanelChispas={() => setPanelChispasVisible(!panelChispasVisible)}
               chispasConfig={chispasConfig}
               onActualizarChispasConfig={onActualizarChispasConfig}
               textoSeleccionadoId={textoSeleccionadoId}
               textos={textos}
               fuentesDisponibles={fuentesDisponibles}
               tamanosDisponibles={tamanosDisponibles}
               configTexto={configTexto}
               onConfigTextoChange={onConfigTextoChange}
               onActualizarTexto={onActualizarTexto}
               onEliminarTexto={onEliminarTexto}
               inputTextoVisible={textEditor.inputTexto.visible}
               shiftPresionado={shiftPresionado}
               onCerrarEdicion={onCerrarEdicion}
            />
         )}
      </div>
   );
};

export default GrillaUnifilar;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/hooks/index.js =====

// hooks/index.js
export { useTextEditor } from "./useTextEditor.js";
export { useDragLines } from "./useDragLines.js";
export { useAreaBorrador } from "./useAreaBorrador.js";
export { useKeyboardShortcuts } from "./useKeyboardShortcuts.js";

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/hooks/useAreaBorrador.js =====

// hooks/useAreaBorrador.js
// Hook para manejar la selecci√≥n de √°rea del borrador

import { useState, useCallback } from "react";

/**
 * Estado inicial del √°rea de borrador
 */
const AREA_INICIAL = {
   activo: false,
   inicioX: 0,
   inicioY: 0,
   actualX: 0,
   actualY: 0
};

/**
 * Hook para manejar la selecci√≥n de √°rea del borrador
 * @param {Object} params - Par√°metros del hook
 * @returns {Object} Estado y funciones del borrador
 */
export function useAreaBorrador({ onBorrarArea }) {
   const [areaBorrador, setAreaBorrador] = useState(AREA_INICIAL);

   /**
    * Iniciar selecci√≥n de √°rea
    */
   const iniciarSeleccion = useCallback((x, y) => {
      setAreaBorrador({
         activo: true,
         inicioX: x,
         inicioY: y,
         actualX: x,
         actualY: y,
      });
   }, []);

   /**
    * Actualizar √°rea de selecci√≥n
    */
   const actualizarSeleccion = useCallback((x, y) => {
      if (areaBorrador.activo) {
         setAreaBorrador(prev => ({
            ...prev,
            actualX: x,
            actualY: y,
         }));
      }
   }, [areaBorrador.activo]);

   /**
    * Confirmar borrado del √°rea
    */
   const confirmarBorrado = useCallback(() => {
      if (areaBorrador.activo) {
         onBorrarArea?.(
            areaBorrador.inicioX,
            areaBorrador.inicioY,
            areaBorrador.actualX,
            areaBorrador.actualY
         );
         setAreaBorrador(AREA_INICIAL);
      }
   }, [areaBorrador, onBorrarArea]);

   /**
    * Cancelar selecci√≥n
    */
   const cancelarSeleccion = useCallback(() => {
      setAreaBorrador(AREA_INICIAL);
   }, []);

   return {
      areaBorrador,
      iniciarSeleccion,
      actualizarSeleccion,
      confirmarBorrado,
      cancelarSeleccion
   };
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/hooks/useDragLines.js =====

// hooks/useDragLines.js
// Hook para manejar el arrastre de l√≠neas y textos

import { useState, useCallback } from "react";

/**
 * Estado inicial de arrastre de texto
 */
const ARRASTRE_TEXTO_INICIAL = {
   activo: false,
   textoId: null,
   offsetX: 0,
   offsetY: 0
};

/**
 * Estado inicial de arrastre de l√≠neas
 */
const ARRASTRE_LINEAS_INICIAL = {
   activo: false,
   celdasConectadas: [],
   celdaInicialX: 0,
   celdaInicialY: 0,
   ultimaCeldaX: 0,
   ultimaCeldaY: 0
};

/**
 * Hook para manejar el arrastre de elementos
 * @param {Object} params - Par√°metros del hook
 * @returns {Object} Estado y funciones de arrastre
 */
export function useDragLines({
   onActualizarTexto,
   onMoverCeldasConectadas,
   onObtenerCeldasConectadas,
   celdas
}) {
   const [arrastrando, setArrastrando] = useState(ARRASTRE_TEXTO_INICIAL);
   const [arrastrandoLineas, setArrastrandoLineas] = useState(ARRASTRE_LINEAS_INICIAL);

   /**
    * Iniciar arrastre de texto
    */
   const iniciarArrastreTexto = useCallback((textoId, coordsX, coordsY, textoX, textoY) => {
      setArrastrando({
         activo: true,
         textoId,
         offsetX: coordsX - textoX,
         offsetY: coordsY - textoY
      });
   }, []);

   /**
    * Mover texto arrastrando
    */
   const moverTextoArrastrando = useCallback((coordsX, coordsY) => {
      if (arrastrando.activo && arrastrando.textoId) {
         onActualizarTexto?.(arrastrando.textoId, {
            x: coordsX - arrastrando.offsetX,
            y: coordsY - arrastrando.offsetY
         });
      }
   }, [arrastrando, onActualizarTexto]);

   /**
    * Iniciar arrastre de l√≠neas conectadas
    */
   const iniciarArrastreLineas = useCallback((x, y) => {
      const celdasConectadas = onObtenerCeldasConectadas?.(x, y, celdas) || [];
      if (celdasConectadas.length > 0) {
         setArrastrandoLineas({
            activo: true,
            celdasConectadas,
            celdaInicialX: x,
            celdaInicialY: y,
            ultimaCeldaX: x,
            ultimaCeldaY: y,
         });
         return true;
      }
      return false;
   }, [celdas, onObtenerCeldasConectadas]);

   /**
    * Mover l√≠neas arrastrando
    */
   const moverLineasArrastrando = useCallback((x, y) => {
      if (!arrastrandoLineas.activo || arrastrandoLineas.celdasConectadas.length === 0) return;

      const deltaX = x - arrastrandoLineas.ultimaCeldaX;
      const deltaY = y - arrastrandoLineas.ultimaCeldaY;

      if (deltaX !== 0 || deltaY !== 0) {
         onMoverCeldasConectadas?.(arrastrandoLineas.celdasConectadas, deltaX, deltaY);

         const nuevasCeldasConectadas = arrastrandoLineas.celdasConectadas.map(clave => {
            const [cx, cy] = clave.split(",").map(Number);
            return `${cx + deltaX},${cy + deltaY}`;
         });

         setArrastrandoLineas(prev => ({
            ...prev,
            celdasConectadas: nuevasCeldasConectadas,
            ultimaCeldaX: x,
            ultimaCeldaY: y,
         }));
      }
   }, [arrastrandoLineas, onMoverCeldasConectadas]);

   /**
    * Detener todo arrastre
    */
   const detenerArrastre = useCallback(() => {
      setArrastrando(ARRASTRE_TEXTO_INICIAL);
      setArrastrandoLineas(ARRASTRE_LINEAS_INICIAL);
   }, []);

   return {
      arrastrando,
      arrastrandoLineas,
      iniciarArrastreTexto,
      moverTextoArrastrando,
      iniciarArrastreLineas,
      moverLineasArrastrando,
      detenerArrastre
   };
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/hooks/useKeyboardShortcuts.js =====

// hooks/useKeyboardShortcuts.js
// Hook para manejar atajos de teclado

import { useState, useEffect, useRef } from "react";

/**
 * Hook para manejar atajos de teclado en la grilla
 * @param {Object} params - Par√°metros del hook
 * @returns {Object} Estado de teclas
 */
export function useKeyboardShortcuts({
   textoSeleccionadoId,
   herramienta,
   inputTextoVisible,
   modoEdicion,
   textos,
   onEliminarTexto,
   onCopiarTexto,
   onPegarTexto,
   posicionMouseRef
}) {
   const [shiftPresionado, setShiftPresionado] = useState(false);

   useEffect(() => {
      const handleKeyDown = (e) => {
         if (e.key === "Shift") {
            setShiftPresionado(true);
         }

         // Delete o Backspace para eliminar texto seleccionado
         if ((e.key === "Delete" || e.key === "Backspace") &&
             textoSeleccionadoId &&
             herramienta === "texto" &&
             !inputTextoVisible) {
            e.preventDefault();
            onEliminarTexto?.(textoSeleccionadoId);
         }

         // Ctrl+C para copiar texto seleccionado
         if (e.ctrlKey && e.key === "c" &&
             textoSeleccionadoId &&
             herramienta === "texto" &&
             modoEdicion &&
             !inputTextoVisible) {
            e.preventDefault();
            onCopiarTexto?.(textoSeleccionadoId);
         }

         // Ctrl+V para pegar texto
         if (e.ctrlKey && e.key === "v" &&
             herramienta === "texto" &&
             modoEdicion &&
             !inputTextoVisible) {
            e.preventDefault();
            const pos = posicionMouseRef?.current || { x: 100, y: 100 };
            onPegarTexto?.(pos.x, pos.y);
         }
      };

      const handleKeyUp = (e) => {
         if (e.key === "Shift") {
            setShiftPresionado(false);
         }
      };

      window.addEventListener("keydown", handleKeyDown);
      window.addEventListener("keyup", handleKeyUp);

      return () => {
         window.removeEventListener("keydown", handleKeyDown);
         window.removeEventListener("keyup", handleKeyUp);
      };
   }, [
      textoSeleccionadoId,
      herramienta,
      inputTextoVisible,
      modoEdicion,
      onEliminarTexto,
      onCopiarTexto,
      onPegarTexto,
      posicionMouseRef
   ]);

   return { shiftPresionado };
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/hooks/useTextEditor.js =====

// hooks/useTextEditor.js
// Hook para manejar la edici√≥n de texto en la grilla

import { useState, useCallback, useRef } from "react";

/**
 * Estado inicial del input de texto
 */
const INPUT_INICIAL = {
   visible: false,
   x: 0,
   y: 0,
   valor: "",
   editandoId: null,
   ancho: 220,
   alto: 55,
   valorOriginal: ""
};

/**
 * Estado inicial de redimensionamiento
 */
const REDIMENSION_INICIAL = {
   activo: false,
   handle: null,
   inicioX: 0,
   inicioY: 0,
   anchoInicial: 0,
   altoInicial: 0
};

/**
 * Hook para manejar el editor de texto
 * @param {Object} params - Par√°metros del hook
 * @returns {Object} Estado y funciones del editor
 */
export function useTextEditor({
   textos,
   colorSeleccionado,
   configTexto,
   onAgregarTexto,
   onActualizarTexto,
   onEliminarTexto,
   onTextoSeleccionadoChange,
   onCambiarColor,
   onConfigTextoChange
}) {
   const [inputTexto, setInputTexto] = useState(INPUT_INICIAL);
   const [redimensionando, setRedimensionando] = useState(REDIMENSION_INICIAL);
   const [textoCopiado, setTextoCopiado] = useState(null);
   const textareaRef = useRef(null);

   /**
    * Verificar si un punto est√° sobre un texto
    */
   const textoEnPunto = useCallback((px, py, canvas) => {
      if (!canvas) return null;

      const ctx = canvas.getContext("2d");

      for (let i = textos.length - 1; i >= 0; i--) {
         const t = textos[i];
         const fontStyle = `${t.cursiva ? "italic " : ""}${t.negrita ? "bold " : ""}${t.tamano}px ${t.fuente}`;
         ctx.font = fontStyle;

         const lineas = t.texto.split("\n");
         const alturaLinea = t.tamano * 1.2;
         let anchoMaximo = 0;
         lineas.forEach(linea => {
            const anchoLinea = ctx.measureText(linea).width;
            if (anchoLinea > anchoMaximo) anchoMaximo = anchoLinea;
         });
         const alturaTotal = lineas.length * alturaLinea;

         if (
            px >= t.x - 2 &&
            px <= t.x + anchoMaximo + 2 &&
            py >= t.y - 2 &&
            py <= t.y + alturaTotal + 2
         ) {
            return t;
         }
      }
      return null;
   }, [textos]);

   /**
    * Abrir editor para nuevo texto
    */
   const abrirEditorNuevo = useCallback((x, y) => {
      setInputTexto({
         visible: true,
         x,
         y,
         valor: "",
         editandoId: null,
         ancho: 220,
         alto: 55,
         valorOriginal: ""
      });
   }, []);

   /**
    * Abrir editor para texto existente
    */
   const abrirEditorExistente = useCallback((texto, canvas) => {
      const ctx = canvas?.getContext("2d");
      let anchoCalculado = 200;
      let altoCalculado = 40;

      if (ctx) {
         const fontStyle = `${texto.cursiva ? "italic " : ""}${texto.negrita ? "bold " : ""}${texto.tamano}px ${texto.fuente}`;
         ctx.font = fontStyle;
         const lineas = texto.texto.split("\n");
         const alturaLinea = texto.tamano * 1.2;
         let anchoMax = 0;
         lineas.forEach(linea => {
            const w = ctx.measureText(linea).width;
            if (w > anchoMax) anchoMax = w;
         });
         anchoCalculado = Math.max(200, anchoMax + 30);
         altoCalculado = Math.max(40, lineas.length * alturaLinea + 20);
      }

      onCambiarColor?.(texto.color);
      onConfigTextoChange?.({
         fuente: texto.fuente,
         tamano: texto.tamano,
         negrita: texto.negrita,
         cursiva: texto.cursiva,
      });

      setInputTexto({
         visible: true,
         x: texto.x,
         y: texto.y,
         valor: texto.texto,
         editandoId: texto.id,
         ancho: anchoCalculado,
         alto: altoCalculado,
         valorOriginal: texto.texto
      });
      onTextoSeleccionadoChange?.(texto.id);
   }, [onCambiarColor, onConfigTextoChange, onTextoSeleccionadoChange]);

   /**
    * Confirmar texto ingresado
    */
   const confirmarTexto = useCallback(() => {
      if (inputTexto.valor.trim()) {
         if (inputTexto.editandoId) {
            onActualizarTexto?.(inputTexto.editandoId, {
               texto: inputTexto.valor,
               color: colorSeleccionado,
               fuente: configTexto.fuente,
               tamano: configTexto.tamano,
               negrita: configTexto.negrita,
               cursiva: configTexto.cursiva,
            });
         } else {
            onAgregarTexto?.(inputTexto.x, inputTexto.y, inputTexto.valor);
         }
      } else if (inputTexto.editandoId) {
         onEliminarTexto?.(inputTexto.editandoId);
      }
      setInputTexto(INPUT_INICIAL);
   }, [inputTexto, colorSeleccionado, configTexto, onAgregarTexto, onActualizarTexto, onEliminarTexto]);

   /**
    * Cancelar edici√≥n
    */
   const cancelarTexto = useCallback(() => {
      setInputTexto(INPUT_INICIAL);
   }, []);

   /**
    * Eliminar texto actual
    */
   const eliminarTextoActual = useCallback(() => {
      if (inputTexto.editandoId) {
         onEliminarTexto?.(inputTexto.editandoId);
      }
      setInputTexto(INPUT_INICIAL);
   }, [inputTexto.editandoId, onEliminarTexto]);

   /**
    * Manejar teclas en el textarea
    */
   const handleInputKeyDown = useCallback((e) => {
      if (e.key === "Enter") {
         if (e.altKey) {
            e.preventDefault();
            const textarea = e.target;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const valor = inputTexto.valor;
            const nuevoValor = valor.substring(0, start) + "\n" + valor.substring(end);
            setInputTexto(prev => ({ ...prev, valor: nuevoValor }));
            setTimeout(() => {
               textarea.selectionStart = textarea.selectionEnd = start + 1;
            }, 0);
         } else {
            e.preventDefault();
            confirmarTexto();
         }
      } else if (e.key === "Escape") {
         cancelarTexto();
      }
   }, [confirmarTexto, cancelarTexto, inputTexto.valor]);

   /**
    * Manejar cambio de texto
    */
   const handleTextareaInput = useCallback((e) => {
      setInputTexto(prev => ({ ...prev, valor: e.target.value }));
   }, []);

   /**
    * Iniciar redimensionamiento
    */
   const iniciarRedimension = useCallback((e, handle) => {
      e.preventDefault();
      e.stopPropagation();
      setRedimensionando({
         activo: true,
         handle,
         inicioX: e.clientX,
         inicioY: e.clientY,
         anchoInicial: inputTexto.ancho,
         altoInicial: inputTexto.alto,
      });
   }, [inputTexto.ancho, inputTexto.alto]);

   /**
    * Copiar texto
    */
   const copiarTexto = useCallback((textoId) => {
      const textoACopiar = textos.find(t => t.id === textoId);
      if (textoACopiar) {
         setTextoCopiado({ ...textoACopiar });
      }
   }, [textos]);

   /**
    * Pegar texto
    */
   const pegarTexto = useCallback((x, y) => {
      if (textoCopiado) {
         onAgregarTexto?.(x, y, textoCopiado.texto);
         setTimeout(() => {
            const ultimoTexto = textos[textos.length - 1];
            if (ultimoTexto) {
               onActualizarTexto?.(ultimoTexto.id, {
                  color: textoCopiado.color,
                  fuente: textoCopiado.fuente,
                  tamano: textoCopiado.tamano,
                  negrita: textoCopiado.negrita,
                  cursiva: textoCopiado.cursiva,
               });
            }
         }, 50);
      }
   }, [textoCopiado, textos, onAgregarTexto, onActualizarTexto]);

   return {
      inputTexto,
      setInputTexto,
      redimensionando,
      setRedimensionando,
      textoCopiado,
      textareaRef,
      textoEnPunto,
      abrirEditorNuevo,
      abrirEditorExistente,
      confirmarTexto,
      cancelarTexto,
      eliminarTextoActual,
      handleInputKeyDown,
      handleTextareaInput,
      iniciarRedimension,
      copiarTexto,
      pegarTexto
   };
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/index.js =====

// grilla-unifilar/index.js
export { default } from "./GrillaUnifilar.jsx";

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/utilidades/coordenadas.js =====

// utilidades/coordenadas.js
// Funciones para calcular coordenadas en el canvas

/**
 * Obtener coordenadas de celda desde evento de mouse
 * @param {MouseEvent} e - Evento del mouse
 * @param {HTMLCanvasElement} canvas - Elemento canvas
 * @param {number} grosorLinea - Tama√±o de cada celda
 * @returns {{x: number, y: number} | null}
 */
export function obtenerCoordenadasCelda(e, canvas, grosorLinea) {
   if (!canvas) return null;

   const rect = canvas.getBoundingClientRect();
   const x = Math.floor((e.clientX - rect.left) / grosorLinea);
   const y = Math.floor((e.clientY - rect.top) / grosorLinea);

   return { x, y };
}

/**
 * Obtener coordenadas en p√≠xeles desde evento de mouse
 * @param {MouseEvent} e - Evento del mouse
 * @param {HTMLCanvasElement} canvas - Elemento canvas
 * @returns {{x: number, y: number} | null}
 */
export function obtenerCoordenadasPixel(e, canvas) {
   if (!canvas) return null;

   const rect = canvas.getBoundingClientRect();
   return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
   };
}

/**
 * Verificar si hay una celda pintada en las coordenadas dadas
 * @param {number} x - Coordenada X de celda
 * @param {number} y - Coordenada Y de celda
 * @param {Object} celdas - Objeto con las celdas pintadas
 * @returns {boolean}
 */
export function hayCeldaEn(x, y, celdas) {
   const claveCelda = `${x},${y}`;
   return !!celdas[claveCelda];
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/utilidades/dibujarFormas.js =====

// utilidades/dibujarFormas.js
// Funciones para dibujar formas de chispas en el canvas

/**
 * Convertir color hex a RGB
 * @param {string} hex - Color en formato hexadecimal
 * @returns {{r: number, g: number, b: number}}
 */
export function hexToRgb(hex) {
   const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
   return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
   } : { r: 254, g: 240, b: 138 };
}

/**
 * Calcular √°ngulo de direcci√≥n de una chispa
 * @param {Object} chispa - Objeto chispa con ruta y posici√≥n
 * @returns {number} √Ångulo en radianes
 */
export function calcularAngulo(chispa) {
   const { ruta, posicion } = chispa;
   if (!ruta || ruta.length < 2 || posicion >= ruta.length - 1) return 0;
   const [x1, y1] = ruta[posicion].split(",").map(Number);
   const [x2, y2] = ruta[posicion + 1].split(",").map(Number);
   return Math.atan2(y2 - y1, x2 - x1);
}

/**
 * Dibujar una forma en el canvas
 * @param {CanvasRenderingContext2D} ctx - Contexto del canvas
 * @param {number} x - Posici√≥n X
 * @param {number} y - Posici√≥n Y
 * @param {number} tamano - Tama√±o de la forma
 * @param {string} color - Color de la forma
 * @param {string} forma - Tipo de forma
 * @param {number} angulo - √Ångulo de rotaci√≥n
 * @param {number} opacidad - Opacidad de la forma
 */
export function dibujarForma(ctx, x, y, tamano, color, forma, angulo = 0, opacidad = 1) {
   ctx.save();
   ctx.translate(x, y);
   ctx.rotate(angulo);
   ctx.globalAlpha = opacidad;

   switch (forma) {
      case "cuadrado":
         ctx.fillStyle = color;
         ctx.fillRect(-tamano, -tamano, tamano * 2, tamano * 2);
         break;

      case "estrella":
         ctx.fillStyle = color;
         ctx.beginPath();
         for (let i = 0; i < 8; i++) {
            const radio = i % 2 === 0 ? tamano * 1.2 : tamano * 0.4;
            const a = (i * Math.PI) / 4;
            if (i === 0) ctx.moveTo(Math.cos(a) * radio, Math.sin(a) * radio);
            else ctx.lineTo(Math.cos(a) * radio, Math.sin(a) * radio);
         }
         ctx.closePath();
         ctx.fill();
         break;

      case "rayo":
         ctx.fillStyle = color;
         ctx.beginPath();
         ctx.moveTo(-tamano * 1.2, -tamano * 0.3);
         ctx.lineTo(-tamano * 0.3, tamano * 0.5);
         ctx.lineTo(-tamano * 0.3, 0);
         ctx.lineTo(tamano * 1.2, tamano * 0.3);
         ctx.lineTo(tamano * 0.3, -tamano * 0.5);
         ctx.lineTo(tamano * 0.3, 0);
         ctx.closePath();
         ctx.fill();
         break;

      case "flecha":
         ctx.fillStyle = color;
         ctx.beginPath();
         ctx.moveTo(tamano * 1.2, 0);
         ctx.lineTo(-tamano * 0.8, -tamano * 0.8);
         ctx.lineTo(-tamano * 0.4, 0);
         ctx.lineTo(-tamano * 0.8, tamano * 0.8);
         ctx.closePath();
         ctx.fill();
         break;

      case "gota":
         ctx.fillStyle = color;
         ctx.beginPath();
         ctx.moveTo(tamano * 1.2, 0);
         ctx.quadraticCurveTo(0, -tamano * 0.8, -tamano * 0.8, 0);
         ctx.quadraticCurveTo(0, tamano * 0.8, tamano * 1.2, 0);
         ctx.fill();
         break;

      case "anillo":
         ctx.strokeStyle = color;
         ctx.lineWidth = tamano * 0.4;
         ctx.beginPath();
         ctx.arc(0, 0, tamano * 0.8, 0, Math.PI * 2);
         ctx.stroke();
         break;

      case "barra":
         if (color.startsWith("#")) {
            const gradientBarra = ctx.createLinearGradient(-tamano * 6, 0, tamano * 6, 0);
            gradientBarra.addColorStop(0, "transparent");
            gradientBarra.addColorStop(0.15, `${color}15`);
            gradientBarra.addColorStop(0.3, `${color}40`);
            gradientBarra.addColorStop(0.45, `${color}80`);
            gradientBarra.addColorStop(0.5, color);
            gradientBarra.addColorStop(0.55, `${color}80`);
            gradientBarra.addColorStop(0.7, `${color}40`);
            gradientBarra.addColorStop(0.85, `${color}15`);
            gradientBarra.addColorStop(1, "transparent");
            ctx.fillStyle = gradientBarra;
            ctx.fillRect(-tamano * 6, -tamano * 1.2, tamano * 12, tamano * 2.4);
         }
         ctx.fillStyle = color;
         ctx.fillRect(-tamano * 0.4, -tamano * 1.2, tamano * 0.8, tamano * 2.4);
         break;

      case "circulo":
      default:
         ctx.fillStyle = color;
         ctx.beginPath();
         ctx.arc(0, 0, tamano, 0, Math.PI * 2);
         ctx.fill();
         break;
   }

   ctx.restore();
}

/**
 * Dibujar efecto de brillo (glow) para una chispa
 * @param {CanvasRenderingContext2D} ctx - Contexto del canvas
 * @param {number} x - Posici√≥n X
 * @param {number} y - Posici√≥n Y
 * @param {number} tamano - Tama√±o de la chispa
 * @param {string} color - Color de la chispa
 */
export function dibujarGlow(ctx, x, y, tamano, color) {
   const gradient = ctx.createRadialGradient(x, y, 0, x, y, tamano * 2);
   gradient.addColorStop(0, color);
   gradient.addColorStop(0.5, `${color}80`);
   gradient.addColorStop(1, "transparent");

   ctx.beginPath();
   ctx.arc(x, y, tamano * 2, 0, Math.PI * 2);
   ctx.fillStyle = gradient;
   ctx.fill();
}

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/grilla-unifilar/utilidades/index.js =====

// utilidades/index.js
export * from "./coordenadas.js";
export * from "./dibujarFormas.js";

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaTarjetas.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaTarjetas.jsx
// Grilla de tarjetas de alimentadores

import React, { useRef } from "react";
import TarjetaAlimentador from "./TarjetaAlimentador.jsx";
import GapResizer from "./GapResizer.jsx";
import RowGapResizer from "./RowGapResizer.jsx";
import GrillaUnifilar from "./GrillaUnifilar.jsx";
import { useGrillaUnifilar } from "../../hooks/grilla-unifilar";
import { useChispas } from "../../hooks/ui";
import { useDeteccionFilas, useModoMobile } from "./hooks";
import { puedeHacerPolling, GAP_FIJO_MOBILE, ROW_GAP_FIJO_MOBILE } from "./utilidades";
import { BotonEditarDiagrama, BotonesArchivo } from "./componentes";
import { ESCALA_MIN, ESCALA_MAX } from "../../constantes/escalas";
import "./GrillaTarjetas.css";

/**
 * Grilla de tarjetas de alimentadores.
 * Estructura flex-wrap con controles de gap horizontales y verticales.
 */
const GrillaTarjetas = ({
   alimentadores,
   lecturas,
   puestoId,
   workspaceId,
   elementoArrastrandoId,
   onAbrirConfiguracion,
   onAbrirHistorial,
   onDragStart,
   onDragOver,
   onDrop,
   onDragEnd,
   onDropAlFinal,
   onAgregarNuevo,
   puedeAgregarNuevo = true,
   esObservador = false,
   estaMidiendo,
   obtenerTimestampInicio,
   obtenerContadorLecturas,
   obtenerGap,
   onGapChange,
   obtenerRowGap,
   onRowGapChange,
   skeletonCard = null,
   estaPolling,
   onPlayStopClick,
   obtenerContadorPolling,
   obtenerErrorPolling,
   obtenerEscalaEfectiva,
   onEscalaChange,
}) => {
   const gridRef = useRef(null);
   const esModoMobile = useModoMobile();

   // Hook de detecci√≥n de filas
   const { posicionesEntreFilas, filasPorTarjeta } = useDeteccionFilas({
      gridRef,
      alimentadores,
      obtenerGap,
      onGapChange,
      puestoId,
      obtenerRowGap,
   });

   // Hook para la grilla unifiliar
   const grillaUnifilar = useGrillaUnifilar(puestoId, workspaceId);

   // Hook para animaci√≥n de chispas
   const chispasHook = useChispas({
      bornes: grillaUnifilar.bornes,
      celdas: grillaUnifilar.celdas,
      chispasConfig: grillaUnifilar.chispasConfig,
      grosorLinea: grillaUnifilar.grosorLinea,
   });

   // Valores para modo m√≥vil o desktop
   const rowGapPrimero = esModoMobile ? ROW_GAP_FIJO_MOBILE : obtenerRowGap(puestoId, 0);

   // Funci√≥n para obtener el margin-top de una tarjeta seg√∫n su fila
   const obtenerMarginTop = (alimId) => {
      const fila = filasPorTarjeta[alimId];
      if (fila === undefined || fila === 0) return 0;
      return esModoMobile ? ROW_GAP_FIJO_MOBILE : obtenerRowGap(puestoId, fila);
   };

   return (
      <div className="grilla-con-row-gaps">
         {/* Grilla unifiliar - solo en desktop */}
         {!esModoMobile && (
            <GrillaUnifilar
               celdas={grillaUnifilar.celdas}
               textos={grillaUnifilar.textos}
               modoEdicion={grillaUnifilar.modoEdicion}
               colorSeleccionado={grillaUnifilar.colorSeleccionado}
               herramienta={grillaUnifilar.herramienta}
               estaPintando={grillaUnifilar.estaPintando}
               coloresDisponibles={grillaUnifilar.coloresDisponibles}
               fuentesDisponibles={grillaUnifilar.fuentesDisponibles}
               tamanosDisponibles={grillaUnifilar.tamanosDisponibles}
               grosoresDisponibles={grillaUnifilar.grosoresDisponibles}
               grosorLinea={grillaUnifilar.grosorLinea}
               onCambiarGrosor={grillaUnifilar.cambiarGrosor}
               configTexto={grillaUnifilar.configTexto}
               onConfigTextoChange={grillaUnifilar.setConfigTexto}
               textoSeleccionadoId={grillaUnifilar.textoSeleccionadoId}
               onTextoSeleccionadoChange={grillaUnifilar.setTextoSeleccionadoId}
               onPintarCelda={grillaUnifilar.pintarCelda}
               onIniciarPintado={grillaUnifilar.iniciarPintado}
               onDetenerPintado={grillaUnifilar.detenerPintado}
               onCambiarColor={grillaUnifilar.setColorSeleccionado}
               onSeleccionarPincel={grillaUnifilar.seleccionarPincel}
               onSeleccionarBorrador={grillaUnifilar.seleccionarBorrador}
               onSeleccionarTexto={grillaUnifilar.seleccionarTexto}
               onSeleccionarBalde={grillaUnifilar.seleccionarBalde}
               onSeleccionarMover={grillaUnifilar.seleccionarMover}
               onRellenarConectadas={grillaUnifilar.rellenarConectadas}
               onBorrarArea={grillaUnifilar.borrarArea}
               onObtenerCeldasConectadas={grillaUnifilar.obtenerCeldasConectadas}
               onMoverCeldasConectadas={grillaUnifilar.moverCeldasConectadas}
               onAgregarTexto={grillaUnifilar.agregarTexto}
               onActualizarTexto={grillaUnifilar.actualizarTexto}
               onEliminarTexto={grillaUnifilar.eliminarTexto}
               onLimpiarTodo={grillaUnifilar.limpiarTodo}
               onCerrarEdicion={grillaUnifilar.desactivarEdicion}
               bornes={grillaUnifilar.bornes}
               chispasConfig={grillaUnifilar.chispasConfig}
               tiposBorne={grillaUnifilar.tiposBorne}
               onSeleccionarBorne={grillaUnifilar.seleccionarBorne}
               onAgregarBorne={grillaUnifilar.agregarBorne}
               onEliminarBorneEnPosicion={grillaUnifilar.eliminarBorneEnPosicion}
               onActualizarChispasConfig={grillaUnifilar.actualizarChispasConfig}
               animandoChispas={chispasHook.animando}
               onToggleAnimacionChispas={chispasHook.toggleAnimacion}
               chispasRef={chispasHook.chispasRef}
               onObtenerPosicionPixelChispa={chispasHook.obtenerPosicionPixel}
               onObtenerEstelaPixeles={chispasHook.obtenerEstelaPixeles}
            />
         )}

         {/* Bot√≥n editar diagrama - solo en desktop */}
         {!esModoMobile && !grillaUnifilar.modoEdicion && (
            <BotonEditarDiagrama onActivar={grillaUnifilar.activarEdicion} />
         )}

         {/* Botones guardar/cargar - solo en modo edici√≥n y desktop */}
         {!esModoMobile && grillaUnifilar.modoEdicion && (
            <BotonesArchivo
               onExportar={grillaUnifilar.exportarAArchivo}
               onImportar={grillaUnifilar.importarDesdeArchivo}
            />
         )}

         {/* RowGapResizer primera fila - solo en desktop */}
         {!elementoArrastrandoId && !esModoMobile ? (
            <RowGapResizer
               gap={obtenerRowGap(puestoId, 0)}
               onGapChange={(nuevoGap) => onRowGapChange(puestoId, 0, nuevoGap)}
               rowIndex={0}
            />
         ) : (
            <div style={{ height: rowGapPrimero }} />
         )}

         {/* Mensaje sin alimentadores */}
         {alimentadores.length === 0 && (
            <p className="alim-empty-message">
               Este puesto no tiene alimentadores. Haz clic en el bot√≥n de abajo para agregar.
            </p>
         )}

         <div ref={gridRef} className="alim-cards-grid">
            {alimentadores.map((alim) => {
               const lecturasAlim = lecturas[alim.id] || {};
               const mideRele = estaMidiendo(alim.id, "rele");
               const mideAnalizador = estaMidiendo(alim.id, "analizador");
               const gapTarjeta = obtenerGap(alim.id);
               const marginTop = obtenerMarginTop(alim.id);

               return (
                  <React.Fragment key={alim.id}>
                     <div
                        className="alim-card-wrapper"
                        data-alim-id={alim.id}
                        style={marginTop > 0 ? { marginTop: `${marginTop}px` } : undefined}
                     >
                        <TarjetaAlimentador
                           nombre={alim.nombre}
                           color={alim.color}
                           onConfigClick={() => onAbrirConfiguracion(puestoId, alim)}
                           onHistorialClick={
                              onAbrirHistorial ? () => onAbrirHistorial(puestoId, alim) : undefined
                           }
                           esObservador={esObservador}
                           topSide={lecturasAlim.parteSuperior}
                           bottomSide={lecturasAlim.parteInferior}
                           draggable={true}
                           isDragging={elementoArrastrandoId === alim.id}
                           onDragStart={() => onDragStart(alim.id)}
                           onDragOver={onDragOver}
                           onDrop={(e) => {
                              e.preventDefault();
                              onDrop(alim.id);
                           }}
                           onDragEnd={onDragEnd}
                           mideRele={mideRele}
                           mideAnalizador={mideAnalizador}
                           periodoRele={alim.periodoSegundos || 60}
                           periodoAnalizador={alim.analizador?.periodoSegundos || 60}
                           timestampInicioRele={obtenerTimestampInicio(alim.id, "rele")}
                           timestampInicioAnalizador={obtenerTimestampInicio(alim.id, "analizador")}
                           contadorRele={obtenerContadorLecturas(alim.id, "rele")}
                           contadorAnalizador={obtenerContadorLecturas(alim.id, "analizador")}
                           estaPolling={estaPolling ? estaPolling(alim.id) : false}
                           puedePolling={puedeHacerPolling(alim)}
                           onPlayStopClick={() => onPlayStopClick && onPlayStopClick(alim.id)}
                           contadorPolling={obtenerContadorPolling ? obtenerContadorPolling(alim.id) : 0}
                           periodoPolling={(alim.intervalo_consulta_ms || 60000) / 1000}
                           errorPolling={obtenerErrorPolling ? obtenerErrorPolling(alim.id) : null}
                           escala={obtenerEscalaEfectiva ? obtenerEscalaEfectiva(alim.id, puestoId) : 1.0}
                           onEscalaChange={
                              !esModoMobile && onEscalaChange
                                 ? (nuevaEscala) => onEscalaChange(alim.id, nuevaEscala)
                                 : undefined
                           }
                           ESCALA_MIN={ESCALA_MIN}
                           ESCALA_MAX={ESCALA_MAX}
                        />
                     </div>
                     {!elementoArrastrandoId && !esModoMobile ? (
                        <div style={marginTop > 0 ? { marginTop: `${marginTop}px` } : undefined}>
                           <GapResizer
                              gap={gapTarjeta}
                              onGapChange={(nuevoGap) => onGapChange(alim.id, nuevoGap)}
                           />
                        </div>
                     ) : (
                        <div
                           className="gap-spacer"
                           style={{
                              width: esModoMobile ? GAP_FIJO_MOBILE : gapTarjeta,
                              ...(marginTop > 0 && { marginTop: `${marginTop}px` }),
                           }}
                        />
                     )}
                  </React.Fragment>
               );
            })}

            {/* Skeleton card */}
            {skeletonCard && (() => {
               const marginTopSkeleton = obtenerMarginTop("nuevo-registrador");
               return (
                  <React.Fragment>
                     <div
                        className="alim-card-wrapper"
                        data-alim-id="skeleton"
                        style={marginTopSkeleton > 0 ? { marginTop: `${marginTopSkeleton}px` } : undefined}
                     >
                        {skeletonCard}
                     </div>
                     <div className="gap-spacer" style={{ width: esModoMobile ? GAP_FIJO_MOBILE : 10 }} />
                  </React.Fragment>
               );
            })()}

            {/* Tarjeta "Nuevo Registrador" o zona de drop */}
            {(elementoArrastrandoId || puedeAgregarNuevo) && (() => {
               const marginTopNuevo = obtenerMarginTop("nuevo-registrador");
               const styleNuevo = {
                  width: 304,
                  minWidth: 304,
                  maxWidth: 304,
                  height: 279,
                  minHeight: 279,
                  ...(marginTopNuevo > 0 && { marginTop: `${marginTopNuevo}px` }),
               };

               return elementoArrastrandoId ? (
                  <div
                     className="alim-card-add"
                     style={styleNuevo}
                     onDragOver={onDragOver}
                     onDrop={(e) => {
                        e.preventDefault();
                        onDropAlFinal();
                     }}
                  >
                     <span style={{ textAlign: "center", padding: "1rem" }}>
                        Soltar aqu√≠ para mover al final
                     </span>
                  </div>
               ) : (
                  <div className="alim-card-add" style={styleNuevo} onClick={onAgregarNuevo}>
                     <span className="alim-card-add-plus">+</span>
                     <span className="alim-card-add-text">Nuevo Registrador</span>
                  </div>
               );
            })()}

            {/* RowGapResizers entre filas - solo en desktop */}
            {!elementoArrastrandoId &&
               !esModoMobile &&
               posicionesEntreFilas.map((pos) => (
                  <div
                     key={`row-gap-${pos.filaIndex}`}
                     className="row-gap-resizer-overlay"
                     style={{ top: `${pos.top}px` }}
                  >
                     <RowGapResizer
                        gap={obtenerRowGap(puestoId, pos.filaIndex)}
                        onGapChange={(nuevoGap) => onRowGapChange(puestoId, pos.filaIndex, nuevoGap)}
                        rowIndex={pos.filaIndex}
                     />
                  </div>
               ))}
         </div>
      </div>
   );
};

export default GrillaTarjetas;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaUnifilar.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/GrillaUnifilar.jsx
// Re-exporta el componente modularizado
export { default } from "./grilla-unifilar";

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/GrupoMedidores.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/GrupoMedidores.jsx

import React from "react"; 

/**
 * Renderiza un grupo de cajas de medici√≥n (parte superior o inferior).
 */
const GrupoMedidores = ({ titulo, boxes, zona, renderizarCaja, estiloTitulo, gap }) => {     // zona: "sup" o "inf"
	// Estilo del contenedor de boxes (gap din√°mico)
	const estiloMeters = gap ? { gap } : {};

	return (
		<div className="alim-card-section">
			<h3
				className="alim-card-section-title"
				style={estiloTitulo || {}}
			>{titulo}</h3>            {/* t√≠tulo del bloque (ej: CONSUMO, TENSI√ìN) */}
			<div
				className="alim-card-meters"
				style={Object.keys(estiloMeters).length > 0 ? estiloMeters : undefined}
			>
				{boxes.map((box, idx) => renderizarCaja(box, idx, zona))}     {/* delega el render de cada CajaMedicion */}
			</div>
		</div>
	);
};

export default GrupoMedidores;

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (GrupoMedidores.jsx)

 - Este componente es un contenedor: solo recibe `titulo`, `boxes` y una
   funci√≥n `renderizarCaja` y se encarga de ordenarlos dentro del layout de la
   tarjeta (`alim-card-section` / `alim-card-meters`).

 - La prop `zona` sirve para que el renderizador de cajas sepa si est√° dibujando
   la parte superior ("sup") o inferior ("inf") de la tarjeta.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (GrupoMedidores.jsx)

0) Visi√≥n general del componente

   `GrupoMedidores` es un componente muy simple que act√∫a como contenedor de un
   bloque de mediciones dentro de la tarjeta de alimentador.

   Pod√©s verlo como ‚Äúla fila‚Äù que contiene:
     - un t√≠tulo (por ejemplo: ‚ÄúCONSUMO (A)‚Äù o ‚ÄúTENSI√ìN (kV)‚Äù),
     - una serie de cajas de medici√≥n (`CajaMedicion`) ordenadas en una l√≠nea.

   No sabe de d√≥nde vienen los datos ni c√≥mo se dibuja cada caja; solo recibe
   todo por props y lo coloca en el layout correcto.


1) Props del componente

   const GrupoMedidores = ({ titulo, boxes, zona, renderizarCaja }) => { ... }

   - `titulo` (string):
       ‚Ä¢ texto que se muestra arriba del grupo,
       ‚Ä¢ ejemplos: ‚ÄúCONSUMO (A)‚Äù, ‚ÄúTENSI√ìN (kV)‚Äù, ‚ÄúPOTENCIAS‚Äù, etc.

   - `boxes` (array):
       ‚Ä¢ lista de objetos de caja ya normalizados,
       ‚Ä¢ t√≠picamente cada `box` tiene:
           - `etiqueta`  ‚Üí texto de cabecera de la caja,
           - `valor`     ‚Üí valor a mostrar,
           - `enabled`   ‚Üí si est√° activa o no,
           - `origen`    ‚Üí de d√≥nde viene la medici√≥n (rel√© / analizador).

       ‚Ä¢ Este componente NO modifica ni interpreta ese contenido,
         solo los recorre para dibujarlos.

   - `zona` (string):
       ‚Ä¢ indica si este grupo pertenece a:
           - "sup" ‚Üí parte superior de la tarjeta,
           - "inf" ‚Üí parte inferior de la tarjeta.
       ‚Ä¢ Se le pasa al renderizador de cajas para que pueda ajustar estilos/
         l√≥gica seg√∫n la zona si es necesario.

   - `renderizarCaja` (funci√≥n):
       ‚Ä¢ funci√≥n que sabe c√≥mo transformar `{ box, idx, zona }` en un elemento
         React (normalmente una `CajaMedicion`).
       ‚Ä¢ Firma t√≠pica: `(box, idx, zona) => <CajaMedicion ... />`
       ‚Ä¢ La idea es que `GrupoMedidores` no tenga que conocer los detalles de
         `CajaMedicion`; solo delega el trabajo.


2) JSX del componente

   return (
     <div className="alim-card-section">
       <h3 className="alim-card-section-title">{titulo}</h3>
       <div className="alim-card-meters">
         {boxes.map((box, idx) => renderizarCaja(box, idx, zona))}
       </div>
     </div>
   );

   2.1) Contenedor principal

   - `<div className="alim-card-section">`:
       ‚Ä¢ envuelve todo el bloque (t√≠tulo + cajas),
       ‚Ä¢ la clase se usa en CSS para dar m√°rgenes, separaci√≥n vertical, etc.

   2.2) T√≠tulo de la secci√≥n

   - `<h3 className="alim-card-section-title">{titulo}</h3>`:
       ‚Ä¢ muestra el t√≠tulo que se pas√≥ por props,
       ‚Ä¢ sirve como encabezado visual del grupo de medidores.

   2.3) Contenedor de cajas

   - `<div className="alim-card-meters">`:
       ‚Ä¢ contenedor donde se colocan las cajas de medici√≥n,
       ‚Ä¢ normalmente se renderizan en fila o grilla seg√∫n el CSS.

   - `{boxes.map((box, idx) => renderizarCaja(box, idx, zona))}`:
       ‚Ä¢ recorre el array `boxes`,
       ‚Ä¢ por cada elemento llama a `renderizarCaja(box, idx, zona)`,
       ‚Ä¢ `renderizarCaja` devuelve el JSX de la caja (por ejemplo, `CajaMedicion`),
       ‚Ä¢ de esta forma:
           - `GrupoMedidores` no est√° atado a un tipo de caja espec√≠fico,
           - solo se encarga de ‚Äúinvocar‚Äù al renderizador en el orden correcto.


3) Export

   export default GrupoMedidores;

   - Exporta el componente para ser usado dentro de `TarjetaAlimentador`.
   - La tarjeta crea los objetos `sup` e `inf` (con `titulo` y `boxes`) y
     luego se los pasa a `GrupoMedidores` para que los dibuje.

---------------------------------------------------------------------------*/
// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/hooks/index.js =====

// hooks/index.js
// Exportaciones de hooks de la grilla de tarjetas

export { useDeteccionFilas } from "./useDeteccionFilas";
export { useModoMobile } from "./useModoMobile";

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/hooks/useDeteccionFilas.js =====

// hooks/useDeteccionFilas.js
// Hook para detectar filas y posiciones en la grilla de tarjetas

import { useState, useCallback, useEffect, useRef } from "react";

/**
 * Hook para detectar las posiciones entre filas y manejar gaps
 * @param {Object} params
 * @param {React.RefObject} params.gridRef - Referencia al elemento grid
 * @param {Array} params.alimentadores - Lista de alimentadores
 * @param {Function} params.obtenerGap - Funci√≥n para obtener gap de tarjeta
 * @param {Function} params.onGapChange - Handler para cambiar gap
 * @param {string} params.puestoId - ID del puesto
 * @param {Function} params.obtenerRowGap - Funci√≥n para obtener row gap
 * @returns {Object} Estado y funciones de detecci√≥n
 */
export const useDeteccionFilas = ({
   gridRef,
   alimentadores,
   obtenerGap,
   onGapChange,
   puestoId,
   obtenerRowGap,
}) => {
   const [posicionesEntreFilas, setPosicionesEntreFilas] = useState([]);
   const [filasPorTarjeta, setFilasPorTarjeta] = useState({});
   const [primerasTarjetasPorFila, setPrimerasTarjetasPorFila] = useState({});

   const filasAnterioresRef = useRef({});
   const snapshotGapsRef = useRef(null);
   const numFilasSnapshotRef = useRef(null);

   const detectarFilasYFinales = useCallback(() => {
      if (!gridRef.current) return;

      const nuevasPosiciones = [];
      const nuevasFilasPorTarjeta = {};
      const nuevasPrimerasPorFila = {};
      let ultimoLeft = null;
      let ultimoBottom = null;
      let filaIndex = 0;

      const tarjetas = Array.from(
         gridRef.current.querySelectorAll(".alim-card-wrapper, .alim-card-add")
      );
      const gridRect = gridRef.current.getBoundingClientRect();

      tarjetas.forEach((wrapper, index) => {
         const alimId = wrapper.dataset.alimId || "nuevo-registrador";
         const rect = wrapper.getBoundingClientRect();

         if (ultimoLeft !== null && rect.left < ultimoLeft) {
            const posY = ultimoBottom - gridRect.top;
            nuevasPosiciones.push({ filaIndex: filaIndex + 1, top: posY });
            filaIndex++;
            nuevasPrimerasPorFila[filaIndex] = alimId;
         } else if (index === 0) {
            nuevasPrimerasPorFila[0] = alimId;
         }

         nuevasFilasPorTarjeta[alimId] = filaIndex;
         ultimoLeft = rect.left;
         ultimoBottom = rect.bottom;
      });

      const numFilasActual = filaIndex + 1;
      const filasAnteriores = filasAnterioresRef.current;
      const numFilasAnterior =
         Object.keys(filasAnteriores).length > 0
            ? Math.max(...Object.values(filasAnteriores)) + 1
            : numFilasActual;

      // Detectar aumento de filas
      if (numFilasActual > numFilasAnterior) {
         if (snapshotGapsRef.current === null) {
            const snapshot = {};
            alimentadores.forEach((alim) => {
               snapshot[alim.id] = obtenerGap(alim.id);
            });
            snapshotGapsRef.current = snapshot;
            numFilasSnapshotRef.current = numFilasAnterior;
         }

         Object.keys(nuevasFilasPorTarjeta).forEach((alimId) => {
            if (alimId === "nuevo-registrador") return;
            const filaAnterior = filasAnteriores[alimId];
            const filaNueva = nuevasFilasPorTarjeta[alimId];

            if (filaAnterior !== undefined && filaNueva > filaAnterior) {
               onGapChange(alimId, 10);
            }
         });
      } else if (numFilasActual < numFilasAnterior) {
         if (
            snapshotGapsRef.current !== null &&
            numFilasActual <= numFilasSnapshotRef.current
         ) {
            Object.keys(snapshotGapsRef.current).forEach((alimId) => {
               onGapChange(alimId, snapshotGapsRef.current[alimId]);
            });
            snapshotGapsRef.current = null;
            numFilasSnapshotRef.current = null;
         }
      }

      filasAnterioresRef.current = nuevasFilasPorTarjeta;

      // Actualizar estado solo si cambi√≥
      const posicionesStr = JSON.stringify(nuevasPosiciones);
      setPosicionesEntreFilas((prev) => {
         if (JSON.stringify(prev) !== posicionesStr) return nuevasPosiciones;
         return prev;
      });

      const filasStr = JSON.stringify(nuevasFilasPorTarjeta);
      setFilasPorTarjeta((prev) => {
         if (JSON.stringify(prev) !== filasStr) return nuevasFilasPorTarjeta;
         return prev;
      });

      const primerasStr = JSON.stringify(nuevasPrimerasPorFila);
      setPrimerasTarjetasPorFila((prev) => {
         if (JSON.stringify(prev) !== primerasStr) return nuevasPrimerasPorFila;
         return prev;
      });
   }, [onGapChange, obtenerGap, alimentadores, gridRef]);

   // Ejecutar despu√©s del primer render
   useEffect(() => {
      const raf = requestAnimationFrame(detectarFilasYFinales);
      return () => cancelAnimationFrame(raf);
   }, [alimentadores, detectarFilasYFinales]);

   // Re-detectar en resize
   useEffect(() => {
      const handleResize = () => requestAnimationFrame(detectarFilasYFinales);
      window.addEventListener("resize", handleResize);

      const resizeObserver = new ResizeObserver(() =>
         requestAnimationFrame(detectarFilasYFinales)
      );
      if (gridRef.current) resizeObserver.observe(gridRef.current);

      return () => {
         window.removeEventListener("resize", handleResize);
         resizeObserver.disconnect();
      };
   }, [detectarFilasYFinales, gridRef]);

   // Re-detectar cuando cambian row gaps o puesto
   useEffect(() => {
      const timer = setTimeout(() => requestAnimationFrame(detectarFilasYFinales), 50);
      return () => clearTimeout(timer);
   }, [obtenerRowGap, puestoId, detectarFilasYFinales]);

   return {
      posicionesEntreFilas,
      filasPorTarjeta,
      primerasTarjetasPorFila,
      detectarFilasYFinales,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/hooks/useModoMobile.js =====

// hooks/useModoMobile.js
// Hook para detectar modo m√≥vil basado en ancho de ventana

import { useState, useEffect } from "react";
import { BREAKPOINT_MOBILE } from "../utilidades";

/**
 * Hook para detectar si estamos en modo m√≥vil
 * @returns {boolean} Si estamos en modo m√≥vil
 */
export const useModoMobile = () => {
   const [esModoMobile, setEsModoMobile] = useState(() =>
      typeof window !== "undefined" ? window.innerWidth < BREAKPOINT_MOBILE : false
   );

   useEffect(() => {
      const handleResize = () => {
         setEsModoMobile(window.innerWidth < BREAKPOINT_MOBILE);
      };

      window.addEventListener("resize", handleResize);
      return () => window.removeEventListener("resize", handleResize);
   }, []);

   return esModoMobile;
};

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/RowGapResizer.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/RowGapResizer.jsx

import React, { useState, useRef, useEffect, useCallback } from "react";
import "./RowGapResizer.css";

/**
 * Componente que permite ajustar el gap vertical entre filas de tarjetas.
 * Aparece como una l√≠nea horizontal con un c√≠rculo al hacer hover entre filas.
 *
 * Comportamiento:
 * - Al hacer hover sobre el handle: aparece la barra de gap con el valor actual
 * - Al arrastrar con click izquierdo: ajusta el gap visualmente (movimiento vertical)
 * - Al hacer doble click: se habilita la edici√≥n manual del input
 * - Enter o click fuera del input: confirma el valor y oculta la barra
 * - Escape: cancela y oculta la barra
 *
 * @param {number} gap - Gap actual en p√≠xeles
 * @param {function} onGapChange - Callback (nuevoGap)
 * @param {number} rowIndex - √çndice de la fila (0 = primera fila, separaci√≥n del men√∫)
 */
const RowGapResizer = ({ gap, onGapChange, rowIndex, minGap = 0, maxGap = 400 }) => {
	const [isHovered, setIsHovered] = useState(false);
	const [isDragging, setIsDragging] = useState(false);
	const [isEditing, setIsEditing] = useState(false);
	const [inputValue, setInputValue] = useState(gap);
	const inputRef = useRef(null);
	const containerRef = useRef(null);
	const hitboxRef = useRef(null);
	const startYRef = useRef(0);
	const startGapRef = useRef(gap);

	// Actualizar inputValue cuando cambia el gap desde afuera
	useEffect(() => {
		if (!isEditing) {
			setInputValue(gap);
		}
	}, [gap, isEditing]);

	// Detectar clicks fuera del componente para cerrar
	useEffect(() => {
		const handleClickOutside = (e) => {
			if (containerRef.current && !containerRef.current.contains(e.target)) {
				if (!isEditing) {
					setIsHovered(false);
				}
			}
		};

		if (isHovered && !isEditing) {
			document.addEventListener('mousedown', handleClickOutside);
		}

		return () => {
			document.removeEventListener('mousedown', handleClickOutside);
		};
	}, [isHovered, isEditing]);

	// ===== DRAG HANDLERS =====
	const handleMouseDown = useCallback((e) => {
		if (e.button !== 0) return;
		e.preventDefault();
		e.stopPropagation();
		setIsDragging(true);
		startYRef.current = e.clientY;
		startGapRef.current = gap;
	}, [gap]);

	const handleMouseMove = useCallback((e) => {
		if (!isDragging) return;

		const deltaY = e.clientY - startYRef.current;
		// Cada 2px de movimiento = 1px de gap
		const newGap = Math.round(startGapRef.current + deltaY / 2);
		const clampedGap = Math.max(minGap, Math.min(maxGap, newGap));

		onGapChange(clampedGap);
		setInputValue(clampedGap);
	}, [isDragging, minGap, maxGap, onGapChange]);

	const handleMouseUp = useCallback((e) => {
		setIsDragging(false);

		// Verificar si el mouse est√° fuera del hitbox al soltar
		if (hitboxRef.current) {
			const rect = hitboxRef.current.getBoundingClientRect();
			const mouseX = e.clientX;
			const mouseY = e.clientY;
			const isOutside =
				mouseX < rect.left ||
				mouseX > rect.right ||
				mouseY < rect.top ||
				mouseY > rect.bottom;

			if (isOutside && !isEditing) {
				setIsHovered(false);
			}
		}
	}, [isEditing]);

	// Doble click para activar modo edici√≥n
	const handleDoubleClick = useCallback((e) => {
		e.preventDefault();
		e.stopPropagation();
		setIsEditing(true);
		setInputValue(gap);
	}, [gap]);

	// Agregar/remover listeners globales para el drag
	useEffect(() => {
		if (isDragging) {
			window.addEventListener("mousemove", handleMouseMove);
			window.addEventListener("mouseup", handleMouseUp);
		}
		return () => {
			window.removeEventListener("mousemove", handleMouseMove);
			window.removeEventListener("mouseup", handleMouseUp);
		};
	}, [isDragging, handleMouseMove, handleMouseUp]);

	// ===== INPUT HANDLERS =====
	const handleValueClick = (e) => {
		e.stopPropagation();
		if (!isDragging) {
			setIsEditing(true);
			setInputValue(gap);
		}
	};

	useEffect(() => {
		if (isEditing && inputRef.current) {
			inputRef.current.focus();
			inputRef.current.select();
		}
	}, [isEditing]);

	const handleInputChange = (e) => {
		setInputValue(e.target.value);
	};

	const confirmarValor = () => {
		const numValue = parseInt(inputValue, 10);
		if (!isNaN(numValue)) {
			const clampedGap = Math.max(minGap, Math.min(maxGap, numValue));
			onGapChange(clampedGap);
			setInputValue(clampedGap);
		} else {
			setInputValue(gap);
		}
		setIsEditing(false);
	};

	const handleInputBlur = () => {
		confirmarValor();
		setIsHovered(false);
	};

	const handleInputKeyDown = (e) => {
		if (e.key === "Enter") {
			e.preventDefault();
			confirmarValor();
			setIsHovered(false);
		} else if (e.key === "Escape") {
			setInputValue(gap);
			setIsEditing(false);
			setIsHovered(false);
		}
	};

	const isActive = isHovered || isDragging || isEditing;

	return (
		<div
			ref={containerRef}
			className={`row-gap-resizer ${isActive ? "row-gap-resizer--active" : ""}`}
			style={{ height: `${gap}px` }}
		>
			<div className="row-gap-resizer__track">
				<div className="row-gap-resizer__handle-wrapper">
					{/* Zona de hitbox invisible */}
					<div
						ref={hitboxRef}
						className="row-gap-resizer__hitbox"
						onMouseEnter={() => setIsHovered(true)}
						onMouseLeave={() => !isDragging && !isEditing && setIsHovered(false)}
						onMouseDown={handleMouseDown}
						onDoubleClick={handleDoubleClick}
					/>
					{/* Handle visual */}
					<div
						className={`row-gap-resizer__handle ${isDragging ? "row-gap-resizer__handle--dragging" : ""}`}
						title="Arrastra para ajustar el espaciado vertical"
					>
						<div className="row-gap-resizer__line" />
						<div className="row-gap-resizer__circle" />
						<div className="row-gap-resizer__line" />
					</div>
				</div>

				{isActive && (
					<div className="row-gap-resizer__input-container">
						{isEditing ? (
							<input
								ref={inputRef}
								type="number"
								className="row-gap-resizer__input"
								value={inputValue}
								onChange={handleInputChange}
								onBlur={handleInputBlur}
								onKeyDown={handleInputKeyDown}
								min={minGap}
								max={maxGap}
							/>
						) : (
							<span
								className="row-gap-resizer__value"
								onClick={handleValueClick}
								title="Click para editar"
							>
								{gap}px
							</span>
						)}
					</div>
				)}
			</div>
		</div>
	);
};

export default RowGapResizer;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/SkeletonCard.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/SkeletonCard.jsx
// Componente skeleton (esqueleto) que se muestra mientras se carga/guarda un alimentador

import React from "react";
import "./SkeletonCard.css";

const SkeletonCard = () => {
	return (
		<div className="skeleton-card">
			{/* Header de la tarjeta - botones a la izquierda, t√≠tulo a la derecha */}
			<div className="skeleton-header">
				<div className="skeleton-buttons">
					<div className="skeleton-button-square"></div>
					<div className="skeleton-button-square"></div>
				</div>
				<div className="skeleton-title"></div>
			</div>

			{/* Parte superior (ej: Corriente) */}
			<div className="skeleton-section">
				<div className="skeleton-section-title"></div>
				<div className="skeleton-boxes">
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
				</div>
			</div>

			{/* Parte inferior (ej: Tensi√≥n) */}
			<div className="skeleton-section">
				<div className="skeleton-section-title"></div>
				<div className="skeleton-boxes">
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
					<div className="skeleton-box">
						<div className="skeleton-label"></div>
						<div className="skeleton-value"></div>
					</div>
				</div>
			</div>
		</div>
	);
};

export default SkeletonCard;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/TarjetaAlimentador.jsx =====

// src/paginas/PaginaAlimentadores/componentes/tarjetas/TarjetaAlimentador.jsx

import "./TarjetaAlimentador.css";
import CajaMedicion from "./CajaMedicion.jsx";
import GrupoMedidores from "./GrupoMedidores.jsx";
import { usarContextoConfiguracion } from "../../contexto/ContextoConfiguracion";
import { useTarjetaAlimentador } from "../../hooks/mediciones";
import { PopoverEscala, MenuFlotante } from "./componentes";
import { ESCALA_MIN, ESCALA_MAX } from "../../constantes/escalas";

// ============================================================================
// Helper que prepara la estructura de un lado de la tarjeta (sup/inf)
// ============================================================================

const construirLado = (side, tituloDefault) => {
   const cajasPorDefecto = ["R", "S", "T"].map((label) => ({
      etiqueta: label,
      valor: "--,--",
      enabled: false,
      origen: null,
   }));

   if (!side) {
      return {
         titulo: tituloDefault,
         boxes: cajasPorDefecto,
         oculto: false,
      };
   }

   const titulo = (side.titulo && String(side.titulo).trim()) || tituloDefault;
   const oculto = !!side.oculto;

   let boxes = Array.isArray(side.boxes) ? side.boxes : [];
   boxes = boxes.slice(0, 4);

   if (boxes.length === 0) {
      boxes = cajasPorDefecto;
   } else {
      boxes = boxes.map((b, idx) => ({
         etiqueta: (b?.etiqueta && String(b.etiqueta).trim()) || `Box ${idx + 1}`,
         valor: b?.valor == null || b.valor === "" ? "--,--" : String(b.valor),
         enabled: !!b?.enabled,
         origen: b?.origen || null,
      }));
   }

   return { titulo, boxes, oculto };
};

// ============================================================================
// Componentes auxiliares inline
// ============================================================================

/**
 * Barra de progreso de polling animada
 */
const BarraProgresoPolling = ({ cicloPolling, periodoPolling }) => (
   <div className="alim-card-progress-track" key={cicloPolling}>
      <div
         className="alim-card-progress-fill"
         style={{ "--progress-duration": `${periodoPolling}s` }}
      >
         <div className="alim-card-progress-spark" />
      </div>
   </div>
);

/**
 * Overlay de error cr√≠tico
 */
const OverlayError = () => (
   <div className="alim-card-error-overlay alim-card-error-overlay--parpadeo">
      <div className="alim-card-error-content">
         <span className="alim-card-error-icon">‚ö†</span>
         <span className="alim-card-error-title">ATENCI√ìN</span>
         <span className="alim-card-error-message">Posiblemente fuera de servicio</span>
         <span className="alim-card-error-detail">
            Las √∫ltimas 3 lecturas no fueron v√°lidas o dieron error
         </span>
      </div>
   </div>
);

/**
 * Bot√≥n de escala (tri√°ngulo)
 */
const BotonEscala = ({ triangleRef, escala, escalaModificada, onClick }) => (
   <button
      ref={triangleRef}
      type="button"
      className={`alim-card-scale-btn${escalaModificada ? " alim-card-scale-btn--active" : ""}`}
      onClick={onClick}
      title={`Escala: ${escala}x (click para cambiar)`}
   >
      <span className="alim-card-scale-triangle">‚ñº</span>
      {escalaModificada && <span className="alim-card-scale-value">{escala}x</span>}
   </button>
);

// ============================================================================
// Componente principal TarjetaAlimentador
// ============================================================================

const TarjetaAlimentador = ({
   nombre,
   color,
   onConfigClick,
   onHistorialClick,
   esObservador = false,
   topSide,
   bottomSide,
   draggable = false,
   isDragging = false,
   onDragStart,
   onDragOver,
   onDrop,
   onDragEnd,

   // Info de mediciones y periodos
   mideRele = false,
   mideAnalizador = false,
   periodoRele = 60,
   periodoAnalizador = 60,
   contadorRele = 0,
   contadorAnalizador = 0,

   // Play/Stop para polling de lecturas
   estaPolling = false,
   contadorPolling = 0,
   periodoPolling = 60,
   errorPolling = null,

   // Escala de la tarjeta
   escala = 1.0,
   onEscalaChange,
}) => {
   // Obtener estilos globales del contexto
   const { estilosGlobales } = usarContextoConfiguracion();

   // Hook para manejar estado y l√≥gica de la tarjeta
   const {
      triangleRef,
      popoverRef,
      menuRef,
      cardRef,
      mostrarProgresoRele,
      mostrarProgresoAnalizador,
      mostrarProgresoPolling,
      cicloPolling,
      mostrarPopoverEscala,
      posicionPopover,
      valorEscalaInput,
      menuAbierto,
      posicionMenu,
      togglePopoverEscala,
      handleEscalaInputChange,
      handleEscalaKeyDown,
      handleIncrementarEscala,
      handleDecrementarEscala,
      handleResetearEscala,
      toggleMenu,
      cerrarMenu,
   } = useTarjetaAlimentador({
      mideRele,
      mideAnalizador,
      estaPolling,
      contadorRele,
      contadorAnalizador,
      contadorPolling,
      escala,
      onEscalaChange,
      ESCALA_MIN,
      ESCALA_MAX,
   });

   // Armar lados de la tarjeta con valores por defecto si no hay dise√±o
   const sup = construirLado(topSide, "CONSUMO (A)");
   const inf = construirLado(bottomSide, "TENSI√ìN (kV)");

   // Detectar si alg√∫n lado tiene 4 boxes (para ensanchar la tarjeta)
   const maxBoxes = Math.max(sup.boxes.length, inf.boxes.length);
   const isWide = maxBoxes >= 4;

   // Determinar errores por zona
   const errorSuperior = errorPolling?.superior || false;
   const errorInferior = errorPolling?.inferior || false;
   const errorSuperiorCritico = errorPolling?.superiorCritico || false;
   const errorInferiorCritico = errorPolling?.inferiorCritico || false;
   const tieneErrorCritico = errorSuperiorCritico || errorInferiorCritico;

   // Armar clases de la card
   const clasesCard = ["alim-card"];
   if (isWide) clasesCard.push("alim-card-wide");
   if (isDragging) clasesCard.push("alim-card-dragging");
   if (tieneErrorCritico) clasesCard.push("alim-card-error");

   // Renderizar una caja de medici√≥n
   const renderizarCaja = (box, idx, zona) => {
      const zonaConError = zona === "sup" ? errorSuperior : errorInferior;
      return (
         <CajaMedicion
            key={`${zona}-${idx}`}
            box={box}
            indice={idx}
            zona={zona}
            mideRele={mideRele}
            mideAnalizador={mideAnalizador}
            mostrarProgresoRele={mostrarProgresoRele}
            mostrarProgresoAnalizador={mostrarProgresoAnalizador}
            periodoRele={periodoRele}
            periodoAnalizador={periodoAnalizador}
            contadorRele={contadorRele}
            contadorAnalizador={contadorAnalizador}
            estaPolling={estaPolling}
            mostrarProgresoPolling={mostrarProgresoPolling}
            periodoPolling={periodoPolling}
            contadorPolling={contadorPolling}
            tieneError={zonaConError}
            estilosBox={{
               tituloBox: {
                  fontFamily: estilosGlobales?.tituloBox?.fontFamily || "inherit",
                  fontSize: estilosGlobales?.tituloBox?.fontSize || "1rem",
               },
               valorBox: {
                  fontFamily:
                     estilosGlobales?.valorBox?.fontFamily ||
                     "'DS-Digital', 'Courier New', monospace",
                  fontSize: estilosGlobales?.valorBox?.fontSize || "1.5rem",
                  color: estilosGlobales?.valorBox?.color || "#ffff00",
                  decimales: estilosGlobales?.valorBox?.decimales ?? 2,
               },
               box: {
                  width: estilosGlobales?.box?.width || "80px",
                  height: estilosGlobales?.box?.height || "auto",
               },
            }}
         />
      );
   };

   // Escala modificada
   const escalaModificada = escala !== 1.0;
   const estiloEscala =
      escala !== 1.0
         ? {
              transform: `scale(${escala})`,
              transformOrigin: "top left",
           }
         : {};

   return (
      <div
         ref={cardRef}
         className={clasesCard.join(" ")}
         style={{
            cursor: draggable ? "grab" : "default",
            ...estiloEscala,
         }}
         draggable={draggable}
         onDragStart={onDragStart}
         onDragOver={onDragOver}
         onDrop={onDrop}
         onDragEnd={onDragEnd}
      >
         {/* Header con nombre y botones de acciones */}
         <div
            className="alim-card-header"
            style={{
               background: `linear-gradient(to right, ${color || "#0ea5e9"}, ${color || "#0ea5e9"}80)`,
            }}
         >
            {/* Flecha animada para desplegar men√∫ */}
            <button
               type="button"
               className={`alim-card-menu-toggle ${menuAbierto ? "alim-card-menu-toggle--abierto" : ""}`}
               onClick={toggleMenu}
               title="Opciones"
            >
               <span className="alim-card-menu-arrow">‚ñº</span>
            </button>

            <span
               className="alim-card-title"
               style={{
                  fontFamily: estilosGlobales?.header?.fontFamily || "inherit",
                  fontSize: estilosGlobales?.header?.fontSize || "1rem",
                  fontWeight: estilosGlobales?.header?.fontWeight || 700,
               }}
            >
               {nombre}
            </span>
         </div>

         {/* Barra de progreso de polling */}
         {estaPolling && mostrarProgresoPolling && (
            <BarraProgresoPolling cicloPolling={cicloPolling} periodoPolling={periodoPolling} />
         )}

         {/* Cuerpo con los 2 bloques (superior / inferior) */}
         <div className="alim-card-body">
            {/* Parte superior */}
            {!sup.oculto && (
               <GrupoMedidores
                  titulo={sup.titulo}
                  boxes={sup.boxes}
                  zona="sup"
                  renderizarCaja={renderizarCaja}
                  estiloTitulo={{
                     fontFamily: estilosGlobales?.tituloZona?.fontFamily || "inherit",
                     fontSize: estilosGlobales?.tituloZona?.fontSize || "0.8rem",
                  }}
                  gap={estilosGlobales?.box?.gap}
               />
            )}

            {/* Parte inferior */}
            {!inf.oculto && (
               <GrupoMedidores
                  titulo={inf.titulo}
                  boxes={inf.boxes}
                  zona="inf"
                  renderizarCaja={renderizarCaja}
                  estiloTitulo={{
                     fontFamily: estilosGlobales?.tituloZona?.fontFamily || "inherit",
                     fontSize: estilosGlobales?.tituloZona?.fontSize || "0.8rem",
                  }}
                  gap={estilosGlobales?.box?.gap}
               />
            )}

            {/* Overlay de error cr√≠tico */}
            {tieneErrorCritico && <OverlayError />}

            {/* Tri√°ngulo de escala */}
            {onEscalaChange && (
               <BotonEscala
                  triangleRef={triangleRef}
                  escala={escala}
                  escalaModificada={escalaModificada}
                  onClick={togglePopoverEscala}
               />
            )}
         </div>

         {/* Popover de escala (portal) */}
         {mostrarPopoverEscala && (
            <PopoverEscala
               popoverRef={popoverRef}
               posicion={posicionPopover}
               valorInput={valorEscalaInput}
               escalaMin={ESCALA_MIN}
               escalaMax={ESCALA_MAX}
               onInputChange={handleEscalaInputChange}
               onKeyDown={handleEscalaKeyDown}
               onIncrementar={handleIncrementarEscala}
               onDecrementar={handleDecrementarEscala}
               onResetear={handleResetearEscala}
            />
         )}

         {/* Men√∫ flotante desplegable (portal) */}
         {menuAbierto && (
            <MenuFlotante
               menuRef={menuRef}
               posicion={posicionMenu}
               onConfigClick={onConfigClick}
               onHistorialClick={onHistorialClick}
               esObservador={esObservador}
               onCerrar={cerrarMenu}
            />
         )}
      </div>
   );
};

export default TarjetaAlimentador;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/utilidades/constantesGrilla.js =====

// utilidades/constantesGrilla.js
// Constantes para la grilla de tarjetas

// Breakpoint para desactivar los controles de gap en m√≥viles/tablets
export const BREAKPOINT_MOBILE = 982;

// Gaps fijos para modo m√≥vil
export const GAP_FIJO_MOBILE = 10;
export const ROW_GAP_FIJO_MOBILE = 20;

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/utilidades/index.js =====

// utilidades/index.js
// Exportaciones de utilidades de la grilla

export { puedeHacerPolling } from "./validacionPolling";
export { BREAKPOINT_MOBILE, GAP_FIJO_MOBILE, ROW_GAP_FIJO_MOBILE } from "./constantesGrilla";

// ===== ./src/paginas/PaginaAlimentadores/componentes/tarjetas/utilidades/validacionPolling.js =====

// utilidades/validacionPolling.js
// Utilidades para validar configuraci√≥n de polling de alimentadores

/**
 * Verifica si un array de boxes tiene al menos uno habilitado con √≠ndice v√°lido
 * @param {Array} boxes - Array de boxes a verificar
 * @returns {boolean}
 */
const tieneBoxHabilitado = (boxes) => {
   return boxes.some((box) => {
      if (!box.enabled) return false;
      const indice = box.indice !== undefined ? box.indice : box.registro;
      if (indice === null || indice === undefined || indice === "") {
         return false;
      }
      const numIndice = Number(indice);
      return Number.isFinite(numIndice) && numIndice >= 0;
   });
};

/**
 * Verifica si un alimentador tiene la configuraci√≥n completa para hacer polling.
 * Requisitos:
 * - Al menos una zona (superior o inferior) con registrador_id definido
 * - intervalo_consulta_ms definido y > 0
 * - Al menos un box habilitado (enabled: true) con un √≠ndice v√°lido
 * @param {Object} alim - Alimentador a verificar
 * @returns {boolean}
 */
export const puedeHacerPolling = (alim) => {
   // 1. Verificar intervalo_consulta_ms
   if (!alim.intervalo_consulta_ms || alim.intervalo_consulta_ms <= 0) {
      return false;
   }

   // 2. Verificar card_design y zonas
   const cardDesign = alim.card_design || {};
   const superior = cardDesign.superior || {};
   const inferior = cardDesign.inferior || {};

   // 3. Verificar que haya al menos una zona con registrador_id
   const tieneRegistradorSuperior = !!superior.registrador_id;
   const tieneRegistradorInferior = !!inferior.registrador_id;
   const tieneRegistradorLegacy = !!alim.registrador_id;

   if (!tieneRegistradorSuperior && !tieneRegistradorInferior && !tieneRegistradorLegacy) {
      return false;
   }

   // 4. Verificar boxes habilitados
   const boxesSuperior = superior.boxes || [];
   const boxesInferior = inferior.boxes || [];

   const superiorValido = tieneRegistradorSuperior && tieneBoxHabilitado(boxesSuperior);
   const inferiorValido = tieneRegistradorInferior && tieneBoxHabilitado(boxesInferior);
   const legacyValido =
      tieneRegistradorLegacy &&
      (tieneBoxHabilitado(boxesSuperior) || tieneBoxHabilitado(boxesInferior));

   return superiorValido || inferiorValido || legacyValido;
};

// ===== ./src/paginas/PaginaAlimentadores/constantes/clavesAlmacenamiento.js =====

// src/paginas/PaginaAlimentadores/constantes/clavesAlmacenamiento.js

/**
 * Claves para guardar datos en localStorage
 * Centralizadas ac√° para evitar typos y mantener consistencia.
 */
export const CLAVES_STORAGE = {
	PUESTOS: "rw-puestos",                    // lista completa de puestos configurados
	PUESTO_SELECCIONADO: "rw-puesto-seleccionado", // id del puesto que qued√≥ seleccionado
	CONFIGURACION_SELECCIONADA: "rw-configuracion-seleccionada", // id del workspace activo
	USUARIOS_RECORDADOS: "usuariosRecordados",     // lista de usuarios recordados (login)
	GAP_TARJETAS: "rw-gap-tarjetas",          // espaciado horizontal entre tarjetas (en px)
	GAP_FILAS: "rw-gap-filas",                // espaciado vertical entre filas (en px)
	ESCALA_GLOBAL: "rw-escala-global",        // escala global de todas las tarjetas
	ESCALA_PUESTOS: "rw-escala-puestos",      // escala por puesto { puestoId: escala }
	ESCALA_TARJETAS: "rw-escala-tarjetas",    // escala individual por tarjeta { alimId: escala }
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (clavesAlmacenamiento.js)

 - Ac√° defino todas las claves de `localStorage` que usa la pantalla de
   alimentadores (y algunas compartidas, como `USUARIOS_RECORDADOS`).

 - La idea es nunca escribir las strings a mano en el resto del c√≥digo,
   sino importar `CLAVES_STORAGE` y usar `CLAVES_STORAGE.PUESTOS`, etc., para
   evitar errores de tipeo y poder cambiar el prefijo f√°cilmente si hace falta.
---------------------------------------------------------------------------*/}


// ===== ./src/paginas/PaginaAlimentadores/constantes/colores.js =====

// src/paginas/PaginaAlimentadores/constantes/colores.js

/**
 * Paleta de colores del sistema
 * Usada para puestos y alimentadores (botones, tarjetas, etc.).
 */
export const COLORES_SISTEMA = [
	"#22c55e", // Verde
	"#0ea5e9", // Azul cielo
	"#3b82f6", // Azul
	"#a855f7", // P√∫rpura
	"#ec4899", // Rosa
	"#f97316", // Naranja
	"#ef4444", // Rojo
	"#eab308", // Amarillo
	"#14b8a6", // Turquesa
	"#10b981", // Verde esmeralda
	"#6366f1", // √çndigo
	"#64748b", // Gris azulado
];

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (colores.js)

 - `COLORES_SISTEMA` es la paleta central para elegir colores de puestos y
   alimentadores. En el modal de configuraci√≥n se recorre este array para
   dibujar los cuadrados de color.

 - Si en alg√∫n momento quiero cambiar el look&feel (por ejemplo, usar otros
   verdes o agregar m√°s opciones), basta con modificar esta lista sin tocar
   el resto de los componentes.
---------------------------------------------------------------------------*/}


// ===== ./src/paginas/PaginaAlimentadores/constantes/escalas.js =====

// constantes/escalas.js
// Constantes de escala y gap centralizadas

// Escala de tarjetas
export const ESCALA_DEFAULT = 1.0;
export const ESCALA_MIN = 0.5;
export const ESCALA_MAX = 2.0;

// Gap horizontal entre tarjetas
export const GAP_DEFAULT = 10;
export const GAP_MIN = 0;
export const GAP_MAX = 500;

// Gap vertical entre filas
export const ROW_GAP_DEFAULT = 40;
export const ROW_GAP_MIN = 0;
export const ROW_GAP_MAX = 400;

// ===== ./src/paginas/PaginaAlimentadores/constantes/estilosGlobalesTarjeta.js =====

/**
 * Constantes de estilos globales para las tarjetas de alimentador
 * Estos valores son los defaults que se usan si el usuario no ha personalizado nada
 */

// Lista curada de fuentes disponibles (ordenada alfab√©ticamente)
export const FUENTES_DISPONIBLES = [
  // Opci√≥n por defecto (siempre primera)
  { id: "inherit", label: "Por defecto" },
  // Resto ordenado alfab√©ticamente
  { id: "'Arial', sans-serif", label: "Arial" },
  { id: "'Barlow', sans-serif", label: "Barlow" },
  { id: "'Bebas Neue', sans-serif", label: "Bebas Neue" },
  { id: "'Cabin', sans-serif", label: "Cabin" },
  { id: "'Comfortaa', sans-serif", label: "Comfortaa" },
  { id: "'Consolas', monospace", label: "Consolas" },
  { id: "'Digital-7', 'Courier New', monospace", label: "Digital-7" },
  { id: "'Digital-7-Mono', 'Courier New', monospace", label: "Digital-7 Mono" },
  { id: "'DS-Digital', 'Courier New', monospace", label: "DS-Digital" },
  { id: "'DS-Digital-Bold', 'Courier New', monospace", label: "DS-Digital Bold" },
  { id: "'Exo 2', sans-serif", label: "Exo 2" },
  { id: "'Fira Code', monospace", label: "Fira Code" },
  { id: "'IBM Plex Sans', sans-serif", label: "IBM Plex Sans" },
  { id: "'Inconsolata', monospace", label: "Inconsolata" },
  { id: "'Inter', sans-serif", label: "Inter" },
  { id: "'JetBrains Mono', monospace", label: "JetBrains Mono" },
  { id: "'Kanit', sans-serif", label: "Kanit" },
  { id: "'Lato', sans-serif", label: "Lato" },
  { id: "'Montserrat', sans-serif", label: "Montserrat" },
  { id: "'Nunito', sans-serif", label: "Nunito" },
  { id: "'Open Sans', sans-serif", label: "Open Sans" },
  { id: "'Orbitron', sans-serif", label: "Orbitron" },
  { id: "'Oswald', sans-serif", label: "Oswald" },
  { id: "'Oxanium', sans-serif", label: "Oxanium" },
  { id: "'Play', sans-serif", label: "Play" },
  { id: "'Playfair Display', serif", label: "Playfair Display" },
  { id: "'Poppins', sans-serif", label: "Poppins" },
  { id: "'Quicksand', sans-serif", label: "Quicksand" },
  { id: "'Rajdhani', sans-serif", label: "Rajdhani" },
  { id: "'Roboto', sans-serif", label: "Roboto" },
  { id: "'Roboto Mono', monospace", label: "Roboto Mono" },
  { id: "'Rubik', sans-serif", label: "Rubik" },
  { id: "'Russo One', sans-serif", label: "Russo One" },
  { id: "'Segoe UI', sans-serif", label: "Segoe UI" },
  { id: "'Share Tech Mono', monospace", label: "Share Tech Mono" },
  { id: "'Source Sans 3', sans-serif", label: "Source Sans" },
  { id: "'Space Mono', monospace", label: "Space Mono" },
  { id: "'Teko', sans-serif", label: "Teko" },
  { id: "'Titillium Web', sans-serif", label: "Titillium Web" },
  { id: "'Ubuntu', sans-serif", label: "Ubuntu" },
  { id: "'Work Sans', sans-serif", label: "Work Sans" },
  { id: "'Zilla Slab', serif", label: "Zilla Slab" },
];

// Key para localStorage
export const ESTILOS_GLOBALES_STORAGE_KEY = "alimentadores_estilos_globales";

// Valores por defecto (extra√≠dos del CSS actual)
export const ESTILOS_GLOBALES_DEFAULT = {
  // 1. Header de la tarjeta (t√≠tulo como "TRAFO 1")
  header: {
    fontFamily: "inherit",
    fontSize: "1rem",        // ~16px
    fontWeight: 400,          // normal
  },

  // 2. T√≠tulos de zona (superior e inferior como conjunto)
  // Ej: "CORRIENTE DE L√çNEA (A) (EN 33 KV)"
  tituloZona: {
    fontFamily: "inherit",
    fontSize: "0.8rem",      // ~12.8px
  },

  // 3. T√≠tulos de los boxes (R, S, T) como conjunto
  tituloBox: {
    fontFamily: "inherit",
    fontSize: "1rem",        // ~16px
  },

  // 4. Contenido de los boxes (valores como "--,--")
  valorBox: {
    fontFamily: "'DS-Digital', 'Courier New', monospace",
    fontSize: "1.5rem",      // ~24px
    color: "#ffff00",        // amarillo
    decimales: 2,            // cantidad de decimales a mostrar (0, 1 o 2)
  },

  // 5. Configuraci√≥n del box contenedor
  box: {
    gap: "18px",                  // espacio entre boxes (igual a CSS: gap: 18px)
    width: "80px",                // ancho fijo del box
    height: "auto",               // alto del box ("auto" = se ajusta al contenido)
  },
};

// L√≠mites para los sliders de tama√±o
export const LIMITES_TAMA√ëO = {
  header: { min: 0.7, max: 1.6, step: 0.05 },           // rem
  tituloZona: { min: 0.6, max: 1.2, step: 0.05 },       // rem
  tituloBox: { min: 0.7, max: 1.4, step: 0.05 },        // rem
  valorBox: { min: 0, max: 2.5, step: 0.1 },             // rem (0 a 2.5)
  gap: { min: 5, max: 40, step: 1 },                    // px (espacio entre boxes)
  boxWidth: { min: 60, max: 120, step: 2 },             // px (ancho del box)
  boxHeight: { min: 24, max: 60, step: 2 },             // px (alto del box, 0 = auto)
};

// Opciones de decimales para los valores
export const OPCIONES_DECIMALES = [
  { valor: 2, label: "2 decimales" },
  { valor: 1, label: "1 decimal" },
  { valor: 0, label: "Sin decimales" },
];

// Colores predefinidos para el texto de los valores
export const COLORES_VALOR_PREDEFINIDOS = [
  "#ffff00", // amarillo (default)
  "#00ff00", // verde
  "#00ffff", // cyan
  "#ff9900", // naranja
  "#ff6666", // rojo claro
  "#ffffff", // blanco
  "#99ccff", // azul claro
];

// ===== ./src/paginas/PaginaAlimentadores/constantes/funcionalidadesRele.js =====

/**
 * Funcionalidades disponibles para configurar rel√©s de protecci√≥n ABB Serie 615.
 * Cada funcionalidad define qu√© datos se pueden monitorear y su registro Modbus por defecto.
 */

export const FUNCIONALIDADES_DISPONIBLES = {
  // MEDICIONES
  corrientes: {
    id: "corrientes",
    nombre: "Corrientes de fase (IL1, IL2, IL3)",
    categoria: "mediciones",
    registroDefault: 137,
    cantidad: 3,
  },
  tensiones: {
    id: "tensiones",
    nombre: "Tensiones (VA, VB, VC, VAB, VBC, VCA)",
    categoria: "mediciones",
    registroDefault: 151,
    cantidad: 6,
  },
  corrienteResidual: {
    id: "corrienteResidual",
    nombre: "Corriente residual Io",
    categoria: "mediciones",
    registroDefault: 141,
    cantidad: 1,
  },
  potencias: {
    id: "potencias",
    nombre: "Potencias (P, Q, S, FP)",
    categoria: "mediciones",
    registroDefault: 160,
    cantidad: 7,
  },

  // ESTADOS Y ALARMAS
  estadoRele: {
    id: "estadoRele",
    nombre: "Estado del rel√© (Ready/Start/Trip)",
    categoria: "estados",
    registroDefault: 170,
    cantidad: 1,
  },
  leds: {
    id: "leds",
    nombre: "LEDs del panel (alarmas visibles)",
    categoria: "estados",
    registroDefault: 172,
    cantidad: 1,
  },
  posicionCB: {
    id: "posicionCB",
    nombre: "Posici√≥n del interruptor (CB)",
    categoria: "estados",
    registroDefault: 175,
    cantidad: 1,
  },

  // SISTEMA
  saludDispositivo: {
    id: "saludDispositivo",
    nombre: "Salud del dispositivo (SSR1 - Ready)",
    categoria: "sistema",
    registroDefault: 127,
    cantidad: 1,
  },
  heartbeat: {
    id: "heartbeat",
    nombre: "Heartbeat (SSR5 - Alive counter)",
    categoria: "sistema",
    registroDefault: 131,
    cantidad: 1,
  },
};

/**
 * Categor√≠as de funcionalidades para agrupar en la UI
 */
export const CATEGORIAS_FUNCIONALIDADES = {
  mediciones: {
    id: "mediciones",
    nombre: "Mediciones",
    icono: "üìä",
  },
  estados: {
    id: "estados",
    nombre: "Estados y Alarmas",
    icono: "üö¶",
  },
  sistema: {
    id: "sistema",
    nombre: "Sistema",
    icono: "‚öôÔ∏è",
  },
};

/**
 * Key de localStorage para las plantillas de rel√©
 */
export const STORAGE_KEY_PLANTILLAS = "rw-plantillas-rele";

// ===== ./src/paginas/PaginaAlimentadores/constantes/historialConfig.js =====

/**
 * Configuraci√≥n y constantes para el sistema de historial y gr√°ficos
 */

// Retenci√≥n de datos en IndexedDB (horas)
export const HORAS_RETENCION_LOCAL = 48;

// Umbral de cobertura para considerar cache v√°lido (85%)
export const UMBRAL_COBERTURA_CACHE = 0.85;

// Umbral de cobertura para complementar con datos remotos (90%)
export const UMBRAL_COBERTURA_REMOTO = 0.90;

// Margen adicional al l√≠mite de 48h para evitar edge cases (5 minutos en ms)
export const MARGEN_LIMITE_LOCAL_MS = 5 * 60 * 1000;

// Antig√ºedad m√°xima permitida para el √∫ltimo dato en cache (minutos)
// Si el √∫ltimo dato es m√°s antiguo que esto, se fuerza recarga del servidor
export const MAX_ANTIGUEDAD_CACHE_MINUTOS = 15;

// Opciones de rango de tiempo predefinidas
export const RANGOS_TIEMPO = [
  { id: "1h", label: "1h", ms: 60 * 60 * 1000 },
  { id: "2h", label: "2h", ms: 2 * 60 * 60 * 1000 },
  { id: "6h", label: "6h", ms: 6 * 60 * 60 * 1000 },
  { id: "12h", label: "12h", ms: 12 * 60 * 60 * 1000 },
  { id: "24h", label: "24h", ms: 24 * 60 * 60 * 1000 },
  { id: "48h", label: "48h", ms: 48 * 60 * 60 * 1000 },
  { id: "7d", label: "7d", ms: 7 * 24 * 60 * 60 * 1000 },
  { id: "custom", label: "Custom", ms: null },
];

// Tipos de gr√°fico disponibles
export const TIPOS_GRAFICO = [
  { id: "line", label: "L√≠nea", icon: "üìà" },
  { id: "area", label: "√Årea", icon: "üìä" },
  { id: "bar", label: "Barras", icon: "üì∂" },
];

// Intervalos de muestreo para informes (en minutos)
export const INTERVALOS_INFORME = [
  { id: 15, label: "15 min", minutos: 15 },
  { id: 30, label: "30 min", minutos: 30 },
  { id: 60, label: "1 hora", minutos: 60 },
  { id: 180, label: "3 horas", minutos: 180 },
  { id: 360, label: "6 horas", minutos: 360 },
  { id: 720, label: "12 horas", minutos: 720 },
];

// Colores del gradiente verde-amarillo-rojo
export const COLORES_GRADIENTE = {
  verde: { r: 34, g: 197, b: 94 },     // #22c55e
  amarillo: { r: 234, g: 179, b: 8 },  // #eab308
  rojo: { r: 239, g: 68, b: 68 },      // #ef4444
};


// ===== ./src/paginas/PaginaAlimentadores/constantes/index.js =====

// constantes/index.js
// Exportaciones centralizadas de constantes

export * from "./escalas";
export * from "./colores";
export * from "./clavesAlmacenamiento";
export * from "./titulosMediciones";
export * from "./historialConfig";
export * from "./estilosGlobalesTarjeta";
export * from "./funcionalidadesRele";

// ===== ./src/paginas/PaginaAlimentadores/constantes/titulosMediciones.js =====

// src/paginas/PaginaAlimentadores/constantes/titulosMediciones.js

/**
 * T√≠tulos descriptivos para cada tipo de medici√≥n.
 * Aparecen en las tarjetas de alimentadores (parte superior/inferior).
 */
export const TITULOS_MEDICIONES = {
	tension_linea: "Tensi√≥n de l√≠nea (kV)",
	tension_entre_lineas: "Tensi√≥n entre l√≠neas (kV)",
	corriente_132: "Corriente de l√≠nea (A) (en 13,2 kV)",
	corriente_33: "Corriente de l√≠nea (A) (en 33 kV)",
	potencia_activa: "Potencia activa (kW)",
	potencia_reactiva: "Potencia reactiva (kVAr)",
	potencia_aparente: "Potencia aparente (kVA)",
	factor_potencia: "Factor de Potencia",
	frecuencia: "Frecuencia (Hz)",
	corriente_neutro: "Corriente de Neutro (A)",
};

/**
 * Etiquetas que aparecen en cada medidor (R, S, T, etc.),
 * organizadas por tipo de medici√≥n.
 */
export const ETIQUETAS_POR_DEFECTO = {
	corriente_132: ["R", "S", "T", "N"],
	corriente_33: ["R", "S", "T", "N"],
	tension_linea: ["R", "S", "T", "N"],
	tension_entre_lineas: ["L1-L2", "L2-L3", "L1-L3", ""],
	potencia_activa: ["L1", "L2", "L3", "Total"],
	potencia_reactiva: ["L1", "L2", "L3", "Total"],
	potencia_aparente: ["L1", "L2", "L3", "Total"],
	factor_potencia: ["L1", "L2", "L3", ""],
	frecuencia: ["L1", "L2", "L3", ""],
	corriente_neutro: ["N", "", "", ""],
};

/**
 * Dise√±o por defecto de una tarjeta de alimentador.
 * Define qu√© se muestra en la parte superior e inferior.
 */
export const DISE√ëO_TARJETA_POR_DEFECTO = {
	superior: {
		tituloId: "corriente_132", // arriba se muestran corrientes de l√≠nea (13,2 kV)
		tituloCustom: "",
		cantidad: 3,               // por defecto R, S, T
		boxes: [],
	},
	inferior: {
		tituloId: "tension_linea", // abajo se muestran tensiones de l√≠nea (kV)
		tituloCustom: "",
		cantidad: 3,
		boxes: [],
	},
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (titulosMediciones.js)

 - `TITULOS_MEDICIONES` traduce ids como `corriente_132` o `tension_linea`
   a textos legibles que aparecen como t√≠tulos en los lados de la tarjeta.

 - `ETIQUETAS_POR_DEFECTO` define las etiquetas iniciales de cada box seg√∫n
   el tipo de magnitud (por ejemplo, R/S/T/N para corrientes y L1/L2/L3/Total
   para potencias).

 - `DISE√ëO_TARJETA_POR_DEFECTO` se usa en `calculosMediciones.js` como base
   cuando todav√≠a no hay ning√∫n `cardDesign` configurado por el usuario, de
   modo que siempre exista una estructura razonable para mostrar.
---------------------------------------------------------------------------*/}


// ===== ./src/paginas/PaginaAlimentadores/contexto/ContextoAlimentadoresSupabase.jsx =====

// src/paginas/PaginaAlimentadores/contexto/ContextoAlimentadoresSupabase.jsx
// Contexto de alimentadores que usa Supabase para persistencia

import React, { createContext, useContext, useMemo, useEffect, useState, useCallback } from "react";

import { usePuestosSupabase, useCambiosPendientes } from "../hooks/puestos";
import { useMediciones } from "../hooks/mediciones";
import { usePreferenciasUI, usePreferenciasVisuales } from "../hooks/preferencias";
import {
   useGapsCombinados,
   useEscalasCombinadas,
   useSincronizacionCambios,
   useColoresPuesto,
} from "../hooks/preferencias";
import { usarContextoConfiguracion } from "./ContextoConfiguracion";

import { obtenerDisenoTarjeta, calcularValoresLadoTarjeta } from "../utilidades/calculosMediciones";

const ContextoAlimentadores = createContext(null);

/**
 * Provider de alimentadores que usa Supabase.
 * Requiere estar envuelto por ProveedorConfiguracion.
 */
export const ProveedorAlimentadoresSupabase = ({ children }) => {
   // Obtener workspace activo del contexto superior
   const {
      configuracionSeleccionada,
      configuracionSeleccionadaId,
      cargando: cargandoConfig,
   } = usarContextoConfiguracion();

   // Determinar si el usuario es creador del workspace
   const esCreador = configuracionSeleccionada?.esCreador ?? null;

   // Hook de puestos conectado a Supabase
   const puestosHook = usePuestosSupabase(configuracionSeleccionadaId);

   // Hook de mediciones
   const medicionesHook = useMediciones();

   // Hook de preferencias UI (gaps horizontales y verticales) - localStorage
   const preferenciasHook = usePreferenciasUI();

   // Hook de preferencias visuales persistentes en BD (para invitados)
   const preferenciasVisualesHook = usePreferenciasVisuales(
      configuracionSeleccionadaId,
      esCreador,
      puestosHook.puestos,
      puestosHook.cargarPuestos
   );

   // Hook de cambios pendientes (draft/publish pattern)
   const cambiosPendientesHook = useCambiosPendientes();

   const { registrosEnVivo } = medicionesHook;
   const { puestoSeleccionado, puestos, cargando: cargandoPuestos } = puestosHook;
   const { gapsPorTarjeta, gapsPorFila, escalasPorPuesto, escalasPorTarjeta } = preferenciasHook;

   const [lecturasTarjetas, setLecturasTarjetas] = useState({});

   // Estado de carga combinado
   const cargando =
      cargandoConfig || cargandoPuestos || (esCreador !== true && preferenciasVisualesHook.cargando);

   /**
    * Para invitados: aplica las preferencias personales sobre los puestos base.
    */
   const obtenerPuestosConPreferencias = useCallback(() => {
      if (esCreador || !preferenciasVisualesHook.preferenciasUsuario) {
         return puestos;
      }

      return puestos.map((puesto) => {
         const prefsPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puesto.id);

         return {
            ...puesto,
            color: prefsPuesto?.color || puesto.color,
            bgColor: prefsPuesto?.bg_color || puesto.bgColor || puesto.bg_color,
            escala: prefsPuesto?.escala ?? puesto.escala,
            gapsVerticales: {
               ...(puesto.gapsVerticales || { "0": 40 }),
               ...(prefsPuesto?.gapsVerticales || {}),
            },
            alimentadores: (puesto.alimentadores || []).map((alim) => {
               const prefsAlim = preferenciasVisualesHook.obtenerConfigAlimentador(alim.id, puesto.id);
               return {
                  ...alim,
                  color: prefsAlim?.color || alim.color,
                  escala: prefsAlim?.escala ?? alim.escala,
                  gapHorizontal: prefsAlim?.gapHorizontal ?? alim.gapHorizontal ?? 10,
               };
            }),
         };
      });
   }, [esCreador, puestos, preferenciasVisualesHook]);

   // Hook de colores de puesto
   const { obtenerColorPuesto, obtenerBgColorPuesto } = useColoresPuesto({
      esCreador,
      puestos: puestosHook.puestos,
      preferenciasVisualesHook,
   });

   // Hook de gaps combinados
   const { obtenerGapCombinado, obtenerRowGapCombinado } = useGapsCombinados({
      esCreador,
      gapsPorTarjeta,
      gapsPorFila,
      puestoSeleccionado,
      puestos,
      preferenciasVisualesHook,
      GAP_DEFAULT: preferenciasHook.GAP_DEFAULT,
      ROW_GAP_DEFAULT: preferenciasHook.ROW_GAP_DEFAULT,
   });

   // Hook de escalas combinadas
   const {
      obtenerEscalaPuestoCombinada,
      obtenerEscalaTarjetaCombinada,
      obtenerEscalaEfectivaCombinada,
   } = useEscalasCombinadas({
      esCreador,
      escalasPorPuesto,
      escalasPorTarjeta,
      puestoSeleccionado,
      puestos,
      preferenciasVisualesHook,
      escalaGlobal: preferenciasHook.escalaGlobal,
      ESCALA_DEFAULT: preferenciasHook.ESCALA_DEFAULT,
   });

   // Hook de sincronizaci√≥n de cambios
   const { hayCambiosPendientes, sincronizando, errorSincronizacion, sincronizarCambios, descartarCambios } =
      useSincronizacionCambios({
         esCreador,
         puestos,
         obtenerPuestosConPreferencias,
         gapsPorTarjeta,
         gapsPorFila,
         escalasPorPuesto,
         escalasPorTarjeta,
         cambiosPendientesHook,
         preferenciasHook,
         preferenciasVisualesHook,
         puestosHook,
         cargandoPuestos,
         configuracionSeleccionadaId,
      });

   // Funci√≥n para limpiar todo el localStorage de preferencias UI (al salir)
   const limpiarPreferenciasUI = useCallback(() => {
      preferenciasHook.resetearTodosLosGaps();
      preferenciasHook.resetearTodosLosRowGaps();
   }, [preferenciasHook]);

   /**
    * Actualiza puestos seg√∫n el rol del usuario.
    * - Creador: guarda en BASE (tabla puestos)
    * - Invitado: solo guarda colores en preferencias_usuario
    */
   const actualizarPuestosInteligente = useCallback(
      async (puestosEditados) => {
         if (esCreador) {
            await puestosHook.actualizarPuestos(puestosEditados);
         } else {
            // Invitado: solo guardar colores en preferencias_usuario
            for (const puesto of puestosEditados) {
               const puestoBase = puestosHook.puestos.find((p) => p.id === puesto.id);
               if (!puestoBase) continue;

               const colorActual = obtenerColorPuesto(puesto.id) || puestoBase.color;
               const bgColorActual =
                  obtenerBgColorPuesto(puesto.id) || puestoBase.bgColor || puestoBase.bg_color;

               const cambios = {};
               if (puesto.color !== colorActual) {
                  cambios.color = puesto.color;
               }
               if ((puesto.bgColor || puesto.bg_color) !== bgColorActual) {
                  cambios.bg_color = puesto.bgColor || puesto.bg_color;
               }

               if (Object.keys(cambios).length > 0) {
                  await preferenciasVisualesHook.guardarPreferenciasPuesto(puesto.id, cambios);
               }
            }
         }
      },
      [esCreador, puestosHook, preferenciasVisualesHook, obtenerColorPuesto, obtenerBgColorPuesto]
   );

   // Recalcular lecturas de tarjetas cuando cambian los datos
   useEffect(() => {
      if (!puestoSeleccionado) {
         setLecturasTarjetas({});
         return;
      }

      setLecturasTarjetas(() => {
         const nuevo = {};

         puestoSeleccionado.alimentadores.forEach((alim) => {
            const regsDelAlim = registrosEnVivo[alim.id] || null;
            const cardDesignData = alim.card_design || alim.mapeoMediciones || {};
            const diseno = obtenerDisenoTarjeta(cardDesignData);

            const parteSuperior = calcularValoresLadoTarjeta(regsDelAlim, diseno.superior);
            const parteInferior = calcularValoresLadoTarjeta(regsDelAlim, diseno.inferior);

            nuevo[alim.id] = { parteSuperior, parteInferior };
         });

         return nuevo;
      });
   }, [puestoSeleccionado, registrosEnVivo]);

   // Objeto de contexto
   const valorContexto = useMemo(
      () => ({
         // Estados de carga
         cargando,
         error: puestosHook.error,

         // Workspace actual
         configuracionSeleccionada,
         configuracionSeleccionadaId,

         // Datos de puestos
         puestos: puestosHook.puestos,
         puestoSeleccionado: puestosHook.puestoSeleccionado,
         puestoSeleccionadoId: puestosHook.puestoSeleccionadoId,

         agregarPuesto: puestosHook.agregarPuesto,
         eliminarPuesto: puestosHook.eliminarPuesto,
         seleccionarPuesto: puestosHook.seleccionarPuesto,
         actualizarPuestos: actualizarPuestosInteligente,
         setPuestos: puestosHook.setPuestos,
         cargarPuestos: puestosHook.cargarPuestos,

         // Getters de colores
         obtenerColorPuesto,
         obtenerBgColorPuesto,

         // Alimentadores
         agregarAlimentador: puestosHook.agregarAlimentador,
         actualizarAlimentador: puestosHook.actualizarAlimentador,
         eliminarAlimentador: puestosHook.eliminarAlimentador,
         reordenarAlimentadores: puestosHook.reordenarAlimentadores,

         // Mediciones y lecturas
         lecturasTarjetas,
         registrosEnVivo: medicionesHook.registrosEnVivo,

         detenerMedicion: medicionesHook.detenerMedicion,
         obtenerRegistros: medicionesHook.obtenerRegistros,
         estaMidiendo: medicionesHook.estaMidiendo,
         obtenerTimestampInicio: medicionesHook.obtenerTimestampInicio,
         obtenerContadorLecturas: medicionesHook.obtenerContadorLecturas,
         actualizarRegistros: medicionesHook.actualizarRegistros,

         // Preferencias UI (gaps)
         gapsPorTarjeta: preferenciasHook.gapsPorTarjeta,
         gapsPorFila: preferenciasHook.gapsPorFila,
         obtenerGap: obtenerGapCombinado,
         establecerGap: preferenciasHook.establecerGap,
         obtenerRowGap: obtenerRowGapCombinado,
         establecerRowGap: preferenciasHook.establecerRowGap,
         GAP_MIN: preferenciasHook.GAP_MIN,
         GAP_MAX: preferenciasHook.GAP_MAX,
         GAP_DEFAULT: preferenciasHook.GAP_DEFAULT,
         ROW_GAP_MIN: preferenciasHook.ROW_GAP_MIN,
         ROW_GAP_MAX: preferenciasHook.ROW_GAP_MAX,
         ROW_GAP_DEFAULT: preferenciasHook.ROW_GAP_DEFAULT,

         // Escala de tarjetas
         escalaGlobal: preferenciasHook.escalaGlobal,
         establecerEscalaGlobal: preferenciasHook.establecerEscalaGlobal,
         resetearEscalaGlobal: preferenciasHook.resetearEscalaGlobal,
         escalasPorPuesto: preferenciasHook.escalasPorPuesto,
         obtenerEscalaPuesto: obtenerEscalaPuestoCombinada,
         establecerEscalaPuesto: preferenciasHook.establecerEscalaPuesto,
         resetearEscalaPuesto: preferenciasHook.resetearEscalaPuesto,
         escalasPorTarjeta: preferenciasHook.escalasPorTarjeta,
         obtenerEscalaTarjeta: obtenerEscalaTarjetaCombinada,
         establecerEscalaTarjeta: preferenciasHook.establecerEscalaTarjeta,
         resetearEscalaTarjeta: preferenciasHook.resetearEscalaTarjeta,
         obtenerEscalaEfectiva: obtenerEscalaEfectivaCombinada,
         resetearTodasLasEscalas: preferenciasHook.resetearTodasLasEscalas,
         ESCALA_MIN: preferenciasHook.ESCALA_MIN,
         ESCALA_MAX: preferenciasHook.ESCALA_MAX,
         ESCALA_DEFAULT: preferenciasHook.ESCALA_DEFAULT,

         // Cambios pendientes (draft/publish)
         hayCambiosPendientes,
         sincronizando,
         errorSincronizacion,
         sincronizarCambios,
         descartarCambios,

         // Limpieza al salir
         limpiarPreferenciasUI,

         // Info del rol del usuario
         esCreador,

         // Preferencias visuales persistentes
         preferenciasVisuales: {
            cargando: preferenciasVisualesHook.cargando,
            guardando: preferenciasVisualesHook.guardando,
            tienePreferenciasPersonales: preferenciasVisualesHook.tienePreferenciasPersonales,
            guardarPreferencia: preferenciasVisualesHook.guardarPreferencia,
            guardarPreferenciasPuesto: preferenciasVisualesHook.guardarPreferenciasPuesto,
            guardarPreferenciasAlimentador: preferenciasVisualesHook.guardarPreferenciasAlimentador,
            resetearPreferencias: preferenciasVisualesHook.resetearPreferencias,
            obtenerConfigPuesto: preferenciasVisualesHook.obtenerConfigPuesto,
            obtenerConfigAlimentador: preferenciasVisualesHook.obtenerConfigAlimentador,
         },
      }),
      [
         puestosHook,
         medicionesHook,
         preferenciasHook,
         preferenciasVisualesHook,
         lecturasTarjetas,
         configuracionSeleccionada,
         cargando,
         hayCambiosPendientes,
         sincronizando,
         errorSincronizacion,
         sincronizarCambios,
         descartarCambios,
         obtenerGapCombinado,
         obtenerRowGapCombinado,
         obtenerEscalaPuestoCombinada,
         obtenerEscalaTarjetaCombinada,
         obtenerEscalaEfectivaCombinada,
         limpiarPreferenciasUI,
         esCreador,
         actualizarPuestosInteligente,
         obtenerColorPuesto,
         obtenerBgColorPuesto,
      ]
   );

   return (
      <ContextoAlimentadores.Provider value={valorContexto}>{children}</ContextoAlimentadores.Provider>
   );
};

export const usarContextoAlimentadores = () => {
   const contexto = useContext(ContextoAlimentadores);

   if (!contexto) {
      throw new Error("usarContextoAlimentadores debe usarse dentro de ProveedorAlimentadoresSupabase");
   }

   return contexto;
};

// ===== ./src/paginas/PaginaAlimentadores/contexto/ContextoConfiguracion.jsx =====

// src/paginas/PaginaAlimentadores/contexto/ContextoConfiguracion.jsx
// Contexto global para manejar el workspace activo del usuario y estilos globales

import React, { createContext, useContext, useMemo } from "react";
import { useConfiguracion } from "../hooks/mediciones";
import { useEstilosGlobales } from "../hooks/preferencias";

const ContextoConfiguracion = createContext(null);

/**
 * Provider que maneja los workspaces del usuario y los estilos globales de tarjetas.
 * Debe envolver a ProveedorAlimentadores para que este tenga acceso
 * al workspace seleccionado.
 */
export const ProveedorConfiguracion = ({ children }) => {
  const configuracionHook = useConfiguracion();
  const estilosGlobalesHook = useEstilosGlobales();

  // Combinar ambos hooks en un solo valor de contexto
  const valorContexto = useMemo(() => ({
    ...configuracionHook,
    // Estilos globales de tarjetas
    estilosGlobales: estilosGlobalesHook.estilos,
    guardarEstilosGlobales: estilosGlobalesHook.aplicarTodosEstilos,
    obtenerEstilosCSS: estilosGlobalesHook.obtenerEstilosCSS,
  }), [configuracionHook, estilosGlobalesHook]);

  return (
    <ContextoConfiguracion.Provider value={valorContexto}>
      {children}
    </ContextoConfiguracion.Provider>
  );
};

/**
 * Hook para acceder al contexto de workspace
 */
export const usarContextoConfiguracion = () => {
  const contexto = useContext(ContextoConfiguracion);

  if (!contexto) {
    throw new Error(
      "usarContextoConfiguracion debe usarse dentro de ProveedorConfiguracion"
    );
  }

  return contexto;
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/agentes/index.js =====

// hooks/agentes/index.js
// Hooks relacionados con la gesti√≥n de agentes y registradores

export { useAgentesConfig } from "./useAgentesConfig";
export { useRegistradoresConfig } from "./useRegistradoresConfig";
export { useConsolaTest } from "./useConsolaTest";
export { default as useVentanaConfigAgente } from "./useVentanaConfigAgente";
export { useRegistradoresWorkspace } from "./useRegistradoresWorkspace";

// ===== ./src/paginas/PaginaAlimentadores/hooks/agentes/useAgentesConfig.js =====

// hooks/useAgentesConfig.js
// Hook para manejar CRUD de agentes

import { useState, useCallback } from "react";
import {
   listarAgentesWorkspace,
   listarAgentesDisponibles,
   vincularAgenteWorkspace,
   desvincularAgenteWorkspace,
   listarTodosLosAgentes,
   crearAgente,
   eliminarAgente,
   rotarClaveAgentePorId,
} from "../../../../servicios/apiService";

/**
 * Hook para manejar CRUD de agentes
 * @param {Object} params - Par√°metros del hook
 * @param {string} params.workspaceId - ID del workspace actual
 * @param {boolean} params.puedeVincular - Si el usuario puede vincular agentes
 * @param {boolean} params.esSuperadmin - Si el usuario es superadmin
 * @returns {Object} Estado y funciones de agentes
 */
export function useAgentesConfig({ workspaceId, puedeVincular, esSuperadmin }) {
   const [cargando, setCargando] = useState(false);
   const [error, setError] = useState(null);

   // Listas de agentes
   const [agentesVinculados, setAgentesVinculados] = useState([]);
   const [agentesDisponibles, setAgentesDisponibles] = useState([]);
   const [todosAgentes, setTodosAgentes] = useState([]);

   // Estado para crear agente
   const [mostrarFormCrear, setMostrarFormCrear] = useState(false);
   const [nuevoAgente, setNuevoAgente] = useState({ nombre: '', descripcion: '' });
   const [creando, setCreando] = useState(false);
   const [claveGenerada, setClaveGenerada] = useState(null);

   // Estado para expandir registradores
   const [agenteExpandido, setAgenteExpandido] = useState(null);

   /**
    * Cargar todos los datos de agentes
    */
   const cargarDatos = useCallback(async () => {
      if (!workspaceId) return;

      setCargando(true);
      setError(null);

      try {
         // Cargar agentes vinculados al workspace
         const vinculados = await listarAgentesWorkspace(workspaceId);
         setAgentesVinculados(vinculados || []);

         // Si puede vincular, cargar disponibles
         if (puedeVincular) {
            const disponibles = await listarAgentesDisponibles();
            const idsVinculados = new Set((vinculados || []).map(a => a.id));
            setAgentesDisponibles((disponibles || []).filter(a => !idsVinculados.has(a.id)));
         }

         // Si es superadmin, cargar todos
         if (esSuperadmin) {
            const todos = await listarTodosLosAgentes();
            setTodosAgentes(todos || []);
         }
      } catch (err) {
         console.error('Error cargando datos:', err);
         setError(err.message || 'Error cargando datos');
      } finally {
         setCargando(false);
      }
   }, [workspaceId, puedeVincular, esSuperadmin]);

   /**
    * Vincular agente al workspace
    */
   const vincularAgente = useCallback(async (agenteId) => {
      setCargando(true);
      try {
         await vincularAgenteWorkspace(workspaceId, agenteId);
         await cargarDatos();
         return true;
      } catch (err) {
         setError(err.message);
         return false;
      } finally {
         setCargando(false);
      }
   }, [workspaceId, cargarDatos]);

   /**
    * Desvincular agente del workspace
    */
   const desvincularAgente = useCallback(async (agenteId) => {
      setCargando(true);
      try {
         await desvincularAgenteWorkspace(workspaceId, agenteId);
         await cargarDatos();
         return true;
      } catch (err) {
         setError(err.message);
         return false;
      } finally {
         setCargando(false);
      }
   }, [workspaceId, cargarDatos]);

   /**
    * Crear nuevo agente (superadmin)
    */
   const crearNuevoAgente = useCallback(async (nombre, descripcion) => {
      if (!nombre.trim()) return null;

      setCreando(true);
      setError(null);
      try {
         const resultado = await crearAgente(nombre, descripcion);
         setClaveGenerada(resultado.claveSecreta);
         setNuevoAgente({ nombre: '', descripcion: '' });
         await cargarDatos();
         return resultado;
      } catch (err) {
         setError(err.message);
         return null;
      } finally {
         setCreando(false);
      }
   }, [cargarDatos]);

   /**
    * Eliminar agente (superadmin)
    */
   const eliminarAgenteById = useCallback(async (agenteId) => {
      setCargando(true);
      try {
         await eliminarAgente(agenteId);
         await cargarDatos();
         return true;
      } catch (err) {
         setError(err.message);
         return false;
      } finally {
         setCargando(false);
      }
   }, [cargarDatos]);

   /**
    * Rotar clave de agente (superadmin)
    */
   const rotarClave = useCallback(async (agenteId) => {
      setCargando(true);
      try {
         const resultado = await rotarClaveAgentePorId(agenteId);
         setClaveGenerada(resultado.nuevaClave);
         return resultado.nuevaClave;
      } catch (err) {
         setError(err.message);
         return null;
      } finally {
         setCargando(false);
      }
   }, []);

   /**
    * Toggle expandir agente (para ver registradores)
    */
   const toggleExpandirAgente = useCallback((agenteId) => {
      setAgenteExpandido(prev => prev === agenteId ? null : agenteId);
   }, []);

   /**
    * Resetear estado al cerrar
    */
   const resetearEstado = useCallback(() => {
      setError(null);
      setMostrarFormCrear(false);
      setClaveGenerada(null);
      setAgenteExpandido(null);
      setNuevoAgente({ nombre: '', descripcion: '' });
   }, []);

   /**
    * Limpiar error
    */
   const limpiarError = useCallback(() => {
      setError(null);
   }, []);

   /**
    * Limpiar clave generada
    */
   const limpiarClaveGenerada = useCallback(() => {
      setClaveGenerada(null);
   }, []);

   return {
      // Estado
      cargando,
      error,
      agentesVinculados,
      agentesDisponibles,
      todosAgentes,
      mostrarFormCrear,
      nuevoAgente,
      creando,
      claveGenerada,
      agenteExpandido,

      // Setters
      setMostrarFormCrear,
      setNuevoAgente,
      setError,

      // Funciones
      cargarDatos,
      vincularAgente,
      desvincularAgente,
      crearNuevoAgente,
      eliminarAgenteById,
      rotarClave,
      toggleExpandirAgente,
      resetearEstado,
      limpiarError,
      limpiarClaveGenerada,
   };
}

// ===== ./src/paginas/PaginaAlimentadores/hooks/agentes/useConsolaTest.js =====

// hooks/useConsolaTest.js
// Hook para manejar la consola de test Modbus

import { useState, useRef, useCallback } from "react";
import { solicitarTestRegistrador, consultarTestRegistrador } from "../../../../servicios/apiService";

/**
 * Hook para manejar la consola de test Modbus
 * @param {Object} params - Par√°metros del hook
 * @param {Object} params.config - Configuraci√≥n actual del rel√©
 * @param {string} params.agenteId - ID del agente para ejecutar tests
 * @returns {Object} Estado y funciones de la consola
 */
export function useConsolaTest({ config, agenteId }) {
   const consolaRef = useRef(null);
   const containerRef = useRef(null);
   const resizerRef = useRef(null);

   const [consolaLogs, setConsolaLogs] = useState([]);
   const [ejecutandoTest, setEjecutandoTest] = useState(false);
   const [registrosCrudos, setRegistrosCrudos] = useState(null);
   const [consolaWidth, setConsolaWidth] = useState(60);

   /**
    * Agregar log a la consola
    */
   const agregarLog = useCallback((mensaje, tipo = "info") => {
      const timestamp = new Date().toLocaleTimeString();
      setConsolaLogs((prev) => [...prev, { timestamp, mensaje, tipo }]);
      setTimeout(() => {
         if (consolaRef.current) {
            consolaRef.current.scrollTop = consolaRef.current.scrollHeight;
         }
      }, 50);
   }, []);

   /**
    * Limpiar consola
    */
   const limpiarConsola = useCallback(() => {
      setConsolaLogs([]);
      setRegistrosCrudos(null);
   }, []);

   /**
    * Manejadores del resizer
    */
   const handleMouseDown = useCallback((e) => {
      e.preventDefault();

      const handleMouseMove = (e) => {
         if (!containerRef.current) return;
         const container = containerRef.current;
         const containerRect = container.getBoundingClientRect();
         const newWidth = ((e.clientX - containerRect.left) / containerRect.width) * 100;
         const clampedWidth = Math.min(80, Math.max(30, newWidth));
         setConsolaWidth(clampedWidth);
      };

      const handleMouseUp = () => {
         document.removeEventListener("mousemove", handleMouseMove);
         document.removeEventListener("mouseup", handleMouseUp);
         document.body.style.cursor = "";
         document.body.style.userSelect = "";
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      document.body.style.cursor = "col-resize";
      document.body.style.userSelect = "none";
   }, []);

   /**
    * Ejecutar test Modbus real usando el agente
    */
   const ejecutarTest = useCallback(async () => {
      if (!config.conexion.ip) {
         agregarLog("Error: Debes ingresar una IP", "error");
         return;
      }

      if (!agenteId) {
         agregarLog("Error: No hay agente configurado para ejecutar el test", "error");
         agregarLog("El test requiere un agente conectado para comunicarse con el rel√©", "info");
         return;
      }

      setEjecutandoTest(true);
      setRegistrosCrudos(null);
      limpiarConsola();

      const indiceInicial = config.registroInicial || 0;
      const cantidad = config.cantidadRegistros || 20;

      agregarLog(`Iniciando test de conexi√≥n...`, "info");
      agregarLog(`IP: ${config.conexion.ip}:${config.conexion.puerto} (Unit ID: ${config.conexion.unitId})`, "info");
      agregarLog(`Registros: ${indiceInicial} - ${indiceInicial + cantidad - 1} (${cantidad} registros)`, "info");
      agregarLog(`Agente: ${agenteId}`, "info");

      try {
         agregarLog("Enviando solicitud al agente...", "info");

         const respuesta = await solicitarTestRegistrador(agenteId, {
            ip: config.conexion.ip,
            puerto: parseInt(config.conexion.puerto) || 502,
            unitId: parseInt(config.conexion.unitId) || 1,
            indiceInicial,
            cantidadRegistros: cantidad,
         });

         const testId = respuesta.testId;
         agregarLog(`Solicitud enviada (ID: ${testId})`, "success");
         agregarLog("Esperando respuesta del agente...", "info");

         const maxIntentos = 15;
         const intervaloMs = 2000;
         let intentos = 0;

         while (intentos < maxIntentos) {
            await new Promise((resolve) => setTimeout(resolve, intervaloMs));
            intentos++;

            const resultado = await consultarTestRegistrador(agenteId, testId);

            if (resultado.estado === "completado") {
               const registros = resultado.valores || [];
               const tiempoMs = resultado.tiempo_respuesta_ms || 0;

               agregarLog(`Conexi√≥n exitosa (${tiempoMs}ms)`, "success");
               agregarLog(`Registros le√≠dos: ${registros.length}`, "success");

               for (let i = 0; i < registros.length; i++) {
                  const regNum = indiceInicial + i;
                  const valor = registros[i];
                  agregarLog(`  [${regNum}] = ${valor}`, "data");
               }

               setRegistrosCrudos({
                  valores: registros,
                  indiceInicial,
                  ip: config.conexion.ip,
                  puerto: config.conexion.puerto,
                  tiempoMs,
               });

               agregarLog("Test completado exitosamente", "success");
               return;

            } else if (resultado.estado === "error" || resultado.estado === "timeout") {
               agregarLog(`Error: ${resultado.error_mensaje || "Error de conexi√≥n"}`, "error");
               if (resultado.tiempo_respuesta_ms) {
                  agregarLog(`Tiempo transcurrido: ${resultado.tiempo_respuesta_ms}ms`, "info");
               }
               return;
            }

            agregarLog(`Esperando... (${intentos}/${maxIntentos})`, "info");
         }

         agregarLog("Timeout: El agente no respondi√≥ a tiempo", "error");
         agregarLog("Verifica que el agente est√© conectado y el dispositivo sea accesible", "info");

      } catch (error) {
         agregarLog(`Error: ${error.message}`, "error");

         if (error.message?.includes("esperar")) {
            agregarLog("Debes esperar antes de ejecutar otro test", "info");
         } else if (error.message?.includes("agente")) {
            agregarLog("Verifica que el agente est√© conectado", "info");
         }
      } finally {
         setEjecutandoTest(false);
      }
   }, [config, agenteId, agregarLog, limpiarConsola]);

   /**
    * Exportar registros a CSV
    */
   const exportarCSV = useCallback(() => {
      if (!registrosCrudos || !registrosCrudos.valores || registrosCrudos.valores.length === 0) {
         agregarLog("No hay registros para exportar. Ejecuta un test primero.", "error");
         return;
      }

      const { valores, indiceInicial, ip, puerto, tiempoMs } = registrosCrudos;
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);

      const cabecera = "Registro,Valor";
      const filas = valores.map((valor, idx) => {
         const registro = indiceInicial + idx;
         return `${registro},${valor}`;
      });

      const metadatos = [
         `# Test Modbus - RelayWatch`,
         `# Fecha: ${new Date().toLocaleString()}`,
         `# Dispositivo: ${ip}:${puerto}`,
         `# Registros: ${indiceInicial} - ${indiceInicial + valores.length - 1}`,
         `# Tiempo de respuesta: ${tiempoMs}ms`,
         `# Total registros: ${valores.length}`,
         "",
      ];

      const contenidoCSV = [...metadatos, cabecera, ...filas].join("\n");

      const blob = new Blob([contenidoCSV], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `registros_${ip}_${puerto}_${timestamp}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      agregarLog(`CSV exportado: registros_${ip}_${puerto}_${timestamp}.csv`, "success");
   }, [registrosCrudos, agregarLog]);

   return {
      // Refs
      consolaRef,
      containerRef,
      resizerRef,

      // Estado
      consolaLogs,
      ejecutandoTest,
      registrosCrudos,
      consolaWidth,

      // Funciones
      agregarLog,
      limpiarConsola,
      handleMouseDown,
      ejecutarTest,
      exportarCSV,
   };
}

// ===== ./src/paginas/PaginaAlimentadores/hooks/agentes/useRegistradoresConfig.js =====

// hooks/useRegistradoresConfig.js
// Hook para manejar CRUD de registradores de agentes

import { useState, useCallback } from "react";
import {
   listarRegistradoresAgente,
   crearRegistradorAgente,
   actualizarRegistradorAgente,
   eliminarRegistradorAgente,
   toggleRegistradorAgente,
   solicitarTestRegistrador,
   consultarTestRegistrador,
} from "../../../../servicios/apiService";

const REGISTRADOR_INICIAL = {
   nombre: '',
   tipo: 'modbus',
   tipoDispositivo: 'analizador',
   ip: '',
   puerto: '',
   unitId: '',
   indiceInicial: '',
   cantidadRegistros: '',
   intervaloSegundos: '',
   configuracionRele: null,
};

/**
 * Hook para manejar CRUD de registradores
 * @returns {Object} Estado y funciones de registradores
 */
export function useRegistradoresConfig() {
   // Cache de registradores por agente
   const [registradoresAgente, setRegistradoresAgente] = useState({});

   // Estado del formulario
   const [mostrarFormRegistrador, setMostrarFormRegistrador] = useState(null);
   const [registradorEditando, setRegistradorEditando] = useState(null);
   const [nuevoRegistrador, setNuevoRegistrador] = useState(REGISTRADOR_INICIAL);
   const [guardandoRegistrador, setGuardandoRegistrador] = useState(false);
   const [registradorProcesando, setRegistradorProcesando] = useState(null);

   // Estado de test
   const [testEnCurso, setTestEnCurso] = useState(null);
   const [resultadoTest, setResultadoTest] = useState(null);

   /**
    * Reset del formulario de registrador
    */
   const resetFormRegistrador = useCallback(() => {
      setNuevoRegistrador(REGISTRADOR_INICIAL);
      setRegistradorEditando(null);
   }, []);

   /**
    * Cargar registradores de un agente
    */
   const cargarRegistradores = useCallback(async (agenteId) => {
      try {
         const regs = await listarRegistradoresAgente(agenteId);
         setRegistradoresAgente(prev => ({ ...prev, [agenteId]: regs }));
         return regs;
      } catch (err) {
         console.error('Error cargando registradores:', err);
         throw err;
      }
   }, []);

   /**
    * Recargar registradores de un agente
    */
   const recargarRegistradores = useCallback(async (agenteId) => {
      return cargarRegistradores(agenteId);
   }, [cargarRegistradores]);

   /**
    * Preparar datos para guardar registrador
    */
   const prepararDatosRegistrador = useCallback((formData) => {
      const esRele = formData.tipoDispositivo === 'rele';

      if (esRele) {
         const configRele = formData.configuracionRele;
         return {
            nombre: formData.nombre,
            tipo: 'modbus',
            tipoDispositivo: 'rele',
            ip: configRele.conexion.ip,
            puerto: String(configRele.conexion.puerto || 502),
            unitId: String(configRele.conexion.unitId || 1),
            indiceInicial: String(configRele.registroInicial || 120),
            cantidadRegistros: String(configRele.cantidadRegistros || 80),
            intervaloSegundos: '60',
            configuracionRele: configRele,
         };
      }

      return {
         ...formData,
         tipoDispositivo: 'analizador',
         unitId: formData.unitId || '1',
         intervaloSegundos: formData.intervaloSegundos || '60',
      };
   }, []);

   /**
    * Guardar registrador (crear o editar)
    */
   const guardarRegistrador = useCallback(async (agenteId, formData, registradorId = null) => {
      const datos = prepararDatosRegistrador(formData);

      setGuardandoRegistrador(true);
      try {
         if (registradorId) {
            await actualizarRegistradorAgente(agenteId, registradorId, datos);
         } else {
            await crearRegistradorAgente(agenteId, datos);
         }
         await recargarRegistradores(agenteId);
         setMostrarFormRegistrador(null);
         resetFormRegistrador();
      } finally {
         setGuardandoRegistrador(false);
      }
   }, [prepararDatosRegistrador, recargarRegistradores, resetFormRegistrador]);

   /**
    * Editar registrador - poblar formulario
    */
   const editarRegistrador = useCallback((reg) => {
      setRegistradorEditando(reg);
      setNuevoRegistrador({
         nombre: reg.nombre || '',
         tipo: reg.tipo || 'modbus',
         tipoDispositivo: reg.tipo_dispositivo || 'analizador',
         ip: reg.ip || '',
         puerto: String(reg.puerto || '502'),
         unitId: String(reg.unit_id || '1'),
         indiceInicial: String(reg.indice_inicial || '0'),
         cantidadRegistros: String(reg.cantidad_registros || '10'),
         intervaloSegundos: String(reg.intervalo_segundos || '60'),
         configuracionRele: reg.configuracion_rele || null,
      });
      setMostrarFormRegistrador(reg.agente_id);
   }, []);

   /**
    * Eliminar registrador
    */
   const eliminarRegistrador = useCallback(async (agenteId, registradorId) => {
      await eliminarRegistradorAgente(agenteId, registradorId);
      await recargarRegistradores(agenteId);
   }, [recargarRegistradores]);

   /**
    * Toggle activo de registrador
    */
   const toggleRegistrador = useCallback(async (agenteId, registradorId) => {
      setRegistradorProcesando(registradorId);
      try {
         await toggleRegistradorAgente(agenteId, registradorId);
         await recargarRegistradores(agenteId);
      } finally {
         setRegistradorProcesando(null);
      }
   }, [recargarRegistradores]);

   /**
    * Toggle todos los registradores de un agente
    */
   const toggleTodosRegistradores = useCallback(async (agenteId, iniciar) => {
      const regs = registradoresAgente[agenteId] || [];
      const registrosAToggle = regs.filter(r => iniciar ? !r.activo : r.activo);

      if (registrosAToggle.length === 0) return;

      setRegistradorProcesando('todos');
      try {
         for (const reg of registrosAToggle) {
            await toggleRegistradorAgente(agenteId, reg.id);
         }
         await recargarRegistradores(agenteId);
      } finally {
         setRegistradorProcesando(null);
      }
   }, [registradoresAgente, recargarRegistradores]);

   /**
    * Test de conexi√≥n de registrador
    */
   const testRegistrador = useCallback(async (agenteId, datosForm) => {
      if (testEnCurso) return;

      const datosTest = {
         nombre: datosForm.nombre || 'Test',
         ip: datosForm.ip,
         puerto: parseInt(datosForm.puerto),
         unit_id: parseInt(datosForm.unitId) || 1,
         indice_inicial: parseInt(datosForm.indiceInicial),
         cantidad_registros: parseInt(datosForm.cantidadRegistros),
      };

      setTestEnCurso({
         agenteId,
         registradorId: 'form',
         testId: null,
         estado: 'solicitando',
         progreso: 0,
      });
      setResultadoTest(null);

      try {
         const respuesta = await solicitarTestRegistrador(agenteId, {
            ip: datosTest.ip,
            puerto: datosTest.puerto,
            unitId: datosTest.unit_id,
            indiceInicial: datosTest.indice_inicial,
            cantidadRegistros: datosTest.cantidad_registros,
         });

         const { testId, timeoutSegundos } = respuesta;

         setTestEnCurso(prev => ({
            ...prev,
            testId,
            estado: 'esperando',
            progreso: 0,
         }));

         // Polling del resultado
         const tiempoInicio = Date.now();
         const tiempoMaximo = (timeoutSegundos || 30) * 1000;
         const intervalo = 1000;

         const poll = async () => {
            const tiempoTranscurrido = Date.now() - tiempoInicio;

            if (tiempoTranscurrido > tiempoMaximo) {
               setTestEnCurso(null);
               setResultadoTest({
                  exito: false,
                  estado: 'timeout',
                  error_mensaje: 'El agente no respondi√≥ a tiempo',
                  registrador: datosTest,
               });
               return;
            }

            try {
               const resultado = await consultarTestRegistrador(agenteId, testId);
               const progreso = Math.min((tiempoTranscurrido / tiempoMaximo) * 100, 95);
               setTestEnCurso(prev => prev ? { ...prev, progreso } : null);

               if (resultado.estado === 'completado' || resultado.estado === 'error' || resultado.estado === 'timeout') {
                  setTestEnCurso(prev => prev ? { ...prev, progreso: 100 } : null);

                  setTimeout(() => {
                     setTestEnCurso(null);
                     setResultadoTest({
                        ...resultado,
                        exito: resultado.estado === 'completado',
                        registrador: datosTest,
                     });
                  }, 400);
               } else {
                  setTimeout(poll, intervalo);
               }
            } catch (err) {
               setTestEnCurso(null);
               setResultadoTest({
                  exito: false,
                  estado: 'error',
                  error_mensaje: err.message,
                  registrador: datosTest,
               });
            }
         };

         setTimeout(poll, intervalo);

      } catch (err) {
         setTestEnCurso(null);

         if (err.message?.includes('esperar')) {
            setResultadoTest({
               exito: false,
               estado: 'cooldown',
               error_mensaje: err.message,
               registrador: datosTest,
            });
         } else {
            throw err;
         }
      }
   }, [testEnCurso]);

   /**
    * Limpiar estado de test
    */
   const limpiarResultadoTest = useCallback(() => {
      setResultadoTest(null);
   }, []);

   /**
    * Resetear todo el estado
    */
   const resetearEstado = useCallback(() => {
      setMostrarFormRegistrador(null);
      setRegistradorEditando(null);
      resetFormRegistrador();
      setTestEnCurso(null);
      setResultadoTest(null);
   }, [resetFormRegistrador]);

   return {
      // Estado
      registradoresAgente,
      mostrarFormRegistrador,
      registradorEditando,
      nuevoRegistrador,
      guardandoRegistrador,
      registradorProcesando,
      testEnCurso,
      resultadoTest,

      // Setters
      setMostrarFormRegistrador,
      setNuevoRegistrador,

      // Funciones
      resetFormRegistrador,
      cargarRegistradores,
      recargarRegistradores,
      guardarRegistrador,
      editarRegistrador,
      eliminarRegistrador,
      toggleRegistrador,
      toggleTodosRegistradores,
      testRegistrador,
      limpiarResultadoTest,
      resetearEstado,
   };
}

// ===== ./src/paginas/PaginaAlimentadores/hooks/agentes/useRegistradoresWorkspace.js =====

// hooks/agentes/useRegistradoresWorkspace.js
// Hook para cargar registradores de un workspace a trav√©s de sus agentes

import { useState, useEffect, useCallback } from "react";
import { listarAgentesWorkspace, listarRegistradoresAgente } from "../../../../servicios/apiService";

/**
 * Hook para cargar todos los registradores de un workspace
 *
 * @param {string|null} workspaceId - ID del workspace
 * @returns {Object} Lista de registradores y funci√≥n helper
 */
export const useRegistradoresWorkspace = (workspaceId) => {
   const [registradores, setRegistradores] = useState([]);
   const [cargando, setCargando] = useState(false);
   const [error, setError] = useState(null);

   useEffect(() => {
      if (!workspaceId) return;

      const cargarRegistradores = async () => {
         setCargando(true);
         setError(null);

         try {
            // Primero obtener los agentes vinculados al workspace
            const agentes = await listarAgentesWorkspace(workspaceId);

            // Luego cargar los registradores de cada agente
            const todosRegistradores = [];
            for (const agente of agentes || []) {
               try {
                  const regs = await listarRegistradoresAgente(agente.id);
                  if (regs && regs.length > 0) {
                     todosRegistradores.push(...regs);
                  }
               } catch (err) {
                  console.error(`Error cargando registradores del agente ${agente.id}:`, err);
               }
            }
            setRegistradores(todosRegistradores);
         } catch (err) {
            console.error("Error cargando registradores:", err);
            setError(err.message);
         } finally {
            setCargando(false);
         }
      };

      cargarRegistradores();
   }, [workspaceId]);

   // Helper para buscar un registrador por ID
   const buscarRegistrador = useCallback(
      (regId) => registradores.find((r) => r.id === regId) || null,
      [registradores]
   );

   return {
      registradores,
      cargando,
      error,
      buscarRegistrador,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/agentes/useVentanaConfigAgente.js =====

/**
 * Hook para gestionar el estado de la ventana flotante de configuraci√≥n de agentes
 * Gestiona: abrir, cerrar, minimizar, maximizar, mover, redimensionar
 */

import { useState, useCallback, useRef } from "react";

// Z-index base para la ventana de config agente
const Z_INDEX_BASE = 1100;

export const useVentanaConfigAgente = () => {
  // Estado de la ventana
  const [ventana, setVentana] = useState({
    abierta: false,
    minimizada: false,
    maximizada: false,
    posicion: { x: 100, y: 50 },
    zIndex: Z_INDEX_BASE,
    workspaceId: null,
  });

  // Contador para z-index (para traer al frente)
  const zIndexCounterRef = useRef(Z_INDEX_BASE);

  /**
   * Obtiene el siguiente z-index y lo incrementa
   */
  const getNextZIndex = useCallback(() => {
    zIndexCounterRef.current += 1;
    return zIndexCounterRef.current;
  }, []);

  /**
   * Abre la ventana de configuraci√≥n de agentes
   */
  const abrirVentana = useCallback((workspaceId) => {
    setVentana((prev) => ({
      ...prev,
      abierta: true,
      minimizada: false,
      workspaceId,
      zIndex: getNextZIndex(),
    }));
  }, [getNextZIndex]);

  /**
   * Cierra la ventana
   */
  const cerrarVentana = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      abierta: false,
      minimizada: false,
      maximizada: false,
    }));
  }, []);

  /**
   * Minimiza/restaura la ventana
   */
  const toggleMinimizar = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      minimizada: !prev.minimizada,
    }));
  }, []);

  /**
   * Maximiza/restaura la ventana
   */
  const toggleMaximizar = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      maximizada: !prev.maximizada,
      zIndex: getNextZIndex(),
    }));
  }, [getNextZIndex]);

  /**
   * Trae la ventana al frente (actualiza z-index)
   */
  const enfocarVentana = useCallback(() => {
    setVentana((prev) => ({
      ...prev,
      minimizada: false,
      zIndex: getNextZIndex(),
    }));
  }, [getNextZIndex]);

  /**
   * Actualiza la posici√≥n de la ventana (al arrastrar)
   */
  const moverVentana = useCallback((nuevaPosicion) => {
    setVentana((prev) => ({
      ...prev,
      posicion: nuevaPosicion,
    }));
  }, []);

  return {
    ventana,
    abrirVentana,
    cerrarVentana,
    toggleMinimizar,
    toggleMaximizar,
    enfocarVentana,
    moverVentana,
  };
};

export default useVentanaConfigAgente;

// ===== ./src/paginas/PaginaAlimentadores/hooks/grilla-unifilar/algoritmos.js =====

/**
 * Algoritmos para manipulaci√≥n de celdas en la grilla
 */

/**
 * Obtiene todas las celdas conectadas a una celda dada (BFS)
 * @param {number} x - Coordenada X de la celda inicial
 * @param {number} y - Coordenada Y de la celda inicial
 * @param {Object} celdasActuales - Objeto de celdas actual
 * @returns {Array<string>} Array de claves de celdas conectadas
 */
export const obtenerCeldasConectadas = (x, y, celdasActuales) => {
   const claveCelda = `${x},${y}`;
   const colorOriginal = celdasActuales[claveCelda];

   if (!colorOriginal) return [];

   const visitadas = new Set();
   const cola = [[x, y]];
   const celdasConectadas = [];

   while (cola.length > 0) {
      const [cx, cy] = cola.shift();
      const claveActual = `${cx},${cy}`;

      if (visitadas.has(claveActual)) continue;
      visitadas.add(claveActual);

      if (celdasActuales[claveActual] !== colorOriginal) continue;

      celdasConectadas.push(claveActual);

      // Agregar vecinos (arriba, abajo, izquierda, derecha)
      cola.push([cx, cy - 1]);
      cola.push([cx, cy + 1]);
      cola.push([cx - 1, cy]);
      cola.push([cx + 1, cy]);
   }

   return celdasConectadas;
};

/**
 * Calcula las nuevas celdas despu√©s de mover un grupo de celdas conectadas
 * @param {Object} celdasActuales - Objeto de celdas actual
 * @param {Array<string>} celdasAMover - Array de claves a mover
 * @param {number} deltaX - Desplazamiento en X
 * @param {number} deltaY - Desplazamiento en Y
 * @returns {Object} Nuevo objeto de celdas
 */
export const calcularCeldasMovidas = (celdasActuales, celdasAMover, deltaX, deltaY) => {
   if (deltaX === 0 && deltaY === 0) return celdasActuales;
   if (celdasAMover.length === 0) return celdasActuales;

   const nuevasCeldas = { ...celdasActuales };

   // Remover todas las celdas que vamos a mover
   const coloresOriginales = {};
   celdasAMover.forEach((clave) => {
      coloresOriginales[clave] = celdasActuales[clave];
      delete nuevasCeldas[clave];
   });

   // Agregar las celdas en sus nuevas posiciones
   celdasAMover.forEach((clave) => {
      const [x, y] = clave.split(",").map(Number);
      const nuevaClave = `${x + deltaX},${y + deltaY}`;
      nuevasCeldas[nuevaClave] = coloresOriginales[clave];
   });

   return nuevasCeldas;
};

/**
 * Calcula las celdas a rellenar con flood fill (BFS)
 * @param {Object} celdasActuales - Objeto de celdas actual
 * @param {number} x - Coordenada X inicial
 * @param {number} y - Coordenada Y inicial
 * @param {string} nuevoColor - Color a aplicar
 * @returns {Object|null} Nuevo objeto de celdas o null si no hay cambios
 */
export const calcularFloodFill = (celdasActuales, x, y, nuevoColor) => {
   const claveCelda = `${x},${y}`;
   const colorOriginal = celdasActuales[claveCelda];

   if (!colorOriginal) return null;
   if (colorOriginal === nuevoColor) return null;

   const visitadas = new Set();
   const cola = [[x, y]];
   const celdasARellenar = [];

   while (cola.length > 0) {
      const [cx, cy] = cola.shift();
      const claveActual = `${cx},${cy}`;

      if (visitadas.has(claveActual)) continue;
      visitadas.add(claveActual);

      if (celdasActuales[claveActual] !== colorOriginal) continue;

      celdasARellenar.push(claveActual);

      cola.push([cx, cy - 1]);
      cola.push([cx, cy + 1]);
      cola.push([cx - 1, cy]);
      cola.push([cx + 1, cy]);
   }

   const nuevasCeldas = { ...celdasActuales };
   celdasARellenar.forEach((clave) => {
      nuevasCeldas[clave] = nuevoColor;
   });

   return nuevasCeldas;
};

/**
 * Calcula las celdas despu√©s de borrar un √°rea rectangular
 * @param {Object} celdasActuales - Objeto de celdas actual
 * @param {number} x1 - Coordenada X esquina 1
 * @param {number} y1 - Coordenada Y esquina 1
 * @param {number} x2 - Coordenada X esquina 2
 * @param {number} y2 - Coordenada Y esquina 2
 * @returns {{celdas: Object, huboCambios: boolean}}
 */
export const calcularBorradoArea = (celdasActuales, x1, y1, x2, y2) => {
   const minX = Math.min(x1, x2);
   const maxX = Math.max(x1, x2);
   const minY = Math.min(y1, y2);
   const maxY = Math.max(y1, y2);

   const nuevasCeldas = { ...celdasActuales };
   let huboCambios = false;

   for (let x = minX; x <= maxX; x++) {
      for (let y = minY; y <= maxY; y++) {
         const clave = `${x},${y}`;
         if (nuevasCeldas[clave]) {
            delete nuevasCeldas[clave];
            huboCambios = true;
         }
      }
   }

   return { celdas: nuevasCeldas, huboCambios };
};

/**
 * Calcula la posici√≥n restringida para l√≠nea recta con Shift
 * @param {number} x - Coordenada X actual
 * @param {number} y - Coordenada Y actual
 * @param {{x: number, y: number}|null} puntoInicial - Punto inicial
 * @param {string|null} direccionBloqueada - Direcci√≥n bloqueada
 * @returns {{x: number, y: number, direccion: string|null}}
 */
export const calcularPosicionLineaRecta = (x, y, puntoInicial, direccionBloqueada) => {
   if (!puntoInicial) {
      return { x, y, direccion: direccionBloqueada };
   }

   const { x: xInicial, y: yInicial } = puntoInicial;
   const deltaX = Math.abs(x - xInicial);
   const deltaY = Math.abs(y - yInicial);

   let nuevaDireccion = direccionBloqueada;

   // Determinar direcci√≥n si no est√° bloqueada
   if (nuevaDireccion === null && (deltaX > 1 || deltaY > 1)) {
      nuevaDireccion = deltaX > deltaY ? "horizontal" : "vertical";
   }

   // Aplicar restricci√≥n seg√∫n direcci√≥n
   let xFinal = x;
   let yFinal = y;

   if (nuevaDireccion === "horizontal") {
      yFinal = yInicial;
   } else if (nuevaDireccion === "vertical") {
      xFinal = xInicial;
   }

   return { x: xFinal, y: yFinal, direccion: nuevaDireccion };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/grilla-unifilar/constantes.js =====

/**
 * Constantes para el sistema de grilla unifiliar
 */

/** Clave base para localStorage */
export const CLAVE_BASE = "rw-grilla-unifilar";

/** Colores predefinidos para dibujar el diagrama unifiliar */
export const COLORES_UNIFILAR = [
   { id: "rojo", color: "#dc2626", nombre: "Rojo" },
   { id: "azul", color: "#2563eb", nombre: "Azul" },
   { id: "verde", color: "#16a34a", nombre: "Verde" },
   { id: "amarillo", color: "#ca8a04", nombre: "Amarillo" },
   { id: "naranja", color: "#ea580c", nombre: "Naranja" },
   { id: "rosa", color: "#db2777", nombre: "Rosa" },
   { id: "violeta", color: "#7c3aed", nombre: "Violeta" },
   { id: "celeste", color: "#0891b2", nombre: "Celeste" },
   { id: "blanco", color: "#ffffff", nombre: "Blanco" },
   { id: "negro", color: "#000000", nombre: "Negro" },
];

/** Fuentes disponibles para texto */
export const FUENTES_DISPONIBLES = [
   { id: "arial", nombre: "Arial", familia: "Arial, sans-serif" },
   { id: "helvetica", nombre: "Helvetica", familia: "Helvetica, Arial, sans-serif" },
   { id: "times", nombre: "Times New Roman", familia: "Times New Roman, serif" },
   { id: "courier", nombre: "Courier", familia: "Courier New, monospace" },
   { id: "georgia", nombre: "Georgia", familia: "Georgia, serif" },
   { id: "verdana", nombre: "Verdana", familia: "Verdana, sans-serif" },
];

/** Tama√±os de fuente disponibles */
export const TAMANOS_FUENTE = [10, 12, 14, 16, 18, 20, 24, 28, 32, 36, 42, 48];

/** Grosores de l√≠nea disponibles (en p√≠xeles) */
export const GROSORES_LINEA = [
   { id: "fino", valor: 8, nombre: "Fino" },
   { id: "normal", valor: 12, nombre: "Normal" },
   { id: "medio", valor: 16, nombre: "Medio" },
   { id: "grueso", valor: 20, nombre: "Grueso" },
   { id: "extra", valor: 28, nombre: "Extra" },
];

/** Tipos de bornes para el sistema de chispas */
export const TIPOS_BORNE = {
   EMISOR: "EMISOR",
   RECEPTOR: "RECEPTOR",
};

/** Configuraci√≥n por defecto de chispas */
export const CONFIG_CHISPAS_DEFAULT = {
   velocidad: 8, // celdas por segundo
   tamano: 4, // radio en p√≠xeles
   color: "#fef08a", // amarillo brillante
   estela: true, // mostrar estela
   longitudEstela: 5, // cantidad de posiciones en la estela
   frecuenciaEmision: 2000, // ms entre emisiones
};

/** Estado inicial del hook */
export const ESTADO_INICIAL = {
   celdas: {},
   textos: [],
   grosorLinea: GROSORES_LINEA[1].valor,
   bornes: [],
   chispasConfig: CONFIG_CHISPAS_DEFAULT,
};

/** Estado inicial de configuraci√≥n de texto */
export const CONFIG_TEXTO_INICIAL = {
   fuente: FUENTES_DISPONIBLES[0].familia,
   tamano: 16,
   negrita: false,
   cursiva: false,
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/grilla-unifilar/index.js =====

// hooks/grilla-unifilar/index.js
// Exportaciones centralizadas

export * from "./constantes";
export * from "./algoritmos";
export * from "./persistencia";
export { default as useGrillaUnifilar } from "./useGrillaUnifilar";

// ===== ./src/paginas/PaginaAlimentadores/hooks/grilla-unifilar/persistencia.js =====

/**
 * Funciones de persistencia para la grilla unifiliar
 */

import { CLAVE_BASE, ESTADO_INICIAL, GROSORES_LINEA } from "./constantes";

/**
 * Genera la clave √∫nica de localStorage
 * @param {string} puestoId
 * @param {string} workspaceId
 * @returns {string|null}
 */
export const generarClave = (puestoId, workspaceId) => {
   if (!puestoId || !workspaceId) return null;
   return `${CLAVE_BASE}-${workspaceId}-${puestoId}`;
};

/**
 * Carga los datos de localStorage
 * @param {string} clave - Clave de localStorage
 * @returns {Object} Estado cargado
 */
export const cargarDatos = (clave) => {
   if (!clave) return ESTADO_INICIAL;

   try {
      const datos = localStorage.getItem(clave);
      if (!datos) return ESTADO_INICIAL;

      const parsed = JSON.parse(datos);

      // Compatibilidad: formato antiguo (solo celdas)
      if (parsed && typeof parsed === "object" && !parsed.celdas) {
         return {
            ...ESTADO_INICIAL,
            celdas: parsed,
         };
      }

      // Formato nuevo
      return {
         celdas: parsed.celdas || {},
         textos: parsed.textos || [],
         grosorLinea: parsed.grosor || GROSORES_LINEA[1].valor,
         bornes: parsed.bornes || [],
         chispasConfig: parsed.chispasConfig || ESTADO_INICIAL.chispasConfig,
      };
   } catch (error) {
      console.error("Error al cargar grilla unifiliar:", error);
      return ESTADO_INICIAL;
   }
};

/**
 * Guarda los datos en localStorage
 * @param {string} clave - Clave de localStorage
 * @param {Object} datos - Datos a guardar
 */
export const guardarDatosEnStorage = (clave, { celdas, textos, grosorLinea, bornes, chispasConfig }) => {
   if (!clave) return;

   try {
      const sinCeldas = Object.keys(celdas).length === 0;
      const sinTextos = textos.length === 0;
      const sinBornes = bornes.length === 0;

      if (sinCeldas && sinTextos && sinBornes) {
         localStorage.removeItem(clave);
      } else {
         localStorage.setItem(
            clave,
            JSON.stringify({
               celdas,
               textos,
               grosor: grosorLinea,
               bornes,
               chispasConfig,
            })
         );
      }
   } catch (error) {
      console.error("Error al guardar grilla unifiliar:", error);
   }
};

/**
 * Exporta el dibujo a un archivo JSON
 * @param {Object} datos - Datos a exportar
 * @param {string} puestoId - ID del puesto
 */
export const exportarAArchivo = ({ celdas, textos, grosorLinea }, puestoId) => {
   const datos = {
      version: 1,
      celdas,
      textos,
      grosor: grosorLinea,
      exportadoEn: new Date().toISOString(),
   };

   const blob = new Blob([JSON.stringify(datos, null, 2)], { type: "application/json" });
   const url = URL.createObjectURL(blob);
   const link = document.createElement("a");
   link.href = url;
   link.download = `diagrama-unifiliar-${puestoId || "sin-puesto"}.json`;
   document.body.appendChild(link);
   link.click();
   document.body.removeChild(link);
   URL.revokeObjectURL(url);
};

/**
 * Importa un dibujo desde un archivo JSON
 * @param {File} archivo - Archivo a importar
 * @returns {Promise<{exito: boolean, datos: Object|null}>}
 */
export const importarDesdeArchivo = (archivo) => {
   return new Promise((resolve) => {
      const reader = new FileReader();

      reader.onload = (e) => {
         try {
            const datos = JSON.parse(e.target.result);

            if (!datos || typeof datos !== "object") {
               console.error("Archivo inv√°lido: no es un objeto JSON");
               resolve({ exito: false, datos: null });
               return;
            }

            // Extraer datos (compatible con formato antiguo y nuevo)
            const celdas = datos.celdas || (datos.version ? {} : datos);
            const textos = datos.textos || [];
            const grosorLinea = datos.grosor || GROSORES_LINEA[1].valor;

            if (typeof celdas !== "object" || Array.isArray(celdas)) {
               console.error("Archivo inv√°lido: celdas no es un objeto");
               resolve({ exito: false, datos: null });
               return;
            }

            resolve({
               exito: true,
               datos: { celdas, textos, grosorLinea },
            });
         } catch (error) {
            console.error("Error al parsear archivo JSON:", error);
            resolve({ exito: false, datos: null });
         }
      };

      reader.onerror = () => {
         console.error("Error al leer archivo");
         resolve({ exito: false, datos: null });
      };

      reader.readAsText(archivo);
   });
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/grilla-unifilar/useGrillaUnifilar.js =====

// src/paginas/PaginaAlimentadores/hooks/usarGrillaUnifilar.js

import { useState, useCallback, useEffect, useRef } from "react";
import {
   // Constantes
   COLORES_UNIFILAR,
   FUENTES_DISPONIBLES,
   TAMANOS_FUENTE,
   GROSORES_LINEA,
   TIPOS_BORNE,
   CONFIG_CHISPAS_DEFAULT,
   CONFIG_TEXTO_INICIAL,
   // Algoritmos
   obtenerCeldasConectadas as obtenerConectadas,
   calcularCeldasMovidas,
   calcularFloodFill,
   calcularBorradoArea,
   calcularPosicionLineaRecta,
   // Persistencia
   generarClave,
   cargarDatos,
   guardarDatosEnStorage,
   exportarAArchivo as exportarArchivo,
   importarDesdeArchivo as importarArchivo,
} from ".";

// Re-exportar constantes para uso externo
export { COLORES_UNIFILAR, FUENTES_DISPONIBLES, TAMANOS_FUENTE, GROSORES_LINEA, TIPOS_BORNE, CONFIG_CHISPAS_DEFAULT };

/**
 * Hook para manejar la grilla de dibujo unifiliar
 * @param {string} puestoId - ID del puesto actual
 * @param {string} workspaceId - ID del workspace actual
 */
const useGrillaUnifilar = (puestoId, workspaceId) => {
   // Estado del dibujo
   const [celdas, setCeldas] = useState({});
   const [textos, setTextos] = useState([]);
   const [modoEdicion, setModoEdicion] = useState(false);
   const [colorSeleccionado, setColorSeleccionado] = useState(COLORES_UNIFILAR[0].color);
   const [herramienta, setHerramienta] = useState("pincel");
   const [grosorLinea, setGrosorLinea] = useState(GROSORES_LINEA[1].valor);
   const [estaPintando, setEstaPintando] = useState(false);

   // Referencias para l√≠neas rectas con Shift
   const puntoInicialRef = useRef(null);
   const direccionBloqueadaRef = useRef(null);

   // Configuraci√≥n de texto
   const [configTexto, setConfigTexto] = useState(CONFIG_TEXTO_INICIAL);
   const [textoSeleccionadoId, setTextoSeleccionadoId] = useState(null);

   // Sistema de bornes y chispas
   const [bornes, setBornes] = useState([]);
   const [chispasConfig, setChispasConfig] = useState(CONFIG_CHISPAS_DEFAULT);

   // Clave de localStorage
   const clave = generarClave(puestoId, workspaceId);

   // Cargar datos al montar o cambiar de puesto
   useEffect(() => {
      const datos = cargarDatos(clave);
      setCeldas(datos.celdas);
      setTextos(datos.textos);
      setGrosorLinea(datos.grosorLinea);
      setBornes(datos.bornes);
      setChispasConfig(datos.chispasConfig);
   }, [clave]);

   // Funci√≥n de guardado
   const guardar = useCallback(
      (nuevasCeldas, nuevosTextos, nuevoGrosor = null, nuevosBornes = null, nuevaChispasConfig = null) => {
         guardarDatosEnStorage(clave, {
            celdas: nuevasCeldas,
            textos: nuevosTextos,
            grosorLinea: nuevoGrosor ?? grosorLinea,
            bornes: nuevosBornes ?? bornes,
            chispasConfig: nuevaChispasConfig ?? chispasConfig,
         });
      },
      [clave, grosorLinea, bornes, chispasConfig]
   );

   // ============================================================================
   // Acciones de pintado
   // ============================================================================

   const pintarCelda = useCallback(
      (x, y, shiftPresionado = false) => {
         const pos = shiftPresionado
            ? calcularPosicionLineaRecta(x, y, puntoInicialRef.current, direccionBloqueadaRef.current)
            : { x, y, direccion: null };

         if (shiftPresionado) {
            direccionBloqueadaRef.current = pos.direccion;
         }

         const claveCelda = `${pos.x},${pos.y}`;

         setCeldas((prev) => {
            let nuevasCeldas;
            if (herramienta === "borrador") {
               nuevasCeldas = { ...prev };
               delete nuevasCeldas[claveCelda];
            } else {
               nuevasCeldas = { ...prev, [claveCelda]: colorSeleccionado };
            }

            setTextos((currentTextos) => {
               guardar(nuevasCeldas, currentTextos);
               return currentTextos;
            });
            return nuevasCeldas;
         });
      },
      [colorSeleccionado, herramienta, guardar]
   );

   const limpiarTodo = useCallback(() => {
      setCeldas({});
      setTextos([]);
      guardar({}, []);
   }, [guardar]);

   const iniciarPintado = useCallback((x, y) => {
      setEstaPintando(true);
      puntoInicialRef.current = { x, y };
      direccionBloqueadaRef.current = null;
   }, []);

   const detenerPintado = useCallback(() => {
      setEstaPintando(false);
      puntoInicialRef.current = null;
      direccionBloqueadaRef.current = null;
   }, []);

   const rellenarConectadas = useCallback(
      (x, y) => {
         setCeldas((prev) => {
            const nuevasCeldas = calcularFloodFill(prev, x, y, colorSeleccionado);
            if (!nuevasCeldas) return prev;

            setTextos((currentTextos) => {
               guardar(nuevasCeldas, currentTextos);
               return currentTextos;
            });
            return nuevasCeldas;
         });
      },
      [colorSeleccionado, guardar]
   );

   const borrarArea = useCallback(
      (x1, y1, x2, y2) => {
         setCeldas((prev) => {
            const { celdas: nuevasCeldas, huboCambios } = calcularBorradoArea(prev, x1, y1, x2, y2);
            if (!huboCambios) return prev;

            setTextos((currentTextos) => {
               guardar(nuevasCeldas, currentTextos);
               return currentTextos;
            });
            return nuevasCeldas;
         });
      },
      [guardar]
   );

   // ============================================================================
   // Funciones para mover l√≠neas conectadas
   // ============================================================================

   const obtenerCeldasConectadas = useCallback((x, y) => obtenerConectadas(x, y, celdas), [celdas]);

   const moverCeldasConectadas = useCallback(
      (celdasAMover, deltaX, deltaY) => {
         if (deltaX === 0 && deltaY === 0 || celdasAMover.length === 0) return;

         setCeldas((prev) => {
            const nuevasCeldas = calcularCeldasMovidas(prev, celdasAMover, deltaX, deltaY);

            setTextos((currentTextos) => {
               guardar(nuevasCeldas, currentTextos);
               return currentTextos;
            });
            return nuevasCeldas;
         });
      },
      [guardar]
   );

   // ============================================================================
   // Acciones de texto
   // ============================================================================

   const agregarTexto = useCallback(
      (x, y, contenido) => {
         if (!contenido.trim()) return;

         const nuevoTexto = {
            id: `texto-${Date.now()}`,
            x,
            y,
            texto: contenido,
            color: colorSeleccionado,
            fuente: configTexto.fuente,
            tamano: configTexto.tamano,
            negrita: configTexto.negrita,
            cursiva: configTexto.cursiva,
         };

         setTextos((prev) => {
            const nuevosTextos = [...prev, nuevoTexto];
            setCeldas((currentCeldas) => {
               guardar(currentCeldas, nuevosTextos);
               return currentCeldas;
            });
            return nuevosTextos;
         });
      },
      [colorSeleccionado, configTexto, guardar]
   );

   const actualizarTexto = useCallback(
      (id, cambios) => {
         setTextos((prev) => {
            const nuevosTextos = prev.map((t) => (t.id === id ? { ...t, ...cambios } : t));
            setCeldas((currentCeldas) => {
               guardar(currentCeldas, nuevosTextos);
               return currentCeldas;
            });
            return nuevosTextos;
         });
      },
      [guardar]
   );

   const eliminarTexto = useCallback(
      (id) => {
         setTextos((prev) => {
            const nuevosTextos = prev.filter((t) => t.id !== id);
            setCeldas((currentCeldas) => {
               guardar(currentCeldas, nuevosTextos);
               return currentCeldas;
            });
            return nuevosTextos;
         });
         setTextoSeleccionadoId(null);
      },
      [guardar]
   );

   // ============================================================================
   // Selecci√≥n de herramientas
   // ============================================================================

   const activarEdicion = useCallback(() => setModoEdicion(true), []);
   const desactivarEdicion = useCallback(() => {
      setModoEdicion(false);
      setEstaPintando(false);
   }, []);
   const toggleEdicion = useCallback(
      () => (modoEdicion ? desactivarEdicion() : activarEdicion()),
      [modoEdicion, activarEdicion, desactivarEdicion]
   );

   const seleccionarPincel = useCallback(() => setHerramienta("pincel"), []);
   const seleccionarBorrador = useCallback(() => {
      setHerramienta("borrador");
      setTextoSeleccionadoId(null);
   }, []);
   const seleccionarTexto = useCallback(() => setHerramienta("texto"), []);
   const seleccionarBalde = useCallback(() => {
      setHerramienta("balde");
      setTextoSeleccionadoId(null);
   }, []);
   const seleccionarMover = useCallback(() => {
      setHerramienta("mover");
      setTextoSeleccionadoId(null);
   }, []);
   const seleccionarBorne = useCallback(() => setHerramienta("borne"), []);

   const cambiarGrosor = useCallback(
      (nuevoGrosor) => {
         setGrosorLinea(nuevoGrosor);
         setCeldas((currentCeldas) => {
            setTextos((currentTextos) => {
               guardar(currentCeldas, currentTextos, nuevoGrosor);
               return currentTextos;
            });
            return currentCeldas;
         });
      },
      [guardar]
   );

   // ============================================================================
   // Sistema de bornes
   // ============================================================================

   const agregarBorne = useCallback(
      (x, y, tipo) => {
         const claveCelda = `${x},${y}`;
         if (!celdas[claveCelda]) {
            console.warn("Solo se pueden colocar bornes sobre l√≠neas pintadas");
            return false;
         }
         if (bornes.some((b) => b.x === x && b.y === y)) {
            console.warn("Ya existe un borne en esta posici√≥n");
            return false;
         }

         const contadorTipo = bornes.filter((b) => b.tipo === tipo).length + 1;
         const nuevoBorne = {
            id: `borne-${Date.now()}`,
            tipo,
            x,
            y,
            color: tipo === TIPOS_BORNE.EMISOR ? "#22d3ee" : "#f97316",
            activo: true,
            frecuenciaMs: chispasConfig.frecuenciaEmision,
            nombre: `${tipo === TIPOS_BORNE.EMISOR ? "E" : "R"}${contadorTipo}`,
         };

         const nuevosBornes = [...bornes, nuevoBorne];
         setBornes(nuevosBornes);

         setCeldas((currentCeldas) => {
            setTextos((currentTextos) => {
               guardar(currentCeldas, currentTextos, grosorLinea, nuevosBornes);
               return currentTextos;
            });
            return currentCeldas;
         });

         return true;
      },
      [celdas, bornes, chispasConfig.frecuenciaEmision, grosorLinea, guardar]
   );

   const eliminarBorne = useCallback(
      (borneId) => {
         const nuevosBornes = bornes.filter((b) => b.id !== borneId);
         setBornes(nuevosBornes);

         setCeldas((currentCeldas) => {
            setTextos((currentTextos) => {
               guardar(currentCeldas, currentTextos, grosorLinea, nuevosBornes);
               return currentTextos;
            });
            return currentCeldas;
         });
      },
      [bornes, grosorLinea, guardar]
   );

   const eliminarBorneEnPosicion = useCallback(
      (x, y) => {
         const borneEnPosicion = bornes.find((b) => b.x === x && b.y === y);
         if (borneEnPosicion) {
            eliminarBorne(borneEnPosicion.id);
            return true;
         }
         return false;
      },
      [bornes, eliminarBorne]
   );

   const actualizarBorne = useCallback(
      (borneId, cambios) => {
         const nuevosBornes = bornes.map((b) => (b.id === borneId ? { ...b, ...cambios } : b));
         setBornes(nuevosBornes);

         setCeldas((currentCeldas) => {
            setTextos((currentTextos) => {
               guardar(currentCeldas, currentTextos, grosorLinea, nuevosBornes);
               return currentTextos;
            });
            return currentCeldas;
         });
      },
      [bornes, grosorLinea, guardar]
   );

   const obtenerBorneEnPosicion = useCallback((x, y) => bornes.find((b) => b.x === x && b.y === y) || null, [bornes]);

   const actualizarChispasConfig = useCallback(
      (nuevaConfig) => {
         const configActualizada = { ...chispasConfig, ...nuevaConfig };
         setChispasConfig(configActualizada);

         setCeldas((currentCeldas) => {
            setTextos((currentTextos) => {
               guardar(currentCeldas, currentTextos, grosorLinea, bornes, configActualizada);
               return currentTextos;
            });
            return currentCeldas;
         });
      },
      [chispasConfig, grosorLinea, bornes, guardar]
   );

   // ============================================================================
   // Importar/Exportar
   // ============================================================================

   const exportarAArchivo = useCallback(() => {
      exportarArchivo({ celdas, textos, grosorLinea }, puestoId);
   }, [celdas, textos, grosorLinea, puestoId]);

   const importarDesdeArchivo = useCallback(
      async (archivo) => {
         const { exito, datos } = await importarArchivo(archivo);
         if (exito && datos) {
            setCeldas(datos.celdas);
            setTextos(datos.textos);
            setGrosorLinea(datos.grosorLinea);
            guardar(datos.celdas, datos.textos, datos.grosorLinea);
         }
         return exito;
      },
      [guardar]
   );

   // ============================================================================
   // Return
   // ============================================================================

   const tieneDibujo = Object.keys(celdas).length > 0 || textos.length > 0;

   return {
      // Estado
      celdas,
      textos,
      modoEdicion,
      colorSeleccionado,
      herramienta,
      estaPintando,
      tieneDibujo,
      grosorLinea,

      // Configuraci√≥n de texto
      configTexto,
      setConfigTexto,
      textoSeleccionadoId,
      setTextoSeleccionadoId,

      // Colores, fuentes y grosores disponibles
      coloresDisponibles: COLORES_UNIFILAR,
      fuentesDisponibles: FUENTES_DISPONIBLES,
      tamanosDisponibles: TAMANOS_FUENTE,
      grosoresDisponibles: GROSORES_LINEA,

      // Acciones de edici√≥n
      toggleEdicion,
      activarEdicion,
      desactivarEdicion,

      // Acciones de pintado
      pintarCelda,
      limpiarTodo,
      iniciarPintado,
      detenerPintado,
      rellenarConectadas,
      borrarArea,

      // Acciones de texto
      agregarTexto,
      actualizarTexto,
      eliminarTexto,

      // Selecci√≥n de herramientas
      setColorSeleccionado,
      seleccionarPincel,
      seleccionarBorrador,
      seleccionarTexto,
      seleccionarBalde,
      seleccionarMover,

      // Funciones para mover l√≠neas conectadas
      obtenerCeldasConectadas,
      moverCeldasConectadas,

      // Grosor de l√≠nea
      cambiarGrosor,

      // Importar/Exportar archivo
      exportarAArchivo,
      importarDesdeArchivo,

      // Sistema de bornes y chispas
      bornes,
      chispasConfig,
      tiposBorne: TIPOS_BORNE,

      // Acciones de bornes
      seleccionarBorne,
      agregarBorne,
      eliminarBorne,
      eliminarBorneEnPosicion,
      actualizarBorne,
      obtenerBorneEnPosicion,

      // Configuraci√≥n de chispas
      actualizarChispasConfig,
   };
};

export default useGrillaUnifilar;

// ===== ./src/paginas/PaginaAlimentadores/hooks/historial/index.js =====

// hooks/historial/index.js
// Exportaciones centralizadas de la l√≥gica de historial

export * from "./logicaFuenteDatos";
export * from "./logicaPrecarga";
export { useHistorialLocal } from "./useHistorialLocal";
export { useVentanaHistorialLogica } from "./useVentanaHistorialLogica";

// ===== ./src/paginas/PaginaAlimentadores/hooks/historial/logicaFuenteDatos.js =====

/**
 * L√≥gica para determinar y obtener datos de diferentes fuentes
 * Separada del hook principal para mejor testabilidad y mantenibilidad
 */

import { obtenerLecturasRango, cachearLecturasRemotas } from "../../utilidades/indexedDBHelper";
import { obtenerLecturasHistoricasPorRegistrador } from "@/servicios/apiService";
import {
   HORAS_RETENCION_LOCAL,
   UMBRAL_COBERTURA_REMOTO,
   MARGEN_LIMITE_LOCAL_MS,
} from "../../constantes/historialConfig";

/**
 * Normaliza timestamps a milisegundos
 * @param {Array} datos - Datos con timestamps en cualquier formato
 * @returns {Array} Datos con timestamps normalizados
 */
export const normalizarTimestamps = (datos) =>
   datos.map((l) => ({
      ...l,
      timestamp: typeof l.timestamp === "string" ? new Date(l.timestamp).getTime() : l.timestamp,
      indiceInicial: l.indice_inicial ?? l.indiceInicial ?? 0,
   }));

/**
 * Combina y deduplica datos por timestamp
 * @param {Array} datosRemotos - Datos de fuente remota
 * @param {Array} datosLocales - Datos de fuente local
 * @returns {Array} Datos combinados y ordenados
 */
export const combinarYDeduplicar = (datosRemotos, datosLocales) => {
   const mapaTimestamps = new Map();

   for (const dato of datosRemotos) {
      mapaTimestamps.set(dato.timestamp, dato);
   }
   for (const dato of datosLocales) {
      mapaTimestamps.set(dato.timestamp, dato);
   }

   const datosCombinados = Array.from(mapaTimestamps.values());
   datosCombinados.sort((a, b) => a.timestamp - b.timestamp);
   return datosCombinados;
};

/**
 * Calcula el l√≠mite temporal para datos locales
 * @returns {number} Timestamp del l√≠mite local
 */
export const calcularLimiteLocal = () => {
   const ahora = Date.now();
   return ahora - HORAS_RETENCION_LOCAL * 60 * 60 * 1000 - MARGEN_LIMITE_LOCAL_MS;
};

/**
 * Verifica si un rango excede el per√≠odo de retenci√≥n local
 * @param {number} desde - Timestamp inicio
 * @param {number} hasta - Timestamp fin
 * @returns {boolean}
 */
export const rangoExcede48h = (desde, hasta) => {
   const rangoSolicitadoMs = hasta - desde;
   const rangoMaximoLocalMs = HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
   return rangoSolicitadoMs > rangoMaximoLocalMs;
};

/**
 * Calcula el porcentaje de cobertura de datos locales
 * @param {Array} datosLocales - Datos locales encontrados
 * @param {number} desde - Timestamp inicio solicitado
 * @param {number} hasta - Timestamp fin solicitado
 * @returns {number} Porcentaje de cobertura (0-1)
 */
export const calcularCobertura = (datosLocales, desde, hasta) => {
   if (datosLocales.length === 0) return 0;

   const primerTimestamp = Math.min(...datosLocales.map((d) => d.timestamp));
   const rangoSolicitadoMs = hasta - desde;
   const rangoCubiertoMs = hasta - primerTimestamp;
   return rangoCubiertoMs / rangoSolicitadoMs;
};

/**
 * Consulta datos remotos y los cachea en IndexedDB
 * @param {IDBDatabase} db - Referencia a IndexedDB
 * @param {string} alimentadorId
 * @param {string} registradorId
 * @param {string} zona
 * @param {number} desde
 * @param {number} hasta
 * @returns {Promise<Array>} Datos remotos normalizados
 */
export const consultarYCachearRemoto = async (db, alimentadorId, registradorId, zona, desde, hasta) => {
   const datosRemotos = await obtenerLecturasHistoricasPorRegistrador(
      registradorId,
      new Date(desde).toISOString(),
      new Date(hasta).toISOString()
   );

   if (!datosRemotos || datosRemotos.length === 0) {
      return [];
   }

   // Cachear los datos remotos
   if (db) {
      try {
         const guardadas = await cachearLecturasRemotas(db, alimentadorId, registradorId, zona, datosRemotos);
         console.log("[Historial] CACHEO COMPLETADO:", {
            alimentadorId,
            registradorId,
            zona,
            lecturasRecibidas: datosRemotos.length,
            lecturasGuardadas: guardadas,
            rangoGuardado:
               datosRemotos.length > 0
                  ? {
                       desde: new Date(
                          Math.min(
                             ...datosRemotos.map((d) =>
                                typeof d.timestamp === "string" ? new Date(d.timestamp).getTime() : d.timestamp
                             )
                          )
                       ).toISOString(),
                       hasta: new Date(
                          Math.max(
                             ...datosRemotos.map((d) =>
                                typeof d.timestamp === "string" ? new Date(d.timestamp).getTime() : d.timestamp
                             )
                          )
                       ).toISOString(),
                    }
                  : null,
         });
      } catch (err) {
         console.error("[Historial] Error en cacheo:", err);
      }
   }

   return normalizarTimestamps(datosRemotos);
};

/**
 * Obtiene datos locales de IndexedDB
 * @param {IDBDatabase} db
 * @param {string} alimentadorId
 * @param {string} registradorId
 * @param {string} zona
 * @param {number} desde
 * @param {number} hasta
 * @returns {Promise<Array>}
 */
export const obtenerDatosLocales = async (db, alimentadorId, registradorId, zona, desde, hasta) => {
   if (!db) return [];
   return obtenerLecturasRango(db, alimentadorId, registradorId, zona, desde, hasta);
};

/**
 * Determina la estrategia de obtenci√≥n de datos seg√∫n el rango
 * @param {number} desde
 * @param {number} hasta
 * @param {boolean} forzarSoloLocal
 * @returns {'soloLocal' | 'remoto' | 'hibrido'}
 */
export const determinarEstrategia = (desde, hasta, forzarSoloLocal) => {
   const limiteLocal = calcularLimiteLocal();
   const excede48h = rangoExcede48h(desde, hasta);

   // Modo precarga completa y rango dentro de 48h
   if (forzarSoloLocal && !excede48h) {
      return "soloLocal";
   }

   // Rango excede 48h
   if (excede48h) {
      return "remoto";
   }

   // Rango dentro del per√≠odo local
   if (desde >= limiteLocal) {
      return "hibrido";
   }

   // Rango mixto o fuera de per√≠odo local
   return "hibrido";
};

/**
 * Obtiene datos usando estrategia h√≠brida (local + remoto si necesario)
 * @param {Object} params
 * @returns {Promise<{datos: Array, fuente: string}>}
 */
export const obtenerDatosHibrido = async ({
   db,
   alimentadorId,
   registradorId,
   zona,
   desde,
   hasta,
}) => {
   const limiteLocal = calcularLimiteLocal();

   // Caso 1: Todo el rango est√° dentro del periodo local
   if (desde >= limiteLocal) {
      const datosLocales = await obtenerDatosLocales(db, alimentadorId, registradorId, zona, desde, hasta);

      console.log("[Historial] CONSULTA LOCAL:", {
         alimentadorId,
         registradorId,
         zona,
         rangoBuscado: {
            desde: new Date(desde).toISOString(),
            hasta: new Date(hasta).toISOString(),
            horasSolicitadas: (hasta - desde) / (1000 * 60 * 60),
         },
         datosEncontrados: datosLocales.length,
         rangoEncontrado:
            datosLocales.length > 0
               ? {
                    primero: new Date(Math.min(...datosLocales.map((d) => d.timestamp))).toISOString(),
                    ultimo: new Date(Math.max(...datosLocales.map((d) => d.timestamp))).toISOString(),
                 }
               : null,
      });

      // Verificar cobertura
      if (datosLocales.length > 0) {
         const porcentajeCubierto = calcularCobertura(datosLocales, desde, hasta);

         console.log("[Historial] COBERTURA:", {
            rangoSolicitadoHoras: (hasta - desde) / (1000 * 60 * 60),
            porcentaje: (porcentajeCubierto * 100).toFixed(1) + "%",
            decision: porcentajeCubierto < UMBRAL_COBERTURA_REMOTO ? "IR A REMOTO" : "USAR LOCAL",
         });

         // Si cobertura insuficiente, complementar con remoto
         if (porcentajeCubierto < UMBRAL_COBERTURA_REMOTO) {
            const datosRemotos = await consultarYCachearRemoto(
               db,
               alimentadorId,
               registradorId,
               zona,
               desde,
               hasta
            );
            const datosCombinados = combinarYDeduplicar(datosRemotos, datosLocales);
            return { datos: datosCombinados, fuente: "mixto" };
         }

         return { datos: datosLocales, fuente: "local" };
      }

      // Sin datos locales, ir a remoto
      const datosRemotos = await consultarYCachearRemoto(db, alimentadorId, registradorId, zona, desde, hasta);
      return { datos: datosRemotos, fuente: "remoto" };
   }

   // Caso 2: Todo el rango est√° fuera del periodo local
   if (hasta < limiteLocal) {
      const datosLocales = await obtenerDatosLocales(db, alimentadorId, registradorId, zona, desde, hasta);

      if (datosLocales.length > 0) {
         return { datos: datosLocales, fuente: "local" };
      }

      const datosRemotos = await consultarYCachearRemoto(db, alimentadorId, registradorId, zona, desde, hasta);
      return { datos: datosRemotos, fuente: "remoto" };
   }

   // Caso 3: Rango mixto
   const datosLocalesCompletos = await obtenerDatosLocales(db, alimentadorId, registradorId, zona, desde, hasta);

   if (datosLocalesCompletos.length > 0) {
      const primerTimestamp = Math.min(...datosLocalesCompletos.map((d) => d.timestamp));
      // Si el primer dato est√° cerca del inicio, asumir completo
      if (primerTimestamp <= desde + 5 * 60 * 1000) {
         return { datos: datosLocalesCompletos, fuente: "local" };
      }
   }

   // Combinar remoto (parte antigua) + local (parte reciente)
   const datosRemotosAntiguos = await consultarYCachearRemoto(
      db,
      alimentadorId,
      registradorId,
      zona,
      desde,
      limiteLocal
   );

   let datosLocalesRecientes = await obtenerDatosLocales(
      db,
      alimentadorId,
      registradorId,
      zona,
      limiteLocal,
      hasta
   );

   if (datosLocalesRecientes.length === 0) {
      datosLocalesRecientes = await consultarYCachearRemoto(
         db,
         alimentadorId,
         registradorId,
         zona,
         limiteLocal,
         hasta
      );
   }

   const datosCombinados = combinarYDeduplicar(datosRemotosAntiguos, datosLocalesRecientes);
   return { datos: datosCombinados, fuente: "mixto" };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/historial/logicaPrecarga.js =====

/**
 * L√≥gica de precarga de datos hist√≥ricos
 * Maneja la precarga de 48h y precarga por puesto
 */

import { obtenerLecturasRango, cachearLecturasRemotas } from "../../utilidades/indexedDBHelper";
import { obtenerLecturasHistoricasPorRegistrador } from "@/servicios/apiService";
import {
   HORAS_RETENCION_LOCAL,
   UMBRAL_COBERTURA_CACHE,
   MAX_ANTIGUEDAD_CACHE_MINUTOS,
} from "../../constantes/historialConfig";

/**
 * Verifica si ya hay datos suficientes y recientes en cache
 * @param {IDBDatabase} db
 * @param {string} alimentadorId
 * @param {string} registradorId
 * @param {string} zona
 * @returns {Promise<boolean>}
 */
export const verificarCacheExistente = async (db, alimentadorId, registradorId, zona) => {
   if (!db || !registradorId) return false;

   const ahora = Date.now();
   const desde = ahora - HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
   const hasta = ahora;

   try {
      const datosLocales = await obtenerLecturasRango(db, alimentadorId, registradorId, zona, desde, hasta);

      if (datosLocales.length === 0) return false;

      // Verificar cobertura temporal
      const primerTimestamp = Math.min(...datosLocales.map((d) => d.timestamp));
      const ultimoTimestamp = Math.max(...datosLocales.map((d) => d.timestamp));
      const rangoSolicitadoMs = hasta - desde;
      const rangoCubiertoMs = hasta - primerTimestamp;
      const porcentajeCubierto = rangoCubiertoMs / rangoSolicitadoMs;

      // Verificar antig√ºedad del √∫ltimo dato
      const antiguedadUltimoDatoMs = ahora - ultimoTimestamp;
      const maxAntiguedadMs = MAX_ANTIGUEDAD_CACHE_MINUTOS * 60 * 1000;
      const datosRecientes = antiguedadUltimoDatoMs <= maxAntiguedadMs;

      const coberturaOK = porcentajeCubierto >= UMBRAL_COBERTURA_CACHE;
      const cacheValido = coberturaOK && datosRecientes;

      console.log(`[Historial] Cache existente para ${zona}:`, {
         registradorId,
         datosEncontrados: datosLocales.length,
         porcentajeCubierto: (porcentajeCubierto * 100).toFixed(1) + "%",
         antiguedadUltimoDato: Math.round(antiguedadUltimoDatoMs / 60000) + " min",
         maxAntiguedadPermitida: MAX_ANTIGUEDAD_CACHE_MINUTOS + " min",
         datosRecientes,
         cacheValido,
      });

      return cacheValido;
   } catch (err) {
      console.error("[Historial] Error verificando cache:", err);
      return false;
   }
};

/**
 * Construye las tareas de consulta para precarga
 * Agrupa por registrador para evitar consultas duplicadas
 * @param {string} registradorIdSuperior
 * @param {string} registradorIdInferior
 * @param {boolean} cacheSuperiorOK
 * @param {boolean} cacheInferiorOK
 * @returns {Array<{registradorId: string, zonas: string[]}>}
 */
export const construirTareasConsulta = (
   registradorIdSuperior,
   registradorIdInferior,
   cacheSuperiorOK,
   cacheInferiorOK
) => {
   const tareasConsulta = [];
   const mismoRegistrador = registradorIdSuperior === registradorIdInferior;

   if (registradorIdSuperior && !cacheSuperiorOK) {
      tareasConsulta.push({ registradorId: registradorIdSuperior, zonas: ["superior"] });
   }

   if (registradorIdInferior && !cacheInferiorOK) {
      if (mismoRegistrador) {
         const consultaExistente = tareasConsulta.find((t) => t.registradorId === registradorIdInferior);
         if (consultaExistente) {
            consultaExistente.zonas.push("inferior");
         } else {
            tareasConsulta.push({ registradorId: registradorIdInferior, zonas: ["inferior"] });
         }
      } else {
         tareasConsulta.push({ registradorId: registradorIdInferior, zonas: ["inferior"] });
      }
   }

   return tareasConsulta;
};

/**
 * Ejecuta la precarga de 48h para un alimentador
 * @param {Object} params
 * @returns {Promise<{exito: boolean, datosDeBD: boolean}>}
 */
export const ejecutarPrecarga48h = async ({
   db,
   alimentadorId,
   registradorIdSuperior,
   registradorIdInferior,
   onProgreso,
   abortRef,
}) => {
   const ahora = Date.now();
   const desde = ahora - HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
   const hasta = ahora;
   let datosDeBD = false;

   // Verificar cache existente
   const cacheSuperiorOK = await verificarCacheExistente(db, alimentadorId, registradorIdSuperior, "superior");
   const cacheInferiorOK = await verificarCacheExistente(db, alimentadorId, registradorIdInferior, "inferior");

   if (cacheSuperiorOK && cacheInferiorOK) {
      console.log("[Historial] Cache ya v√°lido para ambas zonas, omitiendo precarga");
      onProgreso(100);
      return { exito: true, datosDeBD: false };
   }

   const tareasConsulta = construirTareasConsulta(
      registradorIdSuperior,
      registradorIdInferior,
      cacheSuperiorOK,
      cacheInferiorOK
   );

   if (tareasConsulta.length === 0) {
      console.log("[Historial] No hay registradores configurados para precargar");
      onProgreso(100);
      return { exito: true, datosDeBD: false };
   }

   const totalZonas = tareasConsulta.reduce((sum, t) => sum + t.zonas.length, 0);
   const progresoPorZona = 100 / totalZonas;
   let progresoActual = 0;

   try {
      for (const tarea of tareasConsulta) {
         if (abortRef.current) {
            console.log("[Historial] Precarga abortada");
            return { exito: false, datosDeBD };
         }

         console.log(
            `[Historial] Precargando registrador ${tarea.registradorId} para zonas: ${tarea.zonas.join(", ")}...`
         );

         onProgreso(Math.round(progresoActual + progresoPorZona * 0.1));

         const datosRemotos = await obtenerLecturasHistoricasPorRegistrador(
            tarea.registradorId,
            new Date(desde).toISOString(),
            new Date(hasta).toISOString()
         );

         if (abortRef.current) {
            return { exito: false, datosDeBD };
         }

         onProgreso(Math.round(progresoActual + progresoPorZona * tarea.zonas.length * 0.5));

         if (datosRemotos && datosRemotos.length > 0 && db) {
            datosDeBD = true;

            for (const zona of tarea.zonas) {
               const guardadas = await cachearLecturasRemotas(
                  db,
                  alimentadorId,
                  tarea.registradorId,
                  zona,
                  datosRemotos
               );

               console.log(`[Historial] Precarga ${zona} completada:`, {
                  registradorId: tarea.registradorId,
                  lecturasRecibidas: datosRemotos.length,
                  lecturasGuardadas: guardadas,
               });

               progresoActual += progresoPorZona;
               onProgreso(Math.round(progresoActual));
            }
         } else {
            console.log(`[Historial] No hay datos remotos para registrador ${tarea.registradorId}`);
            progresoActual += progresoPorZona * tarea.zonas.length;
            onProgreso(Math.round(progresoActual));
         }
      }

      onProgreso(100);
      console.log("[Historial] Precarga de 48h completada exitosamente");
      return { exito: true, datosDeBD };
   } catch (err) {
      console.error("[Historial] Error en precarga:", err);
      return { exito: false, datosDeBD };
   }
};

/**
 * Recopila tareas pendientes de precarga para un puesto
 * @param {IDBDatabase} db
 * @param {Array} alimentadores
 * @param {Object} abortRef
 * @returns {Promise<Array>}
 */
export const recopilarTareasPuesto = async (db, alimentadores, abortRef) => {
   const tareasPendientes = [];

   for (const alimentador of alimentadores) {
      if (abortRef.current) break;

      const cardDesign = alimentador.card_design || {};
      const regSuperior = cardDesign.superior?.registrador_id || alimentador.registrador_id;
      const regInferior = cardDesign.inferior?.registrador_id || alimentador.registrador_id;

      if (regSuperior) {
         const cacheSuperiorOK = await verificarCacheExistente(db, alimentador.id, regSuperior, "superior");
         if (!cacheSuperiorOK) {
            tareasPendientes.push({
               alimentadorId: alimentador.id,
               registradorId: regSuperior,
               zona: "superior",
            });
         }
      }

      if (regInferior && regInferior !== regSuperior) {
         const cacheInferiorOK = await verificarCacheExistente(db, alimentador.id, regInferior, "inferior");
         if (!cacheInferiorOK) {
            tareasPendientes.push({
               alimentadorId: alimentador.id,
               registradorId: regInferior,
               zona: "inferior",
            });
         }
      } else if (regInferior && regInferior === regSuperior) {
         const cacheInferiorOK = await verificarCacheExistente(db, alimentador.id, regInferior, "inferior");
         if (!cacheInferiorOK) {
            tareasPendientes.push({
               alimentadorId: alimentador.id,
               registradorId: regInferior,
               zona: "inferior",
            });
         }
      }
   }

   return tareasPendientes;
};

/**
 * Agrupa tareas por registrador para optimizar consultas
 * @param {Array} tareasPendientes
 * @returns {Object}
 */
export const agruparPorRegistrador = (tareasPendientes) => {
   const tareasPorRegistrador = {};

   for (const tarea of tareasPendientes) {
      if (!tareasPorRegistrador[tarea.registradorId]) {
         tareasPorRegistrador[tarea.registradorId] = [];
      }
      tareasPorRegistrador[tarea.registradorId].push(tarea);
   }

   return tareasPorRegistrador;
};

/**
 * Ejecuta la precarga de un puesto completo
 * @param {Object} params
 * @returns {Promise<{exito: boolean, datosDeBD: boolean}>}
 */
export const ejecutarPrecargaPuesto = async ({ db, alimentadores, onProgreso, abortRef }) => {
   if (!alimentadores || alimentadores.length === 0) {
      onProgreso(100);
      return { exito: true, datosDeBD: false };
   }

   const ahora = Date.now();
   const desde = ahora - HORAS_RETENCION_LOCAL * 60 * 60 * 1000;
   const hasta = ahora;
   let datosDeBD = false;

   const tareasPendientes = await recopilarTareasPuesto(db, alimentadores, abortRef);

   if (tareasPendientes.length === 0) {
      console.log("[Historial] Cache del puesto ya est√° actualizado");
      onProgreso(100);
      return { exito: true, datosDeBD: false };
   }

   console.log(`[Historial] Precargando puesto: ${tareasPendientes.length} tareas pendientes`);

   const tareasPorRegistrador = agruparPorRegistrador(tareasPendientes);
   const totalRegistradores = Object.keys(tareasPorRegistrador).length;
   let registradoresProcesados = 0;

   try {
      for (const [registradorId, tareas] of Object.entries(tareasPorRegistrador)) {
         if (abortRef.current) {
            console.log("[Historial] Precarga de puesto abortada");
            return { exito: false, datosDeBD };
         }

         const datosRemotos = await obtenerLecturasHistoricasPorRegistrador(
            registradorId,
            new Date(desde).toISOString(),
            new Date(hasta).toISOString()
         );

         if (datosRemotos && datosRemotos.length > 0 && db) {
            datosDeBD = true;

            for (const tarea of tareas) {
               await cachearLecturasRemotas(db, tarea.alimentadorId, tarea.registradorId, tarea.zona, datosRemotos);
            }
         }

         registradoresProcesados++;
         onProgreso(Math.round((registradoresProcesados / totalRegistradores) * 100));
      }

      onProgreso(100);
      console.log("[Historial] Precarga de puesto completada");
      return { exito: true, datosDeBD };
   } catch (err) {
      console.error("[Historial] Error en precarga de puesto:", err);
      return { exito: false, datosDeBD };
   }
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/historial/useHistorialLocal.js =====

/**
 * Hook para manejar el historial local de lecturas
 * Usa IndexedDB como cach√© inteligente que se auto-alimenta:
 * - Guarda lecturas del polling en tiempo real
 * - Cachea datos remotos cuando se consultan por primera vez
 * - Evita duplicados por timestamp
 */

import { useState, useCallback, useRef, useEffect } from "react";
import {
   abrirDB,
   guardarLectura,
   limpiarLecturasAntiguas,
   obtenerEstadisticas,
   limpiarTodo,
} from "../../utilidades/indexedDBHelper";
import { HORAS_RETENCION_LOCAL } from "../../constantes/historialConfig";
import {
   determinarEstrategia,
   obtenerDatosLocales,
   consultarYCachearRemoto,
   obtenerDatosHibrido,
   rangoExcede48h,
} from "./logicaFuenteDatos";
import { ejecutarPrecarga48h, ejecutarPrecargaPuesto } from "./logicaPrecarga";

export const useHistorialLocal = () => {
   const [cargando, setCargando] = useState(false);
   const [error, setError] = useState(null);
   const [estadisticas, setEstadisticas] = useState(null);
   const [dbLista, setDbLista] = useState(false);

   // Estado de precarga de 48h
   const [precargaProgreso, setPrecargaProgreso] = useState(0);
   const [precargaCompleta, setPrecargaCompleta] = useState(false);
   const [precargando, setPrecargando] = useState(false);
   const [datosDeBD, setDatosDeBD] = useState(false);
   const precargaAbortRef = useRef(false);

   const dbRef = useRef(null);

   // Inicializar IndexedDB
   useEffect(() => {
      const init = async () => {
         if (dbRef.current) {
            setDbLista(true);
            return;
         }

         try {
            dbRef.current = await abrirDB();

            const eliminados = await limpiarLecturasAntiguas(dbRef.current, HORAS_RETENCION_LOCAL);
            if (eliminados > 0) {
               console.log(`[Historial] Limpiados ${eliminados} registros antiguos`);
            }

            const stats = await obtenerEstadisticas(dbRef.current);
            setEstadisticas(stats);
            setDbLista(true);
         } catch (err) {
            console.error("[Historial] Error inicializando IndexedDB:", err);
         }
      };

      init();
   }, []);

   /**
    * Guarda una lectura en IndexedDB (llamado desde el polling)
    */
   const guardarLecturaLocal = useCallback(async (alimentadorId, registradorId, zona, lectura) => {
      if (!dbRef.current) return;

      try {
         await guardarLectura(dbRef.current, {
            alimentadorId,
            registradorId,
            zona,
            timestamp: lectura.timestamp || Date.now(),
            valores: lectura.valores,
            indiceInicial: lectura.indice_inicial ?? lectura.indiceInicial ?? 0,
            exito: lectura.exito !== false,
         });
      } catch {
         // No logueamos errores de guardado para no saturar la consola
      }
   }, []);

   /**
    * Obtiene datos para el gr√°fico (l√≥gica h√≠brida con cache inteligente)
    * @param {boolean} forzarSoloLocal - Si true, fuerza usar solo datos locales
    */
   const obtenerDatosGrafico = useCallback(
      async (alimentadorId, registradorId, zona, desde, hasta, forzarSoloLocal = false) => {
         setCargando(true);
         setError(null);

         try {
            const estrategia = determinarEstrategia(desde, hasta, forzarSoloLocal);
            const excede48h = rangoExcede48h(desde, hasta);

            // MODO SOLO LOCAL (precarga completa y rango <= 48h)
            if (estrategia === "soloLocal") {
               const datosLocales = await obtenerDatosLocales(
                  dbRef.current,
                  alimentadorId,
                  registradorId,
                  zona,
                  desde,
                  hasta
               );

               console.log("[Historial] MODO SOLO LOCAL (precarga completa):", {
                  alimentadorId,
                  registradorId,
                  zona,
                  datosEncontrados: datosLocales.length,
               });

               return { datos: datosLocales, fuente: "local" };
            }

            // MODO REMOTO DIRECTO (rango > 48h)
            if (estrategia === "remoto" || excede48h) {
               console.log("[Historial] Rango excede 48h, consultando remoto");

               const datosRemotos = await consultarYCachearRemoto(
                  dbRef.current,
                  alimentadorId,
                  registradorId,
                  zona,
                  desde,
                  hasta
               );
               return { datos: datosRemotos, fuente: "remoto" };
            }

            // MODO H√çBRIDO
            return await obtenerDatosHibrido({
               db: dbRef.current,
               alimentadorId,
               registradorId,
               zona,
               desde,
               hasta,
            });
         } catch (err) {
            console.error("[Historial] Error obteniendo datos:", err);
            setError(err.message);
            return { datos: [], fuente: "error" };
         } finally {
            setCargando(false);
         }
      },
      []
   );

   /**
    * Precarga las √∫ltimas 48h de datos para ambas zonas
    */
   const precargar48h = useCallback(async (alimentadorId, registradorIdSuperior, registradorIdInferior) => {
      setPrecargaProgreso(0);
      setPrecargaCompleta(false);
      setPrecargando(true);
      setDatosDeBD(false);
      precargaAbortRef.current = false;

      try {
         const resultado = await ejecutarPrecarga48h({
            db: dbRef.current,
            alimentadorId,
            registradorIdSuperior,
            registradorIdInferior,
            onProgreso: setPrecargaProgreso,
            abortRef: precargaAbortRef,
         });

         setDatosDeBD(resultado.datosDeBD);
         setPrecargaCompleta(true);
         setPrecargando(false);
         return resultado.exito;
      } catch {
         setPrecargando(false);
         setPrecargaProgreso(0);
         setPrecargaCompleta(true);
         return false;
      }
   }, []);

   /**
    * Precarga datos para todos los alimentadores de un puesto
    */
   const precargarPuesto = useCallback(async (alimentadores) => {
      setPrecargaProgreso(0);
      setPrecargaCompleta(false);
      setPrecargando(true);
      setDatosDeBD(false);
      precargaAbortRef.current = false;

      try {
         const resultado = await ejecutarPrecargaPuesto({
            db: dbRef.current,
            alimentadores,
            onProgreso: setPrecargaProgreso,
            abortRef: precargaAbortRef,
         });

         setDatosDeBD(resultado.datosDeBD);
         setPrecargaCompleta(true);
         setPrecargando(false);
         return resultado.exito;
      } catch {
         setPrecargando(false);
         setPrecargaProgreso(0);
         setPrecargaCompleta(true);
         return false;
      }
   }, []);

   /**
    * Cancela la precarga en curso
    */
   const cancelarPrecarga = useCallback(() => {
      precargaAbortRef.current = true;
   }, []);

   /**
    * Resetea el estado de precarga (al cerrar modal)
    */
   const resetearPrecarga = useCallback(() => {
      precargaAbortRef.current = true;
      setPrecargaProgreso(0);
      setPrecargaCompleta(false);
      setPrecargando(false);
      setDatosDeBD(false);
   }, []);

   /**
    * Limpia lecturas antiguas manualmente
    */
   const limpiarHistorial = useCallback(async () => {
      if (!dbRef.current) return 0;

      try {
         const eliminados = await limpiarLecturasAntiguas(dbRef.current, HORAS_RETENCION_LOCAL);
         const stats = await obtenerEstadisticas(dbRef.current);
         setEstadisticas(stats);
         return eliminados;
      } catch (err) {
         console.error("[Historial] Error limpiando historial:", err);
         return 0;
      }
   }, []);

   /**
    * Limpia TODO el cache local
    */
   const limpiarCacheCompleto = useCallback(async () => {
      if (!dbRef.current) return false;

      try {
         await limpiarTodo(dbRef.current);
         const stats = await obtenerEstadisticas(dbRef.current);
         setEstadisticas(stats);
         setPrecargaProgreso(0);
         setPrecargaCompleta(false);
         setDatosDeBD(false);
         console.log("[Historial] Cache local limpiado completamente");
         return true;
      } catch (err) {
         console.error("[Historial] Error limpiando cache completo:", err);
         return false;
      }
   }, []);

   /**
    * Actualiza estad√≠sticas
    */
   const actualizarEstadisticas = useCallback(async () => {
      if (!dbRef.current) return;

      try {
         const stats = await obtenerEstadisticas(dbRef.current);
         setEstadisticas(stats);
      } catch (err) {
         console.error("[Historial] Error actualizando estad√≠sticas:", err);
      }
   }, []);

   return {
      guardarLecturaLocal,
      obtenerDatosGrafico,
      limpiarHistorial,
      limpiarCacheCompleto,
      actualizarEstadisticas,
      // Precarga 48h
      precargar48h,
      precargarPuesto,
      cancelarPrecarga,
      resetearPrecarga,
      precargaProgreso,
      precargaCompleta,
      precargando,
      datosDeBD,
      // Estado general
      dbLista,
      cargando,
      error,
      estadisticas,
      horasRetencion: HORAS_RETENCION_LOCAL,
   };
};

export default useHistorialLocal;

// ===== ./src/paginas/PaginaAlimentadores/hooks/historial/useVentanaHistorialLogica.js =====

// hooks/historial/useVentanaHistorialLogica.js
// Hook que encapsula toda la l√≥gica de estado y efectos de la ventana de historial

import { useState, useEffect, useMemo, useCallback } from "react";
import { useHistorialLocal } from "./useHistorialLocal";
import { RANGOS_TIEMPO } from "../../constantes/historialConfig";
import {
   obtenerTituloZona,
   calcularPromedioZona,
   calcularEstadisticasGrafico,
   calcularLimitesEscalaY,
   filtrarDatosPorIntervalo,
   generarTituloPeriodo,
} from "../../utilidades/calculosHistorial";
import { generarColoresBarras } from "../../utilidades/coloresGrafico";
import { generarOpcionesGrafico } from "../../utilidades/configGraficoHistorial";

/**
 * Hook que maneja toda la l√≥gica de la ventana de historial
 * @param {Object} params - Par√°metros
 * @param {Object} params.alimentadorInicial - Alimentador inicial
 * @param {Object} params.cardDesignInicial - Card design inicial
 * @param {boolean} params.minimizada - Si la ventana est√° minimizada
 * @param {Array} params.alimentadoresPuesto - Lista de alimentadores del puesto
 * @returns {Object} Estado y handlers de la ventana
 */
export const useVentanaHistorialLogica = ({
   alimentadorInicial,
   cardDesignInicial,
   minimizada,
   alimentadoresPuesto,
}) => {
   // Estado local para permitir cambiar de alimentador sin cerrar el modal
   const [alimentadorActual, setAlimentadorActual] = useState(alimentadorInicial);
   const [cardDesignActual, setCardDesignActual] = useState(cardDesignInicial);

   // Alias para compatibilidad
   const alimentador = alimentadorActual;
   const cardDesign = cardDesignActual;

   // Hook de historial
   const {
      obtenerDatosGrafico,
      cargando,
      error,
      precargarPuesto,
      resetearPrecarga,
      precargaProgreso,
      precargaCompleta,
      precargando,
      datosDeBD,
      limpiarCacheCompleto,
      dbLista,
   } = useHistorialLocal();

   // Estados del selector
   const [rangoSeleccionado, setRangoSeleccionado] = useState("24h");
   const [fechaRangoDesde, setFechaRangoDesde] = useState(null);
   const [fechaRangoHasta, setFechaRangoHasta] = useState(null);
   const [zonaSeleccionada, setZonaSeleccionada] = useState("superior");
   const [datosGrafico, setDatosGrafico] = useState([]);
   const [fuenteDatos, setFuenteDatos] = useState(null);
   const [panelDatosAbierto, setPanelDatosAbierto] = useState(true);
   const [intervaloFiltro, setIntervaloFiltro] = useState(60);
   const [tipoGrafico, setTipoGrafico] = useState("line");
   const [modalInformeVisible, setModalInformeVisible] = useState(false);
   const [escalaYMax, setEscalaYMax] = useState(null);
   const [graficoVisible, setGraficoVisible] = useState(true);
   const [editandoEscalaY, setEditandoEscalaY] = useState(false);

   // T√≠tulos de zonas
   const tituloSuperior = useMemo(() => obtenerTituloZona(cardDesign, "superior"), [cardDesign]);
   const tituloInferior = useMemo(() => obtenerTituloZona(cardDesign, "inferior"), [cardDesign]);
   const tituloZonaActual = zonaSeleccionada === "superior" ? tituloSuperior : tituloInferior;

   const zonaDisponible = useCallback(
      (zona) => {
         const config = cardDesign?.[zona];
         return config?.boxes?.some((b) => b.enabled);
      },
      [cardDesign]
   );

   const obtenerRegistradorZona = useCallback(
      (zona) => {
         const regIdZona = cardDesign?.[zona]?.registrador_id;
         if (regIdZona) return regIdZona;
         return alimentador?.registrador_id || null;
      },
      [cardDesign, alimentador]
   );

   // Cargar datos
   const cargarDatos = useCallback(async () => {
      if (!alimentador?.id) return;
      const registradorId = obtenerRegistradorZona(zonaSeleccionada);
      if (!registradorId) {
         setDatosGrafico([]);
         setFuenteDatos(null);
         return;
      }

      const ahora = Date.now();
      const rango = RANGOS_TIEMPO.find((r) => r.id === rangoSeleccionado);
      let desde, hasta;

      if (fechaRangoDesde && fechaRangoHasta) {
         const fDesde = new Date(fechaRangoDesde);
         const fHasta = new Date(fechaRangoHasta);
         desde = new Date(fDesde.getFullYear(), fDesde.getMonth(), fDesde.getDate(), 0, 0, 0, 0).getTime();
         hasta = new Date(fHasta.getFullYear(), fHasta.getMonth(), fHasta.getDate(), 23, 59, 59, 999).getTime();
      } else if (rango?.ms) {
         desde = ahora - rango.ms;
         hasta = ahora;
      } else {
         return;
      }

      const usandoRangoPredefinido = !fechaRangoDesde && !fechaRangoHasta;
      const forzarSoloLocal = precargaCompleta && usandoRangoPredefinido;
      const { datos, fuente } = await obtenerDatosGrafico(
         alimentador.id,
         registradorId,
         zonaSeleccionada,
         desde,
         hasta,
         forzarSoloLocal
      );

      const zonaConfig = cardDesign?.[zonaSeleccionada];
      const datosTransformados = datos
         .map((lectura) => {
            const promedio = calcularPromedioZona(lectura, zonaConfig);
            if (promedio === null) return null;
            return { x: new Date(lectura.timestamp), y: promedio };
         })
         .filter((d) => d !== null);

      setDatosGrafico(datosTransformados);
      setFuenteDatos(fuente);
   }, [
      alimentador,
      cardDesign,
      rangoSeleccionado,
      fechaRangoDesde,
      fechaRangoHasta,
      zonaSeleccionada,
      obtenerDatosGrafico,
      obtenerRegistradorZona,
      precargaCompleta,
   ]);

   // Iniciar precarga al montar
   useEffect(() => {
      if (!alimentador?.id || !dbLista || alimentadoresPuesto.length === 0) return;
      precargarPuesto(alimentadoresPuesto);
      return () => resetearPrecarga();
   }, [alimentador?.id, dbLista, alimentadoresPuesto, precargarPuesto, resetearPrecarga]);

   // Cargar datos cuando cambia selecci√≥n
   useEffect(() => {
      if (!minimizada && precargaCompleta) {
         cargarDatos();
      }
   }, [cargarDatos, minimizada, precargaCompleta]);

   // Datos filtrados por intervalo
   const datosFiltrados = useMemo(
      () => filtrarDatosPorIntervalo(datosGrafico, intervaloFiltro),
      [datosGrafico, intervaloFiltro]
   );

   // L√≠mites para el slider de escala Y
   const limitesEscalaY = useMemo(
      () => calcularLimitesEscalaY(datosFiltrados),
      [datosFiltrados]
   );

   // Colores para gr√°fico de barras
   const coloresBarras = useMemo(
      () => generarColoresBarras(datosFiltrados),
      [datosFiltrados]
   );

   // Configuraci√≥n ApexCharts
   const opcionesGrafico = useMemo(
      () =>
         generarOpcionesGrafico({
            alimentadorId: alimentador?.id,
            tipoGrafico,
            escalaYMax,
            coloresBarras,
         }),
      [alimentador?.id, tipoGrafico, escalaYMax, coloresBarras]
   );

   // Series para el gr√°fico
   const seriesGrafico = useMemo(
      () => [{ name: `Promedio ${tituloZonaActual}`, data: datosFiltrados }],
      [datosFiltrados, tituloZonaActual]
   );

   // Fuente de datos efectiva
   const fuenteDatosEfectiva = useMemo(() => {
      if (fuenteDatos === "local" && datosDeBD) {
         return "remoto";
      }
      return fuenteDatos;
   }, [fuenteDatos, datosDeBD]);

   // T√≠tulo del panel
   const tituloPanelDatos = useMemo(
      () => generarTituloPeriodo(datosGrafico),
      [datosGrafico]
   );

   // Estad√≠sticas del gr√°fico
   const estadisticasGrafico = useMemo(
      () => calcularEstadisticasGrafico(datosGrafico),
      [datosGrafico]
   );

   // Manejador para edici√≥n manual de escala Y
   const handleEscalaYManual = useCallback(
      (valorInput) => {
         const valor = parseFloat(valorInput);
         if (isNaN(valor)) {
            setEditandoEscalaY(false);
            return;
         }
         const valorValidado = Math.min(Math.max(valor, limitesEscalaY.min), limitesEscalaY.max);
         setEscalaYMax(valorValidado);
         setEditandoEscalaY(false);
      },
      [limitesEscalaY]
   );

   // Handler para cambio de rango predefinido
   const handleRangoChange = useCallback((rangoId) => {
      setRangoSeleccionado(rangoId);
      setFechaRangoDesde(null);
      setFechaRangoHasta(null);
   }, []);

   // Handler para cambio de rango de fechas personalizado
   const handleFechaRangoChange = useCallback((desde, hasta) => {
      setFechaRangoDesde(desde);
      setFechaRangoHasta(hasta);
   }, []);

   // Handler para limpiar cache
   const handleLimpiarCache = useCallback(async () => {
      if (window.confirm("¬øLimpiar cache local?")) {
         await limpiarCacheCompleto();
         precargarPuesto(alimentadoresPuesto);
      }
   }, [limpiarCacheCompleto, precargarPuesto, alimentadoresPuesto]);

   // Handler para cambio de tipo de gr√°fico
   const handleTipoGraficoChange = useCallback(
      (nuevoTipo) => {
         if (nuevoTipo === "bar" && intervaloFiltro === 0) {
            setIntervaloFiltro(15);
         }
         setTipoGrafico(nuevoTipo);
      },
      [intervaloFiltro]
   );

   // Handler para cambio de alimentador
   const handleAlimentadorChange = useCallback(
      (nuevoAlimentadorId) => {
         const nuevoAlimentador = alimentadoresPuesto.find((a) => a.id === nuevoAlimentadorId);
         if (nuevoAlimentador) {
            setAlimentadorActual(nuevoAlimentador);
            setCardDesignActual(nuevoAlimentador.card_design || {});
            setZonaSeleccionada("superior");
            setDatosGrafico([]);
         }
      },
      [alimentadoresPuesto]
   );

   return {
      // Estado
      alimentador,
      cardDesign,
      cargando,
      error,
      datosGrafico,
      datosFiltrados,
      precargando,
      precargaProgreso,
      precargaCompleta,

      // UI
      panelDatosAbierto,
      setPanelDatosAbierto,
      graficoVisible,
      setGraficoVisible,
      modalInformeVisible,
      setModalInformeVisible,
      editandoEscalaY,
      setEditandoEscalaY,

      // Zona
      zonaSeleccionada,
      setZonaSeleccionada,
      zonaDisponible,
      tituloSuperior,
      tituloInferior,
      tituloZonaActual,

      // Rango
      rangoSeleccionado,
      fechaRangoDesde,
      fechaRangoHasta,
      handleRangoChange,
      handleFechaRangoChange,

      // Gr√°fico
      tipoGrafico,
      handleTipoGraficoChange,
      opcionesGrafico,
      seriesGrafico,
      escalaYMax,
      setEscalaYMax,
      handleEscalaYManual,
      limitesEscalaY,

      // Intervalo
      intervaloFiltro,
      setIntervaloFiltro,

      // Datos
      fuenteDatosEfectiva,
      tituloPanelDatos,
      estadisticasGrafico,
      cargarDatos,
      handleLimpiarCache,

      // Alimentador
      handleAlimentadorChange,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/mediciones/index.js =====

// hooks/mediciones/index.js
// Hooks relacionados con mediciones, polling y configuraci√≥n de tarjetas

export { useMediciones } from "./useMediciones";
export { usePollingLecturas } from "./usePollingLecturas";
export { default as useTransformadores } from "./useTransformadores";
export { useTarjetaAlimentador } from "./useTarjetaAlimentador";
export { useConfiguracion } from "./useConfiguracion";

// ===== ./src/paginas/PaginaAlimentadores/hooks/mediciones/useConfiguracion.js =====

// src/paginas/PaginaAlimentadores/hooks/usarConfiguracion.js
// Hook para manejar workspaces del usuario en Supabase

import { useState, useEffect, useCallback } from "react";
import {
  obtenerWorkspaces,
  crearWorkspace,
  actualizarWorkspace as actualizarWorkspaceAPI,
  eliminarWorkspace as eliminarWorkspaceAPI,
  obtenerPerfil,
  actualizarWorkspaceDefault,
} from "../../../../servicios/apiService";
import { CLAVES_STORAGE } from "../../constantes/clavesAlmacenamiento";

/**
 * Hook para manejar workspaces del usuario.
 * Los workspaces son contenedores que agrupan puestos y alimentadores.
 *
 * @returns {Object} Estado y funciones para trabajar con workspaces.
 */
export const useConfiguracion = () => {
  // Lista de workspaces del usuario
  const [configuraciones, setConfiguraciones] = useState([]);

  // ID del workspace actualmente seleccionado (UUID string)
  const [configuracionSeleccionadaId, setConfiguracionSeleccionadaId] = useState(() => {
    const guardado = localStorage.getItem(CLAVES_STORAGE.CONFIGURACION_SELECCIONADA);
    return guardado || null;
  });

  // Estado de carga
  const [cargando, setCargando] = useState(true);

  // Error si ocurre
  const [error, setError] = useState(null);

  // Perfil del usuario (incluye rol global)
  const [perfil, setPerfil] = useState(null);

  // ID del workspace por defecto (derivado del perfil)
  const workspaceDefaultId = perfil?.workspace_default_id || null;

  // Workspace seleccionado (derivado)
  const configuracionSeleccionada = configuraciones.find(
    (c) => c.id === configuracionSeleccionadaId
  ) || configuraciones[0] || null;

  // Permisos derivados del perfil
  const puedeCrearWorkspaces = perfil?.puedeCrearWorkspaces ?? false;
  const rolGlobal = perfil?.rolGlobal ?? 'observador';

  /**
   * Carga el perfil del usuario y los workspaces desde el backend
   */
  const cargarConfiguraciones = useCallback(async () => {
    try {
      setCargando(true);
      setError(null);

      // Cargar perfil y workspaces en paralelo
      const [perfilData, workspacesData] = await Promise.all([
        obtenerPerfil(),
        obtenerWorkspaces(),
      ]);

      setPerfil(perfilData);
      setConfiguraciones(workspacesData);

      // Validar la selecci√≥n guardada contra los workspaces del usuario
      if (workspacesData.length > 0) {
        const seleccionActualValida = workspacesData.some((c) => c.id === configuracionSeleccionadaId);
        const defaultId = perfilData?.workspace_default_id;
        const defaultValido = defaultId && workspacesData.some((c) => c.id === defaultId);

        // Prioridad: 1) selecci√≥n actual v√°lida, 2) workspace default, 3) primer workspace
        if (!seleccionActualValida) {
          if (defaultValido) {
            setConfiguracionSeleccionadaId(defaultId);
          } else {
            setConfiguracionSeleccionadaId(workspacesData[0].id);
          }
        }
      } else {
        // Si el usuario no tiene workspaces, limpiar cualquier selecci√≥n guardada
        setConfiguracionSeleccionadaId(null);
      }
    } catch (err) {
      console.error("Error cargando configuraciones:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  }, [configuracionSeleccionadaId]);

  // Cargar configuraciones al montar
  useEffect(() => {
    cargarConfiguraciones();
  }, []);

  // Guardar selecci√≥n en localStorage cuando cambie
  useEffect(() => {
    if (configuracionSeleccionadaId != null) {
      localStorage.setItem(
        CLAVES_STORAGE.CONFIGURACION_SELECCIONADA,
        configuracionSeleccionadaId.toString()
      );
    } else {
      localStorage.removeItem(CLAVES_STORAGE.CONFIGURACION_SELECCIONADA);
    }
  }, [configuracionSeleccionadaId]);

  /**
   * Crea un nuevo workspace
   * @param {string} nombre - Nombre del workspace
   * @param {string} descripcion - Descripci√≥n opcional
   */
  const agregarConfiguracion = async (nombre, descripcion = "") => {
    try {
      setError(null);
      const nueva = await crearWorkspace(nombre, descripcion);
      setConfiguraciones((prev) => [...prev, nueva]);
      setConfiguracionSeleccionadaId(nueva.id);
      return nueva;
    } catch (err) {
      console.error("Error creando workspace:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Actualiza un workspace existente
   * @param {number} id - ID del workspace
   * @param {Object} datos - Datos a actualizar
   */
  const actualizarConfiguracion = async (id, datos) => {
    try {
      setError(null);
      const actualizada = await actualizarWorkspaceAPI(id, datos);
      setConfiguraciones((prev) =>
        prev.map((c) => (c.id === id ? actualizada : c))
      );
      return actualizada;
    } catch (err) {
      console.error("Error actualizando workspace:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Elimina un workspace
   * @param {number} id - ID del workspace a eliminar
   */
  const eliminarConfiguracion = async (id) => {
    try {
      setError(null);
      await eliminarWorkspaceAPI(id);
      setConfiguraciones((prev) => prev.filter((c) => c.id !== id));

      // Si se elimin√≥ el seleccionado, seleccionar otro
      if (configuracionSeleccionadaId === id) {
        const restantes = configuraciones.filter((c) => c.id !== id);
        setConfiguracionSeleccionadaId(restantes[0]?.id || null);
      }
    } catch (err) {
      console.error("Error eliminando workspace:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Selecciona un workspace como activo
   * @param {number} id - ID del workspace
   */
  const seleccionarConfiguracion = (id) => {
    setConfiguracionSeleccionadaId(id);
  };

  /**
   * Alterna el workspace por defecto con optimistic update.
   * El cambio se aplica inmediatamente en la UI y se revierte si hay error.
   * @param {string} id - UUID del workspace
   */
  const toggleWorkspaceDefault = async (id) => {
    const nuevoDefault = workspaceDefaultId === id ? null : id;
    const valorAnterior = perfil?.workspace_default_id;

    // Optimistic update: aplicar cambio inmediatamente
    setPerfil((prev) => ({ ...prev, workspace_default_id: nuevoDefault }));

    try {
      setError(null);
      await actualizarWorkspaceDefault(nuevoDefault);
    } catch (err) {
      // Revertir en caso de error
      console.error("Error cambiando workspace default:", err);
      setPerfil((prev) => ({ ...prev, workspace_default_id: valorAnterior }));
      setError(err.message);
    }
  };

  return {
    // Estados
    configuraciones,
    configuracionSeleccionada,
    configuracionSeleccionadaId,
    workspaceDefaultId,
    cargando,
    error,

    // Perfil y permisos
    perfil,
    rolGlobal,
    puedeCrearWorkspaces,

    // Funciones
    cargarConfiguraciones,
    agregarConfiguracion,
    actualizarConfiguracion,
    eliminarConfiguracion,
    seleccionarConfiguracion,
    toggleWorkspaceDefault,
  };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/mediciones/useMediciones.js =====

// src/paginas/PaginaAlimentadores/hooks/usarMediciones.js

import { useState, useCallback } from "react";

/**
 * Hook para manejar el estado de registros/mediciones de alimentadores.
 *
 * Este hook gestiona el estado de los registros le√≠dos desde Supabase (via polling)
 * y provee funciones auxiliares para consultar el estado de las mediciones.
 *
 * NOTA: El flujo anterior de lectura directa Modbus (simulado/real con timers internos)
 * fue eliminado. Ahora las lecturas vienen del polling en VistaAlimentadores que
 * consulta la tabla `lecturas` de Supabase.
 */
export const useMediciones = () => {
	// Registros le√≠dos en vivo por alimentador
	// Estructura: { [alimId]: { rele: [{index, address, value}], analizador: [...] } }
	const [registrosEnVivo, setRegistrosEnVivo] = useState({});

	// Timestamps de √∫ltima actualizaci√≥n por alimentador/equipo
	// Estructura: { [alimId]: { rele: timestamp, analizador: timestamp } }
	const [timestampsInicio, setTimestampsInicio] = useState({});

	// Contador de lecturas por alimentador/equipo
	// Estructura: { [alimId]: { rele: number, analizador: number } }
	const [contadorLecturas, setContadorLecturas] = useState({});

	/**
	 * Actualiza los registros de un alimentador.
	 * Usado por el polling de Supabase para cargar nuevas lecturas.
	 *
	 * @param {string} alimId - ID del alimentador.
	 * @param {Object|Function} nuevosDatosOFuncion - Datos nuevos o funci√≥n actualizadora.
	 */
	const actualizarRegistros = useCallback((alimId, nuevosDatosOFuncion) => {
		const ahora = Date.now();

		setRegistrosEnVivo((anteriores) => {
			const registrosAnteriores = anteriores[alimId] || {};
			const nuevosDatos = typeof nuevosDatosOFuncion === 'function'
				? nuevosDatosOFuncion(registrosAnteriores)
				: nuevosDatosOFuncion;

			return {
				...anteriores,
				[alimId]: {
					...registrosAnteriores,
					...nuevosDatos,
				},
			};
		});

		// Actualizar timestamp
		setTimestampsInicio((anteriores) => ({
			...anteriores,
			[alimId]: {
				...(anteriores[alimId] || {}),
				rele: ahora, // Por ahora usamos rele como default
			},
		}));

		// Incrementar contador
		setContadorLecturas((anteriores) => ({
			...anteriores,
			[alimId]: {
				...(anteriores[alimId] || {}),
				rele: (anteriores[alimId]?.rele || 0) + 1,
			},
		}));
	}, []);

	/**
	 * Obtiene los registros de un alimentador y equipo.
	 */
	const obtenerRegistros = useCallback((alimId, equipo) => {
		return registrosEnVivo[alimId]?.[equipo] || [];
	}, [registrosEnVivo]);

	/**
	 * Verifica si un alimentador tiene datos cargados (est√° "midiendo").
	 * En el nuevo flujo, esto indica si hay datos de polling disponibles.
	 */
	const estaMidiendo = useCallback((alimId, equipo) => {
		const registros = registrosEnVivo[alimId]?.[equipo];
		return Array.isArray(registros) && registros.length > 0;
	}, [registrosEnVivo]);

	/**
	 * Obtiene el timestamp de la √∫ltima actualizaci√≥n.
	 */
	const obtenerTimestampInicio = useCallback((alimId, equipo) => {
		return timestampsInicio[alimId]?.[equipo] || null;
	}, [timestampsInicio]);

	/**
	 * Obtiene el contador de lecturas.
	 */
	const obtenerContadorLecturas = useCallback((alimId, equipo) => {
		return contadorLecturas[alimId]?.[equipo] || 0;
	}, [contadorLecturas]);

	/**
	 * Limpia los datos de un alimentador (usado al eliminar).
	 */
	const detenerMedicion = useCallback((alimId, equipo) => {
		// Limpiar registros del equipo
		setRegistrosEnVivo((anteriores) => {
			if (!anteriores[alimId]) return anteriores;

			const nuevo = { ...anteriores };
			if (nuevo[alimId]?.[equipo]) {
				delete nuevo[alimId][equipo];
				if (Object.keys(nuevo[alimId]).length === 0) {
					delete nuevo[alimId];
				}
			}
			return nuevo;
		});

		// Limpiar timestamp
		setTimestampsInicio((anteriores) => {
			if (!anteriores[alimId]) return anteriores;

			const nuevo = { ...anteriores };
			if (nuevo[alimId]?.[equipo]) {
				delete nuevo[alimId][equipo];
				if (Object.keys(nuevo[alimId]).length === 0) {
					delete nuevo[alimId];
				}
			}
			return nuevo;
		});

		// Limpiar contador
		setContadorLecturas((anteriores) => {
			if (!anteriores[alimId]) return anteriores;

			const nuevo = { ...anteriores };
			if (nuevo[alimId]?.[equipo]) {
				delete nuevo[alimId][equipo];
				if (Object.keys(nuevo[alimId]).length === 0) {
					delete nuevo[alimId];
				}
			}
			return nuevo;
		});
	}, []);

	return {
		// Estado
		registrosEnVivo,

		// Funciones
		actualizarRegistros,
		obtenerRegistros,
		estaMidiendo,
		obtenerTimestampInicio,
		obtenerContadorLecturas,
		detenerMedicion,
	};
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/mediciones/usePollingLecturas.js =====

// hooks/usePollingLecturas.js
// Hook para manejar el polling de lecturas de registradores

import { useState, useRef, useCallback } from "react";
import { obtenerUltimasLecturasPorRegistrador } from "../../../../servicios/apiService";

/**
 * Hook para manejar el polling de lecturas de registradores Modbus
 * @param {Object} params - Par√°metros del hook
 * @returns {Object} Estado y funciones de polling
 */
export function usePollingLecturas({
   actualizarRegistros,
   guardarLecturaLocal,
   buscarAlimentador
}) {
   const [alimentadoresPolling, setAlimentadoresPolling] = useState({});
   const [lecturasPolling, setLecturasPolling] = useState({});
   const [contadoresPolling, setContadoresPolling] = useState({});
   const [contadoresErrorLectura, setContadoresErrorLectura] = useState({});
   const [contadoresErrorRed, setContadoresErrorRed] = useState({});
   const [hayProblemaConexion, setHayProblemaConexion] = useState(false);

   const pollingIntervalsRef = useRef({});
   const contadorIntervalsRef = useRef({});

   /**
    * Verifica si un alimentador est√° haciendo polling
    */
   const estaPolling = useCallback((alimId) => !!alimentadoresPolling[alimId], [alimentadoresPolling]);

   /**
    * Obtiene el contador de lecturas de polling
    */
   const obtenerContadorPolling = useCallback((alimId) => contadoresPolling[alimId] || 0, [contadoresPolling]);

   /**
    * Obtiene el estado de error de lectura por zona
    */
   const obtenerErrorPolling = useCallback((alimId) => {
      const contadorSuperior = contadoresErrorLectura[`${alimId}_superior`] || 0;
      const contadorInferior = contadoresErrorLectura[`${alimId}_inferior`] || 0;

      if (contadorSuperior === 0 && contadorInferior === 0) return null;

      return {
         superior: contadorSuperior >= 1,
         inferior: contadorInferior >= 1,
         superiorCritico: contadorSuperior >= 3,
         inferiorCritico: contadorInferior >= 3,
      };
   }, [contadoresErrorLectura]);

   /**
    * Obtiene lecturas de un registrador
    */
   const fetchLecturasRegistrador = useCallback(async (alimId, registradorId, zona = null) => {
      const claveError = zona ? `${alimId}_${zona}` : `${alimId}_superior`;

      try {
         const lecturas = await obtenerUltimasLecturasPorRegistrador(registradorId, 1);

         // Resetear errores de red si el fetch fue exitoso
         setContadoresErrorRed((prev) => {
            if (prev[claveError]) {
               const nuevo = { ...prev };
               delete nuevo[claveError];
               if (Object.keys(nuevo).length === 0) {
                  setHayProblemaConexion(false);
               }
               return nuevo;
            }
            return prev;
         });

         if (!lecturas || lecturas.length === 0) return;

         const lectura = lecturas[0];
         const clavePolling = zona ? `${alimId}_${zona}` : alimId;

         setLecturasPolling((prev) => ({
            ...prev,
            [clavePolling]: lectura,
         }));

         const tieneErrorLectura = lectura.exito === false;

         if (tieneErrorLectura) {
            setContadoresErrorLectura((prev) => ({
               ...prev,
               [claveError]: (prev[claveError] || 0) + 1,
            }));
            return;
         }

         // Resetear errores si la lectura es exitosa
         setContadoresErrorLectura((prev) => {
            if (prev[claveError]) {
               const nuevo = { ...prev };
               delete nuevo[claveError];
               return nuevo;
            }
            return prev;
         });

         // Transformar y actualizar registros
         if (lectura.valores && Array.isArray(lectura.valores)) {
            const indiceInicial = lectura.indice_inicial ?? 0;

            const registrosTransformados = lectura.valores.map((valor, idx) => ({
               index: idx,
               address: indiceInicial + idx,
               value: valor,
            }));

            actualizarRegistros(alimId, (prevRegistros) => {
               const registrosAnteriores = prevRegistros?.rele || [];
               const rangoNuevo = new Set(registrosTransformados.map(r => r.address));
               const registrosFiltrados = registrosAnteriores.filter(r => !rangoNuevo.has(r.address));
               return {
                  rele: [...registrosFiltrados, ...registrosTransformados]
               };
            });

            guardarLecturaLocal(alimId, registradorId, zona, {
               timestamp: lectura.timestamp ? new Date(lectura.timestamp).getTime() : Date.now(),
               valores: lectura.valores,
               indiceInicial: indiceInicial,
               exito: true,
            });
         }
      } catch (error) {
         console.error(`[Polling] Error de red para alimentador ${alimId}:`, error);
         setContadoresErrorRed((prev) => ({
            ...prev,
            [claveError]: (prev[claveError] || 0) + 1,
         }));
         setHayProblemaConexion(true);
      }
   }, [actualizarRegistros, guardarLecturaLocal]);

   /**
    * Extrae los registrador_id del card_design de un alimentador
    */
   const obtenerRegistradoresDeAlim = useCallback((alim) => {
      const registradores = [];
      const card_design = alim.card_design;

      const regSuperior = card_design?.superior?.registrador_id;
      const regInferior = card_design?.inferior?.registrador_id;

      if (regSuperior && regInferior) {
         if (regSuperior === regInferior) {
            registradores.push({ zona: "superior", zonas: ["superior", "inferior"], id: regSuperior });
         } else {
            registradores.push({ zona: "superior", id: regSuperior });
            registradores.push({ zona: "inferior", id: regInferior });
         }
      } else if (regSuperior) {
         registradores.push({ zona: "superior", zonas: ["superior", "inferior"], id: regSuperior });
      } else if (regInferior) {
         registradores.push({ zona: "inferior", zonas: ["superior", "inferior"], id: regInferior });
      }

      if (registradores.length === 0 && alim.registrador_id) {
         registradores.push({ zona: "legacy", zonas: ["superior", "inferior"], id: alim.registrador_id });
      }

      return registradores;
   }, []);

   /**
    * Inicia el polling para un alimentador
    */
   const iniciarPolling = useCallback((alim) => {
      const registradores = obtenerRegistradoresDeAlim(alim);

      if (registradores.length === 0) {
         console.warn(`[Polling] Alimentador ${alim.id} sin registradores`);
         return;
      }

      if (!alim.intervalo_consulta_ms) {
         console.warn(`[Polling] Alimentador ${alim.id} sin intervalo`);
         return;
      }

      // Limpiar intervalos existentes
      if (pollingIntervalsRef.current[alim.id]) {
         const intervalos = pollingIntervalsRef.current[alim.id];
         if (Array.isArray(intervalos)) {
            intervalos.forEach(clearInterval);
         } else {
            clearInterval(intervalos);
         }
      }
      if (contadorIntervalsRef.current[alim.id]) {
         clearInterval(contadorIntervalsRef.current[alim.id]);
      }

      const intervalos = [];

      registradores.forEach(({ zona, zonas, id: registradorId }) => {
         const zonasACubrir = zonas || [zona];

         zonasACubrir.forEach((z) => {
            fetchLecturasRegistrador(alim.id, registradorId, z);
         });

         const intervalId = setInterval(() => {
            zonasACubrir.forEach((z) => {
               fetchLecturasRegistrador(alim.id, registradorId, z);
            });
         }, alim.intervalo_consulta_ms);

         intervalos.push(intervalId);
      });

      pollingIntervalsRef.current[alim.id] = intervalos.length === 1 ? intervalos[0] : intervalos;

      setContadoresPolling((prev) => ({
         ...prev,
         [alim.id]: (prev[alim.id] || 0) + 1,
      }));

      const contadorIntervalId = setInterval(() => {
         setContadoresPolling((prev) => ({
            ...prev,
            [alim.id]: (prev[alim.id] || 0) + 1,
         }));
      }, alim.intervalo_consulta_ms);

      contadorIntervalsRef.current[alim.id] = contadorIntervalId;
   }, [fetchLecturasRegistrador, obtenerRegistradoresDeAlim]);

   /**
    * Detiene el polling para un alimentador
    */
   const detenerPolling = useCallback((alimId) => {
      if (pollingIntervalsRef.current[alimId]) {
         const intervalos = pollingIntervalsRef.current[alimId];
         if (Array.isArray(intervalos)) {
            intervalos.forEach(clearInterval);
         } else {
            clearInterval(intervalos);
         }
         delete pollingIntervalsRef.current[alimId];
      }

      if (contadorIntervalsRef.current[alimId]) {
         clearInterval(contadorIntervalsRef.current[alimId]);
         delete contadorIntervalsRef.current[alimId];
      }

      setLecturasPolling((prev) => {
         const nuevo = { ...prev };
         delete nuevo[alimId];
         delete nuevo[`${alimId}_superior`];
         delete nuevo[`${alimId}_inferior`];
         delete nuevo[`${alimId}_legacy`];
         return nuevo;
      });

      setContadoresPolling((prev) => {
         const nuevo = { ...prev };
         delete nuevo[alimId];
         return nuevo;
      });

      setContadoresErrorLectura((prev) => {
         const claveSup = `${alimId}_superior`;
         const claveInf = `${alimId}_inferior`;
         if (prev[claveSup] || prev[claveInf]) {
            const nuevo = { ...prev };
            delete nuevo[claveSup];
            delete nuevo[claveInf];
            return nuevo;
         }
         return prev;
      });

      setContadoresErrorRed((prev) => {
         const claveSup = `${alimId}_superior`;
         const claveInf = `${alimId}_inferior`;
         if (prev[claveSup] || prev[claveInf]) {
            const nuevo = { ...prev };
            delete nuevo[claveSup];
            delete nuevo[claveInf];
            if (Object.keys(nuevo).length === 0) {
               setHayProblemaConexion(false);
            }
            return nuevo;
         }
         return prev;
      });
   }, []);

   /**
    * Alterna el polling de un alimentador (play/stop)
    */
   const handlePlayStopClick = useCallback((alimId) => {
      const alimentador = buscarAlimentador(alimId);
      if (!alimentador) return;

      const estaActivo = alimentadoresPolling[alimId];

      if (estaActivo) {
         detenerPolling(alimId);
      } else {
         iniciarPolling(alimentador);
      }

      setAlimentadoresPolling((prev) => ({
         ...prev,
         [alimId]: !prev[alimId],
      }));
   }, [alimentadoresPolling, buscarAlimentador, detenerPolling, iniciarPolling]);

   /**
    * Limpia todos los intervalos
    */
   const limpiarTodosIntervalos = useCallback(() => {
      Object.values(pollingIntervalsRef.current).forEach((intervalos) => {
         if (Array.isArray(intervalos)) {
            intervalos.forEach(clearInterval);
         } else {
            clearInterval(intervalos);
         }
      });
      Object.values(contadorIntervalsRef.current).forEach(clearInterval);
   }, []);

   return {
      estaPolling,
      obtenerContadorPolling,
      obtenerErrorPolling,
      handlePlayStopClick,
      limpiarTodosIntervalos,
      hayProblemaConexion,
      lecturasPolling,
   };
}

// ===== ./src/paginas/PaginaAlimentadores/hooks/mediciones/useTarjetaAlimentador.js =====

// hooks/useTarjetaAlimentador.js
// Hook para manejar el estado y l√≥gica de TarjetaAlimentador

import { useState, useEffect, useRef, useCallback } from "react";

/**
 * Hook para manejar el estado y l√≥gica de una tarjeta de alimentador
 * @param {Object} params
 * @param {boolean} params.mideRele - Si hay medici√≥n de rel√© activa
 * @param {boolean} params.mideAnalizador - Si hay medici√≥n de analizador activa
 * @param {boolean} params.estaPolling - Si hay polling activo
 * @param {number} params.contadorRele - Contador de lecturas de rel√©
 * @param {number} params.contadorAnalizador - Contador de lecturas de analizador
 * @param {number} params.contadorPolling - Contador de lecturas de polling
 * @param {number} params.escala - Escala actual de la tarjeta
 * @param {Function} params.onEscalaChange - Callback para cambiar escala
 * @param {number} params.ESCALA_MIN - Escala m√≠nima permitida
 * @param {number} params.ESCALA_MAX - Escala m√°xima permitida
 */
export function useTarjetaAlimentador({
   mideRele,
   mideAnalizador,
   estaPolling,
   contadorRele,
   contadorAnalizador,
   contadorPolling,
   escala,
   onEscalaChange,
   ESCALA_MIN,
   ESCALA_MAX,
}) {
   // Control local de animaciones de borde: solo se activan tras recibir una lectura
   const [mostrarProgresoRele, setMostrarProgresoRele] = useState(false);
   const [mostrarProgresoAnalizador, setMostrarProgresoAnalizador] = useState(false);
   const [mostrarProgresoPolling, setMostrarProgresoPolling] = useState(false);
   const [cicloPolling, setCicloPolling] = useState(0);

   const ultimoContadorReleRef = useRef(contadorRele);
   const ultimoContadorAnalizadorRef = useRef(contadorAnalizador);
   const ultimoContadorPollingRef = useRef(contadorPolling);

   // Control del popover de escala
   const [mostrarPopoverEscala, setMostrarPopoverEscala] = useState(false);
   const [posicionPopover, setPosicionPopover] = useState({ top: 0, left: 0 });
   const [valorEscalaInput, setValorEscalaInput] = useState(escala.toString());
   const triangleRef = useRef(null);
   const popoverRef = useRef(null);

   // Control del men√∫ desplegable de opciones
   const [menuAbierto, setMenuAbierto] = useState(false);
   const [posicionMenu, setPosicionMenu] = useState({ top: 0, left: 0, width: 0 });
   const menuRef = useRef(null);
   const cardRef = useRef(null);

   // Effect para medici√≥n de rel√©
   useEffect(() => {
      if (!mideRele) {
         setMostrarProgresoRele(false);
         ultimoContadorReleRef.current = contadorRele;
         return;
      }

      if (contadorRele !== ultimoContadorReleRef.current) {
         ultimoContadorReleRef.current = contadorRele;
         setMostrarProgresoRele(contadorRele > 0);
      }
   }, [contadorRele, mideRele]);

   // Effect para medici√≥n de analizador
   useEffect(() => {
      if (!mideAnalizador) {
         setMostrarProgresoAnalizador(false);
         ultimoContadorAnalizadorRef.current = contadorAnalizador;
         return;
      }

      if (contadorAnalizador !== ultimoContadorAnalizadorRef.current) {
         ultimoContadorAnalizadorRef.current = contadorAnalizador;
         setMostrarProgresoAnalizador(contadorAnalizador > 0);
      }
   }, [contadorAnalizador, mideAnalizador]);

   // Effect para polling
   useEffect(() => {
      if (!estaPolling) {
         setMostrarProgresoPolling(false);
         ultimoContadorPollingRef.current = contadorPolling;
         return;
      }

      if (contadorPolling !== ultimoContadorPollingRef.current) {
         ultimoContadorPollingRef.current = contadorPolling;
         setMostrarProgresoPolling(contadorPolling > 0);
         setCicloPolling((prev) => prev + 1);
      }
   }, [contadorPolling, estaPolling]);

   // Sincronizar input con escala cuando cambia externamente
   useEffect(() => {
      setValorEscalaInput(escala.toString());
   }, [escala]);

   // Toggle del popover de escala
   const togglePopoverEscala = useCallback(
      (e) => {
         e.stopPropagation();
         if (mostrarPopoverEscala) {
            setMostrarPopoverEscala(false);
            return;
         }
         if (triangleRef.current) {
            const rect = triangleRef.current.getBoundingClientRect();
            setPosicionPopover({
               top: rect.bottom + 8,
               left: rect.left + rect.width / 2 - 60,
            });
            setMostrarPopoverEscala(true);
         }
      },
      [mostrarPopoverEscala]
   );

   // Cerrar popover al hacer click fuera
   useEffect(() => {
      if (!mostrarPopoverEscala) return;
      const handleClickOutside = (event) => {
         if (
            popoverRef.current &&
            !popoverRef.current.contains(event.target) &&
            triangleRef.current &&
            !triangleRef.current.contains(event.target)
         ) {
            setMostrarPopoverEscala(false);
         }
      };
      const timeoutId = setTimeout(() => {
         document.addEventListener("mousedown", handleClickOutside);
      }, 10);
      return () => {
         clearTimeout(timeoutId);
         document.removeEventListener("mousedown", handleClickOutside);
      };
   }, [mostrarPopoverEscala]);

   // Cerrar men√∫ desplegable al hacer click fuera o al hacer scroll
   useEffect(() => {
      if (!menuAbierto) return;
      const handleClickOutside = (event) => {
         if (
            menuRef.current &&
            !menuRef.current.contains(event.target) &&
            cardRef.current &&
            !cardRef.current.querySelector(".alim-card-menu-toggle")?.contains(event.target)
         ) {
            setMenuAbierto(false);
         }
      };
      const handleWheel = () => {
         setMenuAbierto(false);
      };
      const timeoutId = setTimeout(() => {
         document.addEventListener("mousedown", handleClickOutside);
         window.addEventListener("wheel", handleWheel, { passive: true });
      }, 10);
      return () => {
         clearTimeout(timeoutId);
         document.removeEventListener("mousedown", handleClickOutside);
         window.removeEventListener("wheel", handleWheel);
      };
   }, [menuAbierto]);

   // Toggle del men√∫ desplegable
   const toggleMenu = useCallback(
      (e) => {
         e.stopPropagation();
         if (!menuAbierto && cardRef.current) {
            const rect = cardRef.current.getBoundingClientRect();
            const alturaMenu = 48;
            const separacion = 3;
            setPosicionMenu({
               top: rect.top - alturaMenu - separacion,
               left: rect.left,
               width: rect.width,
            });
         }
         setMenuAbierto(!menuAbierto);
      },
      [menuAbierto]
   );

   // Cerrar men√∫
   const cerrarMenu = useCallback(() => {
      setMenuAbierto(false);
   }, []);

   // Aplicar escala inmediatamente al cambiar el input
   const handleEscalaInputChange = useCallback(
      (e) => {
         const valorStr = e.target.value;
         setValorEscalaInput(valorStr);

         const valor = parseFloat(valorStr);
         if (!isNaN(valor) && valor >= ESCALA_MIN && valor <= ESCALA_MAX) {
            onEscalaChange?.(valor);
         }
      },
      [ESCALA_MIN, ESCALA_MAX, onEscalaChange]
   );

   // Cerrar con Escape
   const handleEscalaKeyDown = useCallback((e) => {
      if (e.key === "Escape") {
         setMostrarPopoverEscala(false);
      }
   }, []);

   // Incrementar escala
   const handleIncrementarEscala = useCallback(() => {
      const valorActual = parseFloat(valorEscalaInput) || escala;
      const nuevoValor = Math.min(ESCALA_MAX, Math.round((valorActual + 0.01) * 100) / 100);
      setValorEscalaInput(nuevoValor.toString());
      onEscalaChange?.(nuevoValor);
   }, [valorEscalaInput, escala, ESCALA_MAX, onEscalaChange]);

   // Decrementar escala
   const handleDecrementarEscala = useCallback(() => {
      const valorActual = parseFloat(valorEscalaInput) || escala;
      const nuevoValor = Math.max(ESCALA_MIN, Math.round((valorActual - 0.01) * 100) / 100);
      setValorEscalaInput(nuevoValor.toString());
      onEscalaChange?.(nuevoValor);
   }, [valorEscalaInput, escala, ESCALA_MIN, onEscalaChange]);

   // Resetear escala a 1.0
   const handleResetearEscala = useCallback(() => {
      setValorEscalaInput("1");
      onEscalaChange?.(1.0);
   }, [onEscalaChange]);

   return {
      // Refs
      triangleRef,
      popoverRef,
      menuRef,
      cardRef,

      // Estado de animaciones
      mostrarProgresoRele,
      mostrarProgresoAnalizador,
      mostrarProgresoPolling,
      cicloPolling,

      // Estado del popover de escala
      mostrarPopoverEscala,
      posicionPopover,
      valorEscalaInput,

      // Estado del men√∫
      menuAbierto,
      posicionMenu,

      // Funciones del popover de escala
      togglePopoverEscala,
      handleEscalaInputChange,
      handleEscalaKeyDown,
      handleIncrementarEscala,
      handleDecrementarEscala,
      handleResetearEscala,

      // Funciones del men√∫
      toggleMenu,
      cerrarMenu,
   };
}

// ===== ./src/paginas/PaginaAlimentadores/hooks/mediciones/useTransformadores.js =====

import { useState, useEffect, useCallback } from "react";

const STORAGE_KEY = "transformadores_ti_tv";

// Transformadores por defecto
const TRANSFORMADORES_DEFAULT = [
  { id: "ti-1", tipo: "TI", nombre: "TI 200/1", formula: "x * 200 / 1000" },
  { id: "ti-2", tipo: "TI", nombre: "TI 400/1", formula: "x * 400 / 1000" },
  { id: "ti-3", tipo: "TI", nombre: "TI 600/1", formula: "x * 600 / 1000" },
  { id: "tv-1", tipo: "TV", nombre: "TV 33kV", formula: "x * 33000 / 10000" },
  { id: "tv-2", tipo: "TV", nombre: "TV 13.2kV", formula: "x * 13200 / 10000" },
];

/**
 * Hook para gestionar transformadores de intensidad (TI) y voltaje (TV)
 * Persiste en localStorage
 */
export const useTransformadores = () => {
  const [transformadores, setTransformadores] = useState([]);
  const [cargando, setCargando] = useState(true);

  // Cargar transformadores del localStorage
  const cargarTransformadores = useCallback(() => {
    try {
      const guardados = localStorage.getItem(STORAGE_KEY);
      if (guardados) {
        setTransformadores(JSON.parse(guardados));
      } else {
        // Primera vez: usar los por defecto
        setTransformadores(TRANSFORMADORES_DEFAULT);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(TRANSFORMADORES_DEFAULT));
      }
    } catch (error) {
      console.error("Error cargando transformadores:", error);
      setTransformadores(TRANSFORMADORES_DEFAULT);
    } finally {
      setCargando(false);
    }
  }, []);

  useEffect(() => {
    cargarTransformadores();
  }, [cargarTransformadores]);

  // Guardar en localStorage
  const guardarEnStorage = useCallback((datos) => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(datos));
      setTransformadores(datos);
      return true;
    } catch (error) {
      console.error("Error guardando transformadores:", error);
      return false;
    }
  }, []);

  // Generar ID √∫nico
  const generarId = () => {
    return "tr-" + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
  };

  // Obtener transformadores por tipo
  const obtenerPorTipo = useCallback(
    (tipo) => {
      return transformadores.filter((t) => t.tipo === tipo);
    },
    [transformadores]
  );

  // Obtener TIs
  const obtenerTIs = useCallback(() => obtenerPorTipo("TI"), [obtenerPorTipo]);

  // Obtener TVs
  const obtenerTVs = useCallback(() => obtenerPorTipo("TV"), [obtenerPorTipo]);

  // Obtener Relaciones
  const obtenerRelaciones = useCallback(() => obtenerPorTipo("REL"), [obtenerPorTipo]);

  // Obtener transformador por ID
  const obtenerPorId = useCallback(
    (id) => {
      return transformadores.find((t) => t.id === id) || null;
    },
    [transformadores]
  );

  // Crear transformador
  const crearTransformador = useCallback(
    (datos) => {
      const nuevo = {
        id: generarId(),
        tipo: datos.tipo,
        nombre: datos.nombre.trim(),
        formula: datos.formula.trim(),
      };

      const nuevos = [...transformadores, nuevo];
      const exito = guardarEnStorage(nuevos);
      return exito ? nuevo : null;
    },
    [transformadores, guardarEnStorage]
  );

  // Actualizar transformador
  const actualizarTransformador = useCallback(
    (id, datos) => {
      const indice = transformadores.findIndex((t) => t.id === id);
      if (indice === -1) return false;

      const actualizado = {
        ...transformadores[indice],
        nombre: datos.nombre?.trim() || transformadores[indice].nombre,
        formula: datos.formula?.trim() || transformadores[indice].formula,
      };

      const nuevos = [...transformadores];
      nuevos[indice] = actualizado;
      return guardarEnStorage(nuevos);
    },
    [transformadores, guardarEnStorage]
  );

  // Eliminar transformador
  const eliminarTransformador = useCallback(
    (id) => {
      const nuevos = transformadores.filter((t) => t.id !== id);
      return guardarEnStorage(nuevos);
    },
    [transformadores, guardarEnStorage]
  );

  return {
    transformadores,
    cargando,
    obtenerTIs,
    obtenerTVs,
    obtenerRelaciones,
    obtenerPorId,
    crearTransformador,
    actualizarTransformador,
    eliminarTransformador,
    recargar: cargarTransformadores,
  };
};

export default useTransformadores;

// ===== ./src/paginas/PaginaAlimentadores/hooks/preferencias/index.js =====

// hooks/preferencias/index.js
// Hooks relacionados con preferencias de UI y estilos visuales

export { usePreferenciasUI } from "./usePreferenciasUI";
export { usePreferenciasVisuales } from "./usePreferenciasVisuales";
export { default as useEstilosGlobales } from "./useEstilosGlobales";
export { useEstilosApariencia } from "./useEstilosApariencia";
export { useGapsCombinados } from "./useGapsCombinados";
export { useEscalasCombinadas } from "./useEscalasCombinadas";
export { useSincronizacionCambios } from "./useSincronizacionCambios";
export { useColoresPuesto } from "./useColoresPuesto";

// ===== ./src/paginas/PaginaAlimentadores/hooks/preferencias/useColoresPuesto.js =====

// hooks/preferencias/useColoresPuesto.js
// Hook para obtener colores de puestos combinando preferencias y BD

import { useCallback } from "react";

/**
 * Hook para obtener colores de puestos considerando preferencias de usuario
 *
 * @param {Object} params
 * @param {boolean} params.esCreador - Si el usuario es creador
 * @param {Array} params.puestos - Lista de puestos
 * @param {Object} params.preferenciasVisualesHook - Hook de preferencias visuales
 * @returns {Object} Funciones para obtener colores
 */
export const useColoresPuesto = ({ esCreador, puestos, preferenciasVisualesHook }) => {
   /**
    * Obtiene el color del bot√≥n de un puesto.
    * - Creador: devuelve el color de la BD
    * - Invitado: devuelve preferencia personal > BD
    */
   const obtenerColorPuesto = useCallback(
      (puestoId) => {
         const puesto = puestos.find((p) => p.id === puestoId);
         if (!puesto) return null;

         // Para invitados, verificar si tienen preferencia personal
         if (!esCreador) {
            const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
            if (configPuesto?.color) {
               return configPuesto.color;
            }
         }

         return puesto.color;
      },
      [esCreador, puestos, preferenciasVisualesHook]
   );

   /**
    * Obtiene el color de fondo de un puesto.
    * - Creador: devuelve el color de la BD
    * - Invitado: devuelve preferencia personal > BD
    */
   const obtenerBgColorPuesto = useCallback(
      (puestoId) => {
         const puesto = puestos.find((p) => p.id === puestoId);
         if (!puesto) return null;

         // Para invitados, verificar si tienen preferencia personal
         if (!esCreador) {
            const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
            if (configPuesto?.bg_color) {
               return configPuesto.bg_color;
            }
         }

         return puesto.bgColor || puesto.bg_color;
      },
      [esCreador, puestos, preferenciasVisualesHook]
   );

   return {
      obtenerColorPuesto,
      obtenerBgColorPuesto,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/preferencias/useEscalasCombinadas.js =====

// hooks/preferencias/useEscalasCombinadas.js
// Hook para obtener escalas combinando localStorage + preferencias usuario + BD

import { useCallback } from "react";

/**
 * Hook para manejar escalas combinadas entre localStorage, preferencias de usuario y BD
 * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > null/default
 *
 * @param {Object} params
 * @param {boolean} params.esCreador - Si el usuario es creador del workspace
 * @param {Object} params.escalasPorPuesto - Escalas de localStorage por puesto
 * @param {Object} params.escalasPorTarjeta - Escalas de localStorage por tarjeta
 * @param {Object} params.puestoSeleccionado - Puesto actualmente seleccionado
 * @param {Array} params.puestos - Lista de puestos
 * @param {Object} params.preferenciasVisualesHook - Hook de preferencias visuales
 * @param {number} params.escalaGlobal - Escala global configurada
 * @param {number} params.ESCALA_DEFAULT - Valor por defecto para escala
 * @returns {Object} Funciones para obtener escalas combinadas
 */
export const useEscalasCombinadas = ({
   esCreador,
   escalasPorPuesto,
   escalasPorTarjeta,
   puestoSeleccionado,
   puestos,
   preferenciasVisualesHook,
   escalaGlobal,
   ESCALA_DEFAULT,
}) => {
   /**
    * Obtiene la escala de un puesto.
    */
   const obtenerEscalaPuestoCombinada = useCallback(
      (puestoId) => {
         if (!puestoId) return null;

         // 1. Primero mirar localStorage
         const escalaLocal = escalasPorPuesto[puestoId];
         if (escalaLocal !== undefined) {
            return escalaLocal;
         }

         // 2. Para invitados, mirar preferencias visuales persistentes
         if (!esCreador) {
            const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
            if (configPuesto?.escala !== undefined && configPuesto?.escala !== null) {
               return configPuesto.escala;
            }
         }

         // 3. Buscar en los datos de BD base
         const puesto = puestos.find((p) => String(p.id) === String(puestoId));
         if (puesto && puesto.escala !== undefined && puesto.escala !== null) {
            return puesto.escala;
         }

         // 4. No hay escala definida (usar jerarqu√≠a global)
         return null;
      },
      [esCreador, escalasPorPuesto, puestos, preferenciasVisualesHook]
   );

   /**
    * Obtiene la escala de un alimentador (tarjeta individual).
    */
   const obtenerEscalaTarjetaCombinada = useCallback(
      (alimId) => {
         if (!alimId) return null;

         // 1. Primero mirar localStorage
         const escalaLocal = escalasPorTarjeta[alimId];
         // Si es null expl√≠cito, significa "ignorar escala individual"
         if (escalaLocal === null) {
            return null;
         }
         if (escalaLocal !== undefined) {
            return escalaLocal;
         }

         // 2. Para invitados, mirar preferencias visuales persistentes
         if (!esCreador) {
            const configAlim = preferenciasVisualesHook.obtenerConfigAlimentador(
               alimId,
               puestoSeleccionado?.id
            );
            if (configAlim?.escala !== undefined && configAlim?.escala !== null) {
               return configAlim.escala;
            }
         }

         // 3. Buscar en los datos de BD base
         if (puestoSeleccionado) {
            const alimentador = puestoSeleccionado.alimentadores.find(
               (a) => String(a.id) === String(alimId)
            );
            if (alimentador && alimentador.escala !== undefined && alimentador.escala !== null) {
               return alimentador.escala;
            }
         }

         // 4. No hay escala definida
         return null;
      },
      [esCreador, escalasPorTarjeta, puestoSeleccionado, preferenciasVisualesHook]
   );

   /**
    * Obtiene la escala efectiva de una tarjeta considerando toda la jerarqu√≠a:
    * Individual > Por puesto > Global > Default
    */
   const obtenerEscalaEfectivaCombinada = useCallback(
      (alimId, puestoId) => {
         // 1. Escala individual (m√°xima prioridad)
         const escalaIndividual = obtenerEscalaTarjetaCombinada(alimId);
         if (escalaIndividual !== null) return escalaIndividual;

         // 2. Escala por puesto
         const escalaPuesto = obtenerEscalaPuestoCombinada(puestoId);
         if (escalaPuesto !== null) return escalaPuesto;

         // 3. Escala global (solo localStorage)
         if (escalaGlobal !== ESCALA_DEFAULT) {
            return escalaGlobal;
         }

         // 4. Default
         return ESCALA_DEFAULT;
      },
      [obtenerEscalaTarjetaCombinada, obtenerEscalaPuestoCombinada, escalaGlobal, ESCALA_DEFAULT]
   );

   return {
      obtenerEscalaPuestoCombinada,
      obtenerEscalaTarjetaCombinada,
      obtenerEscalaEfectivaCombinada,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/preferencias/useEstilosApariencia.js =====

// hooks/useEstilosApariencia.js
// Hook para manejar el estado de estilos de apariencia de tarjetas

import { useState, useCallback, useEffect, useRef } from "react";
import { ESTILOS_GLOBALES_DEFAULT } from "../../constantes/estilosGlobalesTarjeta";

// Versi√≥n del formato de archivo para compatibilidad futura
const FORMATO_VERSION = 1;

// Valores por defecto para el preview
const VALORES_DEFAULT = ["--,--", "--,--", "--,--"];

/**
 * Genera un valor aleatorio con formato de medici√≥n
 * @param {number} decimales - Cantidad de decimales a mostrar (0, 1 o 2)
 */
const generarValorAleatorio = (decimales = 2) => {
   const valor = (Math.random() * 500).toFixed(decimales);
   return valor.replace(".", ",");
};

/**
 * Convierte una cadena rem a n√∫mero
 */
const remANumero = (remStr) => {
   if (typeof remStr === "number") return remStr;
   return parseFloat(remStr) || 1;
};

/**
 * Convierte una cadena px a n√∫mero
 */
const pxANumero = (pxStr) => {
   if (typeof pxStr === "number") return pxStr;
   return parseInt(pxStr) || 80;
};

/**
 * Hook para manejar el estado de estilos de apariencia de tarjetas
 * @param {Object} params
 * @param {Object} params.estilosIniciales - Estilos iniciales para edici√≥n
 * @returns {Object} Estado y funciones de estilos
 */
export function useEstilosApariencia({ estilosIniciales }) {
   // Ref para guardar los estilos iniciales y solo sincronizar una vez
   const estilosInicialesRef = useRef(null);

   // Estado local para los estilos (copia editable)
   const [estilos, setEstilos] = useState(() => ({
      header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...estilosIniciales?.header },
      tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...estilosIniciales?.tituloZona },
      tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...estilosIniciales?.tituloBox },
      valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...estilosIniciales?.valorBox },
      box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...estilosIniciales?.box },
   }));

   // Estado para los valores del preview
   const [valoresPreview, setValoresPreview] = useState(VALORES_DEFAULT);

   // Reiniciar estado local solo cuando cambian los estilos iniciales realmente
   useEffect(() => {
      const estilosStr = JSON.stringify(estilosIniciales);
      if (estilosIniciales && estilosInicialesRef.current !== estilosStr) {
         estilosInicialesRef.current = estilosStr;
         setEstilos({
            header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...estilosIniciales.header },
            tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...estilosIniciales.tituloZona },
            tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...estilosIniciales.tituloBox },
            valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...estilosIniciales.valorBox },
            box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...estilosIniciales.box },
         });
      }
   }, [estilosIniciales]);

   // Funciones para actualizar cada secci√≥n
   const actualizarHeader = useCallback((cambios) => {
      setEstilos((prev) => ({
         ...prev,
         header: { ...prev.header, ...cambios },
      }));
   }, []);

   const actualizarTituloZona = useCallback((cambios) => {
      setEstilos((prev) => ({
         ...prev,
         tituloZona: { ...prev.tituloZona, ...cambios },
      }));
   }, []);

   const actualizarTituloBox = useCallback((cambios) => {
      setEstilos((prev) => ({
         ...prev,
         tituloBox: { ...prev.tituloBox, ...cambios },
      }));
   }, []);

   const actualizarValorBox = useCallback((cambios) => {
      setEstilos((prev) => ({
         ...prev,
         valorBox: { ...prev.valorBox, ...cambios },
      }));
   }, []);

   const actualizarBox = useCallback((cambios) => {
      setEstilos((prev) => ({
         ...prev,
         box: { ...prev.box, ...cambios },
      }));
   }, []);

   // Restaurar valores por defecto
   const restaurarDefecto = useCallback(() => {
      setEstilos(ESTILOS_GLOBALES_DEFAULT);
   }, []);

   // Randomizar valores del preview
   const randomizarValores = useCallback(() => {
      const decimales = estilos.valorBox.decimales ?? 2;
      setValoresPreview([
         generarValorAleatorio(decimales),
         generarValorAleatorio(decimales),
         generarValorAleatorio(decimales),
      ]);
   }, [estilos.valorBox.decimales]);

   // Resetear valores del preview
   const resetearValoresPreview = useCallback(() => {
      setValoresPreview(VALORES_DEFAULT);
   }, []);

   // Exportar configuraci√≥n a archivo JSON
   const exportarConfiguracion = useCallback(async () => {
      const configuracion = {
         version: FORMATO_VERSION,
         fechaExportacion: new Date().toISOString(),
         estilos: estilos,
      };

      const contenidoJSON = JSON.stringify(configuracion, null, 2);
      const nombreArchivo = `apariencia-tarjetas-${new Date().toISOString().slice(0, 10)}.json`;

      // Intentar usar File System Access API (Chrome, Edge)
      if ("showSaveFilePicker" in window) {
         try {
            const handle = await window.showSaveFilePicker({
               suggestedName: nombreArchivo,
               types: [
                  {
                     description: "Archivo JSON",
                     accept: { "application/json": [".json"] },
                  },
               ],
            });
            const writable = await handle.createWritable();
            await writable.write(contenidoJSON);
            await writable.close();
            return; // √âxito con File System Access API
         } catch (err) {
            // Si el usuario cancela, no hacer nada
            if (err.name === "AbortError") return;
            // Si hay otro error, usar el fallback
            console.warn("File System Access API fall√≥, usando fallback:", err);
         }
      }

      // Fallback para navegadores sin soporte (Firefox, Safari, etc.)
      const blob = new Blob([contenidoJSON], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = nombreArchivo;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
   }, [estilos]);

   // Importar configuraci√≥n desde archivo JSON
   const importarConfiguracion = useCallback((evento) => {
      const archivo = evento.target.files?.[0];
      if (!archivo) return;

      const lector = new FileReader();
      lector.onload = (e) => {
         try {
            const contenido = JSON.parse(e.target.result);

            // Validar que tenga la estructura esperada
            if (!contenido.estilos) {
               alert("El archivo no tiene el formato correcto de configuraci√≥n.");
               return;
            }

            // Aplicar los estilos importados
            setEstilos({
               header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...contenido.estilos.header },
               tituloZona: {
                  ...ESTILOS_GLOBALES_DEFAULT.tituloZona,
                  ...contenido.estilos.tituloZona,
               },
               tituloBox: {
                  ...ESTILOS_GLOBALES_DEFAULT.tituloBox,
                  ...contenido.estilos.tituloBox,
               },
               valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...contenido.estilos.valorBox },
               box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...contenido.estilos.box },
            });
         } catch {
            alert("Error al leer el archivo. Aseg√∫rate de que sea un archivo JSON v√°lido.");
         }
      };
      lector.readAsText(archivo);

      // Limpiar el input para permitir reimportar el mismo archivo
      evento.target.value = "";
   }, []);

   return {
      // Estado
      estilos,
      valoresPreview,

      // Funciones de actualizaci√≥n
      actualizarHeader,
      actualizarTituloZona,
      actualizarTituloBox,
      actualizarValorBox,
      actualizarBox,

      // Funciones de utilidad
      restaurarDefecto,
      randomizarValores,
      resetearValoresPreview,
      exportarConfiguracion,
      importarConfiguracion,

      // Helpers de conversi√≥n
      remANumero,
      pxANumero,
   };
}

// ===== ./src/paginas/PaginaAlimentadores/hooks/preferencias/useEstilosGlobales.js =====

/**
 * Hook para manejar los estilos globales de las tarjetas de alimentador
 * Persiste en localStorage y proporciona funciones para actualizar cada secci√≥n
 */

import { useState, useCallback, useEffect } from "react";
import {
  ESTILOS_GLOBALES_DEFAULT,
  ESTILOS_GLOBALES_STORAGE_KEY,
} from "../../constantes/estilosGlobalesTarjeta";

/**
 * Hook que maneja los estilos globales de las tarjetas
 * @returns {Object} Estado y funciones para manejar estilos globales
 */
const useEstilosGlobales = () => {
  const [estilos, setEstilos] = useState(() => {
    // Intentar cargar desde localStorage al inicializar
    try {
      const guardado = localStorage.getItem(ESTILOS_GLOBALES_STORAGE_KEY);
      if (guardado) {
        const parseado = JSON.parse(guardado);
        // Merge con defaults para asegurar que todos los campos existan
        return {
          header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...parseado.header },
          tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...parseado.tituloZona },
          tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...parseado.tituloBox },
          valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...parseado.valorBox },
          box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...parseado.box },
        };
      }
    } catch (e) {
      console.warn("[EstilosGlobales] Error cargando estilos:", e);
    }
    return ESTILOS_GLOBALES_DEFAULT;
  });

  // Guardar en localStorage cuando cambian los estilos
  useEffect(() => {
    try {
      localStorage.setItem(ESTILOS_GLOBALES_STORAGE_KEY, JSON.stringify(estilos));
    } catch (e) {
      console.warn("[EstilosGlobales] Error guardando estilos:", e);
    }
  }, [estilos]);

  /**
   * Actualiza los estilos del header
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarHeader = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      header: { ...prev.header, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos del t√≠tulo de zona (afecta superior e inferior)
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarTituloZona = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      tituloZona: { ...prev.tituloZona, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos de los t√≠tulos de box (R, S, T)
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarTituloBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      tituloBox: { ...prev.tituloBox, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos del valor dentro del box
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarValorBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      valorBox: { ...prev.valorBox, ...cambios },
    }));
  }, []);

  /**
   * Actualiza los estilos del contenedor del box
   * @param {Object} cambios - Propiedades a cambiar
   */
  const actualizarBox = useCallback((cambios) => {
    setEstilos((prev) => ({
      ...prev,
      box: { ...prev.box, ...cambios },
    }));
  }, []);

  /**
   * Resetea todos los estilos a los valores por defecto
   */
  const resetearEstilos = useCallback(() => {
    setEstilos(ESTILOS_GLOBALES_DEFAULT);
  }, []);

  /**
   * Aplica un objeto completo de estilos (para guardar desde TabApariencia)
   * @param {Object} nuevosEstilos - Objeto con todos los estilos a aplicar
   */
  const aplicarTodosEstilos = useCallback((nuevosEstilos) => {
    setEstilos({
      header: { ...ESTILOS_GLOBALES_DEFAULT.header, ...nuevosEstilos.header },
      tituloZona: { ...ESTILOS_GLOBALES_DEFAULT.tituloZona, ...nuevosEstilos.tituloZona },
      tituloBox: { ...ESTILOS_GLOBALES_DEFAULT.tituloBox, ...nuevosEstilos.tituloBox },
      valorBox: { ...ESTILOS_GLOBALES_DEFAULT.valorBox, ...nuevosEstilos.valorBox },
      box: { ...ESTILOS_GLOBALES_DEFAULT.box, ...nuevosEstilos.box },
    });
  }, []);

  /**
   * Genera el objeto de estilos CSS para aplicar en TarjetaAlimentador
   * @returns {Object} Objeto con estilos CSS listos para usar
   */
  const obtenerEstilosCSS = useCallback(() => {
    return {
      // Estilos para .alim-card-title
      headerTitle: {
        fontFamily: estilos.header.fontFamily,
        fontSize: estilos.header.fontSize,
        fontWeight: estilos.header.fontWeight,
      },
      // Estilos para .alim-card-section-title
      tituloZona: {
        fontFamily: estilos.tituloZona.fontFamily,
        fontSize: estilos.tituloZona.fontSize,
      },
      // Estilos para .alim-card-meter-phase
      tituloBox: {
        fontFamily: estilos.tituloBox.fontFamily,
        fontSize: estilos.tituloBox.fontSize,
      },
      // Estilos para .alim-card-meter-value
      valorBox: {
        fontFamily: estilos.valorBox.fontFamily,
        fontSize: estilos.valorBox.fontSize,
        color: estilos.valorBox.color,
      },
      // Estilos para .alim-card-meter y .alim-card-meters
      box: {
        gap: estilos.box.gap,
        width: estilos.box.width,
        height: estilos.box.height,
      },
    };
  }, [estilos]);

  return {
    estilos,
    actualizarHeader,
    actualizarTituloZona,
    actualizarTituloBox,
    actualizarValorBox,
    actualizarBox,
    resetearEstilos,
    aplicarTodosEstilos,
    obtenerEstilosCSS,
  };
};

export default useEstilosGlobales;

// ===== ./src/paginas/PaginaAlimentadores/hooks/preferencias/useGapsCombinados.js =====

// hooks/preferencias/useGapsCombinados.js
// Hook para obtener gaps combinando localStorage + preferencias usuario + BD

import { useCallback } from "react";

/**
 * Hook para manejar gaps combinados entre localStorage, preferencias de usuario y BD
 * Prioridad: localStorage (cambios no guardados) > preferencias_usuario > BD > default
 *
 * @param {Object} params
 * @param {boolean} params.esCreador - Si el usuario es creador del workspace
 * @param {Object} params.gapsPorTarjeta - Gaps de localStorage por tarjeta
 * @param {Object} params.gapsPorFila - Gaps de localStorage por fila
 * @param {Object} params.puestoSeleccionado - Puesto actualmente seleccionado
 * @param {Array} params.puestos - Lista de puestos
 * @param {Object} params.preferenciasVisualesHook - Hook de preferencias visuales
 * @param {number} params.GAP_DEFAULT - Valor por defecto para gaps horizontales
 * @param {number} params.ROW_GAP_DEFAULT - Valor por defecto para gaps verticales
 * @returns {Object} Funciones para obtener gaps combinados
 */
export const useGapsCombinados = ({
   esCreador,
   gapsPorTarjeta,
   gapsPorFila,
   puestoSeleccionado,
   puestos,
   preferenciasVisualesHook,
   GAP_DEFAULT,
   ROW_GAP_DEFAULT,
}) => {
   /**
    * Obtiene el gap horizontal de un alimentador.
    */
   const obtenerGapCombinado = useCallback(
      (alimId) => {
         // 1. Primero mirar localStorage
         const gapLocal = gapsPorTarjeta[alimId];
         if (gapLocal !== undefined) {
            return gapLocal;
         }

         // 2. Para invitados, mirar preferencias visuales persistentes
         if (!esCreador) {
            const configAlim = preferenciasVisualesHook.obtenerConfigAlimentador(
               alimId,
               puestoSeleccionado?.id
            );
            if (configAlim?.gapHorizontal !== undefined) {
               return configAlim.gapHorizontal;
            }
         }

         // 3. Buscar en los datos de BD base
         if (puestoSeleccionado) {
            const alimentador = puestoSeleccionado.alimentadores.find((a) => a.id === alimId);
            if (alimentador && alimentador.gapHorizontal !== undefined) {
               return alimentador.gapHorizontal;
            }
         }

         // 4. Default
         return GAP_DEFAULT;
      },
      [esCreador, gapsPorTarjeta, puestoSeleccionado, GAP_DEFAULT, preferenciasVisualesHook]
   );

   /**
    * Obtiene el gap vertical de una fila en un puesto espec√≠fico.
    */
   const obtenerRowGapCombinado = useCallback(
      (puestoId, rowIndex) => {
         // 1. Primero mirar localStorage
         const claveLocal = `${puestoId}:${rowIndex}`;
         const gapLocal = gapsPorFila[claveLocal];
         if (gapLocal !== undefined) {
            return gapLocal;
         }

         // 2. Para invitados, mirar preferencias visuales persistentes
         if (!esCreador) {
            const configPuesto = preferenciasVisualesHook.obtenerConfigPuesto(puestoId);
            if (configPuesto?.gapsVerticales?.[rowIndex] !== undefined) {
               return configPuesto.gapsVerticales[rowIndex];
            }
         }

         // 3. Buscar en los gaps verticales del puesto espec√≠fico (BD base)
         const puesto = puestos.find((p) => p.id === puestoId);
         if (puesto && puesto.gapsVerticales) {
            const gapBD = puesto.gapsVerticales[rowIndex];
            if (gapBD !== undefined) {
               return gapBD;
            }
         }

         // 4. Default
         return ROW_GAP_DEFAULT;
      },
      [esCreador, gapsPorFila, puestos, ROW_GAP_DEFAULT, preferenciasVisualesHook]
   );

   return {
      obtenerGapCombinado,
      obtenerRowGapCombinado,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/preferencias/usePreferenciasUI.js =====

// src/paginas/PaginaAlimentadores/hooks/usarPreferenciasUI.js

import { useState, useEffect, useCallback } from "react";
import { CLAVES_STORAGE } from "../../constantes/clavesAlmacenamiento";
import {
   GAP_DEFAULT,
   GAP_MIN,
   GAP_MAX,
   ROW_GAP_DEFAULT,
   ROW_GAP_MIN,
   ROW_GAP_MAX,
   ESCALA_DEFAULT,
   ESCALA_MIN,
   ESCALA_MAX,
} from "../../constantes/escalas";

/**
 * Hook para manejar preferencias de UI:
 * - Espaciado horizontal individual por tarjeta
 * - Espaciado vertical por fila (√≠ndice de fila + puestoId)
 * - Escala de tarjetas (global, por puesto, individual)
 *
 * Persiste autom√°ticamente en localStorage.
 *
 * Gaps horizontales: { "alimId1": 10, "alimId2": 50, ... }
 * Gaps verticales: { "puestoId:rowIndex": 20, ... } (combinaci√≥n puesto+fila como key)
 * Escala global: n√∫mero (ej: 1.0)
 * Escala por puesto: { "puestoId": 0.8, ... }
 * Escala por tarjeta: { "alimId": 1.2, ... }
 * Prioridad: Individual > Por puesto > Global > Default (1.0)
 */
export const usePreferenciasUI = () => {
	// ===== GAPS HORIZONTALES (entre tarjetas) =====
	const [gapsPorTarjeta, setGapsPorTarjetaState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.GAP_TARJETAS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.GAP_TARJETAS, JSON.stringify(gapsPorTarjeta));
	}, [gapsPorTarjeta]);

	const obtenerGap = useCallback((alimId) => {
		const gap = gapsPorTarjeta[alimId];
		return gap !== undefined ? gap : GAP_DEFAULT;
	}, [gapsPorTarjeta]);

	const establecerGap = useCallback((alimId, nuevoGap) => {
		const gapValidado = Math.max(GAP_MIN, Math.min(GAP_MAX, nuevoGap));
		setGapsPorTarjetaState(prev => ({
			...prev,
			[alimId]: gapValidado
		}));
	}, []);

	const resetearGap = useCallback((alimId) => {
		setGapsPorTarjetaState(prev => {
			const nuevo = { ...prev };
			delete nuevo[alimId];
			return nuevo;
		});
	}, []);

	const resetearTodosLosGaps = useCallback(() => {
		setGapsPorTarjetaState({});
	}, []);

	// ===== GAPS VERTICALES (entre filas) =====
	const [gapsPorFila, setGapsPorFilaState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.GAP_FILAS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.GAP_FILAS, JSON.stringify(gapsPorFila));
	}, [gapsPorFila]);

	// Generar clave √∫nica para un gap de fila (combinando puestoId y rowIndex)
	const generarClaveRowGap = (puestoId, rowIndex) => `${puestoId}:${rowIndex}`;

	// Obtener el gap de una fila espec√≠fica en un puesto espec√≠fico
	const obtenerRowGap = useCallback((puestoId, rowIndex) => {
		if (!puestoId) return ROW_GAP_DEFAULT;
		const clave = generarClaveRowGap(puestoId, rowIndex);
		const gap = gapsPorFila[clave];
		return gap !== undefined ? gap : ROW_GAP_DEFAULT;
	}, [gapsPorFila]);

	// Establecer el gap de una fila espec√≠fica en un puesto espec√≠fico
	const establecerRowGap = useCallback((puestoId, rowIndex, nuevoGap) => {
		if (!puestoId) return;
		const clave = generarClaveRowGap(puestoId, rowIndex);
		const gapValidado = Math.max(ROW_GAP_MIN, Math.min(ROW_GAP_MAX, nuevoGap));
		setGapsPorFilaState(prev => ({
			...prev,
			[clave]: gapValidado
		}));
	}, []);

	// Resetear gap de una fila al valor por defecto
	const resetearRowGap = useCallback((puestoId, rowIndex) => {
		if (!puestoId) return;
		const clave = generarClaveRowGap(puestoId, rowIndex);
		setGapsPorFilaState(prev => {
			const nuevo = { ...prev };
			delete nuevo[clave];
			return nuevo;
		});
	}, []);

	// Resetear todos los gaps de filas
	const resetearTodosLosRowGaps = useCallback(() => {
		setGapsPorFilaState({});
	}, []);

	// ===== ESCALA GLOBAL =====
	const [escalaGlobal, setEscalaGlobalState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.ESCALA_GLOBAL);
		if (guardado) {
			const valor = parseFloat(guardado);
			if (!isNaN(valor)) return valor;
		}
		return ESCALA_DEFAULT;
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.ESCALA_GLOBAL, escalaGlobal.toString());
	}, [escalaGlobal]);

	const establecerEscalaGlobal = useCallback((nuevaEscala) => {
		const escalaValidada = Math.max(ESCALA_MIN, Math.min(ESCALA_MAX, nuevaEscala));
		setEscalaGlobalState(escalaValidada);
	}, []);

	const resetearEscalaGlobal = useCallback(() => {
		setEscalaGlobalState(ESCALA_DEFAULT);
	}, []);

	// ===== ESCALA POR PUESTO =====
	const [escalasPorPuesto, setEscalasPorPuestoState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.ESCALA_PUESTOS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.ESCALA_PUESTOS, JSON.stringify(escalasPorPuesto));
	}, [escalasPorPuesto]);

	const obtenerEscalaPuesto = useCallback((puestoId) => {
		if (!puestoId) return null;
		return escalasPorPuesto[puestoId];
	}, [escalasPorPuesto]);

	const establecerEscalaPuesto = useCallback((puestoId, nuevaEscala) => {
		if (!puestoId) return;
		const escalaValidada = Math.max(ESCALA_MIN, Math.min(ESCALA_MAX, nuevaEscala));
		setEscalasPorPuestoState(prev => ({
			...prev,
			[puestoId]: escalaValidada
		}));
	}, []);

	const resetearEscalaPuesto = useCallback((puestoId) => {
		if (!puestoId) return;
		setEscalasPorPuestoState(prev => {
			const nuevo = { ...prev };
			delete nuevo[puestoId];
			return nuevo;
		});
	}, []);

	const resetearTodasLasEscalasPuestos = useCallback(() => {
		setEscalasPorPuestoState({});
	}, []);

	// ===== ESCALA POR TARJETA (individual) =====
	const [escalasPorTarjeta, setEscalasPorTarjetaState] = useState(() => {
		const guardado = localStorage.getItem(CLAVES_STORAGE.ESCALA_TARJETAS);
		if (guardado) {
			try {
				return JSON.parse(guardado);
			} catch {
				return {};
			}
		}
		return {};
	});

	useEffect(() => {
		localStorage.setItem(CLAVES_STORAGE.ESCALA_TARJETAS, JSON.stringify(escalasPorTarjeta));
	}, [escalasPorTarjeta]);

	const obtenerEscalaTarjeta = useCallback((alimId) => {
		if (!alimId) return null;
		return escalasPorTarjeta[alimId];
	}, [escalasPorTarjeta]);

	const establecerEscalaTarjeta = useCallback((alimId, nuevaEscala) => {
		if (!alimId) return;
		const escalaValidada = Math.max(ESCALA_MIN, Math.min(ESCALA_MAX, nuevaEscala));
		setEscalasPorTarjetaState(prev => ({
			...prev,
			[alimId]: escalaValidada
		}));
	}, []);

	const resetearEscalaTarjeta = useCallback((alimId) => {
		if (!alimId) return;
		// Guardamos null para indicar "ignorar escala individual (incluso de BD)"
		// Esto permite que la escala del puesto tenga efecto
		setEscalasPorTarjetaState(prev => ({
			...prev,
			[alimId]: null
		}));
	}, []);

	const resetearTodasLasEscalasTarjetas = useCallback(() => {
		setEscalasPorTarjetaState({});
	}, []);

	/**
	 * Obtiene la escala efectiva de una tarjeta considerando la jerarqu√≠a:
	 * Individual > Por puesto > Global > Default
	 * @param {string} alimId - ID del alimentador
	 * @param {string} puestoId - ID del puesto (opcional, para escala por puesto)
	 * @returns {number} Escala efectiva a aplicar
	 */
	const obtenerEscalaEfectiva = useCallback((alimId, puestoId) => {
		// 1. Escala individual (m√°xima prioridad)
		const escalaIndividual = escalasPorTarjeta[alimId];
		if (escalaIndividual !== undefined) return escalaIndividual;

		// 2. Escala por puesto
		if (puestoId) {
			const escalaPuesto = escalasPorPuesto[puestoId];
			if (escalaPuesto !== undefined) return escalaPuesto;
		}

		// 3. Escala global
		if (escalaGlobal !== ESCALA_DEFAULT) return escalaGlobal;

		// 4. Default
		return ESCALA_DEFAULT;
	}, [escalasPorTarjeta, escalasPorPuesto, escalaGlobal]);

	// Resetear todas las escalas
	const resetearTodasLasEscalas = useCallback(() => {
		setEscalaGlobalState(ESCALA_DEFAULT);
		setEscalasPorPuestoState({});
		setEscalasPorTarjetaState({});
	}, []);

	return {
		// Gaps horizontales
		gapsPorTarjeta,
		obtenerGap,
		establecerGap,
		resetearGap,
		resetearTodosLosGaps,
		GAP_MIN,
		GAP_MAX,
		GAP_DEFAULT,
		// Gaps verticales
		gapsPorFila,
		obtenerRowGap,
		establecerRowGap,
		resetearRowGap,
		resetearTodosLosRowGaps,
		ROW_GAP_MIN,
		ROW_GAP_MAX,
		ROW_GAP_DEFAULT,
		// Escala global
		escalaGlobal,
		establecerEscalaGlobal,
		resetearEscalaGlobal,
		// Escala por puesto
		escalasPorPuesto,
		obtenerEscalaPuesto,
		establecerEscalaPuesto,
		resetearEscalaPuesto,
		resetearTodasLasEscalasPuestos,
		// Escala por tarjeta (individual)
		escalasPorTarjeta,
		obtenerEscalaTarjeta,
		establecerEscalaTarjeta,
		resetearEscalaTarjeta,
		resetearTodasLasEscalasTarjetas,
		// Escala efectiva (combina jerarqu√≠a)
		obtenerEscalaEfectiva,
		resetearTodasLasEscalas,
		// Constantes de escala
		ESCALA_MIN,
		ESCALA_MAX,
		ESCALA_DEFAULT,
	};
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/preferencias/usePreferenciasVisuales.js =====

// src/paginas/PaginaAlimentadores/hooks/usePreferenciasVisuales.js
// Hook para manejar preferencias visuales personalizadas por usuario
// Implementa el patr√≥n "User Preferences Override":
// - Creador: guarda en BASE (tablas puestos/alimentadores)
// - Invitado: guarda en preferencias_usuario (solo √©l lo ve)

import { useState, useEffect, useCallback, useMemo } from "react";
import {
  obtenerPreferencias,
  guardarPreferencias,
  actualizarPuesto,
  actualizarAlimentadorAPI,
} from "../../../../servicios/apiService";

// Valores por defecto
const DEFAULTS = {
  escalaGlobal: 1.0,
  GAP_DEFAULT: 10,
  ROW_GAP_DEFAULT: 40,
};

/**
 * Hook para manejar preferencias visuales con patr√≥n de override.
 *
 * Flujo de lectura:
 * 1. Carga config BASE de puestos/alimentadores
 * 2. Carga preferencias personales del usuario
 * 3. Hace merge (preferencia personal > base)
 * 4. Limpia preferencias hu√©rfanas
 *
 * Flujo de escritura:
 * - esCreador=true: guarda en BASE (todos ven el cambio)
 * - esCreador=false: guarda en preferencias_usuario (solo √©l lo ve)
 *
 * @param {string} workspaceId - ID del workspace activo
 * @param {boolean} esCreador - Si el usuario es creador del workspace
 * @param {Array} puestos - Lista de puestos con alimentadores (config BASE)
 * @param {Function} recargarPuestos - Funci√≥n para recargar puestos despu√©s de guardar en BASE
 */
export const usePreferenciasVisuales = (workspaceId, esCreador, puestos, recargarPuestos) => {
  // Preferencias personales del usuario (override)
  const [preferenciasUsuario, setPreferenciasUsuario] = useState(null);
  const [cargando, setCargando] = useState(true);
  const [error, setError] = useState(null);
  const [guardando, setGuardando] = useState(false);
  // Flag para evitar que limpiarHuerfanos se ejecute durante/despu√©s de un guardado
  const [saltarLimpiezaHuerfanos, setSaltarLimpiezaHuerfanos] = useState(false);

  // Estructura de preferenciasUsuario:
  // {
  //   escalaGlobal: 1.0,
  //   puestos: {
  //     "uuid-puesto": { color, bg_color, escala, gapsVerticales }
  //   },
  //   alimentadores: {
  //     "uuid-alim": { color, escala, gapHorizontal }
  //   }
  // }

  /**
   * Carga las preferencias del usuario desde la BD
   */
  const cargarPreferencias = useCallback(async () => {
    if (!workspaceId) {
      setPreferenciasUsuario(null);
      setCargando(false);
      return;
    }

    try {
      setCargando(true);
      setError(null);
      const response = await obtenerPreferencias(workspaceId);
      const prefs = response?.preferencias || {};
      setPreferenciasUsuario(prefs);
    } catch (err) {
      console.error("Error cargando preferencias:", err);
      setError(err.message);
      setPreferenciasUsuario({});
    } finally {
      setCargando(false);
    }
  }, [workspaceId, esCreador]);

  // Cargar preferencias cuando cambie el workspace
  // Nota: cargarPreferencias depende de workspaceId, as√≠ que se recrea cuando cambia
  useEffect(() => {
    cargarPreferencias();
  }, [cargarPreferencias]);

  /**
   * Limpia preferencias hu√©rfanas (referencias a puestos/alimentadores que ya no existen)
   * IMPORTANTE: Solo ejecutar cuando puestos ya est√° cargado para evitar borrar todo
   * IMPORTANTE: Solo ejecutar si los puestos pertenecen al workspace actual
   */
  const limpiarHuerfanos = useCallback(async () => {
    // Verificar que hay datos para comparar
    if (!preferenciasUsuario || !puestos || puestos.length === 0) {
      return;
    }

    // Verificar que hay preferencias que limpiar
    const prefsPuestos = preferenciasUsuario.puestos || {};
    const prefsAlimentadores = preferenciasUsuario.alimentadores || {};
    if (Object.keys(prefsPuestos).length === 0 && Object.keys(prefsAlimentadores).length === 0) {
      return;
    }

    // CR√çTICO: Verificar que los puestos pertenecen al workspace actual
    // Si los puestos tienen un workspace_id diferente, NO ejecutar la limpieza
    // porque significar√≠a que estamos comparando preferencias de un workspace
    // con puestos de otro workspace (durante el cambio de workspace)
    const primerPuesto = puestos[0];
    if (primerPuesto && primerPuesto.workspace_id && primerPuesto.workspace_id !== workspaceId) {
      return;
    }

    // Verificar que al menos uno de los puestos con preferencias existe en la lista actual
    // Si NINGUNO existe, probablemente los puestos son de otro workspace (cambio en progreso)
    const idsPuestos = new Set(puestos.map(p => p.id));
    const prefsPuestosIds = Object.keys(prefsPuestos);
    const algunoPuestoExiste = prefsPuestosIds.some(id => idsPuestos.has(id));

    // Si hay preferencias de puestos pero NINGUNO est√° en la lista actual,
    // es probable que estemos en medio de un cambio de workspace
    if (prefsPuestosIds.length > 0 && !algunoPuestoExiste) {
      return;
    }

    const idsAlimentadores = new Set(
      puestos.flatMap(p => (p.alimentadores || []).map(a => a.id))
    );

    let hayHuerfanos = false;
    const nuevasPrefs = { ...preferenciasUsuario };

    // Limpiar puestos hu√©rfanos
    if (nuevasPrefs.puestos) {
      const puestosLimpios = {};
      for (const [id, prefs] of Object.entries(nuevasPrefs.puestos)) {
        if (idsPuestos.has(id)) {
          puestosLimpios[id] = prefs;
        } else {
          hayHuerfanos = true;
        }
      }
      nuevasPrefs.puestos = puestosLimpios;
    }

    // Limpiar alimentadores hu√©rfanos
    if (nuevasPrefs.alimentadores) {
      const alimentadoresLimpios = {};
      for (const [id, prefs] of Object.entries(nuevasPrefs.alimentadores)) {
        if (idsAlimentadores.has(id)) {
          alimentadoresLimpios[id] = prefs;
        } else {
          hayHuerfanos = true;
        }
      }
      nuevasPrefs.alimentadores = alimentadoresLimpios;
    }

    // Si hubo limpieza, guardar en BD
    if (hayHuerfanos) {
      try {
        await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        setPreferenciasUsuario(nuevasPrefs);
      } catch (err) {
        console.error("Error limpiando preferencias hu√©rfanas:", err);
      }
    }
  }, [preferenciasUsuario, puestos, workspaceId]);

  // Ejecutar limpieza de hu√©rfanos cuando cambian los puestos
  // IMPORTANTE: Solo ejecutar si puestos tiene elementos para evitar borrar preferencias v√°lidas
  // IMPORTANTE: Saltar si estamos en medio de un guardado para evitar race conditions
  useEffect(() => {
    if (saltarLimpiezaHuerfanos) {
      return;
    }
    if (!cargando && preferenciasUsuario && puestos && puestos.length > 0) {
      limpiarHuerfanos();
    }
  }, [puestos, cargando, limpiarHuerfanos, saltarLimpiezaHuerfanos]);

  /**
   * Obtiene la configuraci√≥n visual de un puesto (merge base + override)
   */
  const obtenerConfigPuesto = useCallback((puestoId) => {
    const puesto = puestos.find(p => p.id === puestoId);
    if (!puesto) return null;

    // Config base del puesto
    const base = {
      color: puesto.color,
      bg_color: puesto.bg_color || puesto.bgColor,
      escala: puesto.escala,
      gapsVerticales: puesto.gapsVerticales || { "0": DEFAULTS.ROW_GAP_DEFAULT },
    };

    // Override del usuario (si no es creador)
    const override = preferenciasUsuario?.puestos?.[puestoId] || {};

    // Merge: override tiene prioridad
    return {
      ...base,
      ...override,
      // Para gapsVerticales, hacer merge a nivel de keys
      gapsVerticales: {
        ...base.gapsVerticales,
        ...(override.gapsVerticales || {}),
      },
    };
  }, [puestos, preferenciasUsuario, esCreador]);

  /**
   * Obtiene la configuraci√≥n visual de un alimentador (merge base + override)
   */
  const obtenerConfigAlimentador = useCallback((alimentadorId, puestoId) => {
    const puesto = puestos.find(p => p.id === puestoId);
    const alimentador = puesto?.alimentadores?.find(a => a.id === alimentadorId);
    if (!alimentador) return null;

    // Config base del alimentador
    const base = {
      color: alimentador.color,
      escala: alimentador.escala,
      gapHorizontal: alimentador.gapHorizontal ?? DEFAULTS.GAP_DEFAULT,
    };

    // Override del usuario
    const override = preferenciasUsuario?.alimentadores?.[alimentadorId] || {};

    return { ...base, ...override };
  }, [puestos, preferenciasUsuario]);

  /**
   * Obtiene la escala global (override > default)
   */
  const escalaGlobal = useMemo(() => {
    return preferenciasUsuario?.escalaGlobal ?? DEFAULTS.escalaGlobal;
  }, [preferenciasUsuario]);

  /**
   * Guarda una preferencia visual.
   * - Si esCreador: guarda en BASE (tabla puestos/alimentadores)
   * - Si es invitado: guarda en preferencias_usuario
   *
   * @param {string} tipo - 'puesto' | 'alimentador' | 'global'
   * @param {string} id - ID del elemento (null para global)
   * @param {string} campo - Nombre del campo (color, escala, etc.)
   * @param {any} valor - Nuevo valor
   * @param {string} puestoId - ID del puesto (solo para alimentadores)
   */
  const guardarPreferencia = useCallback(async (tipo, id, campo, valor, puestoId = null) => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      setError(null);

      if (esCreador) {
        // === CREADOR: Guardar en BASE ===
        if (tipo === 'puesto') {
          await actualizarPuesto(id, { [campo]: valor });
          // Recargar para reflejar cambios
          if (recargarPuestos) await recargarPuestos();
        } else if (tipo === 'alimentador') {
          // Mapear campos frontend a backend
          const campoBackend = campo === 'gapHorizontal' ? 'gap_horizontal' : campo;
          await actualizarAlimentadorAPI(id, { [campoBackend]: valor });
          if (recargarPuestos) await recargarPuestos();
        } else if (tipo === 'global') {
          // La escala global no tiene tabla base, se guarda en preferencias
          const nuevasPrefs = {
            ...preferenciasUsuario,
            escalaGlobal: valor,
          };
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
          setPreferenciasUsuario(nuevasPrefs);
        }
      } else {
        // === INVITADO: Guardar en preferencias_usuario ===
        // Activar flag para evitar que limpiarHuerfanos se ejecute durante el guardado
        setSaltarLimpiezaHuerfanos(true);

        // Optimistic update: actualizar estado local primero para evitar lag
        const nuevasPrefs = { ...preferenciasUsuario };

        if (tipo === 'puesto') {
          nuevasPrefs.puestos = nuevasPrefs.puestos || {};
          nuevasPrefs.puestos[id] = nuevasPrefs.puestos[id] || {};
          nuevasPrefs.puestos[id][campo] = valor;
        } else if (tipo === 'alimentador') {
          nuevasPrefs.alimentadores = nuevasPrefs.alimentadores || {};
          nuevasPrefs.alimentadores[id] = nuevasPrefs.alimentadores[id] || {};
          nuevasPrefs.alimentadores[id][campo] = valor;
        } else if (tipo === 'global') {
          nuevasPrefs.escalaGlobal = valor;
        }

        setPreferenciasUsuario(nuevasPrefs);
        // Luego guardar en BD (con await para asegurar que se complete)
        try {
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        } catch (err) {
          console.error("Error guardando preferencia:", err);
          setError(err.message);
        } finally {
          setTimeout(() => {
            setSaltarLimpiezaHuerfanos(false);
          }, 500);
        }
      }
    } catch (err) {
      console.error("Error guardando preferencia:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId, esCreador, preferenciasUsuario, recargarPuestos]);

  /**
   * Guarda m√∫ltiples preferencias de un puesto de una vez
   */
  const guardarPreferenciasPuesto = useCallback(async (puestoId, cambios) => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      setError(null);

      if (esCreador) {
        // Mapear campos frontend a backend
        const cambiosBackend = {};
        for (const [campo, valor] of Object.entries(cambios)) {
          if (campo === 'bgColor') {
            cambiosBackend.bg_color = valor;
          } else if (campo === 'gapsVerticales') {
            cambiosBackend.gaps_verticales = valor;
          } else {
            cambiosBackend[campo] = valor;
          }
        }
        await actualizarPuesto(puestoId, cambiosBackend);
        if (recargarPuestos) await recargarPuestos();
      } else {
        // Activar flag para evitar que limpiarHuerfanos se ejecute durante el guardado
        setSaltarLimpiezaHuerfanos(true);

        // Optimistic update: actualizar estado local primero para evitar lag
        const nuevasPrefs = { ...preferenciasUsuario };
        nuevasPrefs.puestos = nuevasPrefs.puestos || {};
        nuevasPrefs.puestos[puestoId] = {
          ...(nuevasPrefs.puestos[puestoId] || {}),
          ...cambios,
        };
        setPreferenciasUsuario(nuevasPrefs);
        // Luego guardar en BD (con await para asegurar que se complete antes de permitir limpiezaHuerfanos)
        try {
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        } catch (err) {
          console.error("Error guardando preferencias puesto:", err);
          setError(err.message);
        } finally {
          // Reactivar limpiezaHuerfanos despu√©s de un delay para evitar race condition
          setTimeout(() => {
            setSaltarLimpiezaHuerfanos(false);
          }, 500);
        }
      }
    } catch (err) {
      console.error("Error guardando preferencias puesto:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId, esCreador, preferenciasUsuario, recargarPuestos]);

  /**
   * Guarda m√∫ltiples preferencias de un alimentador de una vez
   */
  const guardarPreferenciasAlimentador = useCallback(async (alimentadorId, cambios) => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      setError(null);

      if (esCreador) {
        // Mapear campos frontend a backend
        const cambiosBackend = {};
        for (const [campo, valor] of Object.entries(cambios)) {
          if (campo === 'gapHorizontal') {
            cambiosBackend.gap_horizontal = valor;
          } else {
            cambiosBackend[campo] = valor;
          }
        }
        await actualizarAlimentadorAPI(alimentadorId, cambiosBackend);
        if (recargarPuestos) await recargarPuestos();
      } else {
        // Activar flag para evitar que limpiarHuerfanos se ejecute durante el guardado
        setSaltarLimpiezaHuerfanos(true);

        // Optimistic update: actualizar estado local primero para evitar lag
        const nuevasPrefs = { ...preferenciasUsuario };
        nuevasPrefs.alimentadores = nuevasPrefs.alimentadores || {};
        nuevasPrefs.alimentadores[alimentadorId] = {
          ...(nuevasPrefs.alimentadores[alimentadorId] || {}),
          ...cambios,
        };
        setPreferenciasUsuario(nuevasPrefs);
        // Luego guardar en BD (con await para asegurar que se complete)
        try {
          await guardarPreferencias(workspaceId, { preferencias: nuevasPrefs });
        } catch (err) {
          console.error("Error guardando preferencias alimentador:", err);
          setError(err.message);
        } finally {
          setTimeout(() => {
            setSaltarLimpiezaHuerfanos(false);
          }, 500);
        }
      }
    } catch (err) {
      console.error("Error guardando preferencias alimentador:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId, esCreador, preferenciasUsuario, recargarPuestos]);

  /**
   * Resetea las preferencias personales (vuelve a usar la config base)
   */
  const resetearPreferencias = useCallback(async () => {
    if (!workspaceId) return;

    try {
      setGuardando(true);
      await guardarPreferencias(workspaceId, { preferencias: {} });
      setPreferenciasUsuario({});
    } catch (err) {
      console.error("Error reseteando preferencias:", err);
      setError(err.message);
      throw err;
    } finally {
      setGuardando(false);
    }
  }, [workspaceId]);

  /**
   * Obtiene la escala efectiva de un alimentador considerando la jerarqu√≠a:
   * Individual > Por puesto > Global > Default
   */
  const obtenerEscalaEfectiva = useCallback((alimentadorId, puestoId) => {
    // 1. Escala individual del alimentador
    const configAlim = obtenerConfigAlimentador(alimentadorId, puestoId);
    if (configAlim?.escala != null) return configAlim.escala;

    // 2. Escala del puesto
    const configPuesto = obtenerConfigPuesto(puestoId);
    if (configPuesto?.escala != null) return configPuesto.escala;

    // 3. Escala global
    if (escalaGlobal !== DEFAULTS.escalaGlobal) return escalaGlobal;

    // 4. Default
    return DEFAULTS.escalaGlobal;
  }, [obtenerConfigAlimentador, obtenerConfigPuesto, escalaGlobal]);

  /**
   * Verifica si el usuario tiene preferencias personales para este workspace
   */
  const tienePreferenciasPersonales = useMemo(() => {
    if (!preferenciasUsuario) return false;
    return (
      preferenciasUsuario.escalaGlobal != null ||
      Object.keys(preferenciasUsuario.puestos || {}).length > 0 ||
      Object.keys(preferenciasUsuario.alimentadores || {}).length > 0
    );
  }, [preferenciasUsuario]);

  return {
    // Estado
    preferenciasUsuario,
    cargando,
    error,
    guardando,
    esCreador,
    tienePreferenciasPersonales,

    // Getters (con merge base+override)
    obtenerConfigPuesto,
    obtenerConfigAlimentador,
    obtenerEscalaEfectiva,
    escalaGlobal,

    // Setters (guardan en base o preferencias seg√∫n rol)
    guardarPreferencia,
    guardarPreferenciasPuesto,
    guardarPreferenciasAlimentador,
    resetearPreferencias,

    // Utilidades
    cargarPreferencias,
    limpiarHuerfanos,

    // Constantes
    DEFAULTS,
  };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/preferencias/useSincronizacionCambios.js =====

// hooks/preferencias/useSincronizacionCambios.js
// Hook para manejar la sincronizaci√≥n de cambios pendientes

import { useState, useCallback, useEffect } from "react";

/**
 * Construye los gaps por fila por puesto desde el formato localStorage
 * @param {Array} puestos - Lista de puestos
 * @param {Object} gapsPorFila - Gaps del localStorage (formato "puestoId:rowIndex")
 * @returns {Object} Gaps organizados por puesto
 */
const construirGapsPorFilaPorPuesto = (puestos, gapsPorFila) => {
   const resultado = {};
   puestos.forEach((p) => {
      const gapsDelPuesto = {};
      Object.entries(gapsPorFila).forEach(([clave, valor]) => {
         if (clave.startsWith(`${p.id}:`)) {
            const rowIndex = clave.split(":")[1];
            gapsDelPuesto[rowIndex] = valor;
         }
      });
      resultado[p.id] = { ...p.gapsVerticales, ...gapsDelPuesto };
   });
   return resultado;
};

/**
 * Hook para manejar la sincronizaci√≥n de cambios entre cliente y servidor
 *
 * @param {Object} params
 * @param {boolean} params.esCreador - Si el usuario es creador
 * @param {Array} params.puestos - Lista de puestos
 * @param {Function} params.obtenerPuestosConPreferencias - Funci√≥n para obtener puestos con preferencias
 * @param {Object} params.gapsPorTarjeta - Gaps horizontales por tarjeta
 * @param {Object} params.gapsPorFila - Gaps verticales por fila
 * @param {Object} params.escalasPorPuesto - Escalas por puesto
 * @param {Object} params.escalasPorTarjeta - Escalas por tarjeta
 * @param {Object} params.cambiosPendientesHook - Hook de cambios pendientes
 * @param {Object} params.preferenciasHook - Hook de preferencias UI
 * @param {Object} params.preferenciasVisualesHook - Hook de preferencias visuales
 * @param {Object} params.puestosHook - Hook de puestos
 * @returns {Object} Estado y funciones de sincronizaci√≥n
 */
export const useSincronizacionCambios = ({
   esCreador,
   puestos,
   obtenerPuestosConPreferencias,
   gapsPorTarjeta,
   gapsPorFila,
   escalasPorPuesto,
   escalasPorTarjeta,
   cambiosPendientesHook,
   preferenciasHook,
   preferenciasVisualesHook,
   puestosHook,
   cargandoPuestos,
   configuracionSeleccionadaId,
}) => {
   const [hayCambiosPendientes, setHayCambiosPendientes] = useState(false);
   const [snapshotGuardado, setSnapshotGuardado] = useState(false);

   const { guardarSnapshot, detectarCambios, sincronizarConBD, sincronizando, errorSincronizacion } =
      cambiosPendientesHook;

   // Guardar snapshot cuando termina la carga de BD
   useEffect(() => {
      if (esCreador === null) return;
      const prefsListas = esCreador || !preferenciasVisualesHook.cargando;

      if (puestos.length > 0 && !cargandoPuestos && prefsListas && !snapshotGuardado) {
         const puestosParaSnapshot = esCreador ? puestos : obtenerPuestosConPreferencias();
         guardarSnapshot(puestosParaSnapshot);
         setSnapshotGuardado(true);
      }
   }, [
      puestos,
      cargandoPuestos,
      snapshotGuardado,
      guardarSnapshot,
      esCreador,
      preferenciasVisualesHook.cargando,
      obtenerPuestosConPreferencias,
   ]);

   // Resetear flag cuando cambia el workspace
   useEffect(() => {
      setSnapshotGuardado(false);
   }, [configuracionSeleccionadaId]);

   // Detectar cambios cada vez que cambian los datos locales
   useEffect(() => {
      if (esCreador === null) return;

      if (puestos.length > 0) {
         const puestosParaDeteccion = esCreador ? puestos : obtenerPuestosConPreferencias();
         const gapsPorFilaPorPuesto = construirGapsPorFilaPorPuesto(puestosParaDeteccion, gapsPorFila);
         const { hayCambios } = detectarCambios(
            puestosParaDeteccion,
            gapsPorTarjeta,
            gapsPorFilaPorPuesto,
            escalasPorPuesto,
            escalasPorTarjeta
         );
         setHayCambiosPendientes(hayCambios);
      }
   }, [
      puestos,
      gapsPorTarjeta,
      gapsPorFila,
      escalasPorPuesto,
      escalasPorTarjeta,
      detectarCambios,
      esCreador,
      obtenerPuestosConPreferencias,
   ]);

   /**
    * Sincroniza cambios visuales de un invitado a preferencias_usuario
    */
   const sincronizarCambiosInvitado = useCallback(
      async (cambios) => {
         try {
            // Guardar cambios de puestos en preferencias
            for (const { id, campos } of cambios.puestos) {
               const prefsToSave = {};
               if (campos.color !== undefined) prefsToSave.color = campos.color;
               if (campos.bgColor !== undefined) prefsToSave.bg_color = campos.bgColor;
               if (campos.gapsVerticales !== undefined) prefsToSave.gapsVerticales = campos.gapsVerticales;
               if (campos.escala !== undefined) prefsToSave.escala = campos.escala;

               if (Object.keys(prefsToSave).length > 0) {
                  await preferenciasVisualesHook.guardarPreferenciasPuesto(id, prefsToSave);
               }
            }

            // Guardar cambios de alimentadores en preferencias
            for (const { id, campos } of cambios.alimentadores) {
               const prefsToSave = {};
               if (campos.color !== undefined) prefsToSave.color = campos.color;
               if (campos.gapHorizontal !== undefined) prefsToSave.gapHorizontal = campos.gapHorizontal;
               if (campos.escala !== undefined) prefsToSave.escala = campos.escala;

               if (Object.keys(prefsToSave).length > 0) {
                  await preferenciasVisualesHook.guardarPreferenciasAlimentador(id, prefsToSave);
               }
            }

            return true;
         } catch (error) {
            console.error("Error sincronizando preferencias de invitado:", error);
            throw error;
         }
      },
      [preferenciasVisualesHook]
   );

   /**
    * Sincroniza cambios con BD
    * Creadores: guarda en BASE
    * Invitados: guarda cambios visuales en preferencias_usuario
    */
   const sincronizarCambios = useCallback(async () => {
      if (!hayCambiosPendientes) return;

      const puestosParaSync = esCreador ? puestos : obtenerPuestosConPreferencias();
      const gapsPorFilaPorPuesto = construirGapsPorFilaPorPuesto(puestosParaSync, gapsPorFila);
      const { cambios } = detectarCambios(
         puestosParaSync,
         gapsPorTarjeta,
         gapsPorFilaPorPuesto,
         escalasPorPuesto,
         escalasPorTarjeta
      );

      const limpiarLocalStorage = () => {
         preferenciasHook.resetearTodosLosGaps();
         preferenciasHook.resetearTodosLosRowGaps();
         preferenciasHook.resetearTodasLasEscalasPuestos();
         preferenciasHook.resetearTodasLasEscalasTarjetas();
      };

      if (esCreador) {
         await sincronizarConBD(
            cambios,
            async () => {
               limpiarLocalStorage();
               setSnapshotGuardado(false);
               await puestosHook.cargarPuestos();
            },
            (error) => {
               console.error("Error al sincronizar:", error);
            }
         );
      } else {
         try {
            await sincronizarCambiosInvitado(cambios);
            limpiarLocalStorage();
            await preferenciasVisualesHook.cargarPreferencias();
            setSnapshotGuardado(false);
            await puestosHook.cargarPuestos();
         } catch (error) {
            console.error("Error al sincronizar preferencias:", error);
         }
      }
   }, [
      hayCambiosPendientes,
      puestos,
      gapsPorTarjeta,
      gapsPorFila,
      escalasPorPuesto,
      escalasPorTarjeta,
      detectarCambios,
      sincronizarConBD,
      puestosHook,
      preferenciasHook,
      esCreador,
      sincronizarCambiosInvitado,
      preferenciasVisualesHook,
      obtenerPuestosConPreferencias,
   ]);

   /**
    * Descarta cambios y restaura datos originales
    */
   const descartarCambios = useCallback(async () => {
      preferenciasHook.resetearTodosLosGaps();
      preferenciasHook.resetearTodosLosRowGaps();
      preferenciasHook.resetearTodasLasEscalasPuestos();
      preferenciasHook.resetearTodasLasEscalasTarjetas();
      setSnapshotGuardado(false);

      if (!esCreador) {
         await preferenciasVisualesHook.cargarPreferencias();
      }

      await puestosHook.cargarPuestos();
   }, [preferenciasHook, puestosHook, esCreador, preferenciasVisualesHook]);

   return {
      hayCambiosPendientes,
      sincronizando,
      errorSincronizacion,
      sincronizarCambios,
      descartarCambios,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/puestos/index.js =====

// hooks/puestos/index.js
// Hooks relacionados con puestos, alimentadores y drag & drop

export { usePuestosSupabase } from "./usePuestosSupabase";
export { useArrastrarSoltar } from "./useArrastrarSoltar";
export { useCambiosPendientes } from "./useCambiosPendientes";
export { usePreferenciasVisualesPuestos } from "./usePreferenciasVisualesPuestos";
export { useGestionPuestos } from "./useGestionPuestos";
export { useGestionAlimentadores } from "./useGestionAlimentadores";
export { useDragDropAlimentadores } from "./useDragDropAlimentadores";

// ===== ./src/paginas/PaginaAlimentadores/hooks/puestos/useArrastrarSoltar.js =====

// src/paginas/PaginaAlimentadores/hooks/usarArrastrarSoltar.js

import { useState } from "react"; // hook de React para manejar estado local

/**
 * Hook personalizado para manejar drag & drop (arrastrar y soltar).
 * Simplifica la l√≥gica de reordenamiento de alimentadores.
 *
 * @returns {Object} Estado y funciones para drag & drop.
 */
export const useArrastrarSoltar = () => {
	// ID del elemento que se est√° arrastrando actualmente (o null si ninguno)
	const [elementoArrastrandoId, setElementoArrastrandoId] = useState(null);

	/**
	 * Maneja el inicio del arrastre.
	 *
	 * @param {number} id - ID del elemento arrastrado.
	 */
	const alIniciarArrastre = (id) => {
		setElementoArrastrandoId(id);
	};

	/**
	 * Maneja el fin del arrastre.
	 * Limpia el estado interno.
	 */
	const alTerminarArrastre = () => {
		setElementoArrastrandoId(null);
	};

	/**
	 * Permite que un elemento sea un destino v√°lido de drop.
	 *
	 * @param {DragEvent} evento - Evento dragover.
	 */
	const alPasarPorEncima = (evento) => {
		evento.preventDefault(); // sin esto, el navegador no permite soltar
	};

	/**
	 * Reordena una lista moviendo un elemento a la posici√≥n de otro.
	 *
	 * @param {Array} lista - Lista original.
	 * @param {number} idOrigen - ID del elemento a mover.
	 * @param {number} idDestino - ID del elemento destino.
	 * @returns {Array} Nueva lista reordenada.
	 */
	const reordenarLista = (lista, idOrigen, idDestino) => {
		if (idOrigen === idDestino) return lista; // nada que hacer si son el mismo

		const nuevaLista = [...lista];
		const indiceOrigen = nuevaLista.findIndex((item) => item.id === idOrigen);
		const indiceDestino = nuevaLista.findIndex((item) => item.id === idDestino);

		if (indiceOrigen === -1 || indiceDestino === -1) return lista; // ids inv√°lidos

		// Remover elemento del origen
		const [elementoMovido] = nuevaLista.splice(indiceOrigen, 1);

		// Insertar en la posici√≥n destino
		nuevaLista.splice(indiceDestino, 0, elementoMovido);

		return nuevaLista;
	};

	/**
	 * Mueve un elemento al final de la lista.
	 *
	 * @param {Array} lista - Lista original.
	 * @param {number} idElemento - ID del elemento a mover.
	 * @returns {Array} Nueva lista con elemento al final.
	 */
	const moverAlFinal = (lista, idElemento) => {
		const nuevaLista = [...lista];
		const indice = nuevaLista.findIndex((item) => item.id === idElemento);

		if (indice === -1) return lista; // id no encontrado

		// Remover y agregar al final
		const [elementoMovido] = nuevaLista.splice(indice, 1);
		nuevaLista.push(elementoMovido);

		return nuevaLista;
	};

	return {
		// Estado
		elementoArrastrandoId,
		estaArrastrando: elementoArrastrandoId !== null,

		// Handlers de eventos
		alIniciarArrastre,
		alTerminarArrastre,
		alPasarPorEncima,

		// Funciones de utilidad
		reordenarLista,
		moverAlFinal,
	};
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (usarArrastrarSoltar.js)

 - Este hook concentra la l√≥gica de drag & drop usada para reordenar tarjetas
   de alimentadores en la grilla.

 - `elementoArrastrandoId` guarda el id de la tarjeta que estoy arrastrando; si
   es `null`, significa que no hay ning√∫n drag activo. La propiedad derivada
   `estaArrastrando` es simplemente un atajo (`id !== null`).

 - `alIniciarArrastre(id)` se llama en `onDragStart` de una tarjeta: marca qu√©
   tarjeta se est√° moviendo.

 - `alTerminarArrastre()` se llama en `onDragEnd` o despu√©s de soltar: limpia el
   estado y vuelve todo a "sin arrastre".

 - `alPasarPorEncima(evento)` se usa en `onDragOver` de los destinos; la llamada
   a `evento.preventDefault()` es lo que le dice al navegador "ac√° s√≠ se puede
   soltar", sin eso el drop no se dispara.

 - `reordenarLista(lista, idOrigen, idDestino)` recibe la lista actual de
   alimentadores y los ids origen/destino, calcula los √≠ndices y devuelve una
   nueva lista con el elemento movido a la posici√≥n correcta.

 - `moverAlFinal(lista, idElemento)` se usa para el √°rea de "solt√° ac√° para
   enviar al final": quita el elemento de su posici√≥n actual y lo agrega al
   final del array.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (usarArrastrarSoltar.js)

0) Visi√≥n general del hook

   Este hook encapsula toda la l√≥gica b√°sica de ‚Äúarrastrar y soltar‚Äù que se usa para reordenar tarjetas de 
	alimentadores.

   La idea es que los componentes de UI no tengan que:
     - recordar qu√© tarjeta se est√° arrastrando,
     - calcular a mano el nuevo orden,
     - ni saber c√≥mo funciona el drag & drop nativo del navegador.

   En cambio, solo usan:
     - estado: `elementoArrastrandoId` y `estaArrastrando`,
     - handlers: `alIniciarArrastre`, `alTerminarArrastre`, `alPasarPorEncima`,
     - utilidades: `reordenarLista` y `moverAlFinal`.


1) Estado: elementoArrastrandoId

   const [elementoArrastrandoId, setElementoArrastrandoId] = useState(null);

   - Guarda el id del elemento (tarjeta) que se est√° arrastrando en este momento.

   - Si vale `null`, significa que actualmente NO hay ning√∫n drag activo.

   - Es el ‚Äúmarcador‚Äù que nos permite saber:
       ‚Ä¢ qui√©n es el origen,
       ‚Ä¢ qu√© elemento hay que mover cuando se suelta sobre otro,
       ‚Ä¢ o si debemos mostrar estilos especiales cuando hay un arrastre activo.

   En el return se expone tambi√©n:

     estaArrastrando: elementoArrastrandoId !== null

   - Es un booleano derivado:
       ‚Ä¢ true  ‚Üí si hay algo en movimiento,
       ‚Ä¢ false ‚Üí si no.

   - Sirve para que la UI pueda cambiar estilos (por ejemplo, resaltar zonas de drop) sin tener que 
	  comparar directamente contra `null`.


2) alIniciarArrastre

   const alIniciarArrastre = (id) => {
     setElementoArrastrandoId(id);
   };

   - Se llama normalmente desde el evento `onDragStart` de una tarjeta.

   - Recibe el `id` del elemento que se empez√≥ a arrastrar.

   - Actualiza el estado `elementoArrastrandoId` con ese id.

   - En otras palabras:
       ‚Ä¢ marca ‚Äúesta tarjeta es la que estoy moviendo‚Äù.

   - A partir de ese momento, las funciones de reordenamiento pueden usar ese id como `idOrigen`.


3) alTerminarArrastre

   const alTerminarArrastre = () => {
     setElementoArrastrandoId(null);
   };

   - Se llama al finalizar el drag:
       ‚Ä¢ t√≠picamente en `onDragEnd`,
       ‚Ä¢ o despu√©s de procesar un drop exitoso.

   - Vuelve a poner `elementoArrastrandoId` en `null`.

   - Deja al hook en estado ‚Äúneutral‚Äù:
       ‚Ä¢ no hay arrastres activos,
       ‚Ä¢ `estaArrastrando` pasa a ser `false`.

   - Es importante para que no queden marcadas tarjetas como si siguieran en movimiento.


4) alPasarPorEncima

   const alPasarPorEncima = (evento) => {
     evento.preventDefault();
   };

   - Se usa en el evento `onDragOver` de los elementos que pueden recibir un drop 
	  (por ejemplo, otras tarjetas o una zona especial ‚Äúsoltar aqu√≠‚Äù).

   - La llamada a `evento.preventDefault()` es la clave:
       ‚Ä¢ por defecto, el navegador NO permite soltar en todos lados,
       ‚Ä¢ al hacer preventDefault() le indicamos que este elemento S√ç acepta drops.

   - Si no se llama a esto, el evento `onDrop` no se dispara en ese destino.


5) reordenarLista

   const reordenarLista = (lista, idOrigen, idDestino) => {
     if (idOrigen === idDestino) return lista;

     const nuevaLista = [...lista];
     const indiceOrigen = nuevaLista.findIndex((item) => item.id === idOrigen);
     const indiceDestino = nuevaLista.findIndex((item) => item.id === idDestino);

     if (indiceOrigen === -1 || indiceDestino === -1) return lista;

     const [elementoMovido] = nuevaLista.splice(indiceOrigen, 1);
     nuevaLista.splice(indiceDestino, 0, elementoMovido);

     return nuevaLista;
   };

   - Esta funci√≥n no toca el estado por s√≠ misma, solo calcula un NUEVO array.

   - Recibe:
       ‚Ä¢ `lista`: la lista actual de elementos (ej: alimentadores),
       ‚Ä¢ `idOrigen`: id del elemento que se est√° moviendo,
       ‚Ä¢ `idDestino`: id del elemento sobre el que se suelta.

   - Pasos que sigue:
       1) Si el origen y el destino son el mismo id, no hace nada y devuelve la lista tal cual (no tiene sentido moverlo sobre s√≠ mismo).
		 
       2) Clona la lista original con `[...]` para no mutarla directamente.

       3) Busca las posiciones (√≠ndices) de origen y destino en ese nuevo array.

       4) Si alguno de los ids no existe (`findIndex === -1`), devuelve la lista sin cambios.

       5) Usa `splice` para:
            ‚Ä¢ sacar el elemento de su posici√≥n original,
            ‚Ä¢ y volver a insertarlo en la posici√≥n del destino.

       6) Devuelve la `nuevaLista` con el elemento movido.

   - Esta funci√≥n suele usarse junto con el estado de `puestos`:
       ‚Ä¢ primero se calcula el nuevo orden de alimentadores con `reordenarLista`,
       ‚Ä¢ luego se guarda ese orden llamando a `reordenarAlimentadores` del hook `usarPuestos`.


6) moverAlFinal

   const moverAlFinal = (lista, idElemento) => {
     const nuevaLista = [...lista];
     const indice = nuevaLista.findIndex((item) => item.id === idElemento);

     if (indice === -1) return lista;

     const [elementoMovido] = nuevaLista.splice(indice, 1);
     nuevaLista.push(elementoMovido);

     return nuevaLista;
   };

   - Permite tomar un elemento de la lista y mandarlo al final.

   - Recibe:
       ‚Ä¢ `lista`: lista original,
       ‚Ä¢ `idElemento`: id del elemento que queremos mover.

   - Pasos:
       1) Clona la lista para no mutar la original.
       2) Busca el √≠ndice del elemento con ese id.
       3) Si no lo encuentra, devuelve la lista original.
       4) Usa `splice` para quitarlo de donde est√°,
       5) y luego `push` para agregarlo al final.

   - Esta funci√≥n est√° pensada para zonas como:
       ‚Ä¢ ‚Äúsolt√° ac√° para enviar al final‚Äù, donde no interesa la posici√≥n exacta del destino, solo que el elemento
       vaya al √∫ltimo lugar.


7) return del hook

   return {
     // Estado
     elementoArrastrandoId,
     estaArrastrando: elementoArrastrandoId !== null,

     // Handlers de eventos
     alIniciarArrastre,
     alTerminarArrastre,
     alPasarPorEncima,

     // Funciones de utilidad
     reordenarLista,
     moverAlFinal,
   };

   - Expone:
       ‚Ä¢ `elementoArrastrandoId`: id actual en movimiento (o null),
       ‚Ä¢ `estaArrastrando`: booleano de conveniencia para la UI.
		 
   - Y las funciones que la vista usa directamente:
       ‚Ä¢ `alIniciarArrastre`   ‚Üí se pega a `onDragStart`,
       ‚Ä¢ `alTerminarArrastre`  ‚Üí se pega a `onDragEnd` / luego de un drop,
       ‚Ä¢ `alPasarPorEncima`    ‚Üí se pega a `onDragOver`,
       ‚Ä¢ `reordenarLista` y `moverAlFinal` ‚Üí sirven para calcular el nuevo
         orden antes de actualizar el estado global de puestos/alimentadores.
---------------------------------------------------------------------------*/

// ===== ./src/paginas/PaginaAlimentadores/hooks/puestos/useCambiosPendientes.js =====

// src/paginas/PaginaAlimentadores/hooks/usarCambiosPendientes.js
// Hook para manejar cambios pendientes de sincronizaci√≥n con la BD
//
// Conceptos:
// - Pbase: Par√°metros guardados en la base de datos (snapshot)
// - Pnavegador: Par√°metros actuales en el navegador (estado local + localStorage)
//
// El bot√≥n "Guardar" se habilita cuando Pbase !== Pnavegador, incluyendo:
// - Valores diferentes (colores, gaps)
// - Elementos nuevos en Pnavegador que no existen en Pbase (alimentadores agregados)
// - Elementos eliminados de Pnavegador que s√≠ existen en Pbase (alimentadores borrados)
// - Diferente cantidad de filas (afecta gaps verticales)

import { useState, useCallback, useRef } from "react";
import {
  actualizarPuesto as actualizarPuestoAPI,
  actualizarAlimentadorAPI,
  reordenarAlimentadores as reordenarAlimentadoresAPI,
} from "../../../../servicios/apiService";

/**
 * Hook para detectar y sincronizar cambios pendientes entre estado local y BD.
 *
 * Trackea:
 * - Colores de puestos (color, bgColor)
 * - Gaps verticales de puestos (por fila)
 * - Escala de puestos
 * - Colores de alimentadores
 * - Gaps horizontales de alimentadores
 * - Escala de alimentadores (individual)
 * - Orden de alimentadores
 * - Cantidad de alimentadores (elementos nuevos/eliminados)
 *
 * NO trackea (van directo a BD):
 * - Crear/eliminar puestos
 * - Crear/eliminar alimentadores
 * - Configuraci√≥n Modbus
 */
export const useCambiosPendientes = () => {
  // Snapshot original de los datos cargados de BD (Pbase)
  const snapshotRef = useRef({
    puestos: {},      // { [id]: { color, bgColor, gapsVerticales, cantidadAlimentadores, escala } }
    alimentadores: {}, // { [id]: { color, gapHorizontal, orden, puestoId, escala } }
    alimentadoresIds: new Set(), // Set de IDs de alimentadores en Pbase
  });

  // Estado de sincronizaci√≥n
  const [sincronizando, setSincronizando] = useState(false);
  const [errorSincronizacion, setErrorSincronizacion] = useState(null);

  /**
   * Guarda el snapshot original de los datos cargados de BD (Pbase).
   * Llamar despu√©s de cargar datos del backend.
   *
   * IMPORTANTE: Todos los IDs se guardan como strings para evitar
   * problemas de comparaci√≥n entre tipos (n√∫meros vs strings).
   */
  const guardarSnapshot = useCallback((puestos) => {
    const snapshot = {
      puestos: {},
      alimentadores: {},
      alimentadoresIds: new Set(), // Set de strings
    };

    puestos.forEach((puesto) => {
      const alimentadoresDelPuesto = puesto.alimentadores || [];
      const puestoIdStr = String(puesto.id);

      snapshot.puestos[puestoIdStr] = {
        color: puesto.color,
        bgColor: puesto.bgColor || puesto.bg_color,
        gapsVerticales: JSON.stringify(puesto.gapsVerticales || { "0": 40 }),
        cantidadAlimentadores: alimentadoresDelPuesto.length,
        escala: puesto.escala, // null si no est√° definida en BD
      };

      alimentadoresDelPuesto.forEach((alim, index) => {
        const alimIdStr = String(alim.id);
        snapshot.alimentadores[alimIdStr] = {
          color: alim.color,
          gapHorizontal: alim.gapHorizontal ?? 10,
          orden: index,
          puestoId: puestoIdStr, // tambi√©n string
          escala: alim.escala, // null si no est√° definida en BD
        };
        snapshot.alimentadoresIds.add(alimIdStr);
      });
    });

    snapshotRef.current = snapshot;
  }, []);

  /**
   * Detecta si hay cambios entre el estado actual (Pnavegador) y el snapshot (Pbase).
   *
   * Detecta:
   * 1. Cambios en valores existentes (colores, gaps)
   * 2. Alimentadores nuevos (en Pnavegador pero no en Pbase)
   * 3. Alimentadores eliminados (en Pbase pero no en Pnavegador)
   * 4. Cambios en cantidad de filas (afecta gaps verticales)
   *
   * @param {Array} puestosActuales - Lista actual de puestos con alimentadores
   * @param {Object} gapsPorTarjeta - Gaps horizontales de localStorage { alimId: gap }
   * @param {Object} gapsPorFilaPorPuesto - Gaps verticales de localStorage por puesto { puestoId: { "0": gap, ... } }
   * @param {Object} escalasPorPuesto - Escalas por puesto de localStorage { puestoId: escala }
   * @param {Object} escalasPorTarjeta - Escalas por tarjeta de localStorage { alimId: escala }
   * @returns {Object} { hayCambios, cambios, hayNuevosElementos, hayElementosEliminados }
   */
  const detectarCambios = useCallback((puestosActuales, gapsPorTarjeta = {}, gapsPorFilaPorPuesto = {}, escalasPorPuesto = {}, escalasPorTarjeta = {}) => {
    const cambios = {
      puestos: [],      // [{ id, campos: { color?, bgColor?, gapsVerticales?, escala? } }]
      alimentadores: [], // [{ id, campos: { color?, gapHorizontal?, escala? } }]
      ordenPorPuesto: {}, // { puestoId: [alimentadorIds en nuevo orden] }
    };

    const snapshot = snapshotRef.current;

    // Trackear IDs actuales para detectar elementos nuevos/eliminados
    // IMPORTANTE: Usamos Set de strings para comparaci√≥n consistente
    const alimentadoresActualesIds = new Set();
    let hayNuevosElementos = false;
    let hayElementosEliminados = false;

    // Comparar puestos
    puestosActuales.forEach((puesto) => {
      const puestoIdStr = String(puesto.id);
      const original = snapshot.puestos[puestoIdStr];
      const alimentadoresDelPuesto = puesto.alimentadores || [];

      // Recolectar IDs de alimentadores actuales (como strings)
      alimentadoresDelPuesto.forEach((alim) => {
        const alimIdStr = String(alim.id);
        alimentadoresActualesIds.add(alimIdStr);

        // Detectar alimentadores nuevos (no estaban en Pbase)
        if (!snapshot.alimentadoresIds.has(alimIdStr)) {
          hayNuevosElementos = true;
        }
      });

      // Detectar cambio de orden comparando arrays de IDs (todos como strings)
      const ordenActualIds = alimentadoresDelPuesto.map(a => String(a.id));
      const ordenOriginalIds = Object.entries(snapshot.alimentadores)
        .filter(([_, data]) => data.puestoId === puestoIdStr)
        .sort((a, b) => a[1].orden - b[1].orden)
        .map(([id, _]) => id); // ya es string porque es key de objeto

      // Comparar si el orden cambi√≥ (solo si tienen la misma cantidad de elementos)
      if (ordenActualIds.length === ordenOriginalIds.length && ordenActualIds.length > 0) {
        const ordenCambio = ordenActualIds.some((id, idx) => id !== ordenOriginalIds[idx]);
        if (ordenCambio) {
          cambios.ordenPorPuesto[puesto.id] = alimentadoresDelPuesto.map(a => a.id);
        }
      }

      // Si es un puesto nuevo, no comparar valores pero s√≠ registrar sus gaps
      if (!original) {
        // Puesto nuevo: considerar como cambio si tiene gaps personalizados
        const gapsFilaActuales = gapsPorFilaPorPuesto[puesto.id] || puesto.gapsVerticales || { "0": 40 };
        const gapsDefault = JSON.stringify({ "0": 40 });
        if (JSON.stringify(gapsFilaActuales) !== gapsDefault) {
          cambios.puestos.push({ id: puesto.id, campos: { gapsVerticales: gapsFilaActuales } });
        }
        return;
      }

      const cambiosPuesto = {};
      const bgColorActual = puesto.bgColor || puesto.bg_color;

      // Comparar colores
      if (puesto.color !== original.color) {
        cambiosPuesto.color = puesto.color;
      }
      if (bgColorActual !== original.bgColor) {
        cambiosPuesto.bgColor = bgColorActual;
      }

      // Gaps verticales: combinar los de la BD con los de localStorage para este puesto
      const gapsFilaActuales = gapsPorFilaPorPuesto[puesto.id] || puesto.gapsVerticales || { "0": 40 };
      const gapsFilaActualesStr = JSON.stringify(gapsFilaActuales);
      if (gapsFilaActualesStr !== original.gapsVerticales) {
        cambiosPuesto.gapsVerticales = gapsFilaActuales;
      }

      // Detectar cambio en cantidad de alimentadores
      if (alimentadoresDelPuesto.length !== original.cantidadAlimentadores) {
        // La cantidad cambi√≥, esto puede afectar los gaps verticales
        // Asegurarse de incluir los gaps actualizados
        if (!cambiosPuesto.gapsVerticales) {
          cambiosPuesto.gapsVerticales = gapsFilaActuales;
        }
      }

      // Escala del puesto: preferir localStorage, luego valor del objeto
      // Si hay escala en localStorage, usarla; si no, usar la del puesto
      const puestoIdStrLS = String(puesto.id);
      const escalaLocalPuesto = escalasPorPuesto[puestoIdStrLS] ?? escalasPorPuesto[puesto.id];
      const escalaActualPuesto = escalaLocalPuesto !== undefined ? escalaLocalPuesto : puesto.escala;
      // Comparar con el snapshot (ambos pueden ser null)
      if (escalaActualPuesto !== original.escala) {
        cambiosPuesto.escala = escalaActualPuesto;
      }

      if (Object.keys(cambiosPuesto).length > 0) {
        cambios.puestos.push({ id: puesto.id, campos: cambiosPuesto });
      }

      // Comparar alimentadores del puesto
      alimentadoresDelPuesto.forEach((alim) => {
        const alimIdStr = String(alim.id);
        const originalAlim = snapshot.alimentadores[alimIdStr];

        // Alimentador nuevo: registrar sus gaps si son diferentes al default
        if (!originalAlim) {
          const gapActual = gapsPorTarjeta[alimIdStr] ?? gapsPorTarjeta[alim.id] ?? alim.gapHorizontal ?? 10;
          if (gapActual !== 10) { // Solo si es diferente al default
            cambios.alimentadores.push({ id: alim.id, campos: { gapHorizontal: gapActual } });
          }
          return;
        }

        const cambiosAlim = {};

        // Comparar color
        if (alim.color !== originalAlim.color) {
          cambiosAlim.color = alim.color;
        }

        // Gap horizontal: preferir localStorage, luego el del objeto
        // Buscar tanto por string como por n√∫mero en gapsPorTarjeta
        const gapActual = gapsPorTarjeta[alimIdStr] ?? gapsPorTarjeta[alim.id] ?? alim.gapHorizontal ?? 10;
        if (gapActual !== originalAlim.gapHorizontal) {
          cambiosAlim.gapHorizontal = gapActual;
        }

        // Escala individual: preferir localStorage, luego valor del objeto
        const escalaLocalAlim = escalasPorTarjeta[alimIdStr] ?? escalasPorTarjeta[alim.id];
        const escalaActualAlim = escalaLocalAlim !== undefined ? escalaLocalAlim : alim.escala;
        // Comparar con el snapshot (ambos pueden ser null)
        if (escalaActualAlim !== originalAlim.escala) {
          cambiosAlim.escala = escalaActualAlim;
        }

        if (Object.keys(cambiosAlim).length > 0) {
          cambios.alimentadores.push({ id: alim.id, campos: cambiosAlim });
        }
      });
    });

    // Detectar alimentadores eliminados (estaban en Pbase pero ya no est√°n en Pnavegador)
    // Ambos Sets ahora contienen strings
    snapshot.alimentadoresIds.forEach((idBase) => {
      if (!alimentadoresActualesIds.has(idBase)) {
        hayElementosEliminados = true;
      }
    });

    // Tambi√©n detectar si hay gaps en localStorage para alimentadores que ya no existen
    // Object.keys devuelve strings, as√≠ que la comparaci√≥n funciona
    Object.keys(gapsPorTarjeta).forEach((alimIdStr) => {
      if (!alimentadoresActualesIds.has(alimIdStr) && snapshot.alimentadoresIds.has(alimIdStr)) {
        // Hay un gap guardado para un alimentador que fue eliminado
        hayElementosEliminados = true;
      }
    });

    const hayCambios =
      cambios.puestos.length > 0 ||
      cambios.alimentadores.length > 0 ||
      Object.keys(cambios.ordenPorPuesto).length > 0 ||
      hayNuevosElementos ||
      hayElementosEliminados;

    return {
      hayCambios,
      cambios,
      hayNuevosElementos,
      hayElementosEliminados,
    };
  }, []);

  /**
   * Sincroniza todos los cambios pendientes con la BD.
   * Despu√©s de sincronizar exitosamente, el snapshot se actualiza
   * al recargar datos en el callback onSuccess.
   *
   * @param {Object} cambios - Cambios detectados por detectarCambios()
   * @param {Function} onSuccess - Callback al completar exitosamente (puede ser async)
   * @param {Function} onError - Callback en caso de error
   */
  const sincronizarConBD = useCallback(async (cambios, onSuccess, onError) => {
    setSincronizando(true);
    setErrorSincronizacion(null);

    try {
      // 1. Actualizar puestos
      for (const { id, campos } of cambios.puestos) {
        const datosAPI = {};
        if (campos.color !== undefined) datosAPI.color = campos.color;
        if (campos.bgColor !== undefined) datosAPI.bg_color = campos.bgColor;
        if (campos.gapsVerticales !== undefined) datosAPI.gaps_verticales = campos.gapsVerticales;
        if (campos.escala !== undefined) datosAPI.escala = campos.escala;

        await actualizarPuestoAPI(id, datosAPI);
      }

      // 2. Actualizar alimentadores
      for (const { id, campos } of cambios.alimentadores) {
        const datosAPI = {};
        if (campos.color !== undefined) datosAPI.color = campos.color;
        if (campos.gapHorizontal !== undefined) datosAPI.gap_horizontal = campos.gapHorizontal;
        if (campos.escala !== undefined) datosAPI.escala = campos.escala;

        await actualizarAlimentadorAPI(id, datosAPI);
      }

      // 3. Reordenar alimentadores
      for (const [puestoId, ordenIds] of Object.entries(cambios.ordenPorPuesto)) {
        await reordenarAlimentadoresAPI(puestoId, ordenIds);
      }

      // El callback onSuccess debe recargar los datos de BD,
      // lo cual disparar√° guardarSnapshot() con los nuevos datos
      // IMPORTANTE: Esperamos al callback para mantener el overlay visible
      if (onSuccess) await onSuccess();
    } catch (error) {
      console.error("Error sincronizando cambios:", error);
      setErrorSincronizacion(error.message);
      if (onError) onError(error);
    } finally {
      setSincronizando(false);
    }
  }, []);

  /**
   * Descarta los cambios locales y recarga desde BD.
   * @param {Function} recargarDatos - Funci√≥n para recargar datos desde BD
   */
  const descartarCambios = useCallback(async (recargarDatos) => {
    if (recargarDatos) {
      await recargarDatos();
    }
  }, []);

  /**
   * Obtiene el snapshot actual (Pbase) para debugging o comparaci√≥n.
   */
  const obtenerSnapshot = useCallback(() => {
    return snapshotRef.current;
  }, []);

  return {
    // Funciones principales
    guardarSnapshot,
    detectarCambios,
    sincronizarConBD,
    descartarCambios,
    obtenerSnapshot,
    // Estado
    sincronizando,
    errorSincronizacion,
  };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/puestos/useDragDropAlimentadores.js =====

// hooks/puestos/useDragDropAlimentadores.js
// Hook para manejar drag & drop de alimentadores en la grilla

import { useCallback } from "react";

/**
 * Hook para gestionar drag & drop de tarjetas de alimentadores
 *
 * @param {Object} params
 * @param {Object} params.puestoSeleccionado - Puesto actualmente seleccionado
 * @param {string|null} params.elementoArrastrandoId - ID del elemento siendo arrastrado
 * @param {Function} params.alIniciarArrastre - Handler para iniciar arrastre
 * @param {Function} params.alTerminarArrastre - Handler para terminar arrastre
 * @param {Function} params.reordenarLista - Funci√≥n para calcular nuevo orden
 * @param {Function} params.moverAlFinal - Funci√≥n para mover al final
 * @param {Function} params.reordenarAlimentadores - Funci√≥n para guardar nuevo orden
 * @param {Function} params.establecerGap - Funci√≥n para establecer gap
 * @param {number} params.GAP_DEFAULT - Valor por defecto del gap
 * @returns {Object} Handlers para drag & drop
 */
export const useDragDropAlimentadores = ({
   puestoSeleccionado,
   elementoArrastrandoId,
   alIniciarArrastre,
   alTerminarArrastre,
   reordenarLista,
   moverAlFinal,
   reordenarAlimentadores,
   establecerGap,
   GAP_DEFAULT,
}) => {
   const handleDragStartAlim = useCallback(
      (alimId) => {
         alIniciarArrastre(alimId);
      },
      [alIniciarArrastre]
   );

   const handleDragEndAlim = useCallback(() => {
      alTerminarArrastre();
   }, [alTerminarArrastre]);

   const handleDropAlim = useCallback(
      (targetAlimId) => {
         if (!puestoSeleccionado || !elementoArrastrandoId) return;

         const nuevaLista = reordenarLista(
            puestoSeleccionado.alimentadores,
            elementoArrastrandoId,
            targetAlimId
         );

         // Resetear el gap de la tarjeta movida
         establecerGap(elementoArrastrandoId, GAP_DEFAULT);

         reordenarAlimentadores(puestoSeleccionado.id, nuevaLista);
         alTerminarArrastre();
      },
      [
         puestoSeleccionado,
         elementoArrastrandoId,
         reordenarLista,
         establecerGap,
         GAP_DEFAULT,
         reordenarAlimentadores,
         alTerminarArrastre,
      ]
   );

   const handleDropAlimAlFinal = useCallback(() => {
      if (!puestoSeleccionado || !elementoArrastrandoId) return;

      const nuevaLista = moverAlFinal(puestoSeleccionado.alimentadores, elementoArrastrandoId);

      // Resetear el gap de la tarjeta movida
      establecerGap(elementoArrastrandoId, GAP_DEFAULT);

      reordenarAlimentadores(puestoSeleccionado.id, nuevaLista);
      alTerminarArrastre();
   }, [
      puestoSeleccionado,
      elementoArrastrandoId,
      moverAlFinal,
      establecerGap,
      GAP_DEFAULT,
      reordenarAlimentadores,
      alTerminarArrastre,
   ]);

   return {
      handleDragStartAlim,
      handleDragEndAlim,
      handleDropAlim,
      handleDropAlimAlFinal,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/puestos/useGestionAlimentadores.js =====

// hooks/puestos/useGestionAlimentadores.js
// Hook para manejar operaciones CRUD de alimentadores

import { useState, useCallback } from "react";

/**
 * Hook para gestionar operaciones de alimentadores (crear, editar, eliminar)
 *
 * @param {Object} params
 * @param {Object} params.puestoSeleccionado - Puesto actualmente seleccionado
 * @param {Object|null} params.alimentadorEnEdicion - Alimentador siendo editado
 * @param {string} params.modoAlimentador - Modo actual ("crear" o "editar")
 * @param {boolean} params.esCreador - Si el usuario es creador del workspace
 * @param {Object} params.preferenciasVisuales - Preferencias visuales del usuario
 * @param {Function} params.agregarAlimentador - Funci√≥n para agregar alimentador
 * @param {Function} params.actualizarAlimentador - Funci√≥n para actualizar alimentador
 * @param {Function} params.eliminarAlimentador - Funci√≥n para eliminar alimentador
 * @param {Function} params.detenerMedicion - Funci√≥n para detener medici√≥n
 * @param {Function} params.obtenerGap - Funci√≥n para obtener gap
 * @param {Function} params.establecerGap - Funci√≥n para establecer gap
 * @param {Function} params.abrirModal - Funci√≥n para abrir modal
 * @param {Function} params.cerrarModal - Funci√≥n para cerrar modal
 * @returns {Object} Handlers y estado para gesti√≥n de alimentadores
 */
export const useGestionAlimentadores = ({
   puestoSeleccionado,
   alimentadorEnEdicion,
   modoAlimentador,
   esCreador,
   preferenciasVisuales,
   agregarAlimentador,
   actualizarAlimentador,
   eliminarAlimentador,
   detenerMedicion,
   obtenerGap,
   establecerGap,
   abrirModal,
   cerrarModal,
}) => {
   const [guardandoAlimentador, setGuardandoAlimentador] = useState(false);

   // Abrir modal para crear nuevo alimentador
   const abrirModalNuevoAlim = useCallback(
      () => abrirModal("alimentador", { modo: "crear" }),
      [abrirModal]
   );

   // Abrir modal para editar alimentador existente
   const abrirModalEditarAlim = useCallback(
      (_puestoId, alimentador) =>
         abrirModal("alimentador", { modo: "editar", alimentadorId: alimentador.id }),
      [abrirModal]
   );

   // Guardar alimentador (crear o editar)
   const handleGuardarAlimentador = useCallback(
      async (datos) => {
         if (!datos || !datos.nombre || !puestoSeleccionado) return;

         // Solo mostrar skeleton si estamos creando
         if (modoAlimentador === "crear") {
            setGuardandoAlimentador(true);
            cerrarModal("alimentador");
         }

         try {
            if (modoAlimentador === "crear") {
               const nuevoAlimentador = await agregarAlimentador(datos);
               // Establecer gap horizontal inicial
               if (nuevoAlimentador?.id) {
                  establecerGap(nuevoAlimentador.id, 10);
               }
            } else if (alimentadorEnEdicion) {
               if (esCreador) {
                  // CREADOR: Guardar todo en BD
                  const gapActual = obtenerGap(alimentadorEnEdicion.id);
                  await actualizarAlimentador(puestoSeleccionado.id, alimentadorEnEdicion.id, {
                     ...datos,
                     gapHorizontal: gapActual,
                  });
               } else {
                  // INVITADO: Solo guardar el color en preferencias personales
                  if (datos.color && preferenciasVisuales?.guardarPreferenciasAlimentador) {
                     await preferenciasVisuales.guardarPreferenciasAlimentador(
                        alimentadorEnEdicion.id,
                        { color: datos.color }
                     );
                  }
               }
               cerrarModal("alimentador");
            }
         } catch (error) {
            console.error("Error guardando alimentador:", error);
            setGuardandoAlimentador(false);
         } finally {
            if (modoAlimentador === "crear") {
               setTimeout(() => {
                  setGuardandoAlimentador(false);
               }, 300);
            }
         }
      },
      [
         puestoSeleccionado,
         modoAlimentador,
         alimentadorEnEdicion,
         esCreador,
         preferenciasVisuales,
         agregarAlimentador,
         actualizarAlimentador,
         obtenerGap,
         establecerGap,
         cerrarModal,
      ]
   );

   // Eliminar alimentador
   const handleEliminarAlimentador = useCallback(() => {
      if (!puestoSeleccionado || !alimentadorEnEdicion) return;

      // Detener mediciones antes de eliminar
      detenerMedicion(alimentadorEnEdicion.id, "rele");
      detenerMedicion(alimentadorEnEdicion.id, "analizador");

      eliminarAlimentador(puestoSeleccionado.id, alimentadorEnEdicion.id);
      cerrarModal("alimentador");
   }, [puestoSeleccionado, alimentadorEnEdicion, detenerMedicion, eliminarAlimentador, cerrarModal]);

   return {
      guardandoAlimentador,
      abrirModalNuevoAlim,
      abrirModalEditarAlim,
      handleGuardarAlimentador,
      handleEliminarAlimentador,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/puestos/useGestionPuestos.js =====

// hooks/puestos/useGestionPuestos.js
// Hook para manejar operaciones CRUD de puestos

import { useState, useCallback } from "react";

/**
 * Hook para gestionar operaciones de puestos (crear, editar, eliminar)
 *
 * @param {Object} params
 * @param {Array} params.puestos - Lista de puestos actuales
 * @param {Function} params.agregarPuesto - Funci√≥n para agregar puesto
 * @param {Function} params.eliminarPuesto - Funci√≥n para eliminar puesto
 * @param {Function} params.actualizarPuestos - Funci√≥n para actualizar puestos
 * @param {Function} params.resetearEscalaTarjeta - Funci√≥n para resetear escala
 * @param {Function} params.establecerEscalaPuesto - Funci√≥n para establecer escala de puesto
 * @param {Function} params.abrirModal - Funci√≥n para abrir modal
 * @param {Function} params.cerrarModal - Funci√≥n para cerrar modal
 * @returns {Object} Handlers y estado para gesti√≥n de puestos
 */
export const useGestionPuestos = ({
   puestos,
   agregarPuesto,
   eliminarPuesto,
   actualizarPuestos,
   resetearEscalaTarjeta,
   establecerEscalaPuesto,
   abrirModal,
   cerrarModal,
}) => {
   const [guardandoPuestos, setGuardandoPuestos] = useState(false);

   // Abrir modales
   const abrirModalNuevoPuesto = useCallback(() => abrirModal("nuevoPuesto"), [abrirModal]);
   const abrirModalEditarPuestos = useCallback(() => abrirModal("editarPuestos"), [abrirModal]);
   const abrirModalConfigPuesto = useCallback(() => abrirModal("configPuesto"), [abrirModal]);

   // Crear puesto
   const handleCrearPuesto = useCallback(
      (nombre, color) => {
         agregarPuesto(nombre, color);
         cerrarModal("nuevoPuesto");
      },
      [agregarPuesto, cerrarModal]
   );

   // Guardar puestos editados
   const handleGuardarPuestos = useCallback(
      async (puestosEditados) => {
         cerrarModal("editarPuestos");
         setGuardandoPuestos(true);

         try {
            // Detectar puestos eliminados
            const idsEditados = new Set(puestosEditados.map((p) => p.id));
            const puestosEliminados = puestos.filter((p) => !idsEditados.has(p.id));

            // Primero eliminar los puestos que fueron removidos
            for (const puesto of puestosEliminados) {
               await eliminarPuesto(puesto.id);
            }

            // Luego actualizar los puestos restantes
            if (puestosEditados.length > 0) {
               await actualizarPuestos(puestosEditados);
            }
         } catch (error) {
            console.error("Error guardando puestos:", error);
         } finally {
            setGuardandoPuestos(false);
         }
      },
      [puestos, eliminarPuesto, actualizarPuestos, cerrarModal]
   );

   // Handler para cambio de escala de puesto
   const handleEscalaPuestoChange = useCallback(
      (puestoId, escala) => {
         const puesto = puestos.find((p) => p.id === puestoId);
         if (puesto && puesto.alimentadores) {
            // Limpiar las escalas individuales de todos los alimentadores del puesto
            puesto.alimentadores.forEach((alim) => {
               resetearEscalaTarjeta(alim.id);
            });
         }
         establecerEscalaPuesto(puestoId, escala);
      },
      [puestos, establecerEscalaPuesto, resetearEscalaTarjeta]
   );

   return {
      guardandoPuestos,
      abrirModalNuevoPuesto,
      abrirModalEditarPuestos,
      abrirModalConfigPuesto,
      handleCrearPuesto,
      handleGuardarPuestos,
      handleEscalaPuestoChange,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/puestos/usePreferenciasVisualesPuestos.js =====

// hooks/puestos/usePreferenciasVisualesPuestos.js
// Hook para aplicar preferencias visuales personales sobre puestos y alimentadores

import { useMemo } from "react";

/**
 * Hook que aplica preferencias visuales personales (color, ocultos, etc.) sobre puestos y alimentadores base.
 * Para invitados: aplica configuraci√≥n personal. Para creadores: usa datos base sin cambios.
 *
 * @param {Object} params
 * @param {boolean} params.esCreador - Si el usuario es creador del workspace
 * @param {Array} params.puestos - Lista de puestos base desde BD
 * @param {Object} params.puestoSeleccionado - Puesto actualmente seleccionado
 * @param {Object|null} params.preferenciasVisuales - Objeto con funciones para obtener preferencias personales
 * @returns {Object} Puestos y alimentadores con preferencias aplicadas
 */
export const usePreferenciasVisualesPuestos = ({
   esCreador,
   puestos,
   puestoSeleccionado,
   preferenciasVisuales,
}) => {
   // Puestos con preferencias (para modal de edici√≥n)
   const puestosConPreferencias = useMemo(() => {
      if (esCreador || !preferenciasVisuales) {
         return puestos;
      }

      return puestos.map((puesto) => {
         const configPuesto = preferenciasVisuales.obtenerConfigPuesto?.(puesto.id);

         return {
            ...puesto,
            color: configPuesto?.color || puesto.color,
            bgColor: configPuesto?.bg_color || puesto.bgColor || puesto.bg_color,
            alimentadores: (puesto.alimentadores || []).map((alim) => {
               const configAlim = preferenciasVisuales.obtenerConfigAlimentador?.(alim.id, puesto.id);
               return {
                  ...alim,
                  color: configAlim?.color || alim.color,
               };
            }),
         };
      });
   }, [esCreador, puestos, preferenciasVisuales]);

   // Alimentadores del puesto seleccionado con preferencias aplicadas
   const alimentadoresConPreferencias = useMemo(() => {
      if (!puestoSeleccionado?.alimentadores) return [];
      if (esCreador || !preferenciasVisuales) {
         return puestoSeleccionado.alimentadores;
      }

      return puestoSeleccionado.alimentadores.map((alim) => {
         const configAlim = preferenciasVisuales.obtenerConfigAlimentador?.(alim.id, puestoSeleccionado.id);

         const alimConPrefs = {
            ...alim,
            color: configAlim?.color || alim.color,
         };

         // Aplicar intervalo personalizado si existe
         if (configAlim?.intervalo_consulta_ms !== undefined) {
            alimConPrefs.intervalo_consulta_ms = configAlim.intervalo_consulta_ms;
         }

         // Aplicar estados "oculto" personalizados a las zonas del card_design
         if (configAlim?.oculto_superior !== undefined || configAlim?.oculto_inferior !== undefined) {
            alimConPrefs.card_design = {
               ...alim.card_design,
               superior: {
                  ...alim.card_design?.superior,
                  ...(configAlim?.oculto_superior !== undefined && { oculto: configAlim.oculto_superior }),
               },
               inferior: {
                  ...alim.card_design?.inferior,
                  ...(configAlim?.oculto_inferior !== undefined && { oculto: configAlim.oculto_inferior }),
               },
            };
         }

         return alimConPrefs;
      });
   }, [esCreador, puestoSeleccionado, preferenciasVisuales]);

   return {
      puestosConPreferencias,
      alimentadoresConPreferencias,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/puestos/usePuestosSupabase.js =====

// src/paginas/PaginaAlimentadores/hooks/usarPuestosSupabase.js
// Hook para manejar puestos y alimentadores usando Supabase

import { useState, useEffect, useCallback } from "react";
import {
  obtenerPuestos,
  crearPuesto,
  actualizarPuesto,
  eliminarPuesto as eliminarPuestoAPI,
  obtenerAlimentadores,
  crearAlimentador,
  actualizarAlimentadorAPI,
  eliminarAlimentadorAPI,
  reordenarAlimentadores as reordenarAlimentadoresAPI,
} from "../../../../servicios/apiService";
import { CLAVES_STORAGE } from "../../constantes/clavesAlmacenamiento";
import { COLORES_SISTEMA } from "../../constantes/colores";

/**
 * Hook para manejar puestos y alimentadores conectados a Supabase.
 * Requiere un workspace seleccionado para funcionar.
 *
 * @param {number|null} workspaceId - ID del workspace activo
 * @returns {Object} Estado y funciones para trabajar con puestos y alimentadores.
 */
export const usePuestosSupabase = (workspaceId) => {
  const COLOR_FONDO_POR_DEFECTO = "#e5e7eb";

  // Estado: lista de puestos (cada uno con sus alimentadores)
  const [puestos, setPuestos] = useState([]);

  // Estado de carga
  const [cargando, setCargando] = useState(false);

  // Error si ocurre
  const [error, setError] = useState(null);

  // Estado: ID del puesto actualmente seleccionado
  const [puestoSeleccionadoId, setPuestoSeleccionadoId] = useState(() => {
    const idGuardado = localStorage.getItem(CLAVES_STORAGE.PUESTO_SELECCIONADO);
    return idGuardado ? Number(idGuardado) : null;
  });

  // Derivado: objeto completo del puesto seleccionado
  const puestoSeleccionado =
    puestos.find((p) => p.id === puestoSeleccionadoId) ||
    puestos[0] ||
    null;

  /**
   * Transforma un puesto de la DB al formato del frontend
   * Convierte snake_case a camelCase para consistencia
   */
  function transformarPuestoDeDB(puesto) {
    // Parsear gaps_verticales si viene como string JSON
    let gapsVerticales = { "0": 40 };
    if (puesto.gaps_verticales) {
      if (typeof puesto.gaps_verticales === "string") {
        try {
          gapsVerticales = JSON.parse(puesto.gaps_verticales);
        } catch {
          gapsVerticales = { "0": 40 };
        }
      } else {
        gapsVerticales = puesto.gaps_verticales;
      }
    }

    return {
      ...puesto,
      bgColor: puesto.bg_color || "#e5e7eb",
      // Mantener bg_color por compatibilidad con c√≥digo existente
      bg_color: puesto.bg_color || "#e5e7eb",
      // Gaps verticales por fila
      gapsVerticales,
      // Escala del puesto (puede ser null si no est√° definida)
      escala: puesto.escala != null ? puesto.escala : null,
    };
  }

  /**
   * Carga los puestos y sus alimentadores desde el backend
   */
  const cargarPuestos = useCallback(async () => {
    if (!workspaceId) {
      setPuestos([]);
      return;
    }

    try {
      setCargando(true);
      setError(null);

      // Obtener puestos del workspace
      const puestosData = await obtenerPuestos(workspaceId);

      // Para cada puesto, cargar sus alimentadores
      const puestosConAlimentadores = await Promise.all(
        puestosData.map(async (puesto) => {
          try {
            const alimentadores = await obtenerAlimentadores(puesto.id);
            return {
              ...transformarPuestoDeDB(puesto),
              alimentadores: alimentadores.map(transformarAlimentadorDeDB),
            };
          } catch (err) {
            console.error(`Error cargando alimentadores del puesto ${puesto.id}:`, err);
            return { ...transformarPuestoDeDB(puesto), alimentadores: [] };
          }
        })
      );

      setPuestos(puestosConAlimentadores);

      // Auto-seleccionar primer puesto si no hay selecci√≥n v√°lida
      if (puestosConAlimentadores.length > 0) {
        const seleccionValida = puestosConAlimentadores.some(
          (p) => p.id === puestoSeleccionadoId
        );
        if (!seleccionValida) {
          setPuestoSeleccionadoId(puestosConAlimentadores[0].id);
        }
      }
    } catch (err) {
      console.error("Error cargando puestos:", err);
      setError(err.message);
    } finally {
      setCargando(false);
    }
  }, [workspaceId, puestoSeleccionadoId]);

  // Cargar puestos cuando cambie el workspace
  useEffect(() => {
    cargarPuestos();
  }, [workspaceId]);

  // Guardar selecci√≥n de puesto en localStorage
  useEffect(() => {
    if (puestoSeleccionadoId != null) {
      localStorage.setItem(CLAVES_STORAGE.PUESTO_SELECCIONADO, puestoSeleccionadoId.toString());
    } else {
      localStorage.removeItem(CLAVES_STORAGE.PUESTO_SELECCIONADO);
    }
  }, [puestoSeleccionadoId]);

  /**
   * Transforma un alimentador de la DB al formato del frontend
   * Genera el formato con objetos rele/analizador que espera el modal
   * Tambi√©n soporta el nuevo formato con registrador_id, intervalo_consulta_ms y card_design
   */
  function transformarAlimentadorDeDB(alim) {
    // Para campos num√©ricos opcionales: si no hay valor en DB, devolver null/undefined
    // para que el modal muestre el placeholder en lugar de un valor por defecto
    const releConfig = alim.config_rele || {};
    const analizadorConfig = alim.config_analizador || {};

    return {
      id: alim.id,
      nombre: alim.nombre,
      color: alim.color || COLORES_SISTEMA[0],
      tipoDispositivo: alim.tipo || "rele",
      // Gap horizontal a la derecha de esta tarjeta
      gapHorizontal: alim.gap_horizontal != null ? alim.gap_horizontal : 0,
      // Escala individual de la tarjeta (puede ser null si no est√° definida)
      escala: alim.escala != null ? alim.escala : null,

      // === NUEVOS CAMPOS para el modal v2 ===
      registrador_id: alim.registrador_id || null,
      intervalo_consulta_ms: alim.intervalo_consulta_ms || 60000,
      card_design: alim.card_design || {},

      // Formato nuevo que espera el modal
      // Si no hay valor guardado, dejamos null para que se muestre el placeholder
      rele: {
        ip: releConfig.ip || "",
        puerto: releConfig.puerto != null ? releConfig.puerto : null,
        unitId: releConfig.unitId || 1,
        indiceInicial: releConfig.indiceInicial != null ? releConfig.indiceInicial : null,
        cantRegistros: releConfig.cantRegistros != null ? releConfig.cantRegistros : null,
      },
      periodoSegundos: releConfig.periodoLectura != null ? releConfig.periodoLectura : 60,
      analizador: {
        ip: analizadorConfig.ip || "",
        puerto: analizadorConfig.puerto != null ? analizadorConfig.puerto : null,
        unitId: analizadorConfig.unitId || 2,
        indiceInicial: analizadorConfig.indiceInicial != null ? analizadorConfig.indiceInicial : null,
        cantRegistros: analizadorConfig.cantRegistros != null ? analizadorConfig.cantRegistros : null,
        periodoSegundos: analizadorConfig.periodoLectura != null ? analizadorConfig.periodoLectura : 60,
      },
      // Campos legacy para compatibilidad con otras partes del c√≥digo
      ip: releConfig.ip || "",
      puerto: releConfig.puerto != null ? releConfig.puerto : null,
      unitId: releConfig.unitId || 1,
      periodoLectura: releConfig.periodoLectura != null ? releConfig.periodoLectura : 60,
      indiceInicio: releConfig.indiceInicial != null ? releConfig.indiceInicial : null,
      indiceFin: releConfig.indiceInicial != null && releConfig.cantRegistros != null
        ? releConfig.indiceInicial + releConfig.cantRegistros
        : null,
      ipAnalizador: analizadorConfig.ip || "",
      puertoAnalizador: analizadorConfig.puerto != null ? analizadorConfig.puerto : null,
      unitIdAnalizador: analizadorConfig.unitId || 2,
      periodoLecturaAnalizador: analizadorConfig.periodoLectura != null ? analizadorConfig.periodoLectura : 60,
      indiceInicioAnalizador: analizadorConfig.indiceInicial != null ? analizadorConfig.indiceInicial : null,
      indiceFinAnalizador: analizadorConfig.indiceInicial != null && analizadorConfig.cantRegistros != null
        ? analizadorConfig.indiceInicial + analizadorConfig.cantRegistros
        : null,
      mapeoMediciones: alim.mapeo_mediciones || {},
    };
  }

  /**
   * Transforma un alimentador del frontend al formato de la DB
   * Acepta tanto el formato plano (legacy) como el formato con objetos rele/analizador anidados
   * Tambi√©n soporta el nuevo formato con registrador_id, intervalo_consulta_ms y card_design
   */
  function transformarAlimentadorADB(alim) {
    // Base com√∫n para todos los formatos
    const base = {
      nombre: alim.nombre,
      color: alim.color,
    };

    // === NUEVO FORMATO: con registrador_id y card_design ===
    // El nuevo modal env√≠a: { nombre, color, registrador_id, intervalo_consulta_ms, card_design }
    if (alim.registrador_id !== undefined || alim.card_design !== undefined || alim.intervalo_consulta_ms !== undefined) {
      return {
        ...base,
        registrador_id: alim.registrador_id || null,
        intervalo_consulta_ms: alim.intervalo_consulta_ms || 60000,
        card_design: alim.card_design || {},
        gap_horizontal: alim.gapHorizontal != null ? alim.gapHorizontal : 0,
        mapeo_mediciones: alim.mapeoMediciones || {},
      };
    }

    // === FORMATO LEGACY: con objetos rele/analizador ===
    const tieneFormatoNuevo = alim.rele || alim.analizador;

    if (tieneFormatoNuevo) {
      // Formato nuevo del modal: { rele: {...}, analizador: {...} }
      // Preservar null para campos num√©ricos opcionales (puerto, indiceInicial, cantRegistros)
      // para que al cargar se muestren los placeholders en lugar de valores por defecto
      return {
        ...base,
        tipo: alim.tipoDispositivo || "rele",
        gap_horizontal: alim.gapHorizontal != null ? alim.gapHorizontal : 10,
        config_rele: alim.rele ? {
          ip: alim.rele.ip || "",
          puerto: alim.rele.puerto != null ? alim.rele.puerto : null,
          unitId: alim.rele.unitId || 1,
          periodoLectura: alim.periodoSegundos || 60,
          indiceInicial: alim.rele.indiceInicial != null ? alim.rele.indiceInicial : null,
          cantRegistros: alim.rele.cantRegistros != null ? alim.rele.cantRegistros : null,
        } : null,
        config_analizador: alim.analizador ? {
          ip: alim.analizador.ip || "",
          puerto: alim.analizador.puerto != null ? alim.analizador.puerto : null,
          unitId: alim.analizador.unitId || 2,
          periodoLectura: alim.analizador.periodoSegundos || 60,
          indiceInicial: alim.analizador.indiceInicial != null ? alim.analizador.indiceInicial : null,
          cantRegistros: alim.analizador.cantRegistros != null ? alim.analizador.cantRegistros : null,
        } : null,
        mapeo_mediciones: alim.mapeoMediciones || {},
      };
    }

    // Formato plano (legacy)
    // Preservar null para campos num√©ricos opcionales
    return {
      ...base,
      tipo: alim.tipoDispositivo || "rele",
      gap_horizontal: alim.gapHorizontal != null ? alim.gapHorizontal : 10,
      config_rele: {
        ip: alim.ip || "",
        puerto: alim.puerto != null ? alim.puerto : null,
        unitId: alim.unitId || 1,
        periodoLectura: alim.periodoLectura || 60,
        indiceInicial: alim.indiceInicio != null ? alim.indiceInicio : null,
        cantRegistros: alim.indiceFin != null && alim.indiceInicio != null
          ? (alim.indiceFin - alim.indiceInicio)
          : null,
      },
      config_analizador: {
        ip: alim.ipAnalizador || "",
        puerto: alim.puertoAnalizador != null ? alim.puertoAnalizador : null,
        unitId: alim.unitIdAnalizador || 2,
        periodoLectura: alim.periodoLecturaAnalizador || 60,
        indiceInicial: alim.indiceInicioAnalizador != null ? alim.indiceInicioAnalizador : null,
        cantRegistros: alim.indiceFinAnalizador != null && alim.indiceInicioAnalizador != null
          ? (alim.indiceFinAnalizador - alim.indiceInicioAnalizador)
          : null,
      },
      mapeo_mediciones: alim.mapeoMediciones || {},
    };
  }

  /**
   * Agrega un nuevo puesto
   */
  const agregarPuesto = async (nombrePuesto, colorPuesto) => {
    if (!workspaceId) return;

    try {
      setError(null);
      const nuevoPuesto = await crearPuesto(workspaceId, {
        nombre: nombrePuesto.trim(),
        color: colorPuesto || COLORES_SISTEMA[0],
        bg_color: COLOR_FONDO_POR_DEFECTO,
      });

      const puestoConAlimentadores = { ...nuevoPuesto, alimentadores: [] };
      setPuestos((prev) => [...prev, puestoConAlimentadores]);
      setPuestoSeleccionadoId(nuevoPuesto.id);

      return nuevoPuesto;
    } catch (err) {
      console.error("Error creando puesto:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Actualiza la lista completa de puestos (para edici√≥n masiva)
   */
  const actualizarPuestos = async (nuevaListaPuestos) => {
    const sinVacios = nuevaListaPuestos.filter((p) => p.nombre.trim() !== "");

    // Actualizar cada puesto en el backend
    try {
      setError(null);

      for (const puesto of sinVacios) {
        await actualizarPuesto(puesto.id, {
          nombre: puesto.nombre,
          color: puesto.color,
          bg_color: puesto.bgColor || puesto.bg_color,
        });
      }

      setPuestos(sinVacios);

      // Si el seleccionado se elimin√≥, seleccionar el primero
      const seleccionExiste = sinVacios.some((p) => p.id === puestoSeleccionadoId);
      if (!seleccionExiste) {
        setPuestoSeleccionadoId(sinVacios[0]?.id || null);
      }
    } catch (err) {
      console.error("Error actualizando puestos:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Elimina un puesto
   */
  const eliminarPuesto = async (idPuesto) => {
    try {
      setError(null);
      await eliminarPuestoAPI(idPuesto);
      setPuestos((prev) => prev.filter((p) => p.id !== idPuesto));

      // Si se elimin√≥ el seleccionado, seleccionar otro
      if (puestoSeleccionadoId === idPuesto) {
        const restantes = puestos.filter((p) => p.id !== idPuesto);
        setPuestoSeleccionadoId(restantes[0]?.id || null);
      }
    } catch (err) {
      console.error("Error eliminando puesto:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Selecciona un puesto como activo
   */
  const seleccionarPuesto = (idPuesto) => {
    setPuestoSeleccionadoId(idPuesto);
  };

  /**
   * Agrega un alimentador al puesto seleccionado
   */
  const agregarAlimentador = async (datosAlimentador) => {
    if (!puestoSeleccionado) return;

    try {
      setError(null);
      const datosDB = transformarAlimentadorADB(datosAlimentador);
      const nuevoAlimentador = await crearAlimentador(puestoSeleccionado.id, datosDB);

      const alimentadorFrontend = transformarAlimentadorDeDB(nuevoAlimentador);

      setPuestos((prev) =>
        prev.map((p) =>
          p.id === puestoSeleccionado.id
            ? { ...p, alimentadores: [...p.alimentadores, alimentadorFrontend] }
            : p
        )
      );

      return alimentadorFrontend;
    } catch (err) {
      console.error("Error creando alimentador:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Actualiza un alimentador existente
   */
  const actualizarAlimentador = async (idPuesto, idAlimentador, nuevosDatos) => {
    try {
      setError(null);
      const datosDB = transformarAlimentadorADB(nuevosDatos);
      const actualizado = await actualizarAlimentadorAPI(idAlimentador, datosDB);

      const alimentadorFrontend = transformarAlimentadorDeDB(actualizado);

      setPuestos((prev) =>
        prev.map((p) =>
          p.id === idPuesto
            ? {
                ...p,
                alimentadores: p.alimentadores.map((a) =>
                  a.id === idAlimentador ? alimentadorFrontend : a
                ),
              }
            : p
        )
      );

      return alimentadorFrontend;
    } catch (err) {
      console.error("Error actualizando alimentador:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Elimina un alimentador
   */
  const eliminarAlimentador = async (idPuesto, idAlimentador) => {
    try {
      setError(null);
      await eliminarAlimentadorAPI(idAlimentador);

      setPuestos((prev) =>
        prev.map((p) =>
          p.id === idPuesto
            ? { ...p, alimentadores: p.alimentadores.filter((a) => a.id !== idAlimentador) }
            : p
        )
      );
    } catch (err) {
      console.error("Error eliminando alimentador:", err);
      setError(err.message);
      throw err;
    }
  };

  /**
   * Reordena los alimentadores de un puesto (solo estado local).
   * La sincronizaci√≥n con BD se hace al presionar "Guardar cambios".
   */
  const reordenarAlimentadores = (idPuesto, nuevoOrdenAlimentadores) => {
    // Solo actualizar estado local - la sincronizaci√≥n con BD
    // se hace mediante el bot√≥n "Guardar cambios" (draft/publish pattern)
    setPuestos((prev) =>
      prev.map((p) =>
        p.id === idPuesto ? { ...p, alimentadores: nuevoOrdenAlimentadores } : p
      )
    );
  };

  return {
    // Estados
    puestos,
    puestoSeleccionado,
    puestoSeleccionadoId,
    cargando,
    error,

    // Funciones de puestos
    cargarPuestos,
    agregarPuesto,
    eliminarPuesto,
    seleccionarPuesto,
    actualizarPuestos,
    setPuestos,

    // Funciones de alimentadores
    agregarAlimentador,
    actualizarAlimentador,
    eliminarAlimentador,
    reordenarAlimentadores,
  };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/rele/index.js =====

// hooks/rele/index.js
// Hooks relacionados con configuraci√≥n de rel√©s y plantillas

export { useConfigRele } from "./useConfigRele";
export { default as usePlantillasRele } from "./usePlantillasRele";
export { useEtiquetasBits } from "./useEtiquetasBits";
export { useFuncionalidadesPlantilla, CATEGORIAS_FUNCIONALIDADES } from "./useFuncionalidadesPlantilla";

// ===== ./src/paginas/PaginaAlimentadores/hooks/rele/useConfigRele.js =====

// hooks/useConfigRele.js
// Hook para manejar la configuraci√≥n de un registrador de tipo Rel√©

import { useState, useEffect, useRef, useCallback } from "react";

const CONFIG_INICIAL = {
   plantillaId: "",
   conexion: {
      ip: "",
      puerto: 502,
      unitId: 1,
   },
   registroInicial: 120,
   cantidadRegistros: 80,
   intervalo: 60,
   transformadorTIId: "",
   transformadorTVId: "",
   funcionalidadesActivas: {},
};

/**
 * Hook para manejar la configuraci√≥n de un rel√©
 * @param {Object} params - Par√°metros del hook
 * @param {Object} params.configuracionInicial - Configuraci√≥n inicial para edici√≥n
 * @param {Function} params.onChange - Callback cuando cambia la configuraci√≥n
 * @param {Function} params.obtenerPlantilla - Funci√≥n para obtener una plantilla por ID
 * @returns {Object} Estado y funciones de configuraci√≥n
 */
export function useConfigRele({ configuracionInicial, onChange, obtenerPlantilla }) {
   const configAnteriorRef = useRef(null);
   const inicializadoRef = useRef(false);

   const [config, setConfig] = useState(CONFIG_INICIAL);

   // Estado para filas expandidas en la tabla de funcionalidades
   const [filasExpandidas, setFilasExpandidas] = useState(new Set());

   // Estado para el tab activo en funcionalidades
   const [tabFuncionalidadesActivo, setTabFuncionalidadesActivo] = useState("mediciones");

   // Cargar configuraci√≥n inicial si existe (solo una vez al montar)
   useEffect(() => {
      if (configuracionInicial && !inicializadoRef.current) {
         inicializadoRef.current = true;
         setConfig((prev) => ({
            ...prev,
            plantillaId: configuracionInicial.plantillaId || "",
            conexion: {
               ip: configuracionInicial.conexion?.ip || "",
               puerto: configuracionInicial.conexion?.puerto || 502,
               unitId: configuracionInicial.conexion?.unitId || 1,
            },
            registroInicial: configuracionInicial.registroInicial || 120,
            cantidadRegistros: configuracionInicial.cantidadRegistros || 80,
            intervalo: configuracionInicial.intervalo || 60,
            transformadorTIId: configuracionInicial.transformadorTIId || "",
            transformadorTVId: configuracionInicial.transformadorTVId || "",
            funcionalidadesActivas: configuracionInicial.funcionalidadesActivas || {},
         }));
         configAnteriorRef.current = JSON.stringify(configuracionInicial);
      }
   }, [configuracionInicial]);

   // Notificar cambios al padre
   useEffect(() => {
      if (!onChange) return;

      const configActualStr = JSON.stringify(config);

      if (configAnteriorRef.current !== configActualStr) {
         configAnteriorRef.current = configActualStr;
         onChange(config);
      }
   }, [config, onChange]);

   // Obtener la plantilla seleccionada
   const plantillaSeleccionada = config.plantillaId
      ? obtenerPlantilla(config.plantillaId)
      : null;

   /**
    * Generar configuraci√≥n inicial basada en una plantilla
    */
   const generarConfigDesdePlantilla = useCallback((plantilla) => {
      if (!plantilla) return {};

      const funcActivas = {};
      Object.entries(plantilla.funcionalidades || {}).forEach(([funcId, func]) => {
         if (func.habilitado !== false) {
            funcActivas[funcId] = {
               nombre: func.nombre,
               habilitado: true,
               registros: func.registros || [{ etiqueta: "", valor: func.registro || 0 }],
            };
         }
      });

      return funcActivas;
   }, []);

   /**
    * Cambiar plantilla seleccionada
    */
   const handlePlantillaChange = useCallback((plantillaId) => {
      if (!plantillaId) {
         setConfig((prev) => ({
            ...prev,
            plantillaId: "",
            funcionalidadesActivas: {},
         }));
         return;
      }

      const plantilla = obtenerPlantilla(plantillaId);
      const funcionalidadesIniciales = generarConfigDesdePlantilla(plantilla);

      setConfig((prev) => ({
         ...prev,
         plantillaId,
         funcionalidadesActivas: funcionalidadesIniciales,
      }));
   }, [obtenerPlantilla, generarConfigDesdePlantilla]);

   /**
    * Cambiar campo de conexi√≥n
    */
   const handleConexionChange = useCallback((campo, valor) => {
      setConfig((prev) => ({
         ...prev,
         conexion: {
            ...prev.conexion,
            [campo]: valor,
         },
      }));
   }, []);

   /**
    * Cambiar registro inicial
    */
   const handleRegistroInicialChange = useCallback((valor) => {
      setConfig((prev) => ({
         ...prev,
         registroInicial: valor === "" ? "" : parseInt(valor) || 0,
      }));
   }, []);

   /**
    * Cambiar cantidad de registros
    */
   const handleCantidadRegistrosChange = useCallback((valor) => {
      setConfig((prev) => ({
         ...prev,
         cantidadRegistros: valor === "" ? "" : parseInt(valor) || 0,
      }));
   }, []);

   /**
    * Cambiar intervalo
    */
   const handleIntervaloChange = useCallback((valor) => {
      setConfig((prev) => ({
         ...prev,
         intervalo: valor === "" ? "" : parseInt(valor) || 0,
      }));
   }, []);

   /**
    * Toggle habilitar/deshabilitar una funcionalidad
    */
   const handleToggleFuncionalidad = useCallback((funcId) => {
      setConfig((prev) => {
         const estadoActual = prev.funcionalidadesActivas[funcId];
         const plantillaFunc = plantillaSeleccionada?.funcionalidades?.[funcId];

         if (estadoActual?.habilitado) {
            const nuevasFunc = { ...prev.funcionalidadesActivas };
            nuevasFunc[funcId] = { ...nuevasFunc[funcId], habilitado: false };
            return { ...prev, funcionalidadesActivas: nuevasFunc };
         } else {
            return {
               ...prev,
               funcionalidadesActivas: {
                  ...prev.funcionalidadesActivas,
                  [funcId]: {
                     nombre: plantillaFunc?.nombre || funcId,
                     habilitado: true,
                     registros: plantillaFunc?.registros || [{ etiqueta: "", valor: 0 }],
                  },
               },
            };
         }
      });
   }, [plantillaSeleccionada]);

   /**
    * Cambiar valor de un registro espec√≠fico
    */
   const handleCambiarRegistro = useCallback((funcId, regIndex, valor) => {
      setConfig((prev) => ({
         ...prev,
         funcionalidadesActivas: {
            ...prev.funcionalidadesActivas,
            [funcId]: {
               ...prev.funcionalidadesActivas[funcId],
               registros: prev.funcionalidadesActivas[funcId].registros.map((reg, idx) =>
                  idx === regIndex
                     ? { ...reg, valor: valor === "" ? "" : parseInt(valor) || 0 }
                     : reg
               ),
            },
         },
      }));
   }, []);

   /**
    * Toggle expandir/colapsar fila
    */
   const toggleFilaExpandida = useCallback((funcId) => {
      setFilasExpandidas((prev) => {
         const nuevas = new Set(prev);
         if (nuevas.has(funcId)) {
            nuevas.delete(funcId);
         } else {
            nuevas.add(funcId);
         }
         return nuevas;
      });
   }, []);

   /**
    * Aplicar plantilla reci√©n creada
    */
   const aplicarPlantillaCreada = useCallback((nuevaPlantilla) => {
      const funcionalidadesIniciales = generarConfigDesdePlantilla(nuevaPlantilla);
      setConfig((prev) => ({
         ...prev,
         plantillaId: nuevaPlantilla.id,
         funcionalidadesActivas: funcionalidadesIniciales,
      }));
   }, [generarConfigDesdePlantilla]);

   /**
    * Actualizar funcionalidades cuando se actualiza la plantilla seleccionada
    */
   const actualizarFuncionalidades = useCallback((plantillaActualizada) => {
      const funcionalidadesActualizadas = generarConfigDesdePlantilla(plantillaActualizada);
      setConfig((prev) => ({
         ...prev,
         funcionalidadesActivas: funcionalidadesActualizadas,
      }));
   }, [generarConfigDesdePlantilla]);

   // Verificar si la plantilla seleccionada a√∫n existe
   const plantillaNoEncontrada = config.plantillaId && !plantillaSeleccionada;

   // Obtener lista de funcionalidades de la plantilla
   const funcionalidadesPlantilla = plantillaSeleccionada
      ? Object.entries(plantillaSeleccionada.funcionalidades || {})
      : [];

   // Contar funcionalidades activas
   const cantidadActivas = Object.values(config.funcionalidadesActivas).filter(
      (f) => f.habilitado
   ).length;

   return {
      // Estado
      config,
      plantillaSeleccionada,
      plantillaNoEncontrada,
      funcionalidadesPlantilla,
      cantidadActivas,
      filasExpandidas,
      tabFuncionalidadesActivo,

      // Setters
      setTabFuncionalidadesActivo,

      // Handlers
      handlePlantillaChange,
      handleConexionChange,
      handleRegistroInicialChange,
      handleCantidadRegistrosChange,
      handleIntervaloChange,
      handleToggleFuncionalidad,
      handleCambiarRegistro,
      toggleFilaExpandida,
      aplicarPlantillaCreada,
      actualizarFuncionalidades,
   };
}

// ===== ./src/paginas/PaginaAlimentadores/hooks/rele/useEtiquetasBits.js =====

// hooks/useEtiquetasBits.js
// Hook para manejar las etiquetas de bits (LEDs del panel frontal)

import { useState, useEffect, useCallback } from "react";
import { PLANTILLAS_ETIQUETAS_LEDS } from "../../utilidades/interpreteRegistrosREF615";

const STORAGE_KEY_PLANTILLAS_ETIQUETAS = "plantillasEtiquetasLeds";

/**
 * Hook para manejar las etiquetas de bits y plantillas personalizadas
 * @returns {Object} Estado y funciones de etiquetas
 */
export function useEtiquetasBits() {
   // Estado para etiquetas de bits
   const [etiquetasBits, setEtiquetasBits] = useState({});
   const [seccionAbierta, setSeccionAbierta] = useState(false);
   const [cantidadBits, setCantidadBits] = useState(1);

   // Estado para plantillas personalizadas
   const [plantillasPersonalizadas, setPlantillasPersonalizadas] = useState({});
   const [plantillaSeleccionada, setPlantillaSeleccionada] = useState("");

   // Estado para modo creaci√≥n de nueva plantilla
   const [modoNuevaPlantilla, setModoNuevaPlantilla] = useState(false);
   const [nombreNuevaPlantilla, setNombreNuevaPlantilla] = useState("");

   // Cargar plantillas personalizadas desde localStorage al montar
   useEffect(() => {
      try {
         const guardadas = localStorage.getItem(STORAGE_KEY_PLANTILLAS_ETIQUETAS);
         if (guardadas) {
            setPlantillasPersonalizadas(JSON.parse(guardadas));
         }
      } catch (error) {
         console.error("Error al cargar plantillas de etiquetas:", error);
      }
   }, []);

   /**
    * Cambiar texto de una etiqueta de bit
    */
   const cambiarEtiquetaBit = useCallback((bit, texto) => {
      setEtiquetasBits((prev) => ({
         ...prev,
         [bit]: {
            ...prev[bit],
            texto: texto,
            severidad: prev[bit]?.severidad || "info"
         }
      }));
   }, []);

   /**
    * Cambiar severidad de una etiqueta de bit
    */
   const cambiarSeveridadBit = useCallback((bit, severidad) => {
      setEtiquetasBits((prev) => ({
         ...prev,
         [bit]: {
            ...prev[bit],
            texto: prev[bit]?.texto || "",
            severidad: severidad
         }
      }));
   }, []);

   /**
    * Aplicar una plantilla de etiquetas (predefinida o personalizada)
    */
   const aplicarPlantilla = useCallback((tipoPlantilla) => {
      // Buscar en plantillas predefinidas
      if (PLANTILLAS_ETIQUETAS_LEDS[tipoPlantilla]) {
         setEtiquetasBits(PLANTILLAS_ETIQUETAS_LEDS[tipoPlantilla].etiquetas);
         setCantidadBits(Object.keys(PLANTILLAS_ETIQUETAS_LEDS[tipoPlantilla].etiquetas).length);
         setModoNuevaPlantilla(false);
         setPlantillaSeleccionada(tipoPlantilla);
         return;
      }
      // Buscar en plantillas personalizadas
      if (plantillasPersonalizadas[tipoPlantilla]) {
         setEtiquetasBits(plantillasPersonalizadas[tipoPlantilla].etiquetas);
         setCantidadBits(Object.keys(plantillasPersonalizadas[tipoPlantilla].etiquetas).length);
         setModoNuevaPlantilla(false);
         setPlantillaSeleccionada(tipoPlantilla);
      }
   }, [plantillasPersonalizadas]);

   /**
    * Iniciar modo de creaci√≥n de nueva plantilla
    */
   const iniciarNuevaPlantilla = useCallback(() => {
      setModoNuevaPlantilla(true);
      setNombreNuevaPlantilla("");
      setCantidadBits(1);
      setEtiquetasBits({ 0: { texto: "", severidad: "info" } });
   }, []);

   /**
    * Cancelar creaci√≥n de nueva plantilla
    */
   const cancelarNuevaPlantilla = useCallback(() => {
      setModoNuevaPlantilla(false);
      setNombreNuevaPlantilla("");
      setCantidadBits(1);
      setEtiquetasBits({});
   }, []);

   /**
    * Agregar una fila de bit
    */
   const agregarFilaBit = useCallback(() => {
      const nuevoBit = cantidadBits;
      setCantidadBits(nuevoBit + 1);
      setEtiquetasBits((prev) => ({
         ...prev,
         [nuevoBit]: { texto: "", severidad: "info" }
      }));
   }, [cantidadBits]);

   /**
    * Quitar la √∫ltima fila de bit
    */
   const quitarFilaBit = useCallback(() => {
      if (cantidadBits <= 1) return;
      const bitAQuitar = cantidadBits - 1;
      setCantidadBits(bitAQuitar);
      setEtiquetasBits((prev) => {
         const nuevas = { ...prev };
         delete nuevas[bitAQuitar];
         return nuevas;
      });
   }, [cantidadBits]);

   /**
    * Guardar plantilla personalizada
    */
   const guardarPlantillaPersonalizada = useCallback(() => {
      if (!nombreNuevaPlantilla.trim()) {
         return { exito: false, error: "Ingresa un nombre para la plantilla de etiquetas" };
      }

      // Limpiar etiquetas vac√≠as
      const etiquetasLimpias = {};
      Object.entries(etiquetasBits).forEach(([bit, etiqueta]) => {
         if (etiqueta.texto && etiqueta.texto.trim() !== "") {
            etiquetasLimpias[bit] = {
               texto: etiqueta.texto.trim(),
               severidad: etiqueta.severidad || "info"
            };
         }
      });

      const id = "custom-" + Date.now().toString(36);
      const nuevaPlantilla = {
         nombre: nombreNuevaPlantilla.trim(),
         etiquetas: etiquetasLimpias
      };

      const nuevasPlantillas = {
         ...plantillasPersonalizadas,
         [id]: nuevaPlantilla
      };

      try {
         localStorage.setItem(STORAGE_KEY_PLANTILLAS_ETIQUETAS, JSON.stringify(nuevasPlantillas));
         setPlantillasPersonalizadas(nuevasPlantillas);
         setModoNuevaPlantilla(false);
         setNombreNuevaPlantilla("");
         return { exito: true };
      } catch (error) {
         console.error("Error al guardar plantilla de etiquetas:", error);
         return { exito: false, error: "Error al guardar la plantilla" };
      }
   }, [nombreNuevaPlantilla, etiquetasBits, plantillasPersonalizadas]);

   /**
    * Eliminar plantilla personalizada
    */
   const eliminarPlantillaPersonalizada = useCallback((id) => {
      const nuevasPlantillas = { ...plantillasPersonalizadas };
      delete nuevasPlantillas[id];

      try {
         localStorage.setItem(STORAGE_KEY_PLANTILLAS_ETIQUETAS, JSON.stringify(nuevasPlantillas));
         setPlantillasPersonalizadas(nuevasPlantillas);
      } catch (error) {
         console.error("Error al eliminar plantilla de etiquetas:", error);
      }
   }, [plantillasPersonalizadas]);

   /**
    * Limpiar todas las etiquetas
    */
   const limpiarEtiquetas = useCallback(() => {
      setEtiquetasBits({});
      setModoNuevaPlantilla(false);
      setCantidadBits(1);
      setPlantillaSeleccionada("");
   }, []);

   /**
    * Contar etiquetas configuradas
    */
   const contarEtiquetasConfiguradas = useCallback(() => {
      return Object.values(etiquetasBits).filter(e => e.texto && e.texto.trim() !== "").length;
   }, [etiquetasBits]);

   /**
    * Obtener nombre de una plantilla por su ID
    */
   const obtenerNombrePlantilla = useCallback((idPlantilla) => {
      if (!idPlantilla) return null;

      if (PLANTILLAS_ETIQUETAS_LEDS[idPlantilla]) {
         return PLANTILLAS_ETIQUETAS_LEDS[idPlantilla].nombre;
      }

      if (plantillasPersonalizadas[idPlantilla]) {
         return plantillasPersonalizadas[idPlantilla].nombre;
      }

      return null;
   }, [plantillasPersonalizadas]);

   /**
    * Cargar etiquetas desde una plantilla existente
    */
   const cargarDesdeObjeto = useCallback((etiquetas, plantillaId = "") => {
      setEtiquetasBits(etiquetas || {});
      setPlantillaSeleccionada(plantillaId);
      if (Object.keys(etiquetas || {}).length > 0) {
         const maxBit = Math.max(...Object.keys(etiquetas).map(Number));
         setCantidadBits(maxBit + 1);
         setSeccionAbierta(true);
      }
   }, []);

   /**
    * Limpiar etiquetas vac√≠as para guardar
    */
   const obtenerEtiquetasLimpias = useCallback(() => {
      const etiquetasLimpias = {};
      Object.entries(etiquetasBits).forEach(([bit, etiqueta]) => {
         if (etiqueta.texto && etiqueta.texto.trim() !== "") {
            etiquetasLimpias[bit] = {
               texto: etiqueta.texto.trim(),
               severidad: etiqueta.severidad || "info"
            };
         }
      });
      return etiquetasLimpias;
   }, [etiquetasBits]);

   /**
    * Resetear todo el estado
    */
   const resetear = useCallback(() => {
      setEtiquetasBits({});
      setSeccionAbierta(false);
      setCantidadBits(1);
      setPlantillaSeleccionada("");
      setModoNuevaPlantilla(false);
      setNombreNuevaPlantilla("");
   }, []);

   return {
      // Estado
      etiquetasBits,
      seccionAbierta,
      cantidadBits,
      plantillasPersonalizadas,
      plantillaSeleccionada,
      modoNuevaPlantilla,
      nombreNuevaPlantilla,

      // Setters
      setSeccionAbierta,
      setNombreNuevaPlantilla,

      // Funciones
      cambiarEtiquetaBit,
      cambiarSeveridadBit,
      aplicarPlantilla,
      iniciarNuevaPlantilla,
      cancelarNuevaPlantilla,
      agregarFilaBit,
      quitarFilaBit,
      guardarPlantillaPersonalizada,
      eliminarPlantillaPersonalizada,
      limpiarEtiquetas,
      contarEtiquetasConfiguradas,
      obtenerNombrePlantilla,
      cargarDesdeObjeto,
      obtenerEtiquetasLimpias,
      resetear,
   };
}

// ===== ./src/paginas/PaginaAlimentadores/hooks/rele/useFuncionalidadesPlantilla.js =====

// hooks/useFuncionalidadesPlantilla.js
// Hook para manejar el CRUD de funcionalidades en plantillas de rel√©

import { useState, useCallback } from "react";

// Categor√≠as disponibles para las funcionalidades
export const CATEGORIAS_FUNCIONALIDADES = {
   mediciones: { id: "mediciones", nombre: "Mediciones", icono: "üìä" },
   estados: { id: "estados", nombre: "Estados y Alarmas", icono: "üö¶" },
   sistema: { id: "sistema", nombre: "Sistema", icono: "‚öôÔ∏è" },
};

/**
 * Hook para manejar el CRUD de funcionalidades
 * @returns {Object} Estado y funciones de funcionalidades
 */
export function useFuncionalidadesPlantilla() {
   const [funcionalidades, setFuncionalidades] = useState([]);

   // Estado para agregar nueva funcionalidad
   const [nuevaFunc, setNuevaFunc] = useState({
      nombre: "",
      cantidad: 1,
      categoria: "mediciones",
   });

   /**
    * Generar ID √∫nico para funcionalidad
    */
   const generarIdFunc = useCallback(() => {
      return "func-" + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
   }, []);

   /**
    * Agregar nueva funcionalidad
    * @returns {{ exito: boolean, error?: string }}
    */
   const agregarFuncionalidad = useCallback(() => {
      if (!nuevaFunc.nombre.trim()) {
         return { exito: false, error: "Ingresa un nombre para la funcionalidad" };
      }

      const cantidad = parseInt(nuevaFunc.cantidad) || 1;

      // Crear array de registros vac√≠os seg√∫n la cantidad
      const registros = Array.from({ length: cantidad }, () => ({
         etiqueta: "",
         valor: 0,
      }));

      const nuevaFuncionalidad = {
         id: generarIdFunc(),
         nombre: nuevaFunc.nombre.trim(),
         categoria: nuevaFunc.categoria,
         habilitado: true,
         registros,
      };

      setFuncionalidades((prev) => [...prev, nuevaFuncionalidad]);
      setNuevaFunc({ nombre: "", cantidad: 1, categoria: nuevaFunc.categoria });
      return { exito: true };
   }, [nuevaFunc, generarIdFunc]);

   /**
    * Eliminar funcionalidad
    */
   const eliminarFuncionalidad = useCallback((funcId) => {
      setFuncionalidades((prev) => prev.filter((f) => f.id !== funcId));
   }, []);

   /**
    * Toggle habilitar/deshabilitar funcionalidad
    */
   const toggleFuncionalidad = useCallback((funcId) => {
      setFuncionalidades((prev) =>
         prev.map((f) =>
            f.id === funcId ? { ...f, habilitado: !f.habilitado } : f
         )
      );
   }, []);

   /**
    * Cambiar etiqueta de un registro
    */
   const cambiarEtiquetaRegistro = useCallback((funcId, regIndex, valor) => {
      setFuncionalidades((prev) =>
         prev.map((f) => {
            if (f.id !== funcId) return f;
            const nuevosRegistros = [...f.registros];
            nuevosRegistros[regIndex] = { ...nuevosRegistros[regIndex], etiqueta: valor };
            return { ...f, registros: nuevosRegistros };
         })
      );
   }, []);

   /**
    * Cambiar valor de un registro
    */
   const cambiarValorRegistro = useCallback((funcId, regIndex, valor) => {
      setFuncionalidades((prev) =>
         prev.map((f) => {
            if (f.id !== funcId) return f;
            const nuevosRegistros = [...f.registros];
            nuevosRegistros[regIndex] = {
               ...nuevosRegistros[regIndex],
               valor: valor === "" ? "" : parseInt(valor) || 0,
            };
            return { ...f, registros: nuevosRegistros };
         })
      );
   }, []);

   /**
    * Cambiar transformador de un registro espec√≠fico
    */
   const cambiarTransformadorRegistro = useCallback((funcId, registroIndex, transformadorId) => {
      setFuncionalidades((prev) =>
         prev.map((f) => {
            if (f.id !== funcId) return f;
            const nuevosRegistros = f.registros.map((reg, idx) =>
               idx === registroIndex
                  ? { ...reg, transformadorId: transformadorId || null }
                  : reg
            );
            return { ...f, registros: nuevosRegistros };
         })
      );
   }, []);

   /**
    * Aplicar un transformador a todos los registros de una funcionalidad
    */
   const aplicarTransformadorATodos = useCallback((funcId, transformadorId) => {
      setFuncionalidades((prev) =>
         prev.map((f) => {
            if (f.id !== funcId) return f;
            const nuevosRegistros = f.registros.map((reg) => ({
               ...reg,
               transformadorId: transformadorId || null,
            }));
            return { ...f, registros: nuevosRegistros };
         })
      );
   }, []);

   /**
    * Mover funcionalidad hacia arriba
    */
   const moverFuncionalidadArriba = useCallback((funcId) => {
      setFuncionalidades((prev) => {
         const index = prev.findIndex((f) => f.id === funcId);
         if (index <= 0) return prev;
         const newArr = [...prev];
         [newArr[index - 1], newArr[index]] = [newArr[index], newArr[index - 1]];
         return newArr;
      });
   }, []);

   /**
    * Mover funcionalidad hacia abajo
    */
   const moverFuncionalidadAbajo = useCallback((funcId) => {
      setFuncionalidades((prev) => {
         const index = prev.findIndex((f) => f.id === funcId);
         if (index < 0 || index >= prev.length - 1) return prev;
         const newArr = [...prev];
         [newArr[index], newArr[index + 1]] = [newArr[index + 1], newArr[index]];
         return newArr;
      });
   }, []);

   /**
    * Cargar funcionalidades desde un objeto de plantilla
    */
   const cargarDesdeObjeto = useCallback((funcionalidadesObj) => {
      const funcsArray = Object.entries(funcionalidadesObj || {}).map(
         ([id, data]) => {
            // Migraci√≥n: si hay transformadorId a nivel de funcionalidad, aplicarlo a cada registro
            const transformadorIdGrupo = data.transformadorId || null;
            const registrosBase = data.registros || [{ etiqueta: "", valor: data.registro || 0 }];
            const registrosMigrados = registrosBase.map((reg) => ({
               ...reg,
               transformadorId: reg.transformadorId !== undefined ? reg.transformadorId : transformadorIdGrupo,
            }));
            return {
               id,
               nombre: data.nombre || id,
               habilitado: data.habilitado !== false,
               categoria: data.categoria || "mediciones",
               registros: registrosMigrados,
            };
         }
      );
      setFuncionalidades(funcsArray);
   }, []);

   /**
    * Convertir funcionalidades a objeto para guardar
    */
   const obtenerParaGuardar = useCallback(() => {
      const funcParaGuardar = {};
      funcionalidades.forEach((func) => {
         if (func.habilitado) {
            funcParaGuardar[func.id] = {
               nombre: func.nombre,
               categoria: func.categoria || "mediciones",
               habilitado: true,
               registros: func.registros,
               registro: func.registros[0]?.valor || 0,
            };
         }
      });
      return funcParaGuardar;
   }, [funcionalidades]);

   /**
    * Contar funcionalidades en una plantilla
    */
   const contarFuncionalidades = useCallback((plantilla) => {
      return Object.values(plantilla?.funcionalidades || {}).filter(
         (f) => f.habilitado !== false
      ).length;
   }, []);

   /**
    * Resetear todo el estado
    */
   const resetear = useCallback(() => {
      setFuncionalidades([]);
      setNuevaFunc({ nombre: "", cantidad: 1, categoria: "mediciones" });
   }, []);

   return {
      // Estado
      funcionalidades,
      nuevaFunc,

      // Setters
      setNuevaFunc,
      setFuncionalidades,

      // Funciones
      agregarFuncionalidad,
      eliminarFuncionalidad,
      toggleFuncionalidad,
      cambiarEtiquetaRegistro,
      cambiarValorRegistro,
      cambiarTransformadorRegistro,
      aplicarTransformadorATodos,
      moverFuncionalidadArriba,
      moverFuncionalidadAbajo,
      cargarDesdeObjeto,
      obtenerParaGuardar,
      contarFuncionalidades,
      resetear,
   };
}

// ===== ./src/paginas/PaginaAlimentadores/hooks/rele/usePlantillasRele.js =====

import { useState, useEffect, useCallback } from "react";
import {
  FUNCIONALIDADES_DISPONIBLES,
  STORAGE_KEY_PLANTILLAS,
} from "../../constantes/funcionalidadesRele";

/**
 * Hook para gestionar plantillas de rel√©s de protecci√≥n.
 * Maneja CRUD de plantillas en localStorage.
 */
export const usePlantillasRele = () => {
  const [plantillas, setPlantillas] = useState([]);
  const [cargando, setCargando] = useState(true);

  // Cargar plantillas al montar
  useEffect(() => {
    cargarPlantillas();
  }, []);

  /**
   * Carga las plantillas desde localStorage
   */
  const cargarPlantillas = useCallback(() => {
    setCargando(true);
    try {
      const datos = localStorage.getItem(STORAGE_KEY_PLANTILLAS);
      const plantillasGuardadas = datos ? JSON.parse(datos) : [];
      setPlantillas(plantillasGuardadas);
    } catch (error) {
      console.error("Error al cargar plantillas:", error);
      setPlantillas([]);
    } finally {
      setCargando(false);
    }
  }, []);

  /**
   * Guarda las plantillas en localStorage
   */
  const guardarEnStorage = useCallback((nuevasPlantillas) => {
    try {
      localStorage.setItem(
        STORAGE_KEY_PLANTILLAS,
        JSON.stringify(nuevasPlantillas)
      );
      setPlantillas(nuevasPlantillas);
      return true;
    } catch (error) {
      console.error("Error al guardar plantillas:", error);
      return false;
    }
  }, []);

  /**
   * Genera un UUID simple
   */
  const generarId = () => {
    return "plt-" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  };

  /**
   * Crea una nueva plantilla
   * @param {Object} datos - { nombre, descripcion, funcionalidades, etiquetasBits, plantillaEtiquetasId }
   * funcionalidades es un objeto con { [idFuncionalidad]: { habilitado, registro } }
   * etiquetasBits es un objeto con { [bit]: { texto, severidad } }
   * plantillaEtiquetasId es el ID de la plantilla de etiquetas seleccionada (para restaurar al editar)
   */
  const crearPlantilla = useCallback(
    (datos) => {
      const nuevaPlantilla = {
        id: generarId(),
        nombre: datos.nombre.trim(),
        descripcion: datos.descripcion?.trim() || "",
        fechaCreacion: new Date().toISOString(),
        funcionalidades: datos.funcionalidades || {},
        etiquetasBits: datos.etiquetasBits || {},
        plantillaEtiquetasId: datos.plantillaEtiquetasId || null,
      };

      const nuevasPlantillas = [...plantillas, nuevaPlantilla];
      const exito = guardarEnStorage(nuevasPlantillas);

      return exito ? nuevaPlantilla : null;
    },
    [plantillas, guardarEnStorage]
  );

  /**
   * Actualiza una plantilla existente
   * @param {string} id - ID de la plantilla
   * @param {Object} datos - Datos a actualizar
   */
  const actualizarPlantilla = useCallback(
    (id, datos) => {
      const indice = plantillas.findIndex((p) => p.id === id);
      if (indice === -1) return false;

      const plantillaActualizada = {
        ...plantillas[indice],
        nombre: datos.nombre?.trim() || plantillas[indice].nombre,
        descripcion: datos.descripcion?.trim() ?? plantillas[indice].descripcion,
        funcionalidades: datos.funcionalidades || plantillas[indice].funcionalidades,
        etiquetasBits: datos.etiquetasBits ?? plantillas[indice].etiquetasBits ?? {},
        plantillaEtiquetasId: datos.plantillaEtiquetasId !== undefined
          ? datos.plantillaEtiquetasId
          : plantillas[indice].plantillaEtiquetasId ?? null,
        fechaModificacion: new Date().toISOString(),
      };

      const nuevasPlantillas = [...plantillas];
      nuevasPlantillas[indice] = plantillaActualizada;

      return guardarEnStorage(nuevasPlantillas);
    },
    [plantillas, guardarEnStorage]
  );

  /**
   * Elimina una plantilla
   * @param {string} id - ID de la plantilla a eliminar
   */
  const eliminarPlantilla = useCallback(
    (id) => {
      const nuevasPlantillas = plantillas.filter((p) => p.id !== id);
      return guardarEnStorage(nuevasPlantillas);
    },
    [plantillas, guardarEnStorage]
  );

  /**
   * Obtiene una plantilla por ID
   * @param {string} id - ID de la plantilla
   */
  const obtenerPlantilla = useCallback(
    (id) => {
      return plantillas.find((p) => p.id === id) || null;
    },
    [plantillas]
  );

  /**
   * Obtiene las funcionalidades de una plantilla con sus valores por defecto
   * @param {string} plantillaId - ID de la plantilla
   * @returns {Object} - { [idFunc]: { habilitado, registro } }
   */
  const obtenerFuncionalidadesPlantilla = useCallback(
    (plantillaId) => {
      const plantilla = obtenerPlantilla(plantillaId);
      if (!plantilla) return {};

      // Construir objeto con todas las funcionalidades de la plantilla
      const funcionalidades = {};
      Object.keys(plantilla.funcionalidades).forEach((funcId) => {
        const funcPlantilla = plantilla.funcionalidades[funcId];
        const funcBase = FUNCIONALIDADES_DISPONIBLES[funcId];

        if (funcBase && funcPlantilla.habilitado) {
          funcionalidades[funcId] = {
            habilitado: true,
            registro: funcPlantilla.registro || funcBase.registroDefault,
            cantidad: funcBase.cantidad,
            nombre: funcBase.nombre,
          };
        }
      });

      return funcionalidades;
    },
    [obtenerPlantilla]
  );

  /**
   * Genera la configuraci√≥n de funcionalidades activas por defecto basada en una plantilla
   * @param {string} plantillaId - ID de la plantilla
   * @returns {Object} - Configuraci√≥n inicial para funcionalidadesActivas
   */
  const generarConfiguracionInicial = useCallback(
    (plantillaId) => {
      const plantilla = obtenerPlantilla(plantillaId);
      if (!plantilla) return {};

      const config = {};
      Object.keys(plantilla.funcionalidades).forEach((funcId) => {
        const funcPlantilla = plantilla.funcionalidades[funcId];
        const funcBase = FUNCIONALIDADES_DISPONIBLES[funcId];

        if (funcBase && funcPlantilla.habilitado) {
          config[funcId] = {
            habilitado: true,
            registro: funcPlantilla.registro || funcBase.registroDefault,
          };
        }
      });

      return config;
    },
    [obtenerPlantilla]
  );

  return {
    plantillas,
    cargando,
    crearPlantilla,
    actualizarPlantilla,
    eliminarPlantilla,
    obtenerPlantilla,
    obtenerFuncionalidadesPlantilla,
    generarConfiguracionInicial,
    recargar: cargarPlantillas,
  };
};

export default usePlantillasRele;

// ===== ./src/paginas/PaginaAlimentadores/hooks/ui/index.js =====

// hooks/ui/index.js
// Hooks relacionados con UI general: modales, ventanas, efectos visuales

export { useGestorModales } from "./useGestorModales";
export { default as useChispas } from "./useChispas";
export { default as useVentanasHistorial } from "./useVentanasHistorial";
export { useVentanaFlotante } from "./useVentanaFlotante";
export { useArrastrarVentana } from "./useArrastrarVentana";
export { useModoCompacto } from "./useModoCompacto";

// ===== ./src/paginas/PaginaAlimentadores/hooks/ui/useArrastrarVentana.js =====

// hooks/ui/useArrastrarVentana.js
// Hook para manejar drag & drop de ventanas flotantes

import { useState, useEffect, useCallback } from "react";

/**
 * Hook para manejar el arrastre de ventanas flotantes
 * @param {Object} params - Par√°metros
 * @param {React.RefObject} params.ventanaRef - Referencia al elemento de la ventana
 * @param {boolean} params.maximizada - Si la ventana est√° maximizada
 * @param {Function} params.onEnfocar - Callback al enfocar la ventana
 * @param {Function} params.onMover - Callback para mover la ventana ({x, y})
 * @returns {Object} Estado y handlers del arrastre
 */
export const useArrastrarVentana = ({ ventanaRef, maximizada, onEnfocar, onMover }) => {
   const [arrastrando, setArrastrando] = useState(false);
   const [offsetArrastre, setOffsetArrastre] = useState({ x: 0, y: 0 });

   const handleMouseDown = useCallback(
      (e) => {
         if (maximizada) return;
         if (e.target.closest("button")) return;
         onEnfocar();
         setArrastrando(true);
         const rect = ventanaRef.current.getBoundingClientRect();
         setOffsetArrastre({
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
         });
      },
      [maximizada, onEnfocar, ventanaRef]
   );

   useEffect(() => {
      if (!arrastrando) return;

      const handleMouseMove = (e) => {
         const newX = Math.max(0, e.clientX - offsetArrastre.x);
         const newY = Math.max(0, e.clientY - offsetArrastre.y);
         onMover({ x: newX, y: newY });
      };

      const handleMouseUp = () => {
         setArrastrando(false);
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      return () => {
         document.removeEventListener("mousemove", handleMouseMove);
         document.removeEventListener("mouseup", handleMouseUp);
      };
   }, [arrastrando, offsetArrastre, onMover]);

   return {
      arrastrando,
      handleMouseDown,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/ui/useChispas.js =====

// src/paginas/PaginaAlimentadores/hooks/usarChispas.js

import { useState, useCallback, useRef, useEffect } from "react";
import {
	construirGrafo,
	calcularRutasDesdeEmisor,
} from "../../utilidades/calculadorRutas.js";

/**
 * L√≠mite m√°ximo de chispas simult√°neas para evitar problemas de rendimiento
 */
const MAX_CHISPAS = 100;

/**
 * Hook para manejar la animaci√≥n de chispas en el diagrama unifilar.
 *
 * OPTIMIZADO: Las chispas se manejan con refs mutables, sin usar setState
 * durante la animaci√≥n. Esto elimina los re-renders de React y el GC.
 *
 * @param {Object} params - Par√°metros del hook
 * @param {Array} params.bornes - Array de bornes
 * @param {Object} params.celdas - Objeto de celdas pintadas
 * @param {Object} params.chispasConfig - Configuraci√≥n de chispas
 * @param {number} params.grosorLinea - Grosor de l√≠nea en p√≠xeles
 * @returns {Object} Estado y funciones para manejar chispas
 */
const useChispas = ({
	bornes = [],
	celdas = {},
	chispasConfig = {},
	grosorLinea = 12,
}) => {
	// Estado de animaci√≥n activa (solo este causa re-render, y solo al iniciar/detener)
	const [animando, setAnimando] = useState(false);
	const animandoRef = useRef(false);

	// *** CAMBIO CLAVE: Las chispas son un REF, no un estado ***
	// Esto evita re-renders durante la animaci√≥n
	const chispasRef = useRef([]);

	// Referencias para el loop de animaci√≥n
	const animationFrameRef = useRef(null);
	const lastTimeRef = useRef(0);

	// Referencias para timers de emisi√≥n
	const emisionTimersRef = useRef({});

	// Grafo de conectividad (se recalcula cuando cambian las celdas)
	const grafoRef = useRef({});

	// Rutas precalculadas desde cada emisor
	const rutasRef = useRef({});

	// Refs para la configuraci√≥n actual (para evitar closures obsoletos)
	const configRef = useRef(chispasConfig);
	const bornesRef = useRef(bornes);
	const grosorLineaRef = useRef(grosorLinea);

	// ID counter para chispas (evita Date.now() y Math.random())
	const chispaIdRef = useRef(0);

	// Mantener refs actualizados
	useEffect(() => {
		configRef.current = chispasConfig;
	}, [chispasConfig]);

	useEffect(() => {
		bornesRef.current = bornes;
	}, [bornes]);

	useEffect(() => {
		grosorLineaRef.current = grosorLinea;
	}, [grosorLinea]);

	/**
	 * Recalcular el grafo cuando cambian las celdas
	 */
	useEffect(() => {
		grafoRef.current = construirGrafo(celdas);
	}, [celdas]);

	/**
	 * Recalcular rutas cuando cambian bornes o celdas
	 */
	useEffect(() => {
		const emisores = bornes.filter(b => b.tipo === "EMISOR");
		const nuevasRutas = {};

		emisores.forEach(emisor => {
			nuevasRutas[emisor.id] = calcularRutasDesdeEmisor(emisor, bornes, grafoRef.current);
		});

		rutasRef.current = nuevasRutas;
	}, [bornes, celdas]);

	/**
	 * Crear una nueva chispa desde un emisor
	 */
	const crearChispa = useCallback((emisor) => {
		const rutas = rutasRef.current[emisor.id] || [];

		// Si no hay rutas a receptores, no crear chispa
		if (rutas.length === 0) {
			return null;
		}

		// Elegir una ruta aleatoria si hay varias
		const rutaElegida = rutas[Math.floor(Math.random() * rutas.length)];

		chispaIdRef.current += 1;

		return {
			id: chispaIdRef.current,
			ruta: rutaElegida.ruta,
			posicion: 0,
			progreso: 0, // 0-1 entre celdas
			emisorId: emisor.id,
			receptorId: rutaElegida.receptorId,
			estela: [], // Array mutable - se modifica in-place
		};
	}, []);

	/**
	 * Emitir una chispa desde un emisor espec√≠fico
	 * *** MODIFICADO: Agrega directamente al ref, sin setState ***
	 */
	const emitirDesdeEmisor = useCallback((emisorId) => {
		const emisor = bornesRef.current.find(b => b.id === emisorId && b.tipo === "EMISOR");
		if (!emisor || !emisor.activo) {
			return;
		}

		// Verificar l√≠mite de chispas
		if (chispasRef.current.length >= MAX_CHISPAS) {
			return;
		}

		const nuevaChispa = crearChispa(emisor);
		if (!nuevaChispa) {
			return;
		}

		// *** Agregar directamente al array del ref ***
		chispasRef.current.push(nuevaChispa);
	}, [crearChispa]);

	/**
	 * Loop de animaci√≥n - actualiza posiciones de chispas
	 * *** MODIFICADO: Modifica el ref directamente, sin setState ***
	 */
	const loopAnimacion = useCallback((timestamp) => {
		if (!animandoRef.current) {
			return;
		}

		const deltaTime = lastTimeRef.current === 0 ? 16 : timestamp - lastTimeRef.current;
		lastTimeRef.current = timestamp;

		// Velocidad en celdas por segundo
		const velocidad = configRef.current.velocidad || 8;
		const longitudEstela = configRef.current.longitudEstela || 5;

		// Calcular cu√°nto avanzar
		const avance = (velocidad * deltaTime) / 1000;

		const chispas = chispasRef.current;

		// Actualizar chispas IN-PLACE
		for (let i = chispas.length - 1; i >= 0; i--) {
			const chispa = chispas[i];
			chispa.progreso += avance;

			// Manejar m√∫ltiples avances de celda si la velocidad es muy alta
			while (chispa.progreso >= 1) {
				const estela = chispa.estela;

				// Shift estela hacia el final (in-place)
				for (let j = Math.min(estela.length, longitudEstela - 1); j > 0; j--) {
					estela[j] = estela[j - 1];
				}
				// Agregar posici√≥n actual al inicio
				estela[0] = chispa.ruta[chispa.posicion];

				// Ajustar longitud de estela
				if (estela.length < longitudEstela) {
					estela.length = Math.min(estela.length + 1, longitudEstela);
				} else if (estela.length > longitudEstela) {
					estela.length = longitudEstela;
				}

				chispa.posicion += 1;
				chispa.progreso -= 1;

				// Verificar si llegamos al final de la ruta
				if (chispa.posicion >= chispa.ruta.length - 1) {
					// Eliminar chispa del array (in-place)
					chispas.splice(i, 1);
					break;
				}
			}
		}

		// Continuar el loop
		animationFrameRef.current = requestAnimationFrame(loopAnimacion);
	}, []);

	/**
	 * Iniciar los timers de emisi√≥n para todos los emisores activos
	 */
	const iniciarEmisiones = useCallback(() => {
		// Limpiar timers anteriores
		Object.values(emisionTimersRef.current).forEach(clearInterval);
		emisionTimersRef.current = {};

		const emisores = bornesRef.current.filter(b => b.tipo === "EMISOR" && b.activo);
		const frecuencia = configRef.current.frecuenciaEmision || 2000;

		emisores.forEach(emisor => {
			// Emitir una chispa inmediatamente
			emitirDesdeEmisor(emisor.id);

			// Configurar timer para emisiones peri√≥dicas
			const timer = setInterval(() => {
				if (animandoRef.current) {
					emitirDesdeEmisor(emisor.id);
				}
			}, frecuencia);

			emisionTimersRef.current[emisor.id] = timer;
		});
	}, [emitirDesdeEmisor]);

	/**
	 * Detener todos los timers de emisi√≥n
	 */
	const detenerEmisiones = useCallback(() => {
		Object.values(emisionTimersRef.current).forEach(clearInterval);
		emisionTimersRef.current = {};
	}, []);

	/**
	 * Reiniciar timers cuando cambia la frecuencia de emisi√≥n (mientras est√° animando)
	 */
	const frecuenciaActual = chispasConfig.frecuenciaEmision || 2000;

	useEffect(() => {
		if (animandoRef.current) {
			// Limpiar timers anteriores
			Object.values(emisionTimersRef.current).forEach(clearInterval);
			emisionTimersRef.current = {};

			const emisores = bornesRef.current.filter(b => b.tipo === "EMISOR" && b.activo);

			emisores.forEach(emisor => {
				// Configurar timer con la nueva frecuencia
				const timer = setInterval(() => {
					if (animandoRef.current) {
						emitirDesdeEmisor(emisor.id);
					}
				}, frecuenciaActual);

				emisionTimersRef.current[emisor.id] = timer;
			});
		}
	}, [frecuenciaActual, emitirDesdeEmisor]);

	/**
	 * Iniciar animaci√≥n
	 */
	const iniciarAnimacion = useCallback(() => {
		// Verificar que hay emisores y receptores
		const emisores = bornesRef.current.filter(b => b.tipo === "EMISOR" && b.activo);
		const receptores = bornesRef.current.filter(b => b.tipo === "RECEPTOR");

		if (emisores.length === 0 || receptores.length === 0) {
			return;
		}

		animandoRef.current = true;
		setAnimando(true);
		lastTimeRef.current = 0;

		// Limpiar chispas anteriores
		chispasRef.current = [];

		// Iniciar emisiones
		iniciarEmisiones();

		// Iniciar loop de animaci√≥n
		animationFrameRef.current = requestAnimationFrame(loopAnimacion);
	}, [iniciarEmisiones, loopAnimacion]);

	/**
	 * Detener animaci√≥n
	 */
	const detenerAnimacion = useCallback(() => {
		animandoRef.current = false;
		setAnimando(false);
		detenerEmisiones();
		chispasRef.current = [];

		if (animationFrameRef.current) {
			cancelAnimationFrame(animationFrameRef.current);
			animationFrameRef.current = null;
		}
	}, [detenerEmisiones]);

	/**
	 * Toggle animaci√≥n
	 */
	const toggleAnimacion = useCallback(() => {
		if (animandoRef.current) {
			detenerAnimacion();
		} else {
			iniciarAnimacion();
		}
	}, [iniciarAnimacion, detenerAnimacion]);

	/**
	 * Obtener posici√≥n en p√≠xeles de una chispa para renderizado
	 * Usa interpolaci√≥n lineal para movimiento constante y fluido
	 *
	 * @param {Object} chispa - Objeto chispa con ruta, posicion y progreso
	 * @returns {Object} { x, y } posici√≥n en p√≠xeles
	 */
	const obtenerPosicionPixel = useCallback((chispa) => {
		const { ruta, posicion, progreso } = chispa;
		const grosor = grosorLineaRef.current;

		if (!ruta || ruta.length === 0) {
			return { x: 0, y: 0 };
		}

		// Posici√≥n actual
		const [x1, y1] = ruta[posicion].split(",").map(Number);

		// Si estamos al final de la ruta, retornar la √∫ltima posici√≥n
		if (posicion >= ruta.length - 1) {
			return {
				x: x1 * grosor + grosor / 2,
				y: y1 * grosor + grosor / 2,
			};
		}

		// Posici√≥n siguiente para interpolaci√≥n
		const [x2, y2] = ruta[posicion + 1].split(",").map(Number);

		// Interpolaci√≥n lineal simple - movimiento constante sin aceleraci√≥n
		const x = (x1 + (x2 - x1) * progreso) * grosor + grosor / 2;
		const y = (y1 + (y2 - y1) * progreso) * grosor + grosor / 2;

		return { x, y };
	}, []);

	/**
	 * Obtener posiciones de la estela de una chispa
	 *
	 * @param {Object} chispa - Objeto chispa
	 * @returns {Array} Array de { x, y, opacidad }
	 */
	const obtenerEstelaPixeles = useCallback((chispa) => {
		const { estela } = chispa;
		const grosor = grosorLineaRef.current;

		if (!estela || estela.length === 0) {
			return [];
		}

		const resultado = [];
		for (let i = 0; i < estela.length; i++) {
			const clave = estela[i];
			if (!clave) continue;
			const [x, y] = clave.split(",").map(Number);
			resultado.push({
				x: x * grosor + grosor / 2,
				y: y * grosor + grosor / 2,
				opacidad: 1 - (i + 1) / (estela.length + 1),
			});
		}
		return resultado;
	}, []);

	/**
	 * Limpiar al desmontar
	 */
	useEffect(() => {
		return () => {
			animandoRef.current = false;
			detenerEmisiones();
			if (animationFrameRef.current) {
				cancelAnimationFrame(animationFrameRef.current);
			}
			chispasRef.current = [];
		};
	}, [detenerEmisiones]);

	return {
		// Estado
		animando,
		// *** CAMBIO: Devolver la referencia al array de chispas ***
		// El componente que usa este hook debe leer chispasRef.current
		chispas: chispasRef.current,
		chispasRef, // Tambi√©n exponer el ref directamente

		// Acciones
		iniciarAnimacion,
		detenerAnimacion,
		toggleAnimacion,

		// Utilidades para renderizado
		obtenerPosicionPixel,
		obtenerEstelaPixeles,
	};
};

export default useChispas;

// ===== ./src/paginas/PaginaAlimentadores/hooks/ui/useGestorModales.js =====

// src/paginas/PaginaAlimentadores/hooks/useGestorModales.js

import { useState, useCallback } from "react"; // estado y memoizaci√≥n de callbacks de React

/**
 * Gestor simple de modales identificados por una clave.
 * Permite abrir/cerrar y guardar datos asociados al modal.
 *
 * Estructura interna:
 *   estadoModales = {
 *     [idModal]: { abierto: boolean, datos: any }
 *   }
 */
export const useGestorModales = () => {
	const [estadoModales, setEstadoModales] = useState({});        // mapa de estados por id de modal

	const abrirModal = useCallback((idModal, datos = null) => {
		setEstadoModales((prev) => ({
			...prev,
			[idModal]: { abierto: true, datos },           // marca el modal como abierto y guarda datos opcionales
		}));
	}, []);

	const cerrarModal = useCallback((idModal) => {
		setEstadoModales((prev) => ({
			...prev,
			[idModal]: { abierto: false, datos: null },     // lo marca como cerrado y limpia datos
		}));
	}, []);

	const obtenerEstado = useCallback(
		(idModal) => estadoModales[idModal] || { abierto: false, datos: null }, // estado por defecto si nunca se abri√≥
		[estadoModales]
	);

	return { abrirModal, cerrarModal, obtenerEstado, estadoModales };
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (useGestorModales.js)

 - Este hook es un "mini gestor de ventanas": centraliza el estado de todos los modales usando una 
   clave (`idModal`) para cada uno.

 - `abrirModal(id, datos)` abre el modal con esa clave y opcionalmente le asocia un objeto `datos` 
   (por ejemplo, el alimentador que se est√° editando).

 - `cerrarModal(id)` cierra el modal y descarta cualquier dato previo asociado.

 - `obtenerEstado(id)` devuelve siempre un objeto con la forma `{ abierto: boolean, datos: any }`, 
   aunque ese modal nunca se haya abierto.

 - Al usar este hook en `VistaAlimentadores`, cada modal (nuevo puesto, editar puestos, configuraci√≥n 
   de alimentador, mapeo) simplemente pide su estado con `obtenerEstado("clave")` y lo abre/cierra 
	llamando a `abrirModal` o `cerrarModal`.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (useGestorModales.js)

0) Visi√≥n general del hook

   Este hook es un ‚Äúmini centro de control de modales‚Äù. Sirve para manejar
   varios modales a la vez usando una clave de texto (idModal) para cada uno.

   La estructura interna es:

     estadoModales = {
       [idModal]: {
         abierto: boolean,   // si el modal est√° visible o no
         datos: any          // info asociada al modal (por ejemplo, el alimentador a editar)
       }
     }

   En vez de tener un useState por cada modal (`isNuevoPuestoAbierto`, `isEditarPuestoAbierto`, etc.), 
	todo se maneja en un solo objeto y con tres funciones simples: abrir, cerrar y leer estado.


1) estadoModales (useState)

   const [estadoModales, setEstadoModales] = useState({});

   - `estadoModales` empieza como un objeto vac√≠o: no hay modales abiertos.

   - Cada vez que abrimos o cerramos un modal, vamos agregando o modificando entradas en este objeto 
	  con la forma:
       estadoModales["configAlim1"] = { abierto: true/false, datos: ... }

   - Tener todo en un solo estado hace f√°cil:
       ‚Ä¢ pasar el estado completo para debug,
       ‚Ä¢ o mostrar un panel de ‚Äúqu√© modales est√°n abiertos‚Äù si se necesitara.


2) abrirModal

   const abrirModal = useCallback((idModal, datos = null) => {
     setEstadoModales((prev) => ({
       ...prev,
       [idModal]: { abierto: true, datos },
     }));
   }, []);

   - Recibe:
       ‚Ä¢ `idModal`: una clave string que identifica al modal (ej: "nuevoPuesto", "editarAlimentador",
		   "mapeoAlim3", etc.),
       ‚Ä¢ `datos` (opcional): cualquier objeto que queramos asociar a ese modal (por ejemplo, el alimentador 
		   que se est√° editando).

   - Usa `setEstadoModales` con funci√≥n para tomar el estado anterior (`prev`) y devolver uno nuevo:
       ‚Ä¢ copia todo lo que ya exist√≠a (`...prev`),
       ‚Ä¢ reemplaza o crea la entrada para esa clave `idModal` con:
           { abierto: true, datos }.

   - Resultado: el modal queda marcado como abierto y con los datos que le pasamos.

   - Est√° envuelto en `useCallback(..., [])` para que la referencia de la funci√≥n se mantenga estable entre 
	  renders (ayuda a evitar renders extra si se pasa como prop a otros componentes).


3) cerrarModal

   const cerrarModal = useCallback((idModal) => {
     setEstadoModales((prev) => ({
       ...prev,
       [idModal]: { abierto: false, datos: null },
     }));
   }, []);

   - Recibe `idModal`, la misma clave que se us√≥ para abrir el modal.

   - Actualiza el estado:
       ‚Ä¢ mantiene el resto del objeto igual (`...prev`),
       ‚Ä¢ para esa clave, pone:
           { abierto: false, datos: null }.

   - Es decir:
       ‚Ä¢ marca el modal como cerrado,
       ‚Ä¢ y borra cualquier dato que se hubiera guardado antes.

   - Tambi√©n est√° memoizada con `useCallback` para que su referencia no cambie en cada render sin necesidad.


4) obtenerEstado

   const obtenerEstado = useCallback(
     (idModal) => estadoModales[idModal] || { abierto: false, datos: null },
     [estadoModales]
   );

   - Recibe `idModal` y devuelve SIEMPRE un objeto con esta forma:
       { abierto: boolean, datos: any }

   - Si ese modal ya fue usado antes:
       ‚Ä¢ devuelve el estado real guardado en `estadoModales[idModal]`.

   - Si ese modal nunca se abri√≥:
       ‚Ä¢ devuelve un estado ‚Äúpor defecto‚Äù:
           { abierto: false, datos: null }.

   - Esto simplifica mucho la UI porque evita tener que hacer chequeos tipo:
       if (estado && estado.abierto) ...
     En cambio, el componente puede hacer directamente:
       const { abierto, datos } = obtenerEstado("configAlim1");

   - Est√° envuelta en `useCallback` dependiente de `estadoModales` para que solo cambie la referencia 
	  de la funci√≥n cuando cambia el estado de los modales, no en cada render.


5) return del hook

   return { abrirModal, cerrarModal, obtenerEstado, estadoModales };

   - Expone cuatro cosas hacia los componentes que usan este hook:

       ‚Ä¢ `abrirModal(id, datos?)`
           ‚Üí marca el modal como abierto y asocia datos opcionales.

       ‚Ä¢ `cerrarModal(id)`
           ‚Üí marca el modal como cerrado y limpia los datos asociados.

       ‚Ä¢ `obtenerEstado(id)`
           ‚Üí devuelve siempre un objeto `{ abierto, datos }` para ese modal, aunque jam√°s se haya abierto.

       ‚Ä¢ `estadoModales`
           ‚Üí estado completo con todos los modales; √∫til para debug o para vistas que quieran mostrar 
			    un resumen general.

   - En `VistaAlimentadores`, cada modal se maneja as√≠:
       const { abierto, datos } = obtenerEstado("claveDelModal");

       y se abre/cierra con:
         abrirModal("claveDelModal", datosOpcionales);
         cerrarModal("claveDelModal");

   - De esta forma, no se acumula l√≥gica de ‚Äúqu√© modal est√° abierto‚Äù en cada
     componente: todo pasa por este hook centralizado.
---------------------------------------------------------------------------*/



// ===== ./src/paginas/PaginaAlimentadores/hooks/ui/useModoCompacto.js =====

// hooks/ui/useModoCompacto.js
// Hook para detectar y manejar el modo compacto/responsive

import { useState, useEffect, useCallback } from "react";

const BREAKPOINT_COMPACTO = 900;

/**
 * Hook para detectar modo compacto (m√≥vil) y ajustar escalas autom√°ticamente
 *
 * @param {Object} params
 * @param {number} params.escalaGlobal - Escala global configurada
 * @param {Function} params.obtenerEscalaEfectiva - Funci√≥n para obtener escala efectiva
 * @returns {Object} Estado de modo compacto y funciones ajustadas
 */
export const useModoCompacto = ({ escalaGlobal, obtenerEscalaEfectiva }) => {
   const [esCompacto, setEsCompacto] = useState(false);

   // Detectar modo compacto seg√∫n el ancho de la ventana
   useEffect(() => {
      const actualizarModo = () => setEsCompacto(window.innerWidth < BREAKPOINT_COMPACTO);
      actualizarModo();
      window.addEventListener("resize", actualizarModo);
      return () => window.removeEventListener("resize", actualizarModo);
   }, []);

   // En modo compacto (m√≥vil), forzar escala global a 1 para visualizaci√≥n
   const escalaGlobalEfectiva = esCompacto ? 1 : escalaGlobal;

   // Wrapper para obtenerEscalaEfectiva que considera el modo compacto
   const obtenerEscalaEfectivaConModoCompacto = useCallback(
      (alimentadorId, puestoId) => {
         if (esCompacto) {
            return 1;
         }
         return obtenerEscalaEfectiva(alimentadorId, puestoId);
      },
      [esCompacto, obtenerEscalaEfectiva]
   );

   return {
      esCompacto,
      escalaGlobalEfectiva,
      obtenerEscalaEfectivaConModoCompacto,
   };
};

// ===== ./src/paginas/PaginaAlimentadores/hooks/ui/useVentanaFlotante.js =====

// hooks/useVentanaFlotante.js
// Hook para manejar el comportamiento de ventanas flotantes (drag, resize)

import { useState, useEffect, useCallback, useRef } from "react";

/**
 * Hook para manejar el comportamiento de arrastrar y redimensionar ventanas flotantes
 * @param {Object} params - Par√°metros del hook
 * @param {boolean} params.maximizada - Si la ventana est√° maximizada
 * @param {Function} params.onMover - Callback cuando se mueve la ventana
 * @param {Function} params.onEnfocar - Callback cuando se enfoca la ventana
 * @param {Object} params.dimensionesMinimas - Dimensiones m√≠nimas { width, height }
 * @param {Object} params.dimensionesIniciales - Dimensiones iniciales { width, height }
 * @returns {Object} Estado y funciones de la ventana flotante
 */
export function useVentanaFlotante({
   maximizada = false,
   onMover,
   onEnfocar,
   dimensionesMinimas = { width: 600, height: 400 },
   dimensionesIniciales = { width: 900, height: 600 },
}) {
   const ventanaRef = useRef(null);
   const headerRef = useRef(null);

   // Estados para drag
   const [arrastrando, setArrastrando] = useState(false);
   const [offsetArrastre, setOffsetArrastre] = useState({ x: 0, y: 0 });

   // Estados para resize
   const [redimensionando, setRedimensionando] = useState(false);
   const [dimensiones, setDimensiones] = useState(dimensionesIniciales);
   const [dimensionesInicialesResize, setDimensionesInicialesResize] = useState({ width: 0, height: 0 });
   const [posicionInicialResize, setPosicionInicialResize] = useState({ x: 0, y: 0 });

   /**
    * Inicia el arrastre de la ventana
    */
   const handleMouseDownDrag = useCallback((e) => {
      if (maximizada) return;
      if (e.target.closest("button")) return;
      if (onEnfocar) onEnfocar();

      setArrastrando(true);
      const rect = ventanaRef.current?.getBoundingClientRect();
      if (rect) {
         setOffsetArrastre({
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
         });
      }
   }, [maximizada, onEnfocar]);

   /**
    * Inicia el redimensionado de la ventana
    */
   const handleMouseDownResize = useCallback((e) => {
      if (maximizada) return;
      e.preventDefault();
      e.stopPropagation();

      setRedimensionando(true);
      setPosicionInicialResize({ x: e.clientX, y: e.clientY });

      const rect = ventanaRef.current?.getBoundingClientRect();
      if (rect) {
         setDimensionesInicialesResize({ width: rect.width, height: rect.height });
      }
   }, [maximizada]);

   // Efecto para manejar el movimiento durante el arrastre
   useEffect(() => {
      if (!arrastrando) return;

      const handleMouseMove = (e) => {
         const newX = Math.max(0, e.clientX - offsetArrastre.x);
         const newY = Math.max(0, e.clientY - offsetArrastre.y);
         if (onMover) {
            onMover({ x: newX, y: newY });
         }
      };

      const handleMouseUp = () => {
         setArrastrando(false);
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);

      return () => {
         document.removeEventListener("mousemove", handleMouseMove);
         document.removeEventListener("mouseup", handleMouseUp);
      };
   }, [arrastrando, offsetArrastre, onMover]);

   // Efecto para manejar el redimensionado
   useEffect(() => {
      if (!redimensionando) return;

      const handleMouseMove = (e) => {
         const deltaX = e.clientX - posicionInicialResize.x;
         const deltaY = e.clientY - posicionInicialResize.y;
         const newWidth = Math.max(dimensionesMinimas.width, dimensionesInicialesResize.width + deltaX);
         const newHeight = Math.max(dimensionesMinimas.height, dimensionesInicialesResize.height + deltaY);
         setDimensiones({ width: newWidth, height: newHeight });
      };

      const handleMouseUp = () => {
         setRedimensionando(false);
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);

      return () => {
         document.removeEventListener("mousemove", handleMouseMove);
         document.removeEventListener("mouseup", handleMouseUp);
      };
   }, [redimensionando, posicionInicialResize, dimensionesInicialesResize, dimensionesMinimas]);

   return {
      ventanaRef,
      headerRef,
      dimensiones,
      arrastrando,
      redimensionando,
      handleMouseDownDrag,
      handleMouseDownResize,
   };
}

// ===== ./src/paginas/PaginaAlimentadores/hooks/ui/useVentanasHistorial.js =====

/**
 * Hook para gestionar m√∫ltiples ventanas de historial flotantes
 * Permite abrir, minimizar, maximizar y cerrar ventanas de historial
 * Solo permite una ventana por alimentador
 */

import { useState, useCallback, useRef } from "react";

// Z-index base para ventanas flotantes
const Z_INDEX_BASE = 1000;

export const useVentanasHistorial = () => {
  // Map de ventanas abiertas: { [alimentadorId]: estadoVentana }
  const [ventanas, setVentanas] = useState({});

  // Contador para z-index de ventanas (foco) - useRef para persistir sin re-renders
  const zIndexCounterRef = useRef(Z_INDEX_BASE);

  /**
   * Obtiene el siguiente z-index y lo incrementa
   */
  const getNextZIndex = useCallback(() => {
    zIndexCounterRef.current += 1;
    return zIndexCounterRef.current;
  }, []);

  /**
   * Estado inicial de una ventana
   */
  const crearEstadoVentana = useCallback((alimentador, cardDesign, posicionInicial) => ({
    id: alimentador.id,
    alimentador,
    cardDesign,
    minimizada: false,
    maximizada: false,
    posicion: posicionInicial || { x: 100 + Math.random() * 100, y: 50 + Math.random() * 50 },
    tama√±o: { width: 900, height: 600 },
    zIndex: getNextZIndex(),
  }), [getNextZIndex]);

  /**
   * Abre una ventana de historial para un alimentador
   * Si ya existe, la trae al frente y la restaura si estaba minimizada
   */
  const abrirVentana = useCallback((alimentador, cardDesign) => {
    setVentanas((prev) => {
      // Si ya existe la ventana para este alimentador
      if (prev[alimentador.id]) {
        // Traer al frente y restaurar si estaba minimizada
        return {
          ...prev,
          [alimentador.id]: {
            ...prev[alimentador.id],
            minimizada: false,
            zIndex: getNextZIndex(),
          },
        };
      }

      // Calcular posici√≥n escalonada basada en n√∫mero de ventanas
      const numVentanas = Object.keys(prev).length;
      const posicionInicial = {
        x: 50 + (numVentanas % 5) * 30,
        y: 50 + (numVentanas % 5) * 30,
      };

      // Crear nueva ventana
      return {
        ...prev,
        [alimentador.id]: crearEstadoVentana(alimentador, cardDesign, posicionInicial),
      };
    });
  }, [crearEstadoVentana, getNextZIndex]);

  /**
   * Cierra una ventana de historial
   */
  const cerrarVentana = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      const { [alimentadorId]: _, ...rest } = prev;
      return rest;
    });
  }, []);

  /**
   * Minimiza/restaura una ventana
   */
  const toggleMinimizar = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          minimizada: !prev[alimentadorId].minimizada,
        },
      };
    });
  }, []);

  /**
   * Maximiza/restaura una ventana
   */
  const toggleMaximizar = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          maximizada: !prev[alimentadorId].maximizada,
          zIndex: getNextZIndex(),
        },
      };
    });
  }, [getNextZIndex]);

  /**
   * Trae una ventana al frente (actualiza z-index)
   */
  const enfocarVentana = useCallback((alimentadorId) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          minimizada: false,
          zIndex: getNextZIndex(),
        },
      };
    });
  }, [getNextZIndex]);

  /**
   * Actualiza la posici√≥n de una ventana (al arrastrar)
   */
  const moverVentana = useCallback((alimentadorId, nuevaPosicion) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          posicion: nuevaPosicion,
        },
      };
    });
  }, []);

  /**
   * Actualiza el tama√±o de una ventana
   */
  const redimensionarVentana = useCallback((alimentadorId, nuevoTama√±o) => {
    setVentanas((prev) => {
      if (!prev[alimentadorId]) return prev;
      return {
        ...prev,
        [alimentadorId]: {
          ...prev[alimentadorId],
          tama√±o: nuevoTama√±o,
        },
      };
    });
  }, []);

  /**
   * Verifica si hay una ventana abierta para un alimentador
   */
  const tieneVentanaAbierta = useCallback(
    (alimentadorId) => {
      return !!ventanas[alimentadorId];
    },
    [ventanas]
  );

  /**
   * Obtiene la lista de ventanas como array (para renderizar)
   */
  const listaVentanas = Object.values(ventanas);

  /**
   * Obtiene las ventanas minimizadas (para barra de tareas)
   */
  const ventanasMinimizadas = listaVentanas.filter((v) => v.minimizada);

  return {
    ventanas,
    listaVentanas,
    ventanasMinimizadas,
    abrirVentana,
    cerrarVentana,
    toggleMinimizar,
    toggleMaximizar,
    enfocarVentana,
    moverVentana,
    redimensionarVentana,
    tieneVentanaAbierta,
  };
};

export default useVentanasHistorial;

// ===== ./src/paginas/PaginaAlimentadores/PaginaAlimentadoresSupabase.jsx =====

// src/paginas/PaginaAlimentadores/PaginaAlimentadoresSupabase.jsx
// Versi√≥n de la p√°gina que usa Supabase para persistencia

import React from "react";

import { ProveedorConfiguracion } from "./contexto/ContextoConfiguracion";
import { ProveedorAlimentadoresSupabase } from "./contexto/ContextoAlimentadoresSupabase";

import VistaAlimentadores from "./componentes/layout/VistaAlimentadores.jsx";

/**
 * P√°gina de alimentadores conectada a Supabase.
 *
 * Estructura de providers:
 * - ProveedorConfiguracion: maneja los workspaces del usuario
 * - ProveedorAlimentadoresSupabase: maneja puestos y alimentadores con Supabase
 */
const PaginaAlimentadoresSupabase = () => {
  return (
    <ProveedorConfiguracion>
      <ProveedorAlimentadoresSupabase>
        <VistaAlimentadores />
      </ProveedorAlimentadoresSupabase>
    </ProveedorConfiguracion>
  );
};

export default PaginaAlimentadoresSupabase;

// ===== ./src/paginas/PaginaAlimentadores/utilidades/calculadorRutas.js =====

// src/paginas/PaginaAlimentadores/utilidades/calculadorRutas.js

/**
 * Utilidades para calcular rutas en el diagrama unifilar.
 * Las chispas viajan desde bornes emisores hasta bornes receptores
 * siguiendo las l√≠neas (celdas adyacentes) del diagrama.
 */

/**
 * Construye un grafo de adyacencia a partir de las celdas pintadas.
 * Cada celda puede conectarse con sus 4 vecinos (arriba, abajo, izquierda, derecha)
 * si estos tambi√©n est√°n pintados (sin importar el color).
 *
 * @param {Object} celdas - Objeto con claves "x,y" y valores de color
 * @returns {Object} Grafo de adyacencia { "x,y": ["x1,y1", "x2,y2", ...] }
 */
export function construirGrafo(celdas) {
	const grafo = {};
	const clavesCeldas = Object.keys(celdas);

	// Para b√∫squeda r√°pida
	const celdasSet = new Set(clavesCeldas);

	clavesCeldas.forEach(clave => {
		const [x, y] = clave.split(",").map(Number);
		const vecinos = [];

		// Verificar los 4 vecinos
		const posiblesVecinos = [
			`${x},${y - 1}`, // arriba
			`${x},${y + 1}`, // abajo
			`${x - 1},${y}`, // izquierda
			`${x + 1},${y}`, // derecha
		];

		posiblesVecinos.forEach(vecino => {
			if (celdasSet.has(vecino)) {
				vecinos.push(vecino);
			}
		});

		grafo[clave] = vecinos;
	});

	return grafo;
}

/**
 * Calcula todas las rutas posibles desde un emisor hasta cualquier receptor.
 * Usa BFS para encontrar el camino m√°s corto a cada receptor.
 *
 * @param {Object} emisor - Borne emisor { x, y, id, ... }
 * @param {Array} bornes - Array de todos los bornes
 * @param {Object} grafo - Grafo de adyacencia
 * @returns {Array} Array de rutas [{ receptorId, ruta: ["x,y", ...] }, ...]
 */
export function calcularRutasDesdeEmisor(emisor, bornes, grafo) {
	const claveEmisor = `${emisor.x},${emisor.y}`;
	const receptores = bornes.filter(b => b.tipo === "RECEPTOR");

	// Si no hay grafo o el emisor no est√° en el grafo, retornar vac√≠o
	if (!grafo[claveEmisor]) {
		return [];
	}

	// Crear mapa de posici√≥n a borne para b√∫squeda r√°pida
	const posicionAReceptor = {};
	receptores.forEach(r => {
		posicionAReceptor[`${r.x},${r.y}`] = r;
	});

	// BFS para encontrar rutas a todos los receptores
	const rutas = [];
	const visitados = new Set([claveEmisor]);
	const cola = [[claveEmisor, [claveEmisor]]]; // [posici√≥n, rutaHastaAqu√≠]

	while (cola.length > 0) {
		const [posActual, rutaActual] = cola.shift();

		// Si llegamos a un receptor, guardar la ruta
		if (posActual !== claveEmisor && posicionAReceptor[posActual]) {
			rutas.push({
				receptorId: posicionAReceptor[posActual].id,
				ruta: rutaActual,
			});
			// Continuamos buscando para encontrar otros receptores
		}

		// Explorar vecinos
		const vecinos = grafo[posActual] || [];
		vecinos.forEach(vecino => {
			if (!visitados.has(vecino)) {
				visitados.add(vecino);
				cola.push([vecino, [...rutaActual, vecino]]);
			}
		});
	}

	return rutas;
}

/**
 * Verifica si desde una celda se puede llegar a alg√∫n receptor
 * (usado para decisiones en bifurcaciones).
 *
 * @param {string} celda - Clave de la celda "x,y"
 * @param {Set} receptoresSet - Set de claves de receptores
 * @param {Object} grafo - Grafo de adyacencia
 * @param {Set} visitados - Celdas ya visitadas (para evitar ciclos)
 * @returns {boolean} true si se puede llegar a un receptor
 */
export function llegaAReceptor(celda, receptoresSet, grafo, visitados = new Set()) {
	if (receptoresSet.has(celda)) {
		return true;
	}

	if (visitados.has(celda)) {
		return false;
	}

	visitados.add(celda);

	const vecinos = grafo[celda] || [];
	for (const vecino of vecinos) {
		if (!visitados.has(vecino)) {
			if (llegaAReceptor(vecino, receptoresSet, grafo, visitados)) {
				return true;
			}
		}
	}

	return false;
}

/**
 * Dado el estado actual de una chispa en una bifurcaci√≥n,
 * determina hacia qu√© caminos debe continuar.
 *
 * Reglas:
 * - Si ambos caminos llevan a receptores: la chispa se divide (retorna ambos)
 * - Si ambos caminos llevan a emisores: la chispa desaparece (retorna vac√≠o)
 * - Si hay mezcla: sigue solo hacia el receptor (retorna solo el camino correcto)
 *
 * @param {string} posicionActual - Clave de la celda actual
 * @param {string} posicionAnterior - Clave de la celda anterior (de donde viene)
 * @param {Object} grafo - Grafo de adyacencia
 * @param {Array} bornes - Array de todos los bornes
 * @returns {Array} Array de claves de celdas hacia donde continuar
 */
export function decidirDireccionEnBifurcacion(posicionActual, posicionAnterior, grafo, bornes) {
	const vecinos = grafo[posicionActual] || [];

	// Filtrar el vecino de donde venimos
	const posiblesCaminos = vecinos.filter(v => v !== posicionAnterior);

	// Si solo hay un camino o ninguno, no hay decisi√≥n
	if (posiblesCaminos.length <= 1) {
		return posiblesCaminos;
	}

	// Crear sets para b√∫squeda r√°pida
	const emisoresSet = new Set(
		bornes.filter(b => b.tipo === "EMISOR").map(b => `${b.x},${b.y}`)
	);
	const receptoresSet = new Set(
		bornes.filter(b => b.tipo === "RECEPTOR").map(b => `${b.x},${b.y}`)
	);

	// Verificar cada camino si lleva a receptor
	const caminosAReceptor = [];
	const caminosAEmisor = [];

	posiblesCaminos.forEach(camino => {
		// Clonar visitados para cada exploraci√≥n
		const visitados = new Set([posicionActual, posicionAnterior]);

		if (llegaAReceptor(camino, receptoresSet, grafo, visitados)) {
			caminosAReceptor.push(camino);
		} else {
			// Si no llega a receptor, asumimos que lleva a emisor o callej√≥n sin salida
			caminosAEmisor.push(camino);
		}
	});

	// Aplicar reglas de bifurcaci√≥n
	if (caminosAReceptor.length > 0) {
		// Si hay caminos a receptores, seguir todos ellos (dividir chispa)
		return caminosAReceptor;
	} else {
		// Todos llevan a emisores o callejones: la chispa desaparece
		return [];
	}
}


// ===== ./src/paginas/PaginaAlimentadores/utilidades/calculosFormulas.js =====

// src/paginas/PaginaAlimentadores/utilidades/calculosFormulas.js

/**
 * Aplica una f√≥rmula matem√°tica a un valor 'x'.
 * Ejemplo: aplicarFormula("x * 2 + 10", 5) => 20.
 *
 * NOTA EDUCATIVA: Usamos new Function() solo para ambiente de aprendizaje.
 * En producci√≥n se usar√≠a una librer√≠a como mathjs para mayor seguridad.
 *
 * @param {string} textoFormula - F√≥rmula en texto, ej: "x / 100".
 * @param {number} x - Valor al que aplicar la f√≥rmula.
 * @returns {number|null} Resultado o null si hay error.
 */
export const aplicarFormula = (textoFormula, x) => {
	const formulaLimpia = (textoFormula || "").trim(); // quita espacios y maneja null/undefined

	// Si no hay f√≥rmula, devolver el valor sin cambios
	if (!formulaLimpia) return x;

	try {
		// Crear funci√≥n din√°mica (solo para ambiente educativo)
		const funcionCalcular = new Function("x", `return ${formulaLimpia};`);
		const resultado = funcionCalcular(x);          // eval√∫a la f√≥rmula con el valor x

		// Verificar que sea n√∫mero v√°lido
		return typeof resultado === "number" && !Number.isNaN(resultado)
			 ? resultado
		 : null;
	} catch (error) {
		console.error("Error al aplicar f√≥rmula:", error);
		return null;                                   // ante error sint√°ctico o ejecuci√≥n, devolvemos null
	}
};

/**
 * Formatea un n√∫mero para mostrarlo en la interfaz.
 * Ejemplos:
 *   - 123.456 => "123,46"
 *   - null => "ERROR"
 *   - NaN => "ERROR"
 *
 * @param {number} valor - N√∫mero a formatear.
 * @returns {string} Valor formateado con 2 decimales y coma.
 */
export const formatearValor = (valor) => {
	// Si es inv√°lido, mostrar ERROR
	if (valor == null || Number.isNaN(valor)) {
		return "ERROR";
	}

	// Convertir a 2 decimales y cambiar punto por coma
	return valor.toFixed(2).replace(".", ",");
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (calculosFormulas.js)

 - `aplicarFormula(textoFormula, x)` permite que cada box de medici√≥n tenga una
   f√≥rmula configurable en texto (por ejemplo, "x * 500 / 1000") que se eval√∫a
   sobre el valor crudo le√≠do del registro Modbus.

 - Para mantenerlo simple se usa `new Function("x", "return ...")`, lo que es
   suficiente en este proyecto educativo pero no ser√≠a adecuado en un entorno
   productivo sin sandboxing.

 - `formatearValor(valor)` toma el n√∫mero ya calculado y lo convierte a un
   string con 2 decimales y coma como separador, o "ERROR" si el valor no es
   v√°lido. Es la salida final que se ve en cada caja de la tarjeta.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (calculosFormulas.js)

0) Visi√≥n general del m√≥dulo

   Este archivo concentra dos utilidades relacionadas con el c√°lculo y
   presentaci√≥n de valores num√©ricos en las tarjetas de medici√≥n:

   - `aplicarFormula`: toma un valor crudo (x) y le aplica una f√≥rmula
     configurable en texto.

   - `formatearValor`: toma el n√∫mero ya calculado y lo convierte a un string
     listo para mostrar en pantalla.


1) aplicarFormula(textoFormula, x)

   export const aplicarFormula = (textoFormula, x) => {
     const formulaLimpia = (textoFormula || "").trim();
     if (!formulaLimpia) return x;

     try {
       const funcionCalcular = new Function("x", `return ${formulaLimpia};`);
       const resultado = funcionCalcular(x);

       return typeof resultado === "number" && !Number.isNaN(resultado)
         ? resultado
         : null;
     } catch (error) {
       console.error("Error al aplicar f√≥rmula:", error);
       return null;
     }
   };

   - Par√°metros:
       ‚Ä¢ `textoFormula`: string con la expresi√≥n matem√°tica, por ejemplo
         "x * 500 / 1000" o "x / 100".
       ‚Ä¢ `x`: valor num√©rico crudo que viene del registro Modbus.

   - Flujo:
       1) Limpia el texto con `trim()` y maneja null/undefined.
       2) Si la f√≥rmula queda vac√≠a, devuelve directamente `x` sin cambios
          (equivale a "no hay f√≥rmula").
       3) Construye din√°micamente una funci√≥n con `new Function("x", ...)` que
          devuelve el resultado de la expresi√≥n.
       4) Llama a esa funci√≥n pasando `x` y guarda el resultado.
       5) Si el resultado es un n√∫mero v√°lido, lo devuelve; si no, devuelve null.

   - Seguridad / contexto educativo:
       ‚Ä¢ `new Function` y cualquier ejecuci√≥n de c√≥digo din√°mico deben evitarse
         en producci√≥n (riesgo de inyecci√≥n de c√≥digo).
       ‚Ä¢ En este proyecto se usa con fines did√°cticos; en un sistema real ser√≠a
         preferible usar una librer√≠a como mathjs o un parser de expresiones
         controlado.


2) formatearValor(valor)

   export const formatearValor = (valor) => {
     if (valor == null || Number.isNaN(valor)) {
       return "ERROR";
     }
     return valor.toFixed(2).replace(".", ",");
   };

   - Par√°metro:
       ‚Ä¢ `valor`: n√∫mero ya procesado (por ejemplo, despu√©s de aplicar la
         f√≥rmula), que se quiere mostrar en la UI.

   - Flujo:
       1) Si `valor` es null, undefined o NaN, devuelve el string "ERROR".
          Esto permite a la interfaz diferenciar claramente un problema de
          c√°lculo de un dato v√°lido.

       2) Si es un n√∫mero v√°lido, usa `toFixed(2)` para dejarlo con dos
          decimales.

       3) Cambia el punto decimal por coma para seguir el formato
          habitual "123,45".

   - Resultado t√≠pico:
       ‚Ä¢ 123.456  ‚Üí "123,46"
       ‚Ä¢ 7        ‚Üí "7,00"
       ‚Ä¢ null     ‚Üí "ERROR"


3) Uso dentro del flujo de mediciones

   - Normalmente, el pipeline es:
       1) Leer registro Modbus ‚Üí valor crudo.

       2) Aplicar `aplicarFormula` con la f√≥rmula definida en el mapeo
          (si falla o devuelve null, se considera error).
			 
       3) Pasar el resultado num√©rico por `formatearValor` para obtener el
          texto final que se mostrar√° en la `CajaMedicion`.

   - Al centralizar estas operaciones en un m√≥dulo, se garantiza un criterio
     uniforme de c√°lculo y de formato a lo largo de toda la app.

---------------------------------------------------------------------------*/
// ===== ./src/paginas/PaginaAlimentadores/utilidades/calculosHistorial.js =====

// utilidades/calculosHistorial.js
// C√°lculos espec√≠ficos para historial de lecturas

import { aplicarFormula } from "./calculosFormulas";
import { TITULOS_MEDICIONES } from "../constantes/titulosMediciones";

/**
 * Obtiene el t√≠tulo de una zona del card design
 * @param {Object} cardDesign - Configuraci√≥n del dise√±o de tarjeta
 * @param {'superior'|'inferior'} zona - Zona a obtener
 * @returns {string} T√≠tulo de la zona
 */
export const obtenerTituloZona = (cardDesign, zona) => {
   const config = cardDesign?.[zona];
   if (!config) return zona === "superior" ? "Superior" : "Inferior";
   if (config.tituloCustom?.trim()) return config.tituloCustom;
   if (config.tituloId && TITULOS_MEDICIONES[config.tituloId]) {
      return TITULOS_MEDICIONES[config.tituloId];
   }
   return zona === "superior" ? "Superior" : "Inferior";
};

/**
 * Calcula el promedio de valores de una zona basado en la lectura y configuraci√≥n
 * @param {Object} lectura - Lectura con valores y timestamp
 * @param {Object} zonaConfig - Configuraci√≥n de la zona (boxes habilitados)
 * @returns {number|null} Promedio calculado o null si no hay datos v√°lidos
 */
export const calcularPromedioZona = (lectura, zonaConfig) => {
   if (!lectura?.valores || !Array.isArray(lectura.valores)) return null;
   if (!zonaConfig?.boxes) return null;

   const indiceInicial = lectura.indiceInicial ?? lectura.indice_inicial ?? 0;
   const valoresCalculados = [];

   zonaConfig.boxes.forEach((box) => {
      if (!box.enabled) return;
      const registro = box.registro ?? box.indice;
      if (registro === null || registro === undefined) return;
      const indiceEnArray = registro - indiceInicial;
      if (indiceEnArray < 0 || indiceEnArray >= lectura.valores.length) return;
      const valorCrudo = lectura.valores[indiceEnArray];
      if (valorCrudo === null || valorCrudo === undefined) return;
      const valorCalculado = aplicarFormula(box.formula || "x", valorCrudo);
      if (valorCalculado !== null && !Number.isNaN(valorCalculado) && valorCalculado !== 0) {
         valoresCalculados.push(valorCalculado);
      }
   });

   if (valoresCalculados.length === 0) return null;
   const suma = valoresCalculados.reduce((a, b) => a + b, 0);
   return suma / valoresCalculados.length;
};

/**
 * Calcula estad√≠sticas de un conjunto de datos de gr√°fico
 * @param {Array<{x: Date, y: number}>} datosGrafico - Datos del gr√°fico
 * @returns {Object|null} Estad√≠sticas (puntos, min, max, promedio) o null
 */
export const calcularEstadisticasGrafico = (datosGrafico) => {
   if (!datosGrafico || datosGrafico.length === 0) return null;

   const valores = datosGrafico.map((d) => d.y);
   const minVal = Math.min(...valores);
   const maxVal = Math.max(...valores);
   const promedio = valores.reduce((a, b) => a + b, 0) / valores.length;

   const puntoMin = datosGrafico.find((d) => d.y === minVal);
   const puntoMax = datosGrafico.find((d) => d.y === maxVal);

   const formatearFecha = (date) => {
      if (!date) return "";
      const d = new Date(date);
      const dia = d.getDate().toString().padStart(2, "0");
      const mes = (d.getMonth() + 1).toString().padStart(2, "0");
      const anio = d.getFullYear().toString().slice(-2);
      const hora = d.getHours().toString().padStart(2, "0");
      const min = d.getMinutes().toString().padStart(2, "0");
      return `${dia}/${mes}/${anio} - ${hora}:${min} hs.`;
   };

   return {
      puntos: datosGrafico.length,
      min: minVal.toFixed(2),
      minFecha: formatearFecha(puntoMin?.x),
      max: maxVal.toFixed(2),
      maxFecha: formatearFecha(puntoMax?.x),
      promedio: promedio.toFixed(2),
   };
};

/**
 * Calcula los l√≠mites para el slider de escala Y
 * @param {Array<{y: number}>} datosFiltrados - Datos filtrados del gr√°fico
 * @returns {{min: number, max: number, valorMaxDatos: number}} L√≠mites de escala
 */
export const calcularLimitesEscalaY = (datosFiltrados) => {
   if (!datosFiltrados || datosFiltrados.length === 0) {
      return { min: 10, max: 100, valorMaxDatos: 0 };
   }

   const valores = datosFiltrados.map((d) => d.y);
   const valorMaxDatos = Math.max(...valores);
   const minRedondeado = Math.ceil(valorMaxDatos);
   const maxRedondeado = Math.ceil(valorMaxDatos * 2);

   return {
      min: Math.max(minRedondeado, 1),
      max: Math.max(maxRedondeado, minRedondeado + 10),
      valorMaxDatos,
   };
};

/**
 * Filtra datos por intervalo de tiempo
 * @param {Array<{x: Date, y: number}>} datosGrafico - Datos completos
 * @param {number} intervaloMinutos - Intervalo en minutos (0 = todos)
 * @returns {Array} Datos filtrados
 */
export const filtrarDatosPorIntervalo = (datosGrafico, intervaloMinutos) => {
   if (intervaloMinutos === 0 || !datosGrafico || datosGrafico.length === 0) {
      return datosGrafico;
   }

   if (datosGrafico.length === 1) {
      return datosGrafico;
   }

   const intervaloMs = intervaloMinutos * 60 * 1000;
   const resultado = [];
   let ultimoTimestamp = 0;

   for (const punto of datosGrafico) {
      const timestamp = new Date(punto.x).getTime();
      if (ultimoTimestamp === 0 || timestamp - ultimoTimestamp >= intervaloMs) {
         resultado.push(punto);
         ultimoTimestamp = timestamp;
      }
   }

   // Siempre incluir la √∫ltima lectura
   const ultimaLectura = datosGrafico[datosGrafico.length - 1];
   const ultimaEnResultado = resultado[resultado.length - 1];
   if (ultimaLectura !== ultimaEnResultado) {
      resultado.push(ultimaLectura);
   }

   return resultado;
};

/**
 * Genera t√≠tulo del panel de datos basado en el per√≠odo de los datos
 * @param {Array<{x: Date}>} datosGrafico - Datos del gr√°fico
 * @returns {string} T√≠tulo del per√≠odo
 */
export const generarTituloPeriodo = (datosGrafico) => {
   if (!datosGrafico || datosGrafico.length === 0) return "Sin datos";

   const primeraFecha = new Date(datosGrafico[0].x);
   const ultimaFecha = new Date(datosGrafico[datosGrafico.length - 1].x);

   const formatoFecha = { day: "2-digit", month: "2-digit", year: "2-digit" };
   const primeraStr = primeraFecha.toLocaleDateString("es-AR", formatoFecha);
   const ultimaStr = ultimaFecha.toLocaleDateString("es-AR", formatoFecha);

   if (primeraStr === ultimaStr) {
      return primeraStr;
   }
   return `${primeraStr} - ${ultimaStr}`;
};

// ===== ./src/paginas/PaginaAlimentadores/utilidades/calculosMediciones.js =====

// src/paginas/PaginaAlimentadores/utilidades/calculosMediciones.js

import { aplicarFormula, formatearValor } from "./calculosFormulas"; // helpers para f√≥rmulas y formato de n√∫meros
import {
	TITULOS_MEDICIONES,
	ETIQUETAS_POR_DEFECTO,
	DISE√ëO_TARJETA_POR_DEFECTO,
} from "../constantes/titulosMediciones";

/**
 * Obtiene la lista de registros seg√∫n el origen (rele o analizador).
 *
 * @param {Object} registrosPorOrigen - { rele: [...], analizador: [...] }.
 * @param {string} origen - "rele" o "analizador".
 * @returns {Array|null} Lista de registros o null.
 */
export const obtenerListaRegistros = (registrosPorOrigen, origen) => {
	if (!registrosPorOrigen) return null;
	const clave = origen === "analizador" ? "analizador" : "rele"; // default: rele
	const lista = registrosPorOrigen[clave];
	return Array.isArray(lista) ? lista : null;
};

/**
 * Obtiene el dise√±o de la tarjeta desde card_design o mapeoMediciones (legacy).
 * Si no hay configuraci√≥n, devuelve el dise√±o por defecto.
 *
 * @param {Object} cardDesign - Configuraci√≥n directa de card_design (nuevo formato)
 *                              o mapeoMediciones.cardDesign (legacy).
 * @returns {Object} Dise√±o con estructura { superior: {...}, inferior: {...} }.
 */
export const obtenerDisenoTarjeta = (cardDesign) => {
	// Si no hay dise√±o, usar por defecto
	if (!cardDesign || Object.keys(cardDesign).length === 0) {
		return DISE√ëO_TARJETA_POR_DEFECTO;
	}

	// Nuevo formato: card_design ya tiene { superior, inferior } directamente
	// Legacy: mapeoMediciones ten√≠a cardDesign.superior/inferior
	const dise√±o = cardDesign.cardDesign || cardDesign;

	// Si el dise√±o tiene superior/inferior, usarlo
	if (dise√±o.superior || dise√±o.inferior) {
		return {
			superior: normalizarLadoDiseno(dise√±o.superior, DISE√ëO_TARJETA_POR_DEFECTO.superior),
			inferior: normalizarLadoDiseno(dise√±o.inferior, DISE√ëO_TARJETA_POR_DEFECTO.inferior),
		};
	}

	return DISE√ëO_TARJETA_POR_DEFECTO;
};

/**
 * Normaliza un lado del dise√±o, convirtiendo el formato del modal al formato esperado.
 * El modal guarda: { tituloId, tituloCustom, cantidad, boxes: [{ enabled, label, indice, formula }] }
 * El c√°lculo espera: { tituloId, tituloCustom, cantidad, boxes: [{ enabled, label, registro, formula, origen }] }
 */
const normalizarLadoDiseno = (lado, ladoDefault) => {
	if (!lado) return ladoDefault;

	// Normalizar los boxes: convertir 'indice' a 'registro' si es necesario
	const boxesNormalizados = (lado.boxes || []).map((box) => ({
		enabled: !!box.enabled,
		label: box.label || "",
		// El modal guarda 'indice', el c√°lculo espera 'registro'
		registro: box.registro !== undefined ? box.registro : box.indice,
		formula: box.formula || "",
		origen: box.origen || "rele", // por defecto rel√©
	}));

	return {
		...ladoDefault,
		...lado,
		boxes: boxesNormalizados,
		oculto: !!lado.oculto, // preservar si la zona est√° marcada como oculta
	};
};

/**
 * Resuelve el t√≠tulo de un lado de la tarjeta.
 * Puede ser un t√≠tulo predefinido o uno personalizado.
 *
 * @param {Object} dise√±oLado - { tituloId, tituloCustom, ... }.
 * @returns {string} T√≠tulo a mostrar.
 */
export const resolverTituloLado = (dise√±oLado) => {
	if (!dise√±oLado) return "";

	// Si es custom, usar el t√≠tulo personalizado
	if (dise√±oLado.tituloId === "custom") {
		return (dise√±oLado.tituloCustom || "").trim();
	}

	// Sino, buscar en la lista de t√≠tulos predefinidos
	return TITULOS_MEDICIONES[dise√±oLado.tituloId] || "";
};

/**
 * Calcula los valores para mostrar en un lado de la tarjeta (superior o inferior).
 * Aplica f√≥rmulas, formatea valores y maneja errores.
 *
 * @param {Object} registrosPorOrigen - { rele: [...], analizador: [...] }.
 * @param {Object} dise√±oLado - Configuraci√≥n del lado de la tarjeta.
 * @returns {Object} { titulo: string, boxes: [{ etiqueta, valor, enabled, origen }] }.
 */
export const calcularValoresLadoTarjeta = (registrosPorOrigen, dise√±oLado) => {
	if (!dise√±oLado) {
		return {
			titulo: "",
			boxes: [],
		};
	}

	const titulo = resolverTituloLado(dise√±oLado); // texto que va arriba del grupo
	const cantidad = Math.min(
		4,
		Math.max(1, Number(dise√±oLado.cantidad) || 1)
	); // fuerza cantidad a [1,4]
	const boxesSalida = [];

	const etiquetasDefault = ETIQUETAS_POR_DEFECTO[dise√±oLado.tituloId] || [];

	for (let i = 0; i < cantidad; i++) {
		const configuracion = dise√±oLado.boxes?.[i] || {};
		const etiqueta =
			(configuracion.label || "").trim() ||
			etiquetasDefault[i] ||
			`Box ${i + 1}`; // etiqueta efectiva que se ver√°

		let valorMostrado = "--,--"; // placeholder por defecto

		if (configuracion.enabled) {
			const numeroRegistro = Number(configuracion.registro);

			// Si hay registro configurado (n√∫mero v√°lido o 0, y no string vac√≠o)
			if (
				(Number.isFinite(numeroRegistro) || numeroRegistro === 0) &&
				configuracion.registro !== ""
			) {
				const origen = configuracion.origen || "rele"; // default: rele
				const listaRegistros = obtenerListaRegistros(
					registrosPorOrigen,
					origen
				);

				if (listaRegistros && listaRegistros.length > 0) {
					// Buscar el registro por su direcci√≥n (address)
					const registroEncontrado = listaRegistros.find(
						(r) => r.address === numeroRegistro
					);

					if (!registroEncontrado) {
						valorMostrado = "ERROR"; // no se encontr√≥ el registro
					} else {
						// Aplicar f√≥rmula al valor del registro
						const valorCalculado = aplicarFormula(
							configuracion.formula || "x",
							registroEncontrado.value
						);

						if (
							valorCalculado == null ||
							Number.isNaN(valorCalculado)
						) {
							valorMostrado = "ERROR";
						} else {
							valorMostrado = formatearValor(valorCalculado);
						}
					}
				}
			}
		}

		boxesSalida.push({
			etiqueta,
			valor: valorMostrado,
			enabled: !!configuracion.enabled,
			origen: configuracion.origen || "rele",
		});
	}

	return { titulo, boxes: boxesSalida, oculto: !!dise√±oLado.oculto };
};

{/*---------------------------------------------------------------------------
 NOTA SOBRE ESTE ARCHIVO (calculosMediciones.js)

 - Este m√≥dulo es el "traductor" entre los registros Modbus crudos y lo que
   termina viendo la tarjeta en pantalla.

 - Flujo general:
     * `obtenerListaRegistros` elige la lista correcta (`rele` o `analizador`)
       dentro del objeto `{ rele, analizador }`.

     * `obtenerDisenoTarjeta` fusiona el `cardDesign` guardado en el mapeo con
       `DISE√ëO_TARJETA_POR_DEFECTO` para garantizar que siempre haya estructura
       v√°lida para superior e inferior.

     * `resolverTituloLado` convierte `tituloId` en un texto legible, o usa
       el `tituloCustom` si se eligi√≥ la opci√≥n "custom".

     * `calcularValoresLadoTarjeta` recorre cada box configurado:
         - busca el registro por `address`,
         - aplica la f√≥rmula configurada (con `aplicarFormula`),
         - formatea el resultado (`formatearValor`),
         - o deja "ERROR" / "--,--" seg√∫n corresponda.

 - El resultado de `calcularValoresLadoTarjeta` es lo que consume la
   `TarjetaAlimentador` para pintar etiquetas y valores en cada caja.
---------------------------------------------------------------------------*/}

/*---------------------------------------------------------------------------
C√ìDIGO + EXPLICACI√ìN DE CADA PARTE (calculosMediciones.js)

0) Visi√≥n general del m√≥dulo

   Este archivo es el "traductor" entre:
   - los registros Modbus crudos que vienen del rel√© / analizador, y
   - la estructura amigable que necesita la tarjeta para dibujar cada box
     (etiqueta, valor formateado, enabled, origen).

   Se apoya en:
     ‚Ä¢ `calculosFormulas.js` para aplicar f√≥rmulas y formatear n√∫meros,
     ‚Ä¢ las constantes de `titulosMediciones` para t√≠tulos y etiquetas por defecto.


1) obtenerListaRegistros(registrosPorOrigen, origen)

   export const obtenerListaRegistros = (registrosPorOrigen, origen) => {
     if (!registrosPorOrigen) return null;
     const clave = origen === "analizador" ? "analizador" : "rele";
     const lista = registrosPorOrigen[clave];
     return Array.isArray(lista) ? lista : null;
   };

   - Par√°metros:
       ‚Ä¢ `registrosPorOrigen`: objeto con las listas de lecturas, por ejemplo
         `{ rele: [...], analizador: [...] }`.
       ‚Ä¢ `origen`: string `"rele"` o `"analizador"`.

   - Comportamiento:
       ‚Ä¢ Si el origen es `"analizador"`, usa la clave `"analizador"`;
         en cualquier otro caso cae a `"rele"` como valor por defecto.
       ‚Ä¢ Si encuentra una lista y es un array, la devuelve; si no, devuelve null.

   - Uso t√≠pico:
       ‚Ä¢ Desde `calcularValoresLadoTarjeta` para obtener la lista correcta
         antes de buscar un registro por direcci√≥n.


2) obtenerDisenoTarjeta(mapeoMediciones)

   export const obtenerDisenoTarjeta = (mapeoMediciones) => {
     const dise√±o = mapeoMediciones?.cardDesign;
     if (!dise√±o) return DISE√ëO_TARJETA_POR_DEFECTO;

     return {
       superior: {
         ...DISE√ëO_TARJETA_POR_DEFECTO.superior,
         ...(dise√±o.superior || {}),
       },
       inferior: {
         ...DISE√ëO_TARJETA_POR_DEFECTO.inferior,
         ...(dise√±o.inferior || {}),
       },
     };
   };

   - Toma el `cardDesign` guardado en el mapeo (si existe) y lo fusiona con
     `DISE√ëO_TARJETA_POR_DEFECTO`.

   - Objetivo:
       ‚Ä¢ garantizar que siempre haya un objeto bien formado para `superior` e
         `inferior`, con campos y estructuras m√≠nimas aunque falten datos.

   - Si `mapeoMediciones` no tiene `cardDesign`, devuelve directamente el
     dise√±o por defecto (corriente arriba, tensi√≥n abajo, etc.).


3) resolverTituloLado(dise√±oLado)

   export const resolverTituloLado = (dise√±oLado) => {
     if (!dise√±oLado) return "";

     if (dise√±oLado.tituloId === "custom") {
       return (dise√±oLado.tituloCustom || "").trim();
     }

     return TITULOS_MEDICIONES[dise√±oLado.tituloId] || "";
   };

   - Si el `tituloId` es `"custom"`, usa el texto libre `tituloCustom`.

   - En caso contrario, busca el t√≠tulo en `TITULOS_MEDICIONES` usando
     `tituloId` como clave (ej: `"tension_linea"`, `"corriente_132"`, etc.).

   - Si no encuentra nada, devuelve string vac√≠o.


4) calcularValoresLadoTarjeta(registrosPorOrigen, dise√±oLado)

   export const calcularValoresLadoTarjeta = (registrosPorOrigen, dise√±oLado) => {
     if (!dise√±oLado) {
       return { titulo: "", boxes: [] };
     }

     const titulo = resolverTituloLado(dise√±oLado);
     const cantidad = Math.min(4, Math.max(1, Number(dise√±oLado.cantidad) || 1));
     const boxesSalida = [];
     const etiquetasDefault = ETIQUETAS_POR_DEFECTO[dise√±oLado.tituloId] || [];

     for (let i = 0; i < cantidad; i++) {
       const configuracion = dise√±oLado.boxes?.[i] || {};
       const etiqueta =
         (configuracion.label || "").trim() ||
         etiquetasDefault[i] ||
         `Box ${i + 1}`;

       let valorMostrado = "--,--";

       if (configuracion.enabled) {
         const numeroRegistro = Number(configuracion.registro);

         if (
           (Number.isFinite(numeroRegistro) || numeroRegistro === 0) &&
           configuracion.registro !== ""
         ) {
           const origen = configuracion.origen || "rele";
           const listaRegistros = obtenerListaRegistros(registrosPorOrigen, origen);

           if (listaRegistros && listaRegistros.length > 0) {
             const registroEncontrado = listaRegistros.find(
               (r) => r.address === numeroRegistro
             );

             if (!registroEncontrado) {
               valorMostrado = "ERROR";
             } else {
               const valorCalculado = aplicarFormula(
                 configuracion.formula || "x",
                 registroEncontrado.value
               );

               if (valorCalculado == null || Number.isNaN(valorCalculado)) {
                 valorMostrado = "ERROR";
               } else {
                 valorMostrado = formatearValor(valorCalculado);
               }
             }
           }
         }
       }

       boxesSalida.push({
         etiqueta,
         valor: valorMostrado,
         enabled: !!configuracion.enabled,
         origen: configuracion.origen || "rele",
       });
     }

     return { titulo, boxes: boxesSalida };
   };

   - Paso a paso para cada box:

       1) Determina la etiqueta efectiva:
            ‚Ä¢ primero `configuracion.label` (si existe y no est√° vac√≠o),
            ‚Ä¢ si no, una etiqueta por defecto seg√∫n magnitud (R, S, T, Total),
            ‚Ä¢ si tampoco hay, usa "Box 1", "Box 2", etc.

       2) Inicializa `valorMostrado` en `"--,--"` como placeholder.

       3) Si el box est√° habilitado (`enabled === true`):
            ‚Ä¢ Valida el n√∫mero de registro (`configuracion.registro`).
            ‚Ä¢ Determina el origen (`rele` o `analizador`).
            ‚Ä¢ Obtiene la lista de registros correspondiente con
              `obtenerListaRegistros`.
            ‚Ä¢ Busca el registro cuyo `address` coincida con el n√∫mero
              configurado.

       4) Si encuentra el registro:
            ‚Ä¢ Aplica la f√≥rmula de ese box con `aplicarFormula` (o "x" si
              no se defini√≥ f√≥rmula).
            ‚Ä¢ Si el resultado es inv√°lido ‚Üí `"ERROR"`.
            ‚Ä¢ Si es v√°lido ‚Üí lo pasa por `formatearValor` para obtener un
              string "amigable" (dos decimales, coma, etc.).

       5) Agrega al array `boxesSalida` un objeto con:
            ‚Ä¢ `etiqueta`: texto visible en la tarjeta,
            ‚Ä¢ `valor`: texto formateado o "ERROR"/"--,--",
            ‚Ä¢ `enabled`: booleano,
            ‚Ä¢ `origen`: "rele" o "analizador".


5) C√≥mo se integra con el resto de la app

   - `ModalMapeoMediciones` define el `cardDesign` (qu√© boxes hay, qu√©
     registro leen, f√≥rmula, origen, etc.) y lo guarda en `mapeoMediciones`
     dentro de cada alimentador.

   - Cuando llegan lecturas nuevas desde los equipos:

       1) Se arma un objeto `{ rele: [...], analizador: [...] }` con registros
          crudos (`index`, `address`, `value`).

       2) Se obtiene el dise√±o de tarjeta con `obtenerDisenoTarjeta`.

       3) Para cada lado (superior / inferior) se llama a
          `calcularValoresLadoTarjeta` y se obtienen `{ titulo, boxes }`.
			 
       4) Esa estructura es la que consume `TarjetaAlimentador` para renderizar
          cada `CajaMedicion` con su etiqueta, valor y comportamiento visual.

   - De esta forma, todo el c√°lculo num√©rico + mapeo queda concentrado en este
     m√≥dulo y las tarjetas se enfocan s√≥lo en mostrar datos.

---------------------------------------------------------------------------*/

// ===== ./src/paginas/PaginaAlimentadores/utilidades/coloresGrafico.js =====

// utilidades/coloresGrafico.js
// Utilidades de colores para gr√°ficos de historial

import { COLORES_GRADIENTE } from "../constantes/historialConfig";

/**
 * Interpola color de verde a rojo basado en porcentaje (0-1)
 * 0 = verde, 0.5 = amarillo, 1 = rojo
 * @param {number} porcentaje - Valor entre 0 y 1
 * @returns {string} Color en formato rgb()
 */
export const interpolarColorVerdeRojo = (porcentaje) => {
   const p = Math.max(0, Math.min(1, porcentaje));
   const { verde, amarillo, rojo } = COLORES_GRADIENTE;

   let r, g, b;

   if (p <= 0.5) {
      // Verde a Amarillo (0 a 0.5)
      const t = p * 2;
      r = Math.round(verde.r + (amarillo.r - verde.r) * t);
      g = Math.round(verde.g + (amarillo.g - verde.g) * t);
      b = Math.round(verde.b + (amarillo.b - verde.b) * t);
   } else {
      // Amarillo a Rojo (0.5 a 1)
      const t = (p - 0.5) * 2;
      r = Math.round(amarillo.r + (rojo.r - amarillo.r) * t);
      g = Math.round(amarillo.g + (rojo.g - amarillo.g) * t);
      b = Math.round(amarillo.b + (rojo.b - amarillo.b) * t);
   }

   return `rgb(${r}, ${g}, ${b})`;
};

/**
 * Genera colores para gr√°fico de barras basado en valores normalizados min-max
 * @param {Array<{y: number}>} datos - Datos con valores y
 * @returns {string[]} Array de colores rgb
 */
export const generarColoresBarras = (datos) => {
   if (!datos || datos.length === 0) return [];

   const valores = datos.map((d) => d.y);
   const minVal = Math.min(...valores);
   const maxVal = Math.max(...valores);
   const rango = maxVal - minVal;

   return valores.map((val) => {
      const porcentaje = rango > 0 ? (val - minVal) / rango : 0;
      return interpolarColorVerdeRojo(porcentaje);
   });
};

// ===== ./src/paginas/PaginaAlimentadores/utilidades/configGraficoHistorial.js =====

// utilidades/configGraficoHistorial.js
// Configuraci√≥n de opciones ApexCharts para historial

/**
 * Genera las opciones base para el gr√°fico de historial
 * @param {Object} params - Par√°metros de configuraci√≥n
 * @param {string} params.alimentadorId - ID del alimentador
 * @param {string} params.tipoGrafico - Tipo de gr√°fico (line, area, bar)
 * @param {number|null} params.escalaYMax - Escala Y m√°xima (null = auto)
 * @returns {Object} Opciones base de ApexCharts
 */
const generarOpcionesBase = ({ alimentadorId, tipoGrafico, escalaYMax }) => ({
   chart: {
      id: `historial-${alimentadorId}-${tipoGrafico}`,
      type: tipoGrafico,
      height: "100%",
      zoom: { enabled: true, type: "x", autoScaleYaxis: true },
      toolbar: {
         show: true,
         tools: {
            download: true,
            selection: true,
            zoom: true,
            zoomin: true,
            zoomout: true,
            pan: true,
            reset: true,
         },
         autoSelected: "zoom",
      },
      background: "#0f172a",
      foreColor: "#e2e8f0",
      animations: { enabled: true, speed: 500 },
   },
   colors: ["#0ea5e9"],
   xaxis: {
      type: "datetime",
      labels: {
         style: { colors: "#94a3b8" },
         datetimeUTC: false,
         datetimeFormatter: {
            year: "yyyy",
            month: "MMM 'yy",
            day: "dd MMM",
            hour: "HH:mm",
         },
      },
      axisBorder: { color: "#334155" },
      axisTicks: { color: "#334155" },
   },
   yaxis: {
      min: 0,
      max: escalaYMax || undefined,
      labels: {
         style: { colors: "#94a3b8" },
         formatter: (val) => (val != null ? val.toFixed(2) : "--"),
      },
   },
   grid: { borderColor: "#334155", strokeDashArray: 3 },
   tooltip: {
      theme: "dark",
      x: { format: "dd/MM/yyyy HH:mm:ss" },
      y: { formatter: (val) => (val != null ? val.toFixed(4) : "--") },
   },
   dataLabels: { enabled: false },
   noData: {
      text: "No hay datos",
      style: { color: "#94a3b8", fontSize: "14px" },
   },
});

/**
 * Opciones espec√≠ficas para gr√°fico de l√≠nea
 */
const opcionesLinea = {
   stroke: {
      curve: "smooth",
      width: 2,
      lineCap: "round",
   },
   fill: {
      type: "gradient",
      gradient: {
         type: "vertical",
         colorStops: [
            { offset: 0, color: "#ef4444", opacity: 1 },
            { offset: 50, color: "#eab308", opacity: 1 },
            { offset: 100, color: "#22c55e", opacity: 1 },
         ],
      },
   },
   markers: { size: 0, hover: { size: 5 } },
};

/**
 * Opciones espec√≠ficas para gr√°fico de √°rea
 */
const opcionesArea = {
   stroke: { curve: "smooth", width: 2, colors: ["#ef4444"] },
   fill: {
      type: "gradient",
      gradient: {
         shade: "light",
         type: "vertical",
         shadeIntensity: 0.1,
         opacityFrom: 0.9,
         opacityTo: 0.9,
         colorStops: [
            { offset: 0, color: "#ef4444", opacity: 0.9 },
            { offset: 50, color: "#eab308", opacity: 0.9 },
            { offset: 100, color: "#22c55e", opacity: 0.9 },
         ],
      },
   },
   markers: { size: 0, hover: { size: 5 } },
};

/**
 * Genera opciones espec√≠ficas para gr√°fico de barras
 * @param {string[]} coloresBarras - Colores individuales por barra
 * @returns {Object} Opciones para barras
 */
const generarOpcionesBarras = (coloresBarras) => ({
   plotOptions: {
      bar: {
         columnWidth: "95%",
         borderRadius: 0,
         distributed: true,
      },
   },
   legend: { show: false },
   fill: { type: "solid" },
   stroke: { show: false },
   ...(coloresBarras.length > 0 && { colors: coloresBarras }),
});

/**
 * Genera la configuraci√≥n completa de opciones para ApexCharts
 * @param {Object} params - Par√°metros de configuraci√≥n
 * @param {string} params.alimentadorId - ID del alimentador
 * @param {string} params.tipoGrafico - Tipo de gr√°fico (line, area, bar)
 * @param {number|null} params.escalaYMax - Escala Y m√°xima (null = auto)
 * @param {string[]} params.coloresBarras - Colores para barras (solo si tipoGrafico='bar')
 * @returns {Object} Configuraci√≥n completa de ApexCharts
 */
export const generarOpcionesGrafico = ({
   alimentadorId,
   tipoGrafico,
   escalaYMax,
   coloresBarras = [],
}) => {
   const opcionesBase = generarOpcionesBase({ alimentadorId, tipoGrafico, escalaYMax });

   switch (tipoGrafico) {
      case "line":
         return { ...opcionesBase, ...opcionesLinea };
      case "area":
         return { ...opcionesBase, ...opcionesArea };
      case "bar":
         return { ...opcionesBase, ...generarOpcionesBarras(coloresBarras) };
      default:
         return opcionesBase;
   }
};

// ===== ./src/paginas/PaginaAlimentadores/utilidades/exportarCSV.js =====

/**
 * Utilidad para exportar datos a formato CSV
 */

/**
 * Exporta datos a un archivo CSV descargable
 * @param {Array} datos - Array de objetos con los datos
 * @param {string} nombreArchivo - Nombre del archivo (sin extensi√≥n)
 * @param {Object} opciones - Opciones de configuraci√≥n
 * @param {Array<string>} opciones.columnas - Columnas a incluir (orden)
 * @param {Object} opciones.etiquetas - Mapeo de nombres de columnas a etiquetas
 */
export const exportarCSV = (datos, nombreArchivo, opciones = {}) => {
  if (!datos || datos.length === 0) {
    console.warn("No hay datos para exportar");
    return;
  }

  const {
    columnas = ["timestamp", "valor"],
    etiquetas = {
      timestamp: "Fecha/Hora",
      valor: "Valor",
      valorCrudo: "Valor Crudo",
      variable: "Variable",
    },
  } = opciones;

  // Crear header con etiquetas
  const header = columnas.map((col) => etiquetas[col] || col);

  // Crear filas de datos
  const filas = datos.map((d) => {
    return columnas
      .map((col) => {
        let valor = obtenerValorColumna(d, col);

        // Escapar valores que contienen separadores
        if (typeof valor === "string" && (valor.includes(";") || valor.includes('"'))) {
          valor = `"${valor.replace(/"/g, '""')}"`;
        }

        return valor;
      })
      .join(";");
  });

  // Unir header y filas
  const contenidoCSV = [header.join(";"), ...filas].join("\n");

  // Crear blob con BOM para Excel
  const BOM = "\uFEFF";
  const blob = new Blob([BOM + contenidoCSV], {
    type: "text/csv;charset=utf-8;",
  });

  // Crear y ejecutar descarga
  descargarBlob(blob, `${nombreArchivo}.csv`);
};

/**
 * Obtiene el valor formateado para una columna espec√≠fica
 * @param {Object} dato - Objeto con los datos
 * @param {string} columna - Nombre de la columna
 * @returns {string} - Valor formateado
 */
const obtenerValorColumna = (dato, columna) => {
  switch (columna) {
    case "timestamp":
      // Formatear timestamp a fecha legible
      const fecha = dato.x instanceof Date ? dato.x : new Date(dato.timestamp || dato.x);
      return formatearFecha(fecha);

    case "valor":
      // Valor calculado con f√≥rmula
      const val = dato.y ?? dato.valor;
      return val != null ? val.toFixed(4).replace(".", ",") : "";

    case "valorCrudo":
      // Valor sin procesar
      const raw = dato.raw ?? dato.valorCrudo;
      return raw != null ? String(raw).replace(".", ",") : "";

    case "variable":
      return dato.variable || dato.etiqueta || "";

    default:
      const v = dato[columna];
      if (v == null) return "";
      if (typeof v === "number") return v.toString().replace(".", ",");
      return String(v);
  }
};

/**
 * Formatea una fecha para el CSV
 * @param {Date} fecha - Fecha a formatear
 * @returns {string} - Fecha formateada DD/MM/YYYY HH:mm:ss
 */
const formatearFecha = (fecha) => {
  if (!(fecha instanceof Date) || isNaN(fecha.getTime())) {
    return "";
  }

  const pad = (n) => String(n).padStart(2, "0");

  const dia = pad(fecha.getDate());
  const mes = pad(fecha.getMonth() + 1);
  const anio = fecha.getFullYear();
  const hora = pad(fecha.getHours());
  const min = pad(fecha.getMinutes());
  const seg = pad(fecha.getSeconds());

  return `${dia}/${mes}/${anio} ${hora}:${min}:${seg}`;
};

/**
 * Descarga un blob como archivo
 * @param {Blob} blob - Blob a descargar
 * @param {string} nombreArchivo - Nombre del archivo
 */
const descargarBlob = (blob, nombreArchivo) => {
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");

  link.href = url;
  link.download = nombreArchivo;
  link.style.display = "none";

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  // Liberar memoria
  URL.revokeObjectURL(url);
};


// ===== ./src/paginas/PaginaAlimentadores/utilidades/exportarInformePDF.js =====

/**
 * Utilidad para exportar informes profesionales en formato PDF
 * Usa pdfmake para generar archivos .pdf con tablas, gr√°ficos e informaci√≥n
 */

import pdfMake from "pdfmake/build/pdfmake";
import pdfFonts from "pdfmake/build/vfs_fonts";

// Configurar fuentes de pdfmake
if (pdfFonts.pdfMake) {
  pdfMake.vfs = pdfFonts.pdfMake.vfs;
} else if (pdfFonts.vfs) {
  pdfMake.vfs = pdfFonts.vfs;
}

// Colores del tema (en formato hex para pdfmake)
const COLORES = {
  primario: "#1E3A5F", // Azul oscuro
  secundario: "#0EA5E9", // Azul claro
  fondo: "#F8FAFC", // Gris muy claro
  texto: "#1E293B", // Gris oscuro
  borde: "#CBD5E1", // Gris medio
  minimo: "#DCFCE7", // Verde claro (para valor m√≠nimo)
  maximo: "#FED7AA", // Naranja claro (para valor m√°ximo)
  blanco: "#FFFFFF",
};

/**
 * Formatea una fecha para mostrar en el informe
 * @param {Date|number|string} fecha - Fecha a formatear
 * @returns {string} - Fecha formateada
 */
const formatearFecha = (fecha) => {
  const d = fecha instanceof Date ? fecha : new Date(fecha);
  if (isNaN(d.getTime())) return "--";

  const pad = (n) => String(n).padStart(2, "0");
  return `${pad(d.getDate())}/${pad(d.getMonth() + 1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
};

/**
 * Formatea solo la fecha (sin hora)
 * @param {Date|number|string} fecha - Fecha a formatear
 * @returns {string} - Fecha formateada
 */
const formatearSoloFecha = (fecha) => {
  const d = fecha instanceof Date ? fecha : new Date(fecha);
  if (isNaN(d.getTime())) return "--";

  const pad = (n) => String(n).padStart(2, "0");
  return `${pad(d.getDate())}/${pad(d.getMonth() + 1)}/${d.getFullYear()}`;
};

/**
 * Genera la definici√≥n del documento PDF
 * @param {Object} config - Configuraci√≥n del informe
 * @returns {Object} - Definici√≥n del documento para pdfmake
 */
const generarDefinicionPDF = (config) => {
  const {
    datos,
    tituloMedicion,
    nombreAlimentador,
    fechaDesde,
    fechaHasta,
    solicitadoPor,
    imagenGrafico,
    intervalo,
  } = config;

  // Calcular estad√≠sticas
  let minimo = 0,
    maximo = 0,
    promedio = 0;
  let fechaMinimo = null,
    fechaMaximo = null;

  if (datos.length > 0) {
    const valores = datos.map((d) => d.y).filter((v) => v != null && !isNaN(v));
    minimo = Math.min(...valores);
    maximo = Math.max(...valores);
    promedio = valores.reduce((a, b) => a + b, 0) / valores.length;

    // Encontrar las fechas de los valores m√≠nimo y m√°ximo
    const puntoMin = datos.find((d) => d.y === minimo);
    const puntoMax = datos.find((d) => d.y === maximo);
    fechaMinimo = puntoMin?.x ? formatearFecha(puntoMin.x) : null;
    fechaMaximo = puntoMax?.x ? formatearFecha(puntoMax.x) : null;
  }

  // Texto del intervalo
  const textoIntervalo = intervalo
    ? intervalo === 0
      ? " (todos)"
      : ` (cada ${intervalo} min)`
    : "";

  // Construir contenido del PDF
  const contenido = [];

  // === T√çTULO PRINCIPAL CON FONDO AZUL (estilo Excel) ===
  contenido.push({
    table: {
      widths: ["*"],
      body: [
        [
          {
            text: "INFORME DE MEDICIONES",
            fontSize: 16,
            bold: true,
            color: COLORES.blanco,
            fillColor: COLORES.primario,
            alignment: "center",
          },
        ],
      ],
    },
    layout: {
      hLineWidth: () => 0.5,
      vLineWidth: () => 0.5,
      hLineColor: () => COLORES.borde,
      vLineColor: () => COLORES.borde,
      paddingTop: () => 12,
      paddingBottom: () => 12,
    },
    margin: [0, 0, 0, 0],
  });

  // === INFORMACI√ìN Y ESTAD√çSTICAS EN COLUMNAS (con borde exterior) ===
  contenido.push({
    table: {
      widths: ["*"],
      body: [
        [
          {
            columns: [
              // Columna izquierda: Informaci√≥n del informe
              {
                width: "55%",
                table: {
                  widths: ["auto", "*"],
                  body: [
                    [
                      { text: "Registros para:", style: "etiqueta" },
                      { text: nombreAlimentador, style: "valor" },
                    ],
                    [
                      { text: "Medici√≥n:", style: "etiqueta" },
                      { text: tituloMedicion, style: "valor" },
                    ],
                    [
                      { text: "Fecha de creaci√≥n:", style: "etiqueta" },
                      { text: formatearFecha(new Date()), style: "valor" },
                    ],
                    [
                      { text: "Solicitado por:", style: "etiqueta" },
                      { text: solicitadoPor || "No especificado", style: "valor" },
                    ],
                    [
                      { text: "Per√≠odo desde:", style: "etiqueta" },
                      { text: formatearFecha(fechaDesde), style: "valor" },
                    ],
                    [
                      { text: "Per√≠odo hasta:", style: "etiqueta" },
                      { text: formatearFecha(fechaHasta), style: "valor" },
                    ],
                    [
                      { text: "Total de registros:", style: "etiqueta" },
                      { text: `${datos.length}${textoIntervalo}`, style: "valor" },
                    ],
                  ],
                },
                layout: {
                  hLineWidth: () => 0,
                  vLineWidth: () => 0,
                  paddingTop: () => 3,
                  paddingBottom: () => 3,
                },
              },
              // Columna derecha: Estad√≠sticas
              {
                width: "45%",
                stack: [
                  {
                    text: "ESTAD√çSTICAS",
                    style: "subtitulo",
                    alignment: "center",
                    margin: [0, 0, 0, 8],
                  },
                  {
                    table: {
                      widths: ["auto", "*"],
                      body: [
                        [
                          { text: "Valor m√≠nimo:", style: "etiqueta", alignment: "right" },
                          {
                            stack: [
                              { text: minimo.toFixed(2), style: "valorEstadistica", alignment: "center" },
                              fechaMinimo
                                ? { text: fechaMinimo, fontSize: 8, color: COLORES.texto, alignment: "center" }
                                : null,
                            ].filter(Boolean),
                            fillColor: COLORES.minimo,
                          },
                        ],
                        [
                          { text: "Valor m√°ximo:", style: "etiqueta", alignment: "right" },
                          {
                            stack: [
                              { text: maximo.toFixed(2), style: "valorEstadistica", alignment: "center" },
                              fechaMaximo
                                ? { text: fechaMaximo, fontSize: 8, color: COLORES.texto, alignment: "center" }
                                : null,
                            ].filter(Boolean),
                            fillColor: COLORES.maximo,
                          },
                        ],
                        [
                          { text: "Valor promedio:", style: "etiqueta", alignment: "right" },
                          { text: promedio.toFixed(2), style: "valorEstadistica", alignment: "center" },
                        ],
                      ],
                    },
                    layout: {
                      hLineWidth: () => 0.5,
                      vLineWidth: () => 0.5,
                      hLineColor: () => COLORES.borde,
                      vLineColor: () => COLORES.borde,
                      paddingTop: () => 4,
                      paddingBottom: () => 4,
                      paddingLeft: () => 8,
                      paddingRight: () => 8,
                    },
                  },
                ],
              },
            ],
            columnGap: 15,
          },
        ],
      ],
    },
    layout: {
      hLineWidth: () => 0.5,
      vLineWidth: () => 0.5,
      hLineColor: () => COLORES.borde,
      vLineColor: () => COLORES.borde,
      paddingTop: () => 10,
      paddingBottom: () => 10,
      paddingLeft: () => 10,
      paddingRight: () => 10,
    },
    margin: [0, 0, 0, 20],
  });

  // === GR√ÅFICO (en p√°gina 2) ===
  if (imagenGrafico) {
    contenido.push({
      text: "GR√ÅFICO DE MEDICIONES",
      style: "subtitulo",
      alignment: "center",
      margin: [0, 10, 0, 10],
      pageBreak: "before",
    });

    contenido.push({
      image: imagenGrafico,
      width: 500,
      alignment: "center",
      margin: [0, 0, 0, 20],
    });
  }

  // === TABLA DE DATOS (en p√°gina 3+) ===
  if (datos.length > 0) {
    contenido.push({
      text: "DATOS DE MEDICIONES",
      style: "subtitulo",
      alignment: "center",
      margin: [0, 10, 0, 10],
      pageBreak: "before",
    });

    // Crear filas de la tabla
    const filasTabla = [
      // Encabezados
      [
        { text: "Fecha/Hora", style: "encabezadoTabla" },
        { text: "Valor de Medici√≥n", style: "encabezadoTabla" },
      ],
    ];

    // Datos
    datos.forEach((punto, index) => {
      const fecha = punto.x instanceof Date ? punto.x : new Date(punto.x);

      // Determinar color de fondo (comparar por valor, no por √≠ndice)
      let fillColor = index % 2 === 0 ? COLORES.fondo : COLORES.blanco;
      if (punto.y === minimo && minimo !== maximo) {
        fillColor = COLORES.minimo;
      } else if (punto.y === maximo && minimo !== maximo) {
        fillColor = COLORES.maximo;
      }

      filasTabla.push([
        {
          text: formatearFecha(fecha),
          style: "celdaTabla",
          fillColor,
        },
        {
          text: punto.y.toFixed(2),
          style: "celdaTabla",
          alignment: "center",
          fillColor,
        },
      ]);
    });

    contenido.push({
      table: {
        headerRows: 1,
        widths: ["*", "*"],
        body: filasTabla,
      },
      layout: {
        hLineWidth: () => 0.5,
        vLineWidth: () => 0.5,
        hLineColor: () => COLORES.borde,
        vLineColor: () => COLORES.borde,
        paddingTop: () => 6,
        paddingBottom: () => 6,
        paddingLeft: () => 8,
        paddingRight: () => 8,
      },
    });
  }

  // Definici√≥n completa del documento
  return {
    pageSize: "A4",
    pageOrientation: "portrait",
    pageMargins: [40, 60, 40, 60],

    // Encabezado de cada p√°gina
    header: {
      columns: [
        {
          text: "RelayWatch - Informe de Mediciones",
          style: "header",
          alignment: "left",
          margin: [40, 20, 0, 0],
        },
        {
          text: formatearSoloFecha(new Date()),
          style: "header",
          alignment: "right",
          margin: [0, 20, 40, 0],
        },
      ],
    },

    // Pie de cada p√°gina
    footer: (currentPage, pageCount) => ({
      columns: [
        {
          text: `${nombreAlimentador} - ${tituloMedicion}`,
          style: "footer",
          alignment: "left",
          margin: [40, 0, 0, 0],
        },
        {
          text: `P√°gina ${currentPage} de ${pageCount}`,
          style: "footer",
          alignment: "right",
          margin: [0, 0, 40, 0],
        },
      ],
    }),

    content: contenido,

    // Estilos
    styles: {
      header: {
        fontSize: 9,
        color: COLORES.texto,
      },
      footer: {
        fontSize: 9,
        color: COLORES.texto,
      },
      tituloPrincipal: {
        fontSize: 16,
        bold: true,
        color: COLORES.blanco,
        fillColor: COLORES.primario,
      },
      titulo: {
        fontSize: 18,
        bold: true,
        color: COLORES.primario,
      },
      subtitulo: {
        fontSize: 14,
        bold: true,
        color: COLORES.primario,
      },
      etiqueta: {
        fontSize: 10,
        bold: true,
        color: COLORES.texto,
      },
      valor: {
        fontSize: 10,
        color: COLORES.texto,
      },
      valorEstadistica: {
        fontSize: 11,
        color: COLORES.texto,
        alignment: "center",
      },
      encabezadoTabla: {
        fontSize: 10,
        bold: true,
        color: COLORES.blanco,
        fillColor: COLORES.primario,
        alignment: "center",
      },
      celdaTabla: {
        fontSize: 9,
        color: COLORES.texto,
      },
    },

    // Configuraci√≥n por defecto
    defaultStyle: {
      font: "Roboto",
    },
  };
};

/**
 * Genera y descarga un informe PDF con los datos de mediciones
 * @param {Object} config - Configuraci√≥n del informe
 * @param {string} config.nombreAlimentador - Nombre del alimentador
 * @param {string} config.tituloMedicion - T√≠tulo de la medici√≥n
 * @param {Array} config.datos - Datos de la zona actual [{x, y}]
 * @param {Date} config.fechaInicio - Fecha del primer registro
 * @param {Date} config.fechaFin - Fecha del √∫ltimo registro
 * @param {string} config.solicitadoPor - Nombre del solicitante
 * @param {string|null} config.imagenGrafico - Data URI de la imagen del gr√°fico
 * @param {number} config.intervalo - Intervalo de filtrado (0, 15, 30, 60 minutos)
 * @returns {Promise<string|null>} - Nombre del archivo o null si se cancel√≥
 */
export const generarInformePDF = async (config) => {
  const {
    nombreAlimentador,
    tituloMedicion,
    datos,
    fechaInicio,
    fechaFin,
    solicitadoPor,
    imagenGrafico,
    intervalo,
  } = config;

  // Si no hay datos, no generar
  if (!datos || datos.length === 0) {
    console.warn("No hay datos para generar el informe PDF");
    return null;
  }

  // Generar definici√≥n del documento
  const docDefinition = generarDefinicionPDF({
    datos,
    tituloMedicion: tituloMedicion || "Mediciones",
    nombreAlimentador,
    fechaDesde: fechaInicio,
    fechaHasta: fechaFin,
    solicitadoPor,
    imagenGrafico,
    intervalo,
  });

  // Generar nombre de archivo
  const fechaArchivo = formatearSoloFecha(new Date()).replace(/\//g, "-");
  const nombreArchivo = `Informe_${nombreAlimentador}_${tituloMedicion}_${fechaArchivo}.pdf`;

  // Crear PDF y descargar
  return new Promise((resolve) => {
    const pdfDoc = pdfMake.createPdf(docDefinition);

    // Intentar usar File System Access API (Chrome/Edge) para elegir ubicaci√≥n
    if ("showSaveFilePicker" in window) {
      pdfDoc.getBlob(async (blob) => {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: nombreArchivo,
            types: [
              {
                description: "Archivo PDF",
                accept: { "application/pdf": [".pdf"] },
              },
            ],
          });

          const writable = await handle.createWritable();
          await writable.write(blob);
          await writable.close();

          resolve(handle.name);
        } catch (err) {
          if (err.name === "AbortError") {
            resolve(null); // Usuario cancel√≥
          } else {
            // Fallback a descarga directa
            pdfDoc.download(nombreArchivo);
            resolve(nombreArchivo);
          }
        }
      });
    } else {
      // Fallback: descarga directa
      pdfDoc.download(nombreArchivo);
      resolve(nombreArchivo);
    }
  });
};

// ===== ./src/paginas/PaginaAlimentadores/utilidades/generarGraficoInforme.js =====

/**
 * Genera un gr√°fico temporal con ApexCharts y captura su imagen
 * para incluir en informes Excel.
 *
 * Crea un gr√°fico invisible, lo renderiza con los datos proporcionados,
 * captura la imagen y lo destruye.
 */

import ApexCharts from "apexcharts";

/**
 * Genera una imagen de gr√°fico a partir de datos de series temporales
 * @param {Array} datos - Array de puntos [{x: timestamp, y: valor}]
 * @param {Object} opciones - Opciones de configuraci√≥n
 * @param {string} opciones.tipo - Tipo de gr√°fico (line, area, bar)
 * @param {string} opciones.titulo - T√≠tulo del gr√°fico (opcional)
 * @param {number} opciones.width - Ancho en p√≠xeles (default: 1100)
 * @param {number} opciones.height - Alto en p√≠xeles (default: 450)
 * @param {number} opciones.scale - Escala de la imagen (default: 2)
 * @returns {Promise<string|null>} - Data URI de la imagen o null si falla
 */
export const generarImagenGrafico = async (datos, opciones = {}) => {
  if (!datos || datos.length === 0) {
    return null;
  }

  const {
    tipo = "line",
    titulo = "",
    width = 1100,
    height = 450,
    scale = 2,
  } = opciones;

  // Crear contenedor temporal - usar visibility:hidden para que ApexCharts
  // pueda calcular las dimensiones pero no sea visible
  const tempContainer = document.createElement("div");
  tempContainer.style.cssText = `
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: ${width}px;
    height: ${height}px;
    visibility: hidden;
  `;
  document.body.appendChild(tempContainer);

  // Forzar un reflow para asegurar que el contenedor tenga dimensiones
  tempContainer.offsetHeight;

  // Preparar series para ApexCharts
  const seriesData = datos.map((punto) => ({
    x: punto.x instanceof Date ? punto.x.getTime() : new Date(punto.x).getTime(),
    y: punto.y,
  }));

  // Calcular min/max para el eje Y con margen
  const valores = datos.map((d) => d.y).filter((v) => v != null && !isNaN(v));
  const minY = Math.min(...valores);
  const maxY = Math.max(...valores);
  const rangoY = maxY - minY || 1;
  const margen = rangoY * 0.1;

  // Configuraci√≥n del gr√°fico simplificada para evitar errores de ApexCharts
  const chartConfig = {
    chart: {
      id: `informe-temp-${Date.now()}`,
      type: tipo,
      width: "100%",
      height: "100%",
      background: "#ffffff",
      foreColor: "#1a1a1a",
      animations: { enabled: false },
      toolbar: { show: false },
      zoom: { enabled: false },
      offsetX: 0,
      offsetY: 0,
      sparkline: { enabled: false },
    },
    series: [
      {
        name: titulo || "Medici√≥n",
        data: seriesData,
      },
    ],
    stroke: {
      curve: "smooth",
      width: tipo === "bar" ? 0 : 3,
    },
    colors: ["#0EA5E9"],
    markers: {
      size: datos.length <= 30 ? 4 : 0,
    },
    xaxis: {
      type: "datetime",
      labels: {
        datetimeUTC: false,
        format: "dd/MM HH:mm",
        style: {
          fontSize: "12px",
        },
      },
    },
    yaxis: {
      min: Math.floor(minY - margen),
      max: Math.ceil(maxY + margen),
      labels: {
        formatter: (val) => val.toFixed(2),
      },
    },
    grid: {
      borderColor: "#e0e0e0",
    },
    tooltip: { enabled: false },
    dataLabels: { enabled: false },
    legend: { show: false },
  };

  let tempChart = null;

  try {
    // Crear y renderizar gr√°fico temporal
    tempChart = new ApexCharts(tempContainer, chartConfig);
    await tempChart.render();

    // Esperar a que el gr√°fico se renderice completamente
    await new Promise((resolve) => setTimeout(resolve, 300));

    // Capturar imagen
    const result = await tempChart.dataURI({ scale });

    // dataURI puede devolver { imgURI } o directamente el string
    const imgURI = result?.imgURI || result;

    if (!imgURI || typeof imgURI !== "string") {
      console.warn("dataURI no devolvi√≥ una imagen v√°lida:", result);
      return null;
    }

    return imgURI;
  } catch (err) {
    console.warn("Error generando imagen de gr√°fico para informe:", err);
    return null;
  } finally {
    // Limpiar: destruir gr√°fico y remover contenedor
    if (tempChart) {
      try {
        tempChart.destroy();
      } catch {
        // Ignorar errores de destrucci√≥n
      }
    }
    if (tempContainer.parentNode) {
      tempContainer.parentNode.removeChild(tempContainer);
    }
  }
};

// ===== ./src/paginas/PaginaAlimentadores/utilidades/index.js =====

// utilidades/index.js
// Exportaciones centralizadas de utilidades

export * from "./calculosMediciones";
export * from "./calculosHistorial";
export * from "./calculosFormulas";
export * from "./calculadorRutas";
export * from "./coloresGrafico";
export * from "./configGraficoHistorial";
export * from "./exportarCSV";
export * from "./exportarInformePDF";
export * from "./generarGraficoInforme";
export * from "./indexedDBHelper";
export * from "./interpreteRegistrosREF615";

// ===== ./src/paginas/PaginaAlimentadores/utilidades/indexedDBHelper.js =====

/**
 * Helper para operaciones con IndexedDB
 * Almacena lecturas de los √∫ltimos 48 horas para acceso r√°pido local
 */

const DB_NAME = "RelayWatchHistorial";
const DB_VERSION = 1;
const STORE_NAME = "lecturas";

/**
 * Abre la conexi√≥n a IndexedDB y crea el schema si es necesario
 * @returns {Promise<IDBDatabase>}
 */
export const abrirDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => {
      console.error("Error abriendo IndexedDB:", request.error);
      reject(request.error);
    };

    request.onsuccess = () => {
      resolve(request.result);
    };

    request.onupgradeneeded = (event) => {
      const db = event.target.result;

      // Crear object store con √≠ndices
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        const store = db.createObjectStore(STORE_NAME, {
          keyPath: "id",
          autoIncrement: true,
        });

        // √çndices para consultas eficientes
        store.createIndex("alimentadorId", "alimentadorId", { unique: false });
        store.createIndex("registradorId", "registradorId", { unique: false });
        store.createIndex("zona", "zona", { unique: false });
        store.createIndex("timestamp", "timestamp", { unique: false });

        // √çndice compuesto para b√∫squedas por alimentador + zona + tiempo
        store.createIndex(
          "alimZonaTimestamp",
          ["alimentadorId", "zona", "timestamp"],
          { unique: false }
        );
      }
    };
  });
};

/**
 * Guarda una lectura en IndexedDB
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {Object} lectura - Datos de la lectura
 * @returns {Promise<number>} - ID de la lectura insertada
 */
export const guardarLectura = async (db, lectura) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);

    const registro = {
      alimentadorId: lectura.alimentadorId,
      registradorId: lectura.registradorId,
      zona: lectura.zona,
      timestamp: lectura.timestamp || Date.now(),
      valores: lectura.valores,
      indiceInicial: lectura.indiceInicial,
      exito: lectura.exito,
      createdAt: Date.now(),
    };

    const request = store.add(registro);

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

/**
 * Obtiene lecturas en un rango de tiempo para un alimentador/zona espec√≠ficos
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @param {string} registradorId - ID del registrador (opcional, para filtrar)
 * @param {string} zona - "superior" o "inferior"
 * @param {number} desde - Timestamp inicial (ms)
 * @param {number} hasta - Timestamp final (ms)
 * @returns {Promise<Array>} - Array de lecturas
 */
export const obtenerLecturasRango = async (
  db,
  alimentadorId,
  registradorId,
  zona,
  desde,
  hasta
) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("alimZonaTimestamp");

    // Rango de b√∫squeda usando √≠ndice compuesto
    const rango = IDBKeyRange.bound(
      [alimentadorId, zona, desde],
      [alimentadorId, zona, hasta]
    );

    const request = index.getAll(rango);

    request.onsuccess = () => {
      let resultados = request.result;

      // Filtrar por registradorId si se especifica
      if (registradorId) {
        resultados = resultados.filter((r) => r.registradorId === registradorId);
      }

      // Ordenar por timestamp ascendente
      resultados.sort((a, b) => a.timestamp - b.timestamp);

      resolve(resultados);
    };

    request.onerror = () => reject(request.error);
  });
};

/**
 * Elimina lecturas m√°s antiguas que el tiempo de retenci√≥n
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {number} horasRetencion - Horas de datos a mantener (default: 48)
 * @returns {Promise<number>} - Cantidad de registros eliminados
 */
export const limpiarLecturasAntiguas = async (db, horasRetencion = 48) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("timestamp");

    const limite = Date.now() - horasRetencion * 60 * 60 * 1000;
    const rango = IDBKeyRange.upperBound(limite);

    let eliminados = 0;
    const request = index.openCursor(rango);

    request.onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor) {
        cursor.delete();
        eliminados++;
        cursor.continue();
      } else {
        resolve(eliminados);
      }
    };

    request.onerror = () => reject(request.error);
  });
};

/**
 * Obtiene estad√≠sticas del almacenamiento
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @returns {Promise<Object>} - Estad√≠sticas
 */
export const obtenerEstadisticas = async (db) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);

    const countRequest = store.count();

    countRequest.onsuccess = () => {
      resolve({
        totalLecturas: countRequest.result,
      });
    };

    countRequest.onerror = () => reject(countRequest.error);
  });
};

/**
 * Elimina todas las lecturas (para testing o reset)
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @returns {Promise<void>}
 */
export const limpiarTodo = async (db) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);

    const request = store.clear();

    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
};

/**
 * Obtiene los timestamps existentes en un rango para evitar duplicados
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @param {string} zona - "superior" o "inferior"
 * @param {number} desde - Timestamp inicial (ms)
 * @param {number} hasta - Timestamp final (ms)
 * @returns {Promise<Set<number>>} - Set de timestamps existentes
 */
export const obtenerTimestampsExistentes = async (
  db,
  alimentadorId,
  zona,
  desde,
  hasta
) => {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    const index = store.index("alimZonaTimestamp");

    const rango = IDBKeyRange.bound(
      [alimentadorId, zona, desde],
      [alimentadorId, zona, hasta]
    );

    const request = index.getAll(rango);

    request.onsuccess = () => {
      const timestamps = new Set(request.result.map((r) => r.timestamp));
      resolve(timestamps);
    };

    request.onerror = () => reject(request.error);
  });
};

/**
 * Cachea datos remotos en IndexedDB, evitando duplicados por timestamp
 * @param {IDBDatabase} db - Conexi√≥n a la base de datos
 * @param {string} alimentadorId - ID del alimentador
 * @param {string} registradorId - ID del registrador
 * @param {string} zona - "superior" o "inferior"
 * @param {Array} lecturas - Array de lecturas remotas a cachear
 * @returns {Promise<number>} - Cantidad de lecturas nuevas guardadas
 */
export const cachearLecturasRemotas = async (
  db,
  alimentadorId,
  registradorId,
  zona,
  lecturas
) => {
  if (!lecturas || lecturas.length === 0) return 0;

  // Obtener rango de timestamps de las lecturas a cachear
  const timestamps = lecturas.map((l) =>
    typeof l.timestamp === "string" ? new Date(l.timestamp).getTime() : l.timestamp
  );
  const desde = Math.min(...timestamps);
  const hasta = Math.max(...timestamps);

  // Obtener timestamps que ya existen en local
  const existentes = await obtenerTimestampsExistentes(
    db,
    alimentadorId,
    zona,
    desde,
    hasta
  );

  // Filtrar solo las lecturas nuevas
  const lecturasNuevas = lecturas.filter((l) => {
    const ts = typeof l.timestamp === "string" ? new Date(l.timestamp).getTime() : l.timestamp;
    return !existentes.has(ts);
  });

  if (lecturasNuevas.length === 0) return 0;

  // Guardar las nuevas en una transacci√≥n
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);
    let guardadas = 0;

    tx.oncomplete = () => resolve(guardadas);
    tx.onerror = () => reject(tx.error);

    for (const lectura of lecturasNuevas) {
      const ts = typeof lectura.timestamp === "string"
        ? new Date(lectura.timestamp).getTime()
        : lectura.timestamp;

      const registro = {
        alimentadorId,
        registradorId,
        zona,
        timestamp: ts,
        valores: lectura.valores,
        indiceInicial: lectura.indice_inicial ?? lectura.indiceInicial ?? 0,
        exito: lectura.exito !== false,
        createdAt: Date.now(),
        fromCache: true, // Marca para identificar datos cacheados
      };

      const request = store.add(registro);
      request.onsuccess = () => guardadas++;
    }
  });
};

// ===== ./src/paginas/PaginaAlimentadores/utilidades/interpreteRegistrosREF615.js =====

/**
 * Int√©rprete de Registros Modbus para Rel√©s ABB REF615/RET615
 *
 * Este m√≥dulo interpreta los valores binarios de los registros de estado
 * del rel√©, decodificando qu√© bits est√°n activos y su significado.
 *
 * MODO DE FUNCIONAMIENTO:
 * 1. Si la plantilla tiene etiquetas personalizadas para el registro, se usan esas
 * 2. Si no, se usan las etiquetas por defecto definidas en este archivo
 *
 * Basado en documentaci√≥n ABB:
 * - REF615 Modbus Point List Manual (1MRS756581)
 * - Documentaci√≥n Rel√©s ABB Serie 615 - Subestaci√≥n CELTA 1
 */

// ============================================================================
// DEFINICIONES DE REGISTROS Y SUS BITS
// ============================================================================

/**
 * Registro 172 - Estado de LEDs del panel frontal
 * Cada bit representa un LED espec√≠fico del rel√©
 */
const REGISTRO_172_LEDS = {
  nombre: "Estado LEDs",
  descripcion: "Indicadores luminosos del panel frontal del rel√©",
  bits: {
    0: { nombre: "Ready", descripcion: "Rel√© listo/operativo", tipo: "estado" },
    1: { nombre: "Start", descripcion: "Protecci√≥n en arranque", tipo: "alarma" },
    2: { nombre: "Trip", descripcion: "Disparo activo", tipo: "alarma" },
    3: { nombre: "Alarm", descripcion: "Alarma general activa", tipo: "alarma" },
    4: { nombre: "Warning", descripcion: "Advertencia activa", tipo: "warning" },
    5: { nombre: "IR Fault", descripcion: "Falla interna del rel√©", tipo: "error" },
    6: { nombre: "Blocked", descripcion: "Protecci√≥n bloqueada", tipo: "warning" },
    7: { nombre: "Test Mode", descripcion: "Modo de prueba activo", tipo: "info" },
    8: { nombre: "LED 9", descripcion: "LED programable 9", tipo: "info" },
    9: { nombre: "LED 10", descripcion: "LED programable 10", tipo: "info" },
    10: { nombre: "LED 11", descripcion: "LED programable 11", tipo: "info" },
    11: { nombre: "LED 12", descripcion: "LED programable 12", tipo: "info" },
  }
};

/**
 * Registro 170 - Estado de Disparo/Trip
 * Indica la causa del √∫ltimo disparo
 */
const REGISTRO_170_DISPARO = {
  nombre: "Estado Disparo",
  descripcion: "Se√±ales de disparo y arranque de protecciones",
  bits: {
    0: { nombre: "Trip General", descripcion: "Se√±al de disparo general", tipo: "alarma" },
    1: { nombre: "Start General", descripcion: "Se√±al de arranque general", tipo: "warning" },
    2: { nombre: "Trip 50", descripcion: "Disparo por sobrecorriente instant√°nea", tipo: "alarma" },
    3: { nombre: "Trip 51", descripcion: "Disparo por sobrecorriente temporizada", tipo: "alarma" },
    4: { nombre: "Trip 50N", descripcion: "Disparo por falla tierra instant√°nea", tipo: "alarma" },
    5: { nombre: "Trip 51N", descripcion: "Disparo por falla tierra temporizada", tipo: "alarma" },
    6: { nombre: "Trip 50BF", descripcion: "Disparo por falla de interruptor", tipo: "alarma" },
    7: { nombre: "Trip 67", descripcion: "Disparo direccional", tipo: "alarma" },
  }
};

/**
 * Registro 173 - Estado del Interruptor (simplificado)
 */
const REGISTRO_173_INTERRUPTOR_SIMPLE = {
  nombre: "Estado Interruptor",
  descripcion: "Posici√≥n del interruptor de potencia",
  bits: {
    0: { nombre: "Cerrado", descripcion: "Interruptor en posici√≥n cerrada", tipo: "estado" },
    1: { nombre: "Abierto", descripcion: "Interruptor en posici√≥n abierta", tipo: "estado" },
    2: { nombre: "Transici√≥n", descripcion: "Interruptor en movimiento", tipo: "warning" },
    3: { nombre: "Error", descripcion: "Error en indicaci√≥n de posici√≥n", tipo: "error" },
  }
};

/**
 * Registro 174 - Estado del Interruptor (detallado con bits 4-6)
 * Seg√∫n documentaci√≥n ABB, bits 4, 5, 6 indican el estado
 */
const REGISTRO_174_INTERRUPTOR = {
  nombre: "Estado Interruptor (CBXCBR)",
  descripcion: "Control y estado del interruptor principal",
  bits: {
    4: { nombre: "Cerrado", descripcion: "Interruptor CERRADO (energizado)", tipo: "estado" },
    5: { nombre: "Abierto", descripcion: "Interruptor ABIERTO (desenergizado)", tipo: "estado" },
    6: { nombre: "Error/Intermedio", descripcion: "Estado intermedio o error", tipo: "error" },
  },
  interpretacionEspecial: (valor) => {
    const cerrado = (valor >> 4) & 1;
    const abierto = (valor >> 5) & 1;
    const error = (valor >> 6) & 1;

    if (error) return { estado: "ERROR", clase: "error", descripcion: "Estado intermedio o falla de contacto auxiliar" };
    if (cerrado && !abierto) return { estado: "CERRADO", clase: "ok", descripcion: "Interruptor cerrado - circuito energizado" };
    if (abierto && !cerrado) return { estado: "ABIERTO", clase: "warning", descripcion: "Interruptor abierto - circuito desenergizado" };
    return { estado: "DESCONOCIDO", clase: "unknown", descripcion: "Estado no determinado" };
  }
};

/**
 * Registro 127 - Estado del Rel√© / SSR1 (Salud del dispositivo)
 *
 * IMPORTANTE: Seg√∫n el manual ABB, solo los bits 0 y 1 son significativos:
 * - Bit 0: Error global del dispositivo (cr√≠tico)
 * - Bit 1: Warning global del dispositivo
 * - Bits 2-15: Reservados (ignorar)
 *
 * Un valor como 4 (bit 2) NO indica alarma - el dispositivo est√° OK.
 */
const REGISTRO_127_RELE = {
  nombre: "Salud Dispositivo (SSR1)",
  descripcion: "Estado de salud general del rel√© de protecci√≥n",
  bits: {
    0: { nombre: "Error Global", descripcion: "Error cr√≠tico del dispositivo - Requiere atenci√≥n inmediata", tipo: "error" },
    1: { nombre: "Warning Global", descripcion: "Advertencia del dispositivo - Revisar cuando sea posible", tipo: "warning" },
    // Bits 2-15 son reservados y se ignoran
  },
  interpretacionEspecial: (valor) => {
    const error = (valor & 0x01) !== 0;    // Bit 0
    const warning = (valor & 0x02) !== 0;  // Bit 1

    if (error) {
      return {
        estado: "ERROR",
        clase: "error",
        icono: "‚õî",
        descripcion: "Error global del dispositivo - Requiere atenci√≥n inmediata"
      };
    } else if (warning) {
      return {
        estado: "WARNING",
        clase: "warning",
        icono: "‚ö†Ô∏è",
        descripcion: "Advertencia del dispositivo - Revisar cuando sea posible"
      };
    } else {
      return {
        estado: "OK",
        clase: "ok",
        icono: "‚úÖ",
        descripcion: "Dispositivo funcionando correctamente"
      };
    }
  }
};

/**
 * Registro 131 - Heartbeat / SSR5
 *
 * Este es un contador que incrementa constantemente mientras el rel√© est√° vivo.
 * NO se debe interpretar como bits - es un valor num√©rico de heartbeat.
 */
const REGISTRO_131_HEARTBEAT = {
  nombre: "Heartbeat (SSR5)",
  descripcion: "Contador de vida del dispositivo",
  bits: {}, // No tiene bits significativos - es un contador
  interpretacionEspecial: (valor) => {
    if (valor > 0) {
      return {
        estado: "CONECTADO",
        clase: "ok",
        icono: "üíö",
        descripcion: `Dispositivo activo (contador: ${valor})`
      };
    } else {
      return {
        estado: "VERIFICAR",
        clase: "warning",
        icono: "‚ùì",
        descripcion: "Heartbeat en cero - Verificar conexi√≥n"
      };
    }
  }
};

/**
 * Registro 179 - Estados de Protecci√≥n (Sobrecorriente Fase)
 */
const REGISTRO_179_PROTECCION = {
  nombre: "Prot. Sobrecorriente Fase",
  descripcion: "Estado de funciones de sobrecorriente de fase",
  bits: {
    0: { nombre: "PHLPTOC1 Start", descripcion: "Sobrecorriente baja - Arranque", tipo: "warning" },
    1: { nombre: "PHLPTOC1 StartL1", descripcion: "Sobrecorriente baja L1 - Arranque", tipo: "warning" },
    2: { nombre: "PHLPTOC1 StartL2", descripcion: "Sobrecorriente baja L2 - Arranque", tipo: "warning" },
    3: { nombre: "PHLPTOC1 StartL3", descripcion: "Sobrecorriente baja L3 - Arranque", tipo: "warning" },
    8: { nombre: "PHLPTOC1 Operate", descripcion: "Sobrecorriente baja - DISPARO", tipo: "alarma" },
    10: { nombre: "PHHPTOC1 Start", descripcion: "Sobrecorriente alta - Arranque", tipo: "warning" },
  }
};

/**
 * Registro 180 - Estados de Protecci√≥n (Sobrecorriente Alta/Instant√°nea)
 */
const REGISTRO_180_PROTECCION = {
  nombre: "Prot. Sobrecorriente Alta",
  descripcion: "Estado de sobrecorriente alta e instant√°nea",
  bits: {
    2: { nombre: "PHHPTOC1 Operate", descripcion: "Sobrecorriente alta 1 - DISPARO", tipo: "alarma" },
    12: { nombre: "PHHPTOC2 Operate", descripcion: "Sobrecorriente alta 2 - DISPARO", tipo: "alarma" },
    14: { nombre: "PHIPTOC1 Start", descripcion: "Instant√°nea - Arranque", tipo: "warning" },
  }
};

/**
 * Registro 181 - Estados de Protecci√≥n (Instant√°nea y Direccional)
 */
const REGISTRO_181_PROTECCION = {
  nombre: "Prot. Instant√°nea/Direccional",
  descripcion: "Estado de protecci√≥n instant√°nea y falla tierra direccional",
  bits: {
    6: { nombre: "PHIPTOC1 Operate", descripcion: "Instant√°nea - DISPARO", tipo: "alarma" },
    8: { nombre: "DEFLPDEF1 Start", descripcion: "Falla tierra dir. baja - Arranque", tipo: "warning" },
    10: { nombre: "DEFLPDEF1 Operate", descripcion: "Falla tierra dir. baja - DISPARO", tipo: "alarma" },
  }
};

/**
 * Registro 182 - Estados de Protecci√≥n (Falla a Tierra)
 */
const REGISTRO_182_PROTECCION = {
  nombre: "Prot. Falla a Tierra",
  descripcion: "Estado de protecciones de falla a tierra",
  bits: {
    4: { nombre: "EFLPTOC1 Start", descripcion: "Falla tierra baja - Arranque", tipo: "warning" },
    6: { nombre: "EFLPTOC1 Operate", descripcion: "Falla tierra baja - DISPARO", tipo: "alarma" },
    12: { nombre: "EFHPTOC1 Start", descripcion: "Falla tierra alta - Arranque", tipo: "warning" },
    14: { nombre: "EFHPTOC1 Operate", descripcion: "Falla tierra alta - DISPARO", tipo: "alarma" },
  }
};

// ============================================================================
// MAPA DE REGISTROS INTERPRETABLES
// ============================================================================

const MAPA_REGISTROS = {
  127: REGISTRO_127_RELE,
  131: REGISTRO_131_HEARTBEAT,
  170: REGISTRO_170_DISPARO,
  172: REGISTRO_172_LEDS,
  173: REGISTRO_173_INTERRUPTOR_SIMPLE,
  174: REGISTRO_174_INTERRUPTOR,
  179: REGISTRO_179_PROTECCION,
  180: REGISTRO_180_PROTECCION,
  181: REGISTRO_181_PROTECCION,
  182: REGISTRO_182_PROTECCION,
};

// Categor√≠as que requieren interpretaci√≥n binaria
const CATEGORIAS_INTERPRETABLES = ["estados", "sistema"];

// ============================================================================
// FUNCIONES DE INTERPRETACI√ìN
// ============================================================================

/**
 * Interpreta un valor de registro y devuelve los bits activos con su significado
 * @param {number} numeroRegistro - N√∫mero del registro Modbus
 * @param {number} valor - Valor le√≠do del registro (0-65535)
 * @param {Object} etiquetasPersonalizadas - Etiquetas de la plantilla (opcional)
 *        Formato: { 0: { texto: "Arranque I>", severidad: "warning" }, ... }
 * @returns {Object} Interpretaci√≥n del registro
 */
export function interpretarRegistro(numeroRegistro, valor, etiquetasPersonalizadas = null) {
  const definicionBase = MAPA_REGISTROS[numeroRegistro];

  // Si hay etiquetas personalizadas, usarlas; si no, usar las por defecto
  const tieneEtiquetasPersonalizadas = etiquetasPersonalizadas &&
    Object.keys(etiquetasPersonalizadas).length > 0;

  // Si no hay definici√≥n base ni etiquetas personalizadas, hacer decodificaci√≥n gen√©rica
  if (!definicionBase && !tieneEtiquetasPersonalizadas) {
    return interpretarGenerico(numeroRegistro, valor);
  }

  const bitsActivos = [];
  const bitsInactivos = [];

  // Determinar qu√© bits analizar (0-15 para registro de 16 bits)
  for (let posicion = 0; posicion < 16; posicion++) {
    const estaActivo = ((valor >> posicion) & 1) === 1;

    // Buscar etiqueta: primero personalizada, luego por defecto
    let etiqueta = null;
    let severidad = "info";
    let descripcion = `Bit ${posicion}`;

    if (tieneEtiquetasPersonalizadas && etiquetasPersonalizadas[posicion]) {
      const etiquetaPersonalizada = etiquetasPersonalizadas[posicion];
      etiqueta = etiquetaPersonalizada.texto || etiquetaPersonalizada;
      severidad = etiquetaPersonalizada.severidad || "info";
      descripcion = etiqueta;
    } else if (definicionBase && definicionBase.bits[posicion]) {
      const bitBase = definicionBase.bits[posicion];
      etiqueta = bitBase.nombre;
      severidad = bitBase.tipo;
      descripcion = bitBase.descripcion;
    }

    // Solo incluir bits que tienen etiqueta definida
    // IMPORTANTE: NO mostrar bits activos sin etiqueta (evita "Bit 12", "Bit 14" sin significado)
    if (etiqueta) {
      const bitData = {
        posicion,
        nombre: etiqueta,
        descripcion,
        tipo: severidad,
        activo: estaActivo
      };

      if (estaActivo) {
        bitsActivos.push(bitData);
      } else {
        // Solo incluir bits inactivos si tienen etiqueta
        bitsInactivos.push(bitData);
      }
    }
  }

  // Interpretaci√≥n especial si existe en la definici√≥n base
  let interpretacionEspecial = null;
  if (definicionBase && definicionBase.interpretacionEspecial) {
    interpretacionEspecial = definicionBase.interpretacionEspecial(valor);
  }

  const nombreRegistro = definicionBase?.nombre || `Registro ${numeroRegistro}`;
  const descripcionRegistro = definicionBase?.descripcion || "Registro con etiquetas personalizadas";

  return {
    tieneInterpretacion: true,
    usaEtiquetasPersonalizadas: tieneEtiquetasPersonalizadas,
    numeroRegistro,
    valor,
    binario: valor.toString(2).padStart(16, "0"),
    hexadecimal: "0x" + valor.toString(16).toUpperCase().padStart(4, "0"),
    nombreRegistro,
    descripcionRegistro,
    bitsActivos,
    bitsInactivos,
    interpretacionEspecial,
    resumen: generarResumen(bitsActivos, interpretacionEspecial)
  };
}

/**
 * Interpretaci√≥n gen√©rica para registros sin definici√≥n
 * Muestra todos los bits activos sin etiquetas
 */
function interpretarGenerico(numeroRegistro, valor) {
  const bitsActivos = [];

  for (let posicion = 0; posicion < 16; posicion++) {
    if (((valor >> posicion) & 1) === 1) {
      bitsActivos.push({
        posicion,
        nombre: `Bit ${posicion}`,
        descripcion: `Bit ${posicion} activo`,
        tipo: "info",
        activo: true
      });
    }
  }

  return {
    tieneInterpretacion: true,
    usaEtiquetasPersonalizadas: false,
    numeroRegistro,
    valor,
    binario: valor.toString(2).padStart(16, "0"),
    hexadecimal: "0x" + valor.toString(16).toUpperCase().padStart(4, "0"),
    nombreRegistro: `Registro ${numeroRegistro}`,
    descripcionRegistro: "Sin definici√≥n de etiquetas",
    bitsActivos,
    bitsInactivos: [],
    interpretacionEspecial: null,
    resumen: bitsActivos.length > 0
      ? `${bitsActivos.length} bit(s) activo(s): ${bitsActivos.map(b => b.posicion).join(", ")}`
      : "Sin bits activos"
  };
}

/**
 * Genera un resumen legible de los bits activos
 */
function generarResumen(bitsActivos, interpretacionEspecial) {
  if (interpretacionEspecial) {
    return interpretacionEspecial.descripcion;
  }

  if (bitsActivos.length === 0) {
    return "Sin se√±ales activas";
  }

  // Priorizar alarmas y errores en el resumen
  const alarmas = bitsActivos.filter(b => b.tipo === "alarma");
  const errores = bitsActivos.filter(b => b.tipo === "error");
  const warnings = bitsActivos.filter(b => b.tipo === "warning");
  const estados = bitsActivos.filter(b => b.tipo === "estado" || b.tipo === "info");

  const partes = [];

  if (errores.length > 0) {
    partes.push(`ERRORES: ${errores.map(e => e.nombre).join(", ")}`);
  }
  if (alarmas.length > 0) {
    partes.push(`ALARMAS: ${alarmas.map(a => a.nombre).join(", ")}`);
  }
  if (warnings.length > 0) {
    partes.push(`Warnings: ${warnings.map(w => w.nombre).join(", ")}`);
  }
  if (estados.length > 0 && partes.length === 0) {
    partes.push(estados.map(e => e.nombre).join(", "));
  }

  return partes.join(" | ");
}

/**
 * Verifica si un registro tiene interpretaci√≥n disponible
 * @param {number} numeroRegistro - N√∫mero del registro
 * @returns {boolean}
 */
export function tieneInterpretacion(numeroRegistro) {
  return Object.prototype.hasOwnProperty.call(MAPA_REGISTROS, numeroRegistro);
}

/**
 * Verifica si una categor√≠a de funcionalidad requiere interpretaci√≥n
 * @param {string} categoriaId - ID de la categor√≠a
 * @returns {boolean}
 */
export function categoriaRequiereInterpretacion(categoriaId) {
  return CATEGORIAS_INTERPRETABLES.includes(categoriaId);
}

/**
 * Obtiene el tipo CSS para un bit seg√∫n su tipo
 * @param {string} tipo - Tipo del bit (alarma, error, warning, estado, info)
 * @returns {string} Clase CSS a aplicar
 */
export function obtenerClaseTipo(tipo) {
  const clases = {
    alarma: "interpretacion-alarma",
    error: "interpretacion-error",
    warning: "interpretacion-warning",
    estado: "interpretacion-estado",
    info: "interpretacion-info",
    ok: "interpretacion-ok",
    unknown: "interpretacion-unknown"
  };
  return clases[tipo] || "interpretacion-info";
}

/**
 * Lista de severidades disponibles para etiquetas
 */
export const SEVERIDADES_DISPONIBLES = [
  { id: "info", nombre: "Info", color: "#93c5fd" },
  { id: "estado", nombre: "Estado", color: "#93c5fd" },
  { id: "warning", nombre: "Advertencia", color: "#fde68a" },
  { id: "alarma", nombre: "Alarma", color: "#fca5a5" },
  { id: "error", nombre: "Error", color: "#fca5a5" }
];

/**
 * Plantillas predefinidas de etiquetas para diferentes tipos de rel√©s
 * El usuario puede seleccionar una de estas como base
 */
export const PLANTILLAS_ETIQUETAS_LEDS = {
  alimentador: {
    nombre: "Alimentador (FE03)",
    etiquetas: {
      0: { texto: "Arranque I>", severidad: "warning" },
      1: { texto: "Disparo I>", severidad: "alarma" },
      2: { texto: "Falla a Tierra / Disparo I>>", severidad: "alarma" },
      3: { texto: "Disparo I>>", severidad: "alarma" },
      4: { texto: "Arranque Io>", severidad: "warning" },
      5: { texto: "Disparo Falla a Tierra", severidad: "alarma" },
      6: { texto: "Desbalance de Fases", severidad: "warning" },
      7: { texto: "Recierre Habilitado", severidad: "info" },
      8: { texto: "Recierre en Progreso", severidad: "info" },
      9: { texto: "Pos CB Abierto", severidad: "estado" },
      10: { texto: "Pos CB Cerrado", severidad: "estado" }
    }
  },
  terna: {
    nombre: "TERNA (FE06)",
    etiquetas: {
      0: { texto: "Sobreintensidad", severidad: "warning" },
      1: { texto: "Falta a tierra", severidad: "alarma" },
      2: { texto: "Sobre/sub tensi√≥n", severidad: "warning" },
      3: { texto: "Desbalance de fases", severidad: "warning" },
      4: { texto: "Sobrecarga t√©rmica", severidad: "warning" },
      5: { texto: "Fallo de interruptor", severidad: "error" },
      6: { texto: "Disparo reg. perturb.", severidad: "info" },
      7: { texto: "Monitorizaci√≥n interruptor", severidad: "info" },
      8: { texto: "Supervisi√≥n", severidad: "info" }
    }
  },
  trafoDif: {
    nombre: "TRAFO Diferencial (TE02)",
    etiquetas: {
      0: { texto: "Prot dif pol. etapa baja", severidad: "warning" },
      1: { texto: "Prot. dif. etapa alta", severidad: "alarma" },
      2: { texto: "Sobreintensidad", severidad: "warning" },
      3: { texto: "Falta a tierra restringida", severidad: "alarma" },
      4: { texto: "Falta a tierra", severidad: "alarma" },
      5: { texto: "Fallo de interruptor", severidad: "error" },
      6: { texto: "F. sec. neg. / sobrecarga 1¬∞", severidad: "warning" },
      7: { texto: "Disparo reg. perturb.", severidad: "info" },
      8: { texto: "Supervisi√≥n", severidad: "info" },
      9: { texto: "Disparo externo", severidad: "alarma" }
    }
  }
};

export default {
  interpretarRegistro,
  tieneInterpretacion,
  categoriaRequiereInterpretacion,
  obtenerClaseTipo,
  SEVERIDADES_DISPONIBLES,
  PLANTILLAS_ETIQUETAS_LEDS
};

// ===== ./src/paginas/PaginaLogin/PaginaLogin.jsx =====

// src/paginas/PaginaLogin/PaginaLogin.jsx

import React, { useState, useEffect, useRef } from "react";
import { Link, useNavigate } from "react-router-dom";
import { useAuth } from "../../contextos/AuthContext";
import { Capacitor } from "@capacitor/core";
import { BiometricAuth } from "@aparajita/capacitor-biometric-auth";
import "./PaginaLogin.css";
import logoApp from "../../assets/imagenes/logo 2 rw.png";

const STORAGE_KEY = "relaywatch_recordarme";

// Icono ojo abierto
const EyeIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
    <circle cx="12" cy="12" r="3"/>
  </svg>
);

// Icono ojo tachado
const EyeOffIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
    <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a21.8 21.8 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a21.8 21.8 0 0 1-2.16 3.19M1 1l22 22"/>
  </svg>
);

const PaginaLogin = () => {
  const [email, setEmail] = useState("");
  const [contrasena, setContrasena] = useState("");
  const [mostrarContrasena, setMostrarContrasena] = useState(false);
  const [recordarme, setRecordarme] = useState(false);
  const [alerta, setAlerta] = useState({ mensaje: "", tipo: "" });
  const [cargando, setCargando] = useState(false);

  // Ref para saber si las credenciales vienen del localStorage (precargadas)
  const credencialesPrecargadas = useRef(false);
  const biometriaYaIntentada = useRef(false);

  const { login } = useAuth();
  const navigate = useNavigate();

  // Cargar credenciales guardadas al montar
  useEffect(() => {
    const guardado = localStorage.getItem(STORAGE_KEY);
    if (guardado) {
      try {
        const { email: emailGuardado, contrasena: contrasenaGuardada } = JSON.parse(guardado);
        if (emailGuardado && contrasenaGuardada) {
          setEmail(emailGuardado);
          setContrasena(contrasenaGuardada);
          setRecordarme(true);
          credencialesPrecargadas.current = true;
        }
      } catch {
        localStorage.removeItem(STORAGE_KEY);
      }
    }
  }, []);

  // Mostrar alerta temporal
  const mostrarAlerta = (mensaje, tipo = "error") => {
    setAlerta({ mensaje, tipo });
    setTimeout(() => {
      setAlerta({ mensaje: "", tipo: "" });
    }, 4000);
  };

  // Mostrar prompt de biometr√≠a autom√°ticamente SOLO si hay credenciales precargadas
  useEffect(() => {
    const intentarBiometria = async () => {
      // Solo ejecutar si:
      // 1. Las credenciales vienen precargadas del localStorage
      // 2. No se ha intentado ya la biometr√≠a
      // 3. Estamos en plataforma nativa
      if (!credencialesPrecargadas.current || biometriaYaIntentada.current) return;
      if (!Capacitor.isNativePlatform()) return;

      biometriaYaIntentada.current = true;

      try {
        const info = await BiometricAuth.checkBiometry();
        if (!info.isAvailable) return;

        await BiometricAuth.authenticate({
          reason: "Inicia sesi√≥n con tu huella digital",
          cancelTitle: "Cancelar",
          allowDeviceCredential: true,
        });

        // Biometr√≠a exitosa, hacer login autom√°tico
        setCargando(true);
        const { exito, error } = await login(email.trim(), contrasena);
        setCargando(false);

        if (!exito) {
          mostrarAlerta(error || "Error al iniciar sesi√≥n", "error");
          return;
        }

        localStorage.setItem(STORAGE_KEY, JSON.stringify({ email: email.trim(), contrasena }));
        mostrarAlerta("¬°Bienvenido!", "exito");

        setTimeout(() => {
          navigate("/alimentadores");
        }, 1200);
      } catch {
        // Usuario cancel√≥ o error de biometr√≠a - no mostrar error
      }
    };

    // Peque√±o delay para que la UI se renderice primero
    const timer = setTimeout(intentarBiometria, 500);
    return () => clearTimeout(timer);
  }, [email, contrasena, login, navigate]);

  // Manejo del submit del formulario
  const handleSubmit = async (event) => {
    event.preventDefault();

    if (!email.trim() || !contrasena.trim()) {
      mostrarAlerta("Por favor completa todos los campos", "error");
      return;
    }

    setCargando(true);

    const { exito, error } = await login(email.trim(), contrasena);

    setCargando(false);

    if (!exito) {
      mostrarAlerta(error || "Error al iniciar sesi√≥n", "error");
      return;
    }

    // Guardar o limpiar credenciales seg√∫n checkbox
    if (recordarme) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ email: email.trim(), contrasena }));
    } else {
      localStorage.removeItem(STORAGE_KEY);
    }

    mostrarAlerta("¬°Bienvenido!", "exito");

    setTimeout(() => {
      navigate("/alimentadores");
    }, 1200);
  };

  return (
    <form onSubmit={handleSubmit} className="login-form">
      <div className="container">
        <div className="izquierda">
          <img
            src={logoApp}
            alt="logoApp"
            className="logo"
          />
        </div>

        <div className="derecha">
          <div className="login">
            <h3 className="usuario">EMAIL</h3>

            <input
              className="input"
              type="email"
              placeholder="Ingrese su email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              autoComplete="email"
              disabled={cargando}
            />

            <h3 className="usuario">CONTRASE√ëA</h3>
            <div className="input-contrase√±a">
              <input
                className="input"
                type={mostrarContrasena ? "text" : "password"}
                placeholder="Ingrese su contrase√±a"
                value={contrasena}
                onChange={(e) => setContrasena(e.target.value)}
                autoComplete="current-password"
                disabled={cargando}
              />
              <span
                onClick={() => setMostrarContrasena(!mostrarContrasena)}
                className='ojito'
              >
                {mostrarContrasena ? <EyeIcon /> : <EyeOffIcon />}
              </span>
            </div>

            <label className="checkbox-recordarme">
              <input
                type="checkbox"
                checked={recordarme}
                onChange={(e) => setRecordarme(e.target.checked)}
                disabled={cargando}
              />
              <span>Recordarme</span>
            </label>

            <div className="acciones">
              <button
                type="submit"
                className="boton"
                disabled={cargando}
              >
                {cargando ? "Iniciando sesi√≥n..." : "Iniciar sesi√≥n"}
              </button>

              <Link to="/recuperarContrase√±a" className="recordarme">
                ¬øOlvidaste tu contrase√±a?
              </Link>

              <Link to="/registro" className="registrarse">
                ¬øNo tienes cuenta? reg√≠strate
              </Link>
            </div>
          </div>
        </div>
      </div>

      {alerta.mensaje && (
        <div className={`alerta alerta-${alerta.tipo}`}>
          {alerta.mensaje}
        </div>
      )}
    </form>
  );
};

export default PaginaLogin;

// ===== ./src/paginas/PaginaRecuperar/RecuperarContrasena.jsx =====

// src/paginas/PaginaRecuperar/RecuperarContrasena.jsx

import { useState } from "react";
import { useNavigate } from "react-router-dom";
import "./RecuperarContrasena.css";
import logoApp from "../../assets/imagenes/logo 2 rw.png";

const RecuperarContrasena = () => {
   const [email, setEmail] = useState("");
   const [alerta, setAlerta] = useState({
      mensaje: "",
      tipo: "",
   });

   const navigate = useNavigate();

   const mostrarAlerta = (mensaje, tipo = "exito") => {
      setAlerta({ mensaje, tipo });
      setTimeout(() => setAlerta({ mensaje: "", tipo: "" }), 5000);
   };

   const handleSubmit = (e) => {
      e.preventDefault();

      if (!email.trim()) {
         mostrarAlerta("Por favor escrib√≠ tu email", "error");
         return;
      }

      if (!email.includes("@") || !email.includes(".")) {
         mostrarAlerta("El email no parece v√°lido", "error");
         return;
      }

      mostrarAlerta(`Listo! Te enviamos un enlace a ${email}`, "exito");

      setTimeout(() => {
         navigate("/");
      }, 3000);
   };

   return (
      <div className="recuperar-fondo">
         <div className="recuperar-caja">
            <button
               className="btn-volver"
               onClick={() => navigate("/")}
            >
               ‚Üê Volver al inicio de sesi√≥n
            </button>

            <img
               src={logoApp}
               alt="Logo"
               className="logo-recuperar"
            />

            <h2 className="h2-Recuperar">Recuperar contrase√±a</h2>

            <p className="texto-ayuda">
               Ingres√° tu email y te enviaremos un enlace para crear una nueva
               contrase√±a.
            </p>

            <form onSubmit={handleSubmit}>
               <input
                  type="text"
                  placeholder="tuemail@ejemplo.com"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="input-recuperar"
               />
               <button type="submit" className="btn-enviar">
                  Enviar enlace
               </button>
            </form>

            {alerta.mensaje && (
               <div className={`alerta alerta-${alerta.tipo}`}>
                  {alerta.mensaje}
               </div>
            )}
         </div>
      </div>
   );
};

export default RecuperarContrasena;

// ===== ./src/paginas/PaginaRegistro/PaginaRegistro.jsx =====

// src/paginas/PaginaRegistro/PaginaRegistro.jsx

import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../contextos/AuthContext";
import "../PaginaLogin/PaginaLogin.css";
import "./PaginaRegistro.css";
import logoApp from "../../assets/imagenes/logo 2 rw.png";

const PaginaRegistro = () => {
  const [nombre, setNombre] = useState("");
  const [email, setEmail] = useState("");
  const [contrasena, setContrasena] = useState("");
  const [confirmar, setConfirmar] = useState("");
  const [errores, setErrores] = useState({});
  const [alerta, setAlerta] = useState({ mensaje: "", tipo: "" });
  const [cargando, setCargando] = useState(false);

  const { registro } = useAuth();
  const navigate = useNavigate();

  // Mostrar alerta temporal
  const mostrarAlerta = (mensaje, tipo = "error") => {
    setAlerta({ mensaje, tipo });
    setTimeout(() => {
      setAlerta({ mensaje: "", tipo: "" });
    }, 5000);
  };

  // Validaci√≥n por campo
  const validarCampo = (campo) => {
    let mensaje = "";

    switch (campo) {
      case "nombre":
        if (!nombre.trim()) {
          mensaje = "El nombre es obligatorio.";
        } else if (nombre.trim().length < 3) {
          mensaje = "El nombre debe tener al menos 3 caracteres.";
        }
        break;

      case "email":
        if (!email.trim()) {
          mensaje = "El email es obligatorio.";
        } else {
          const regexEmail = /^\S+@\S+\.\S+$/;
          if (!regexEmail.test(email)) {
            mensaje = "El formato de email no es v√°lido.";
          }
        }
        break;

      case "contrasena":
        if (!contrasena) {
          mensaje = "La contrase√±a es obligatoria.";
        } else if (contrasena.length < 6) {
          mensaje = "La contrase√±a debe tener al menos 6 caracteres.";
        }
        break;

      case "confirmar":
        if (!confirmar) {
          mensaje = "Debes confirmar la contrase√±a.";
        } else if (confirmar !== contrasena) {
          mensaje = "Las contrase√±as no coinciden.";
        }
        break;

      default:
        break;
    }

    setErrores((prev) => {
      const next = { ...prev };
      if (mensaje) {
        next[campo] = mensaje;
      } else {
        delete next[campo];
      }
      return next;
    });

    return mensaje;
  };

  // Validaci√≥n al salir de cada input
  const handleBlur = (campo) => {
    validarCampo(campo);
  };

  // Validaci√≥n global del formulario
  const validarTodo = () => {
    const campos = ["nombre", "email", "contrasena", "confirmar"];
    const mensajes = campos.map((c) => validarCampo(c));
    return mensajes.every((m) => m === "");
  };

  // Env√≠o del formulario
  const handleSubmit = async (event) => {
    event.preventDefault();

    if (!validarTodo()) {
      return;
    }

    setCargando(true);

    const { exito, error, requiereConfirmacion } = await registro(
      email.trim().toLowerCase(),
      contrasena,
      nombre.trim()
    );

    setCargando(false);

    if (!exito) {
      mostrarAlerta(error || "Error al crear la cuenta", "error");
      return;
    }

    if (requiereConfirmacion) {
      mostrarAlerta(
        "¬°Cuenta creada! Revisa tu email para confirmar tu cuenta antes de iniciar sesi√≥n.",
        "exito"
      );
    } else {
      mostrarAlerta("¬°Cuenta creada con √©xito!", "exito");
    }

    // Limpiar formulario
    setNombre("");
    setEmail("");
    setContrasena("");
    setConfirmar("");
    setErrores({});

    // Volver al login despu√©s de un momento
    setTimeout(() => {
      navigate("/");
    }, 3000);
  };

  // Bot√≥n "Volver"
  const handleVolver = () => {
    navigate("/");
  };

  return (
    <form onSubmit={handleSubmit} className="login-form registro-page">
      <div className="container">
        <div className="izquierda">
          <img
            src={logoApp}
            alt="logoApp"
            className="logo"
          />
        </div>

        <div className="derecha">
          <div className="login">
            <button
              type="button"
              className="btn-volver"
              onClick={handleVolver}
              disabled={cargando}
            >
              ‚Üê Volver
            </button>

            <h2 className="titulo-registro">REGISTRO</h2>

            <h3 className="label-registro">Nombre completo</h3>
            <input
              className={`input ${errores.nombre ? "input-error" : ""}`}
              type="text"
              placeholder="Ingrese su nombre"
              value={nombre}
              onChange={(e) => setNombre(e.target.value)}
              onBlur={() => handleBlur("nombre")}
              disabled={cargando}
            />
            {errores.nombre && (
              <p className="error-text">{errores.nombre}</p>
            )}

            <h3 className="label-registro">Email</h3>
            <input
              className={`input ${errores.email ? "input-error" : ""}`}
              type="email"
              placeholder="Ingrese su email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              onBlur={() => handleBlur("email")}
              disabled={cargando}
            />
            {errores.email && (
              <p className="error-text">{errores.email}</p>
            )}

            <h3 className="label-registro">Contrase√±a</h3>
            <input
              className={`input ${errores.contrasena ? "input-error" : ""}`}
              type="password"
              placeholder="Ingrese su contrase√±a (m√≠n. 6 caracteres)"
              value={contrasena}
              onChange={(e) => setContrasena(e.target.value)}
              onBlur={() => handleBlur("contrasena")}
              disabled={cargando}
            />
            {errores.contrasena && (
              <p className="error-text">{errores.contrasena}</p>
            )}

            <h3 className="label-registro">Confirmar contrase√±a</h3>
            <input
              className={`input ${errores.confirmar ? "input-error" : ""}`}
              type="password"
              placeholder="Repita su contrase√±a"
              value={confirmar}
              onChange={(e) => setConfirmar(e.target.value)}
              onBlur={() => handleBlur("confirmar")}
              disabled={cargando}
            />
            {errores.confirmar && (
              <p className="error-text">{errores.confirmar}</p>
            )}

            <div className="acciones">
              <button
                type="submit"
                className="boton"
                disabled={cargando}
              >
                {cargando ? "Creando cuenta..." : "Crear cuenta"}
              </button>
            </div>
          </div>
        </div>
      </div>

      {alerta.mensaje && (
        <div className={`alerta alerta-${alerta.tipo}`}>
          {alerta.mensaje}
        </div>
      )}
    </form>
  );
};

export default PaginaRegistro;

// ===== ./src/servicios/api/admin.js =====

// servicios/api/admin.js
// API de administraci√≥n (solo superadmin)

import { fetchConAuth } from './base';

/**
 * Lista todos los usuarios del sistema (excepto superadmins)
 * @returns {Promise<Array>} Lista de usuarios con sus permisos de agentes
 */
export async function listarUsuariosAdmin() {
   return fetchConAuth('/api/admin/usuarios');
}

/**
 * Cambia el rol global de un usuario
 * @param {string} usuarioId - ID del usuario
 * @param {string} rolCodigo - C√≥digo del rol ('admin', 'operador', 'observador')
 * @returns {Promise<Object>} Usuario actualizado
 */
export async function cambiarRolUsuarioAdmin(usuarioId, rolCodigo) {
   return fetchConAuth(`/api/admin/usuarios/${usuarioId}/rol`, {
      method: 'PUT',
      body: JSON.stringify({ rolCodigo }),
   });
}

/**
 * Actualiza los agentes a los que un usuario tiene acceso
 * @param {string} usuarioId - ID del usuario
 * @param {boolean} accesoTotal - Si es true, tiene acceso a todos los agentes
 * @param {string[]} agentesIds - Array de IDs de agentes (ignorado si accesoTotal es true)
 * @returns {Promise<Object>} Permisos actualizados
 */
export async function actualizarAgentesUsuarioAdmin(usuarioId, accesoTotal, agentesIds = []) {
   return fetchConAuth(`/api/admin/usuarios/${usuarioId}/agentes`, {
      method: 'PUT',
      body: JSON.stringify({ accesoTotal, agentesIds }),
   });
}

/**
 * Lista todos los agentes disponibles para asignar permisos
 * @returns {Promise<Array>} Lista de agentes con id, nombre y activo
 */
export async function listarAgentesParaPermisos() {
   return fetchConAuth('/api/admin/agentes-disponibles');
}

/**
 * Obtiene detalles completos de un usuario (workspaces, puestos, agentes, invitados)
 * @param {string} usuarioId - ID del usuario
 * @returns {Promise<Object>} Detalles del usuario con workspaces propios e invitado
 */
export async function obtenerDetallesUsuarioAdmin(usuarioId) {
   return fetchConAuth(`/api/admin/usuarios/${usuarioId}/detalles`);
}

// ===== ./src/servicios/api/agentes.js =====

// servicios/api/agentes.js
// API de agentes y registradores

import { fetchConAuth } from './base';

/**
 * Desvincula el agente del workspace (legacy)
 */
export async function desvincularAgente(workspaceId) {
   return fetchConAuth('/api/agentes/desvincular', {
      method: 'POST',
      body: JSON.stringify({ workspaceId }),
   });
}

// --- Panel Admin (solo superadmin) ---

/**
 * Lista todos los agentes del sistema (solo superadmin)
 */
export async function listarTodosLosAgentes() {
   return fetchConAuth('/api/admin/agentes');
}

/**
 * Crea un nuevo agente (solo superadmin)
 */
export async function crearAgente(nombre, descripcion = '') {
   return fetchConAuth('/api/admin/agentes', {
      method: 'POST',
      body: JSON.stringify({ nombre, descripcion }),
   });
}

/**
 * Actualiza un agente (solo superadmin)
 */
export async function actualizarAgente(agenteId, datos) {
   return fetchConAuth(`/api/admin/agentes/${agenteId}`, {
      method: 'PUT',
      body: JSON.stringify(datos),
   });
}

/**
 * Elimina un agente (solo superadmin)
 */
export async function eliminarAgente(agenteId) {
   return fetchConAuth(`/api/admin/agentes/${agenteId}`, {
      method: 'DELETE',
   });
}

/**
 * Rota la clave de un agente (solo superadmin)
 */
export async function rotarClaveAgentePorId(agenteId) {
   return fetchConAuth(`/api/admin/agentes/${agenteId}/rotar-clave`, {
      method: 'POST',
   });
}

// --- Agentes disponibles (admin+) ---

/**
 * Lista agentes disponibles para vincular (admin+)
 */
export async function listarAgentesDisponibles() {
   return fetchConAuth('/api/agentes/disponibles');
}

// --- Vinculaci√≥n workspace-agente (N:M) ---

/**
 * Lista agentes vinculados a un workspace
 */
export async function listarAgentesWorkspace(workspaceId) {
   return fetchConAuth(`/api/workspaces/${workspaceId}/agentes`);
}

/**
 * Vincula un agente a un workspace (admin+)
 */
export async function vincularAgenteWorkspace(workspaceId, agenteId) {
   return fetchConAuth(`/api/workspaces/${workspaceId}/agentes`, {
      method: 'POST',
      body: JSON.stringify({ agenteId }),
   });
}

/**
 * Desvincula un agente de un workspace (admin+)
 */
export async function desvincularAgenteWorkspace(workspaceId, agenteId) {
   return fetchConAuth(`/api/workspaces/${workspaceId}/agentes/${agenteId}`, {
      method: 'DELETE',
   });
}

// ===== ./src/servicios/api/alimentadores.js =====

// servicios/api/alimentadores.js
// API de alimentadores

import { fetchConAuth } from './base';

/**
 * Obtiene los alimentadores de un puesto
 */
export async function obtenerAlimentadores(puestoId) {
   return fetchConAuth(`/api/puestos/${puestoId}/alimentadores`);
}

/**
 * Crea un nuevo alimentador
 */
export async function crearAlimentador(puestoId, datos) {
   return fetchConAuth(`/api/puestos/${puestoId}/alimentadores`, {
      method: 'POST',
      body: JSON.stringify(datos),
   });
}

/**
 * Actualiza un alimentador
 */
export async function actualizarAlimentadorAPI(alimentadorId, datos) {
   return fetchConAuth(`/api/alimentadores/${alimentadorId}`, {
      method: 'PUT',
      body: JSON.stringify(datos),
   });
}

/**
 * Elimina un alimentador
 */
export async function eliminarAlimentadorAPI(alimentadorId) {
   return fetchConAuth(`/api/alimentadores/${alimentadorId}`, {
      method: 'DELETE',
   });
}

/**
 * Reordena los alimentadores de un puesto
 * @param {number} puestoId - ID del puesto
 * @param {number[]} ordenIds - Array de IDs de alimentadores en el nuevo orden
 */
export async function reordenarAlimentadores(puestoId, ordenIds) {
   const ordenes = ordenIds.map((id, index) => ({ id, orden: index }));
   return fetchConAuth(`/api/puestos/${puestoId}/alimentadores/reordenar`, {
      method: 'PUT',
      body: JSON.stringify({ ordenes }),
   });
}


// ===== ./src/servicios/api/base.js =====

// servicios/api/base.js
// Funciones base para comunicaci√≥n con el backend

import { supabase } from '../../lib/supabase';

export const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

/**
 * Obtiene el token de autenticaci√≥n actual
 */
export async function obtenerToken() {
   const { data: { session } } = await supabase.auth.getSession();
   return session?.access_token || null;
}

/**
 * Realiza una petici√≥n al backend con autenticaci√≥n
 */
export async function fetchConAuth(endpoint, opciones = {}) {
   const token = await obtenerToken();

   if (!token) {
      throw new Error('No hay sesi√≥n activa');
   }

   const respuesta = await fetch(`${API_URL}${endpoint}`, {
      ...opciones,
      headers: {
         'Content-Type': 'application/json',
         'Authorization': `Bearer ${token}`,
         ...opciones.headers,
      },
   });

   const datos = await respuesta.json();

   if (!respuesta.ok) {
      throw new Error(datos.error || 'Error en la petici√≥n');
   }

   return datos;
}

// ===== ./src/servicios/api/dispositivos.js =====

// servicios/api/dispositivos.js
// API de dispositivos (Push Notifications)

import { fetchConAuth } from './base';

/**
 * Registra el token FCM del dispositivo para recibir push notifications
 * @param {string} fcmToken - Token FCM del dispositivo
 * @param {string} plataforma - Plataforma del dispositivo ('android' o 'ios')
 * @returns {Promise<Object>} Dispositivo registrado
 */
export async function registrarTokenDispositivo(fcmToken, plataforma = 'android') {
   return fetchConAuth('/api/dispositivos/registrar', {
      method: 'POST',
      body: JSON.stringify({ fcmToken, plataforma }),
   });
}


// ===== ./src/servicios/api/index.js =====

// servicios/api/index.js
// Exportaciones centralizadas de todas las APIs

// Base
export { API_URL, obtenerToken, fetchConAuth } from './base';

// Usuarios
export {
   obtenerPerfil,
   crearPerfilUsuario,
   actualizarWorkspaceDefault,
} from './usuarios';

// Workspaces
export {
   obtenerWorkspaces,
   crearWorkspace,
   actualizarWorkspace,
   eliminarWorkspace,
} from './workspaces';

// Puestos
export {
   obtenerPuestos,
   crearPuesto,
   actualizarPuesto,
   eliminarPuesto,
} from './puestos';

// Alimentadores
export {
   obtenerAlimentadores,
   crearAlimentador,
   actualizarAlimentadorAPI,
   eliminarAlimentadorAPI,
   reordenarAlimentadores,
} from './alimentadores';

// Lecturas
export {
   obtenerUltimasLecturasPorRegistrador,
   obtenerLecturasHistoricasPorRegistrador,
} from './lecturas';

// Preferencias
export {
   obtenerPreferencias,
   guardarPreferencias,
} from './preferencias';

// Agentes
export {
   desvincularAgente,
   listarTodosLosAgentes,
   crearAgente,
   actualizarAgente,
   eliminarAgente,
   rotarClaveAgentePorId,
   listarAgentesDisponibles,
   listarAgentesWorkspace,
   vincularAgenteWorkspace,
   desvincularAgenteWorkspace,
} from './agentes';

// Registradores
export {
   listarRegistradoresAgente,
   crearRegistradorAgente,
   actualizarRegistradorAgente,
   eliminarRegistradorAgente,
   toggleRegistradorAgente,
   solicitarTestRegistrador,
   consultarTestRegistrador,
} from './registradores';

// Permisos
export {
   obtenerPermisosWorkspace,
   agregarPermisoWorkspace,
   actualizarPermisoWorkspace,
   eliminarPermisoWorkspace,
} from './permisos';

// Admin (superadmin)
export {
   listarUsuariosAdmin,
   cambiarRolUsuarioAdmin,
   actualizarAgentesUsuarioAdmin,
   listarAgentesParaPermisos,
   obtenerDetallesUsuarioAdmin,
} from './admin';

// Dispositivos
export {
   registrarTokenDispositivo,
} from './dispositivos';

// Default export para compatibilidad con: import apiService from '...'
import * as usuarios from './usuarios';
import * as workspaces from './workspaces';
import * as puestos from './puestos';
import * as alimentadores from './alimentadores';
import * as lecturas from './lecturas';
import * as preferencias from './preferencias';
import * as agentes from './agentes';
import * as registradores from './registradores';
import * as permisos from './permisos';
import * as admin from './admin';
import * as dispositivos from './dispositivos';

export default {
   ...usuarios,
   ...workspaces,
   ...puestos,
   ...alimentadores,
   ...lecturas,
   ...preferencias,
   ...agentes,
   ...registradores,
   ...permisos,
   ...admin,
   ...dispositivos,
};

// ===== ./src/servicios/api/lecturas.js =====

// servicios/api/lecturas.js
// API de lecturas y mediciones

import { fetchConAuth } from './base';

/**
 * Obtiene las √∫ltimas lecturas de un registrador
 * @param {string} registradorId - ID del registrador
 * @param {number} limite - Cantidad de lecturas a obtener (default 1)
 */
export async function obtenerUltimasLecturasPorRegistrador(registradorId, limite = 1) {
   return fetchConAuth(`/api/registradores/${registradorId}/lecturas?limite=${limite}`);
}

/**
 * Obtiene lecturas hist√≥ricas de un registrador en un rango de tiempo
 * @param {string} registradorId - ID del registrador
 * @param {string} desde - Fecha ISO de inicio del rango
 * @param {string} hasta - Fecha ISO de fin del rango
 * @returns {Promise<Array>} Array de lecturas con indice_inicial incluido
 */
export async function obtenerLecturasHistoricasPorRegistrador(registradorId, desde, hasta) {
   return fetchConAuth(`/api/registradores/${registradorId}/lecturas/historico?desde=${desde}&hasta=${hasta}`);
}

// ===== ./src/servicios/api/permisos.js =====

// servicios/api/permisos.js
// API de permisos de workspace

import { fetchConAuth } from './base';

/**
 * Obtiene los usuarios con acceso a un workspace
 * @param {string} workspaceId - ID del workspace
 * @returns {Promise<Array>} Lista de permisos con datos de usuario y rol
 */
export async function obtenerPermisosWorkspace(workspaceId) {
   return fetchConAuth(`/api/workspaces/${workspaceId}/permisos`);
}

/**
 * Invita/agrega un usuario a un workspace
 * @param {string} workspaceId - ID del workspace
 * @param {string} email - Email del usuario a invitar
 * @param {string} rol - Rol a asignar ('observador', 'operador', 'admin')
 * @returns {Promise<Object>} Permiso creado
 */
export async function agregarPermisoWorkspace(workspaceId, email, rol) {
   return fetchConAuth(`/api/workspaces/${workspaceId}/permisos`, {
      method: 'POST',
      body: JSON.stringify({ email, rol }),
   });
}

/**
 * Actualiza el rol de un usuario en un workspace
 * @param {string} permisoId - ID del permiso a actualizar
 * @param {string} rol - Nuevo rol ('observador', 'operador', 'admin')
 * @returns {Promise<Object>} Permiso actualizado
 */
export async function actualizarPermisoWorkspace(permisoId, rol) {
   return fetchConAuth(`/api/permisos/${permisoId}`, {
      method: 'PUT',
      body: JSON.stringify({ rol }),
   });
}

/**
 * Elimina el acceso de un usuario a un workspace
 * @param {string} permisoId - ID del permiso a eliminar
 * @returns {Promise<Object>} Mensaje de confirmaci√≥n
 */
export async function eliminarPermisoWorkspace(permisoId) {
   return fetchConAuth(`/api/permisos/${permisoId}`, {
      method: 'DELETE',
   });
}

// ===== ./src/servicios/api/preferencias.js =====

// servicios/api/preferencias.js
// API de preferencias de usuario

import { fetchConAuth } from './base';

/**
 * Obtiene las preferencias del usuario para un workspace
 */
export async function obtenerPreferencias(workspaceId) {
   return fetchConAuth(`/api/workspaces/${workspaceId}/preferencias`);
}

/**
 * Guarda las preferencias del usuario
 */
export async function guardarPreferencias(workspaceId, preferencias) {
   return fetchConAuth(`/api/workspaces/${workspaceId}/preferencias`, {
      method: 'POST',
      body: JSON.stringify(preferencias),
   });
}

// ===== ./src/servicios/api/puestos.js =====

// servicios/api/puestos.js
// API de puestos

import { fetchConAuth } from './base';

/**
 * Obtiene los puestos de un workspace
 */
export async function obtenerPuestos(workspaceId) {
   return fetchConAuth(`/api/workspaces/${workspaceId}/puestos`);
}

/**
 * Crea un nuevo puesto
 */
export async function crearPuesto(workspaceId, datos) {
   return fetchConAuth(`/api/workspaces/${workspaceId}/puestos`, {
      method: 'POST',
      body: JSON.stringify(datos),
   });
}

/**
 * Actualiza un puesto
 */
export async function actualizarPuesto(puestoId, datos) {
   return fetchConAuth(`/api/puestos/${puestoId}`, {
      method: 'PUT',
      body: JSON.stringify(datos),
   });
}

/**
 * Elimina un puesto
 */
export async function eliminarPuesto(puestoId) {
   return fetchConAuth(`/api/puestos/${puestoId}`, {
      method: 'DELETE',
   });
}


// ===== ./src/servicios/api/registradores.js =====

// servicios/api/registradores.js
// API de registradores

import { fetchConAuth } from './base';

// ============================================
// REGISTRADORES DE AGENTES (solo superadmin)
// ============================================

/**
 * Lista registradores de un agente espec√≠fico
 */
export async function listarRegistradoresAgente(agenteId) {
   return fetchConAuth(`/api/agentes/${agenteId}/registradores`);
}

/**
 * Crea un registrador para un agente (solo superadmin)
 */
export async function crearRegistradorAgente(agenteId, datos) {
   return fetchConAuth(`/api/agentes/${agenteId}/registradores`, {
      method: 'POST',
      body: JSON.stringify(datos),
   });
}

/**
 * Actualiza un registrador de un agente (solo superadmin)
 */
export async function actualizarRegistradorAgente(agenteId, registradorId, datos) {
   return fetchConAuth(`/api/agentes/${agenteId}/registradores/${registradorId}`, {
      method: 'PUT',
      body: JSON.stringify(datos),
   });
}

/**
 * Elimina un registrador de un agente (solo superadmin)
 */
export async function eliminarRegistradorAgente(agenteId, registradorId) {
   return fetchConAuth(`/api/agentes/${agenteId}/registradores/${registradorId}`, {
      method: 'DELETE',
   });
}

/**
 * Toggle activo de un registrador (solo superadmin)
 */
export async function toggleRegistradorAgente(agenteId, registradorId) {
   return fetchConAuth(`/api/agentes/${agenteId}/registradores/${registradorId}/toggle`, {
      method: 'POST',
   });
}

/**
 * Solicita un test de conexi√≥n para un registrador (ejecutado por el agente)
 * @param {string} agenteId - ID del agente que ejecutar√° el test
 * @param {object} datos - Datos del test: ip, puerto, unitId, indiceInicial, cantidadRegistros
 * @returns {Promise<{testId: string, mensaje: string, timeoutSegundos: number}>}
 */
export async function solicitarTestRegistrador(agenteId, datos) {
   return fetchConAuth(`/api/agentes/${agenteId}/test-registrador`, {
      method: 'POST',
      body: JSON.stringify(datos),
   });
}

/**
 * Consulta el estado/resultado de un test de registrador
 * @param {string} agenteId - ID del agente
 * @param {string} testId - ID del test
 * @returns {Promise<{estado: string, valores?: number[], error_mensaje?: string, tiempo_respuesta_ms?: number}>}
 */
export async function consultarTestRegistrador(agenteId, testId) {
   return fetchConAuth(`/api/agentes/${agenteId}/test-registrador/${testId}`);
}



// ===== ./src/servicios/api/usuarios.js =====

// servicios/api/usuarios.js
// API de usuarios y perfiles

import { fetchConAuth } from './base';

/**
 * Obtiene el perfil del usuario autenticado (incluye rol global)
 */
export async function obtenerPerfil() {
   return fetchConAuth('/api/usuarios/perfil');
}

/**
 * Crea el perfil del usuario despu√©s del registro en Supabase Auth
 * @param {string} nombre - Nombre del usuario
 */
export async function crearPerfilUsuario(nombre) {
   return fetchConAuth('/api/usuarios/perfil', {
      method: 'POST',
      body: JSON.stringify({ nombre }),
   });
}

/**
 * Actualiza el workspace por defecto del usuario
 * @param {string|null} workspaceId - ID del workspace o null para quitar el default
 */
export async function actualizarWorkspaceDefault(workspaceId) {
   return fetchConAuth('/api/usuarios/workspace-default', {
      method: 'PUT',
      body: JSON.stringify({ workspaceId }),
   });
}

// ===== ./src/servicios/api/workspaces.js =====

// servicios/api/workspaces.js
// API de workspaces

import { fetchConAuth } from './base';

/**
 * Obtiene todos los workspaces del usuario
 */
export async function obtenerWorkspaces() {
   return fetchConAuth('/api/workspaces');
}

/**
 * Crea un nuevo workspace
 */
export async function crearWorkspace(nombre, descripcion = '') {
   return fetchConAuth('/api/workspaces', {
      method: 'POST',
      body: JSON.stringify({ nombre, descripcion }),
   });
}

/**
 * Actualiza un workspace
 */
export async function actualizarWorkspace(id, datos) {
   return fetchConAuth(`/api/workspaces/${id}`, {
      method: 'PUT',
      body: JSON.stringify(datos),
   });
}

/**
 * Elimina un workspace
 */
export async function eliminarWorkspace(id) {
   return fetchConAuth(`/api/workspaces/${id}`, {
      method: 'DELETE',
   });
}

// ===== ./src/servicios/apiService.js =====

// src/servicios/apiService.js
// Re-exporta todas las funciones de API desde los m√≥dulos organizados
// Mantiene compatibilidad con imports existentes

export * from './api';

// Export default para compatibilidad con imports como: import apiService from '...'
export { default } from './api/index';

// ===== ./src/servicios/authService.js =====

// src/servicios/authService.js
// Servicio de autenticaci√≥n usando Supabase
// NOTA: Las operaciones de supabase.auth.* van directas a Supabase (correcto)
//       Los datos de usuario van por el backend (crearPerfilUsuario, obtenerPerfil)

import { supabase } from '../lib/supabase';
import { crearPerfilUsuario, obtenerPerfil } from './apiService';

/**
 * Iniciar sesi√≥n con email y contrase√±a
 * @param {string} email
 * @param {string} password
 * @returns {Promise<{user, error}>}
 */
export async function iniciarSesion(email, password) {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    return { user: null, error: traducirError(error.message) };
  }

  return { user: data.user, error: null };
}

/**
 * Registrar nuevo usuario
 * @param {string} email
 * @param {string} password
 * @param {string} nombre
 * @returns {Promise<{user, error}>}
 */
export async function registrarUsuario(email, password, nombre) {
  // 1. Crear usuario en Supabase Auth (directo - esto es correcto)
  const { data: authData, error: authError } = await supabase.auth.signUp({
    email,
    password,
    options: {
      data: {
        nombre: nombre,
      },
    },
  });

  if (authError) {
    return { user: null, error: traducirError(authError.message) };
  }

  // 2. Crear perfil en tabla usuarios VIA BACKEND
  // El backend usa SERVICE_ROLE y valida la creaci√≥n
  if (authData.user && authData.session) {
    try {
      await crearPerfilUsuario(nombre);
    } catch (dbError) {
      console.error('Error al crear perfil en DB:', dbError);
      // No retornamos error porque el usuario ya se cre√≥ en Auth
      // El backend puede crear el perfil despu√©s en obtenerPerfil
    }
  }

  return { user: authData.user, error: null };
}

/**
 * Cerrar sesi√≥n
 * Limpia tambi√©n los datos de localStorage para evitar que persistan entre usuarios
 * @returns {Promise<{error}>}
 */
export async function cerrarSesion() {
  // Limpiar datos de sesi√≥n del localStorage
  // Esto evita que al loguearse otro usuario se intente acceder a workspaces del anterior
  localStorage.removeItem('rw-configuracion-seleccionada');
  localStorage.removeItem('rw-puesto-seleccionado');
  localStorage.removeItem('rw-gap-tarjetas');
  localStorage.removeItem('rw-gap-filas');

  const { error } = await supabase.auth.signOut();
  return { error: error ? traducirError(error.message) : null };
}

/**
 * Obtener sesi√≥n actual
 * @returns {Promise<{session, user}>}
 */
export async function obtenerSesion() {
  const { data: { session } } = await supabase.auth.getSession();
  return {
    session,
    user: session?.user || null,
  };
}

/**
 * Obtener datos del usuario actual desde nuestra tabla
 * Usa el backend para obtener el perfil (incluye rol global y permisos)
 * @returns {Promise<{usuario, error}>}
 */
export async function obtenerUsuarioActual() {
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { usuario: null, error: 'No hay sesi√≥n activa' };
  }

  try {
    // Obtener perfil VIA BACKEND
    // El backend crea el usuario si no existe (auto-provisioning)
    const perfil = await obtenerPerfil();
    return { usuario: perfil, error: null };
  } catch (error) {
    return { usuario: null, error: error.message };
  }
}

/**
 * Enviar email para recuperar contrase√±a
 * @param {string} email
 * @returns {Promise<{error}>}
 */
export async function recuperarContrasena(email) {
  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${window.location.origin}/cambiar-contrasena`,
  });

  return { error: error ? traducirError(error.message) : null };
}

/**
 * Suscribirse a cambios de autenticaci√≥n
 * @param {Function} callback
 * @returns {Function} funci√≥n para desuscribirse
 */
export function suscribirseACambiosAuth(callback) {
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    (event, session) => {
      callback(event, session);
    }
  );

  return () => subscription.unsubscribe();
}

/**
 * Traducir mensajes de error de Supabase al espa√±ol
 * @param {string} mensaje
 * @returns {string}
 */
function traducirError(mensaje) {
  const traducciones = {
    'Invalid login credentials': 'Usuario o contrase√±a incorrectos',
    'Email not confirmed': 'Debes confirmar tu email antes de iniciar sesi√≥n',
    'User already registered': 'Este email ya est√° registrado',
    'Password should be at least 6 characters': 'La contrase√±a debe tener al menos 6 caracteres',
    'Unable to validate email address: invalid format': 'El formato del email no es v√°lido',
    'Email rate limit exceeded': 'Demasiados intentos. Intenta m√°s tarde',
  };

  return traducciones[mensaje] || mensaje;
}

// ===== ./src/servicios/pushNotifications.js =====

// src/servicios/pushNotifications.js
// Servicio para gestionar Push Notifications con Capacitor + Firebase

import { PushNotifications } from '@capacitor/push-notifications';
import { Capacitor } from '@capacitor/core';

/**
 * Verifica si estamos en plataforma nativa (Android/iOS)
 */
export const esPlataformaNativa = () => {
  return Capacitor.isNativePlatform();
};

/**
 * Registra el dispositivo para recibir push notifications
 * @param {Function} onTokenRecibido - Callback cuando se obtiene el token FCM
 * @param {Function} onNotificacionRecibida - Callback cuando llega una notificaci√≥n (app en primer plano)
 * @param {Function} onNotificacionTocada - Callback cuando el usuario toca la notificaci√≥n
 * @returns {Promise<boolean>} true si se registr√≥ correctamente
 */
export const registrarPushNotifications = async (
  onTokenRecibido,
  onNotificacionRecibida = null,
  onNotificacionTocada = null
) => {
  if (!esPlataformaNativa()) {
    console.log('[Push] Solo disponible en app nativa, ignorando en web');
    return null;
  }

  try {
    // Verificar/solicitar permisos
    let permStatus = await PushNotifications.checkPermissions();
    console.log('[Push] Estado de permisos:', permStatus.receive);

    if (permStatus.receive === 'prompt') {
      console.log('[Push] Solicitando permisos...');
      permStatus = await PushNotifications.requestPermissions();
    }

    if (permStatus.receive !== 'granted') {
      console.log('[Push] Permisos denegados por el usuario');
      return null;
    }

    // Registrar en FCM
    await PushNotifications.register();
    console.log('[Push] Registro en FCM iniciado');

    // Listener: Token recibido
    PushNotifications.addListener('registration', (token) => {
      console.log('[Push] Token FCM recibido:', token.value);
      if (onTokenRecibido) {
        onTokenRecibido(token.value);
      }
    });

    // Listener: Error de registro
    PushNotifications.addListener('registrationError', (error) => {
      console.error('[Push] Error en registro:', error);
    });

    // Listener: Notificaci√≥n recibida (app en primer plano)
    PushNotifications.addListener('pushNotificationReceived', (notification) => {
      console.log('[Push] Notificaci√≥n recibida:', notification);
      if (onNotificacionRecibida) {
        onNotificacionRecibida({
          titulo: notification.title,
          cuerpo: notification.body,
          datos: notification.data,
        });
      }
    });

    // Listener: Usuario toc√≥ la notificaci√≥n
    PushNotifications.addListener('pushNotificationActionPerformed', (action) => {
      console.log('[Push] Notificaci√≥n tocada:', action);
      if (onNotificacionTocada) {
        onNotificacionTocada({
          actionId: action.actionId,
          datos: action.notification.data,
        });
      }
    });

    return true;
  } catch (error) {
    console.error('[Push] Error configurando push notifications:', error);
    return null;
  }
};

/**
 * Desregistra todos los listeners de push notifications
 * Llamar al desmontar el componente principal
 */
export const desregistrarPushNotifications = async () => {
  if (!esPlataformaNativa()) return;

  try {
    await PushNotifications.removeAllListeners();
    console.log('[Push] Listeners removidos');
  } catch (error) {
    console.error('[Push] Error removiendo listeners:', error);
  }
};

/**
 * Obtiene la lista de notificaciones entregadas (en el centro de notificaciones)
 */
export const obtenerNotificacionesPendientes = async () => {
  if (!esPlataformaNativa()) return [];

  try {
    const { notifications } = await PushNotifications.getDeliveredNotifications();
    return notifications;
  } catch (error) {
    console.error('[Push] Error obteniendo notificaciones:', error);
    return [];
  }
};

/**
 * Limpia todas las notificaciones del centro de notificaciones
 */
export const limpiarNotificaciones = async () => {
  if (!esPlataformaNativa()) return;

  try {
    await PushNotifications.removeAllDeliveredNotifications();
    console.log('[Push] Notificaciones limpiadas');
  } catch (error) {
    console.error('[Push] Error limpiando notificaciones:', error);
  }
};

// ===== ./src/tipos/index.js =====

// src/tipos/index.js
// Definiciones de tipos centralizadas para el proyecto RelayWatch

/**
 * @typedef {Object} Alimentador
 * @property {string} id - UUID del alimentador
 * @property {string} nombre - Nombre descriptivo
 * @property {string} ip - Direcci√≥n IP del dispositivo
 * @property {number} puerto - Puerto Modbus (default 502)
 * @property {string} [color] - Color de la tarjeta
 * @property {Object} [card_design] - Dise√±o personalizado de la tarjeta
 * @property {number} orden - Orden de visualizaci√≥n
 * @property {string} puesto_id - ID del puesto al que pertenece
 */

/**
 * @typedef {Object} Puesto
 * @property {string} id - UUID del puesto
 * @property {string} nombre - Nombre del puesto
 * @property {string} color - Color del header
 * @property {string} [bgColor] - Color de fondo
 * @property {number} orden - Orden de visualizaci√≥n
 * @property {Alimentador[]} alimentadores - Lista de alimentadores
 */

/**
 * @typedef {Object} Workspace
 * @property {string} id - UUID del workspace
 * @property {string} nombre - Nombre del workspace
 * @property {string} [descripcion] - Descripci√≥n opcional
 * @property {string} creador_id - ID del usuario creador
 */

/**
 * @typedef {Object} LecturaModbus
 * @property {string} registrador_id - ID del registrador
 * @property {number[]} valores - Array de valores le√≠dos
 * @property {string} timestamp - Fecha/hora de la lectura ISO
 * @property {number} indice_inicial - Registro inicial
 */

/**
 * @typedef {Object} ConfiguracionRele
 * @property {string} modeloId - ID del modelo (REF615, RET615)
 * @property {string} configuracionId - ID de la configuraci√≥n
 * @property {number} ratioTI - Ratio del transformador de corriente
 * @property {number} [ratioTV] - Ratio del transformador de tensi√≥n
 */

/**
 * @typedef {Object} Registrador
 * @property {string} id - UUID del registrador
 * @property {string} nombre - Nombre descriptivo
 * @property {string} ip - Direcci√≥n IP
 * @property {number} puerto - Puerto Modbus
 * @property {number} unit_id - Unit ID Modbus
 * @property {number} indice_inicial - Registro inicial a leer
 * @property {number} cantidad_registros - Cantidad de registros a leer
 * @property {boolean} activo - Si est√° activo para polling
 */

/**
 * @typedef {Object} Agente
 * @property {string} id - UUID del agente
 * @property {string} nombre - Nombre del agente
 * @property {string} estado - Estado actual (conectado, desconectado)
 * @property {string} [ultimo_heartbeat] - Timestamp del √∫ltimo heartbeat
 * @property {Registrador[]} registradores - Lista de registradores
 */

/**
 * @typedef {Object} PreferenciasVisuales
 * @property {number} escala - Escala global de tarjetas
 * @property {number} gap - Gap horizontal entre tarjetas
 * @property {number} rowGap - Gap vertical entre filas
 * @property {Object.<string, number>} escalasPorPuesto - Escalas por puesto
 * @property {Object.<string, number>} gapsPorPuesto - Gaps por puesto
 */

/**
 * @typedef {Object} Usuario
 * @property {string} id - UUID del usuario
 * @property {string} email - Email del usuario
 * @property {string} [nombre] - Nombre opcional
 * @property {string} rol - Rol (usuario, admin, superadmin)
 * @property {string} [workspace_default] - Workspace por defecto
 */

export {};
